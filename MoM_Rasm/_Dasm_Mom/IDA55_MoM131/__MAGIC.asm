;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: AC-7625-2E2D-92			    |
; |				 Valued	Client				    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	AABF5C934234A70885DEA7A0C8B3B5DE

; File Name   :	E:\MoM\IDA\IDA50sigs_20141030\MAGIC.EXE
; Format      :	MS-DOS executable (perhaps overlayed)
; Base Address:	1000h Range: 10000h-3C7E0h Loaded length: 2C7E0h
; Entry	Point :	1000:0
; Overlays: base=0002EFE0, size=0001B0B0, EXEinfo=00023D80
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

Ideal
include	uni.inc	; see unicode subdir of	ida for	info on	unicode

p386n
model large

include	"__MAGIC.inc"


; Segment type:	Pure code
segment	seg000 byte public 'CODE' use16
assume cs:seg000
assume es:nothing, ss:seg054, ds:nothing, fs:nothing, gs:nothing


; BORLANDC\LIB\STARTUP\C0.ASM
;
; Attributes: library function

public STARTX
proc STARTX far		; DATA XREF: seg038:ofs_STARTXo

; FUNCTION CHUNK AT 02AD SIZE 00000017 BYTES

mov	dx, seg	dseg	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov dx, DGROUP ; DX =	GROUP Segment address

loc_10003:		; BORLANDC\LIB\STARTUP\C0.ASM
mov	[cs:DGROUP@], dx ; IFNDEF  __BOSS__
			;     mov cs:DGROUP@@, dx ; __BOSS__
			; ENDIF

loc_10008:
mov	ah, 30h

loc_1000A:		; DOS -	GET DOS	VERSION
int	21h		; Return: AL = major version number (00h for DOS 1.x)

loc_1000C:		; BORLANDC\LIB\STARTUP\C0.ASM
mov	bp, [ds:PSPHigh] ; mov bp, ds:[PSPHigh]; BP = Highest Memory Segment Addr
mov	bx, [ds:PSPEnv]	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov bx, ds:[PSPEnv]; BX = Environment	Segment	address
mov	ds, dx
assume ds:dseg
mov	[word ptr _version@], ax ; BORLANDC\LIB\STARTUP\C0.ASM
			; mov _version@, ax ; Leep major and minor version number
mov	[_psp@], es	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov _psp@, es	; Keep Program Segment Prefix address
			; [NOTE: IDA auto-named	this "segx"]
mov	[_envseg@], bx	; BORLANDC\LIB\STARTUP\C0.ASM
			; mv _envseg@, bx ; Keep Environment Segment address
mov	[word ptr _heaptop@+2],	bp ; BORLANDC\LIB\STARTUP\C0.ASM
			; mov word ptr _heaptop@ + 2, bp
call	SaveVectors	; BORLANDC\LIB\STARTUP\C0.ASM
			; ;
			; ; Save several vectors and install default divide by zero handler.
			; ;
			;
mov	ax, [_envseg@]
mov	es, ax		; Extra	Segment	= Environment Segment
xor	ax, ax		; AX = 0
mov	bx, ax
mov	di, ax		; 0 = AX = BX =	DI
mov	cx, 7FFFh	; BORLANDC\LIB\STARTUP\C0.ASM
			; mv cx, 07FFFh	; Environment cann be >	32 Kbytes
cld			; Clear	Direction Flag

@@EnvLoop:		; CODE XREF: STARTX+3Fj
repne scasb		; Compare String
jcxz	short InitFailed ; Jump	if CX is 0
inc	bx		; BORLANDC\LIB\STARTUP\C0.ASM
			; inc bx ; BX =	Nb environment variables
cmp	[es:di], al	; Compare Two Operands
jnz	short @@EnvLoop	; BORLANDC\LIB\STARTUP\C0.ASM
			; jne @@EnvLoop	; Next variable	...

SaveEnv:		; BORLANDC\LIB\STARTUP\C0.ASM
or	ch, 10000000b
neg	cx		; Two's Complement Negation
mov	[_envLng@], cx	; BORLANDC\LIB\STARTUP\C0.ASM
mov	cx, dPtrSize_div2 ; BORLANDC\LIB\STARTUP\C0.ASM
			; mov cx, dPtrSize / 2
			; (dPtrSize / 2	= 1)
shl	bx, cl		; Shift	Logical	Left
add	bx, dPtrSize_mul4 ; BORLANDC\LIB\STARTUP\C0.ASM
			; add bx, dPtrSize * 4
			; (dPtrSize * 4	= 8)
db 83h,0E3h,0F8h ; <BAD>and	bx, 0FFF8h ; BORLANDC\LIB\STARTUP\C0.ASM
			; and bx, not ((dPtrSize * 4) -	1)
mov	[_envSize@], bx	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov _envSize@, bx ; Save Environment Variable	Nb.
			;
			;
			; IFNDEF __BOSS__
			;
mov	dx, ds		; BORLANDC\LIB\STARTUP\C0.ASM
			;
			; ; Determine the amount of memory that	we need	to keep
			;
			;
sub	bp, dx		; BORLANDC\LIB\STARTUP\C0.ASM
			; ; BP = remaining size	in paragraphs
mov	di, [__stklen]	; BORLANDC\LIB\STARTUP\C0.ASM
			; ; DI = Requested stack size
cmp	di, MINSTACK_mul2 ; BORLANDC\LIB\STARTUP\C0.ASM
			;
			; IFDEF	  __NOFLOAT__
			; MINSTACK	  equ	  128	  ; minimal stack size in words
			; ELSE
			; MINSTACK	  equ	  256	  ; minimal stack size in words
			; ENDIF
			;
			; ;
			; ; Make sure that the requested stack size is at least	MINSTACK words.
			; ;
			;
			; cmp di, 2*MINSTACK ; requested stack big enough ?
jnb	short AskedStackOK ; BORLANDC\LIB\STARTUP\C0.ASM
			; jae AskedStackOK

AskedStackNotOK:	; BORLANDC\LIB\STARTUP\C0.ASM
mov	di, MINSTACK_mul2 ; mov	di, 2*MINSTACK ; no -->	use minimal value
mov	[__stklen], di	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov __stklen,	di ; override requested	stack size

AskedStackOK:		; CODE XREF: STARTX+65j
add	di, edata@	; BORLANDC\LIB\STARTUP\C0.ASM
			; AskedStackOK	  label	  near
			; IFDEF	_DSSTACK_
			;   add	di, offset DGROUP:edata@
			;   jb	InitFailed		 ; DATA	segment	can NOT	be > 64	Kbytes
			; ENDIF
jb	short InitFailed ; Jump	if Below (CF=1)

loc_10074:		; BORLANDC\LIB\STARTUP\C0.ASM
add	di, [__heaplen]	; IF LDATA EQ false
			;   add	di, __heaplen
			;   jb	InitFailed    ;	DATA segment can NOT be	> 64 Kbytes
			; ENDIF
jb	short InitFailed ; Jump	if Below (CF=1)

loc_1007A:
mov	cl, 4
shr	di, cl		; BORLANDC\LIB\STARTUP\C0.ASM
			; shr di, cl ; $$$ Do not destroy CL $$$
inc	di		; BORLANDC\LIB\STARTUP\C0.ASM
			; ; DI = DS size in paragraphs
cmp	bp, di		; Compare Two Operands
jb	short InitFailed ; BORLANDC\LIB\STARTUP\C0.ASM
			; IF LDATA EQ false
			;   jb InitFailed ; Not	enough memory

LDATA_EQ_false:		; BORLANDC\LIB\STARTUP\C0.ASM
cmp	[__stklen], 0	; IF LDATA EQ false
			;   ...
			;   cmp	__stklen, 0
			;   je	ExpandDS    ; Expand DS	up to 64 Kb
jz	short ExpandDS	; Jump if Zero (ZF=1)

loc_1008A:		; DATA XREF: __exec+C7r
cmp	[__heaplen], 0	; BORLANDC\LIB\STARTUP\C0.ASM
			; IF LDATA EQ false
			;   ...
			;   cmp	__heaplen, 0
			;   jne	ExcessOfMemory ; Much more available than needed
			;
jnz	short ExcessOfMemory ; Jump if Not Zero	(ZF=0)

ExpandDS:		; CODE XREF: STARTX+88j
			; DATA XREF: __exec+75r
mov	di, 1000h	; BORLANDC\LIB\STARTUP\C0.ASM
			; IF LDATA EQ false
			;   ...
			; ExpandDS	  label	  near
			;   mov	di, 1000h
			;   cmp	bp, di
			;   ja	ExcessOfMemory ; Enough	to run the program
cmp	bp, di		; Compare Two Operands
ja	short ExcessOfMemory ; BORLANDC\LIB\STARTUP\C0.ASM
			; ja ExcessOfMemory ; Enough to	run the	program

loc_10098:
mov	di, bp
jmp	short ExcessOfMemory ; BORLANDC\LIB\STARTUP\C0.ASM
			; jmp short ExcessOfMemory ; Enough to run the program

InitFailed:		; CODE XREF: STARTX+39j
			; STARTX+72j
			; STARTX+78j
			; STARTX+81j
jmp	_abort		; BORLANDC\LIB\STARTUP\C0.ASM
			; ; All	initialization errors arrive here
			; InitFailed label near
			;   jmp	near ptr _abort
			;

ExcessOfMemory:		; CODE XREF: STARTX+8Fj
			; STARTX+96j
			; STARTX+9Aj
mov	bx, di		; BORLANDC\LIB\STARTUP\C0.ASM
			; ; Return to DOS the amount of	memory in excess
			; ; Set	far heap base and pointer
			;
add	bx, dx		; Add
mov	[word ptr _heapbase@+2], bx ; mov word ptr _heapbase@ +	2, bx
mov	[word ptr _brklvl@+2], bx ; mov	word ptr _brklvl@ + 2, bx
mov	ax, [_psp@]
sub	bx, ax		; sub bx, ax ; BX = Number of paragraphs to keep
mov	es, ax		; mov es, ax ; ES = Program Segment Prefix address
mov	ah, 4Ah
push	di		; ; preserve DI
int	21h		; ; this call clobbers SI,DI,BP	!!!!!!
			;
			; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
pop	di		; ; restore  DI
shl	di, cl		; ; $$$	CX is still equal to 4 $$$
cli			; ; req'd for pre-1983 88/86s
mov	ss, dx		; ; Set	the program stack
assume ss:dseg
mov	sp, di
sti			; Set Interrupt	Flag
xor	ax, ax		; IFNDEF __HUGE__
			;
			; ; Reset uninitialized	data area
mov	es, [cs:DGROUP@] ; mov es, cs:DGROUP@@
mov	di, offset bdata@ ; mov	di, offset DGROUP:bdata@
mov	cx, edata@	; mov cx, offset DGROUP:edata@
sub	cx, di		; Integer Subtraction
cld			; Clear	Direction Flag
rep stosb		; ENDIF
			;
			; ; END: Reset uninitialized data area
			;
			;
			;
			;
cmp	[__nfile], size	FILE ; ;   If default number of	file handles have changed then tell DOS
			; cmp	  __nfile, 20
jbe	short @@NoChange ; jbe	   @@NoChange
cmp	[_version@], 3	; cmp _osmajor@, 3 ; Check for >= DOS 3.3
jb	short @@NoChange ; jb	   @@NoChange

loc_100E0:		; ja	  @@DoChange
ja	short @@DoChange_1of5

loc_100E2:		; cmp	  _osminor@, 1Eh
cmp	[_osminor@], 30
jb	short @@NoChange ; jb	   @@NoChange

; __linkproc__ DoChange_1of5
@@DoChange_1of5:	; CODE XREF: STARTX:loc_100E0j
mov	ax, 5801h	; mov	  ax, 5801h	 ; Set last fit	allocation
mov	bx, 2
int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
			; AL = function	code: set allocation strategy
jb	short @@BadInit	; jc	  @@BadInit

@@DoChange_2of5:	; mov	  ah, 67h	 ; Expand handle table
mov	ah, 67h
mov	bx, [__nfile]
int	21h		; DOS -	3.3+ - SET HANDLE COUNT
			; BX = desired number of handles (max 255)
jb	short @@BadInit	; jc	  @@BadInit

; __linkproc__ DoChange_3of5
@@DoChange_3of5:	; ; Allocate 16	bytes to find new
mov	ah, 48h		; ;   top of memory address
mov	bx, 1
int	21h		; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
jb	short @@BadInit	; jc	  @@BadInit

@@DoChange_4of5:	; ; Adjust address to point after block
inc	ax
mov	[word ptr _heaptop@+2],	ax
dec	ax		; ; Change back	and release block
mov	es, ax
assume es:nothing
mov	ah, 49h
int	21h		; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
jb	short @@BadInit	; jc	  @@BadInit

@@DoChange_5of5:	; ; Set	first fit allocation
mov	ax, 5801h
mov	bx, 0
int	21h		; ; Set	first fit allocation
			;
			; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
			; AL = function	code: set allocation strategy
jnb	short @@NoChange ; jnc	   @@NoChange

@@BadInit:		; CODE XREF: STARTX+F1j
			; STARTX+FBj
			; STARTX+104j
			; STARTX+111j
jmp	_abort		; @@BadInit:	  jmp near ptr _abort

@@NoChange:		; CODE XREF: STARTX+D7j
			; STARTX+DEj
			; STARTX+E7j
			; STARTX+11Bj
mov	ah, 0		; @@NoChange:
			;
			; ;	  Prepare main arguments
int	1Ah		; ; get	current	BIOS time in ticks
			;
			; CLOCK	- GET TIME OF DAY
			; Return: CX:DX	= clock	count
			; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
			; midnight
			; Otherwise, AL	> 0

loc_10124:		; ; save it for	clock()	fn
mov	[_StartTime@], dx
mov	[_StartTime@+2], cx
or	al, al		; ; was	midnight flag set?
			;
			; If (AL == 0) Then Set	(ZF = 1)
jz	short @@NotMidnight ; jz      @@NotMidnight

Set_BIOS_Midnight_flag:
@@SetMidnight:		; ; set	BIOS midnight flag
mov	ax, 40h		; ;  at	40:70
mov	es, ax
assume es:nothing
mov	bx, 70h
mov	[byte ptr es:bx], 1 ; 0040:0070	= 1?

@@NotMidnight:		; CODE XREF: STARTX+12Ej
xor	bp, bp		; ; set	BP to 0	for overlay mgr

loc_1013E:
mov	es, [cs:DGROUP@]
assume es:nothing
mov	si, offset InitStart ; ;si = start of table
mov	di, offset InitEnd ; ;di = end of table
call	StartExit	; call	  StartExit
			;
			; ; ExitCode = main(argc,argv,envp);
push	[envp]		; word_31D98 = word_36F98?
push	[argv]		; argv
push	[argc]		; argc

CallMain:		; Call Procedure
call	_f010109_main
push	ax		; main() Return	Status

alignment:		; Alignment
nop

startup_epilogue:
push	cs
call	near ptr _exit	; 'startup' epilogue

__cleanup:		; CODE XREF: __exit_2of2+26p
mov	es, [cs:DGROUP@]
push	si
push	di
mov	si, offset InitEnd
mov	di, offset bdata@
call	idk_CleanUp	; Call Procedure
pop	di
pop	si
retf			; Return Far from Procedure
endp STARTX



; BORLANDC\LIB\STARTUP\C0.ASM
; ;---------------------------------------------------------------------------
; ;	  _cleanup()	  call all #pragma exit	cleanup	routines.
; ;	  _checknull()	  check	for null pointer zapping copyright message
; ;	  _terminate(int) exit program with error code
; ;
; ;	  These	functions are called by	exit(),	_exit(), _cexit(),
; ;	  and _c_exit().
; ;---------------------------------------------------------------------------
;
; ;	  Check	for null pointers before exit
;
; __checknull	  PROC	  DIST
;		  PUBLIC  __checknull
;
; IF	  LDATA	EQ false
;   IFNDEF  __TINY__
;		  push	  si
;		  push	  di
;		  mov	  es, cs:DGROUP@@
;		  xor	  ax, ax
;		  mov	  si, ax
;		  mov	  cx, lgth_CopyRight
; ComputeChecksum label	  near
;		  add	  al, es:[si]
;		  adc	  ah, 0
;		  inc	  si
;		  loop	  ComputeChecksum
;		  sub	  ax, CheckSum
;		  jz	  @@SumOk
;		  mov	  cx, lgth_NullCheck
;		  mov	  dx, offset DGROUP: NullCheck
;		  call	  ErrorDisplay
; @@SumOK:	  pop	  di
;		  pop	  si
;   ENDIF
; ENDIF
;		  ret
; __checknull	  ENDP
;
; Attributes: library function

proc __checknull far	; CODE XREF: __exit_2of2+34p
push	si
push	di
mov	es, [cs:DGROUP@]
xor	ax, ax		; Logical Exclusive OR
mov	si, ax
mov	cx, lgth_CopyRight ; lgth_CopyRight

ComputeChecksum:	; CODE XREF: __checknull+15j
add	al, [es:si]	; Add
adc	ah, 0		; Add with Carry
inc	si		; Increment by 1
loop	ComputeChecksum	; Loop while CX	!= 0
sub	ax, CheckSum	; Integer Subtraction
jz	short @@SumOk	; Jump if Zero (ZF=1)
mov	cx, lgth_NullCheck
mov	dx, offset NullCheck ; "Null pointer assignment\r\n"
call	ErrorDisplay	; Call Procedure

@@SumOk:		; CODE XREF: __checknull+1Aj
pop	di
pop	si
retf			; Return Far from Procedure
endp __checknull



; BORLANDC\LIB\STARTUP\C0.ASM
;
; ;	  Exit to DOS
;
; __terminate	  PROC	  DIST
;		  PUBLIC  __terminate
;		  mov	  bp,sp
;		  mov	  ah,4Ch
;		  mov	  al,[bp+cPtrSize]
;		  int	  21h			  ; Exit to DOS
; __terminate	  ENDP
;
; Attributes: library function noreturn	bp-based frame

proc __terminate near	; CODE XREF: __exit_2of2+4Ep

cPtrSize= byte ptr  4

mov	bp, sp
mov	ah, 4Ch
mov	al, [bp+cPtrSize]
int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
endp __terminate	; AL = exit code

mov	cx, 0Eh
mov	dx, 48h
jmp	MsgExit3	; Jump


; BORLANDC\LIB\STARTUP\C0.ASM
; ;
; ; Save several vectors and install default divide by zero handler.
; ;

proc SaveVectors near	; CODE XREF: STARTX+25p
push	ds

loc_101B1:
mov	ax, 3500h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	[word ptr _Int0Vector@], bx
mov	[word ptr _Int0Vector@+2], es
mov	ax, 3504h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	[word ptr _Int4Vector@], bx
mov	[word ptr _Int4Vector@+2], es
mov	ax, 3505h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector

loc_101D0:
mov	[word ptr _Int5Vector@], bx
mov	[word ptr _Int5Vector@+2], es
mov	ax, 3506h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	[word ptr _Int6Vector@], bx
mov	[word ptr _Int6Vector@+2], es

loc_101E5:		; BORLANDC\LIB\STARTUP\C0.ASM
mov	ax, 2500h	; ;
			; ; Install default divide by zero handler.
			; ;
mov	dx, cs
mov	ds, dx
assume ds:seg000
mov	dx, 1A7h
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
assume ds:dseg
retn			; Return Near from Procedure
endp SaveVectors



; BORLANDC\LIB\STARTUP\C0.ASM
; ;--------------------------------------------------------------------------
; ;	  _restorezero() puts back all the vectors that	SaveVectors took.
; ;
; ;NOTE	: TSRs must BE AWARE that signal() functions which take	these
; ;	  vectors will be deactivated if the keep() function is	executed.
; ;	  If a TSR wants to use	the signal functions when it is	active it
; ;	  will have to save/restore these vectors itself when activated	and
; ;	  deactivated.
; ;--------------------------------------------------------------------------
; __restorezero	  PROC	  DIST
;		  PUBLIC  __restorezero
; IFDEF	  __HUGE__
;		  push	  ds
;		  mov	  ds, cs: DGROUP@@
; ENDIF
;		  push	  ds
;		  mov	  ax, 2500h
;		  lds	  dx, _Int0Vector@
;		  int	  21h
;		  pop	  ds
;
;		  push	  ds
;		  mov	  ax, 2504h
;		  lds	  dx, _Int4Vector@
;		  int	  21h
;		  pop	  ds
;
;		  push	  ds
;		  mov	  ax, 2505h
;		  lds	  dx, _Int5Vector@
;		  int	  21h
;		  pop	  ds
;
; IFNDEF   __HUGE__
;		  push	  ds
; ENDIF
;		  mov	  ax, 2506h
;		  lds	  dx, _Int6Vector@
;		  int	  21h
;		  pop	  ds
;
;		  ret
;		  ENDP
;
; Attributes: library function

proc __restorezero far	; CODE XREF: __exit_2of2+2Fp
push	ds
mov	ax, 2500h
lds	dx, [_Int0Vector@] ; Load Full Pointer to DS:xx
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
push	ds

loc_101FF:
mov	ax, 2504h
lds	dx, [_Int4Vector@] ; Load Full Pointer to DS:xx
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
push	ds
mov	ax, 2505h
lds	dx, [_Int5Vector@] ; Load Full Pointer to DS:xx
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
push	ds
mov	ax, 2506h
lds	dx, [_Int6Vector@] ; Load Full Pointer to DS:xx
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
retf			; Return Far from Procedure
endp __restorezero



; J:\STU\BORLANDC\LIB\STARTUP\C0.ASM
; ;------------------------------------------------------------------
; ;  Loop through a startup/exit (SE) table,
; ;  calling functions in order	of priority.
; ;  ES:SI is assumed to point to the beginning	of the SE table
; ;  ES:DI is assumed to point to the end of the SE table
; ;  First 64 priorities are reserved by Borland
; ;------------------------------------------------------------------
; PNEAR		  EQU	  0
; PFAR		  EQU	  1
; NOTUSED	  EQU	  0ffh
;
; SE		  STRUC
; calltype	  db	  ?			  ; 0=near,1=far,ff=not	used
; priority	  db	  ?			  ; 0=highest,ff=lowest
; addrlow	  dw	  ?
; addrhigh	  dw	  ?
; SE		  ENDS
;
; StartExit	  proc near
; @@Start:
;

proc StartExit near	; CODE XREF: STARTX+149p
			; StartExit+3Aj
			; StartExit+41j
mov	ax, 100h	; IDK, Why this	is different?
			; @@StartLow:
			;   mov	ah,0ffh	; start	with lowest priority
mov	dx, di		; ; set	sentinel to end	of table
mov	bx, si		; ; bx = start of table

@@TopOfTable_1of:	; CODE XREF: StartExit+22j
cmp	bx, di		; ; and	the end	of the table?
jz	short @@EndOfTable_1of2	; je @@EndOfTable ; yes, exit the loop

@@TopOfTable_2of:	; cmp es:[bx.calltype],NOTUSED ; check the call	type
cmp	[byte ptr es:bx], 0FFh
jz	short @@Next	; je	  @@Next
mov	cl, [es:bx+1]
xor	ch, ch		; Logical Exclusive OR
cmp	cx, ax		; Compare Two Operands
jnb	short @@Next	; Jump if Not Below (CF=0)
mov	ax, cx
mov	dx, bx

@@Next:			; CODE XREF: StartExit+Fj
			; StartExit+19j
add	bx, 6		; add bx, SIZE SE ; bx = next item in table
jmp	short @@TopOfTable_1of ; jmp	 @@TopOfTable

@@EndOfTable_1of2:	; CODE XREF: StartExit+9j
cmp	dx, di		; ; did	we exhaust the table?

loc_10246:		; je @@Done : yes, quit
jz	short @@Done

@@EndOfTable_2of2:	; ; BX = highest priority item
mov	bx, dx
cmp	[byte ptr es:bx], e_PNEAR ; ; is it near or far?
mov	[byte ptr es:bx], 0FFh ; ; wipe	the call type
push	es		; ; save es
jz	short @@NearCall ; je	   @@NearCall

@@FarCall:		; call DWORD PTR es:[bx.addrlow]
call	[dword ptr es:bx+2]
pop	es		; ; restore es
jmp	short StartExit	; jmp	  short	@@Start

@@NearCall:		; CODE XREF: StartExit+33j
call	[word ptr es:bx+2] ; call WORD PTR es:[bx.addrlow]
pop	es		; ; restore es
jmp	short StartExit	; Jump

@@Done:			; CODE XREF: StartExit:loc_10246j
retn			; Return Near from Procedure
endp StartExit




proc idk_CleanUp near	; CODE XREF: STARTX+170p
			; idk_CleanUp+37j
			; idk_CleanUp+3Ej
mov	ah, 0
mov	dx, di
mov	bx, si

loc_1026A:		; CODE XREF: idk_CleanUp+1Fj
cmp	bx, di		; Compare Two Operands
jz	short loc_10285	; Jump if Zero (ZF=1)
cmp	[byte ptr es:bx], 255 ;	Compare	Two Operands
jz	short loc_10280	; Jump if Zero (ZF=1)
cmp	[es:bx+1], ah	; Compare Two Operands
jb	short loc_10280	; Jump if Below	(CF=1)
mov	ah, [es:bx+1]
mov	dx, bx

loc_10280:		; CODE XREF: idk_CleanUp+Ej
			; idk_CleanUp+14j
add	bx, 6		; Add
jmp	short loc_1026A	; Jump

loc_10285:		; CODE XREF: idk_CleanUp+8j
cmp	dx, di		; Compare Two Operands
jz	short locret_102A4 ; Jump if Zero (ZF=1)
mov	bx, dx
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
mov	[byte ptr es:bx], 255
push	es
jz	short loc_1029D	; Jump if Zero (ZF=1)
call	[dword ptr es:bx+2] ; Indirect Call Far	Procedure
pop	es
jmp	short idk_CleanUp ; Jump

loc_1029D:		; CODE XREF: idk_CleanUp+30j
call	[word ptr es:bx+2] ; Indirect Call Near	Procedure
pop	es
jmp	short idk_CleanUp ; Jump

locret_102A4:		; CODE XREF: idk_CleanUp+23j
retn			; Return Near from Procedure
endp idk_CleanUp



; BORLANDC\LIB\STARTUP\C0.ASM
;
; ErrorDisplay	  PROC	  NEAR
;		  mov	  ah, 040h
;		  mov	  bx, 2
;		  int	  021h
;		  ret
; ErrorDisplay	  ENDP
;

proc ErrorDisplay near	; CODE XREF: __checknull+22p
			; STARTX+2B8p
mov	ah, 40h
mov	bx, 2		; File Handle 2	is StdErr
int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			;   BX = file handle
			;   CX = number	of bytes to write
			;   DS:DX -> buffer, data to write
			; Return:
			;   CF clear if	successful
			;   AX = number	of bytes actually written
			;   CF set on error
			;   AX = error code
retn			; Return Near from Procedure
endp ErrorDisplay

; START	OF FUNCTION CHUNK FOR STARTX

; void abort(void)
_abort:			; CODE XREF: STARTX:InitFailedj
			; STARTX:@@BadInitj
			; seg000:1C90j
			; unknown_libname_2+39j
			; __OvrPrepare:loc_314B3J
mov	cx, lgth_abortMSG ;
			; ErrorDisplay	  PROC	  NEAR
			;		  mov	  ah, 040h
			;		  mov	  bx, 2
			;		  int	  021h
			;		  ret
			; ErrorDisplay	  ENDP
			;
			; _abort	  PROC	  DIST
			;		  PUBLIC  _abort
			;		  mov	  cx, lgth_abortMSG
			;		  mov	  dx, offset DGROUP: abortMSG
			; MsgExit3	  label	  near
			;		  mov	  ds, cs: DGROUP@@
			;		  call	  ErrorDisplay
			; CallExit3	  label	  near
			;		  mov	  ax, 3
			;		  push	  ax
			;		  call	  __exit	   ; _exit(3);
			;		  ENDP
			;
mov	dx, offset abortMSG ; "Abnormal	program	termination\r\n"

MsgExit3:		; CODE XREF: seg000:01ADj
mov	ds, [cs:DGROUP@] ; DS =	DGROUP;
			; => DS:DX -> buffer, data to write
call	ErrorDisplay	; Call Procedure
mov	ax, 3

CallExit3:		; Exit Status
push	ax
nop			; No Operation
push	cs
call	near ptr __exit__1of2 ;	Call Procedure
; END OF FUNCTION CHUNK	FOR STARTX
DGROUP@	dw 0		; DATA XREF: STARTX:loc_10003w
			; STARTX+C2r
			; STARTX:loc_1013Er
			; STARTX:__cleanupr
			; __checknull+2r
			; STARTX:MsgExit3r
			; __exec+200r
__MMODEL db 2, 80h


; Attributes: library function bp-based	frame

; int __cdecl abs(int x)
proc _abs far		; CODE XREF: sub_1D5DE+3AP
			; sub_1D5DE:loc_1D626P
			; sub_1D906:loc_1D918P
			; sub_1D906:loc_1D926P
			; sub_1D906+3EP
			; sub_1D906+4CP
			; sub_4D5B0:loc_4D740P

x= word	ptr  6

push	bp
mov	bp, sp
mov	ax, [bp+x]
or	ax, ax		; Logical Inclusive OR
jge	short loc_102D4	; Jump if Greater or Equal (SF=OF)
neg	ax		; Two's Complement Negation

loc_102D4:		; CODE XREF: _abs+8j
pop	bp
retf			; Return Far from Procedure
endp _abs



; .\BORLANDC\CRTL\CLIB\ATEXIT.C
;
; #include <stdlib.h>
;
; #define MAX_ATEXIT	  32
;
; int		  _atexitcnt = 0;	  /* count of atexit functions */
; atexit_t	  _atexittbl[MAX_ATEXIT]; /* array of atexit function pointers */
;
; int atexit(atexit_t func)
; {
;	  if (_atexitcnt == MAX_ATEXIT)
;		  return(1);
;	  _atexittbl[_atexitcnt++] = func;
;	  return(0);
; }
;
; Attributes: library function bp-based	frame

; int __cdecl atexit(void (*func)(void))
proc _atexit far

func= dword ptr	 6

push	bp
mov	bp, sp
cmp	[_atexitcnt], 32 ; #define MAX_ATEXIT	   32
jnz	short AddAtExitFunction	; Jump if Not Zero (ZF=0)

ExceededMaxAtExitFunctions:
mov	ax, 1
jmp	short loc_10301	; Jump

AddAtExitFunction:	; CODE XREF: _atexit+8j
mov	bx, [_atexitcnt]
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
mov	ax, [word ptr bp+func+2]
mov	dx, [word ptr bp+func]
mov	[(_atexittbl+2)+bx], ax
mov	[_atexittbl+bx], dx
inc	[_atexitcnt]	; Increment by 1

loc_102FF:		; Logical Exclusive OR
xor	ax, ax

loc_10301:		; CODE XREF: _atexit+Dj
pop	bp

locret_10302:		; Return Far from Procedure
retf
endp _atexit

; [000000A9 BYTES: COLLAPSED FUNCTION __DOSCMD.	PRESS KEYPAD "+" TO EXPAND]
; [000000FD BYTES: COLLAPSED FUNCTION __DOSENV.	PRESS KEYPAD "+" TO EXPAND]
; [0000001D BYTES: COLLAPSED FUNCTION __dos_getfileattr. PRESS KEYPAD "+" TO EXPAND]
; [0000001B BYTES: COLLAPSED FUNCTION __dos_setfileattr. PRESS KEYPAD "+" TO EXPAND]
; [00000033 BYTES: COLLAPSED FUNCTION __dos_findfirst. PRESS KEYPAD "+"	TO EXPAND]
; [0000002D BYTES: COLLAPSED FUNCTION __dos_findnext. PRESS KEYPAD "+" TO EXPAND]


;   mov	    si,	[bp+drive]
;   mov	    ah,	19h	  ; DOS	- GET DEFAULT DISK NUMBER
;   int	    21h
;   mov	    ah,	0
;   inc	    ax
;   mov	    [si], ax
; Attributes: library function bp-based	frame

; void __cdecl _dos_getdrive(unsigned int *drive)
proc __dos_getdrive far	; CODE XREF: sub_10B5F+1Ep

drive= word ptr	 6

push	bp
mov	bp, sp
push	si
mov	si, [bp+drive]
mov	ah, 19h
int	21h		; DOS -	GET DEFAULT DISK NUMBER
mov	ah, 0
inc	ax		; Increment by 1
mov	[si], ax
pop	si
pop	bp
retf			; Return Far from Procedure
endp __dos_getdrive

; [00000017 BYTES: COLLAPSED FUNCTION __dos_setdrive. PRESS KEYPAD "+" TO EXPAND]
; [00000001 BYTES: COLLAPSED FUNCTION nullsub_1. PRESS KEYPAD "+" TO EXPAND]


; .\BORLANDC\CRTL\CLIB\EXIT.C
;
; /*------------------------------------------------------------------------
;  * filename -	exit.c
;  *
;  * function(s)
;  *	  ___exit - handle the four flavors of exit
;  *	  exit	  - terminate program
;  *	  _exit	  - quick termination
;  *	  _cexit  - perform exit cleanup without termination
;  *	  _c_exit - perform quick exit cleanup without termination
;  *-----------------------------------------------------------------------*/
;
; /*[]------------------------------------------------------------[]*/
; /*|								   |*/
; /*|	  C/C++	Run Time Library - Version 4.0			   |*/
; /*|								   |*/
; /*|								   |*/
; /*|	  Copyright (c)	1987, 1991 by Borland International	   |*/
; /*|	  All Rights Reserved.					   |*/
; /*|								   |*/
; /*[]------------------------------------------------------------[]*/
;
; #include <stdlib.h>
;
; extern  int		  _atexitcnt;	 /* count of atexit function pointers */
; extern  atexit_t	  _atexittbl[];	 /* array of atexit function pointers */
;
; void _terminate( int );		  /* terminate program */
; void _cleanup( void );		  /* call #pragma exit routines	*/
; void _checknull( void	);		  /* check for null pointer usage */
; void _restorezero( void );		  /* restore interrupt vectors */
;
; static  void	  dummy(void)
; {
; }
;
; void	  (*_exitbuf)(void)   =	dummy;
; void	  (*_exitfopen)(void) =	dummy;
; void	  (*_exitopen)(void)  =	dummy;
;
; /*---------------------------------------------------------------------------*
;
; Name		  ___exit - perform cleanup and	optionally terminate the program
;
; Usage		  void ___exit(int quick, int dontexit,	int errcode);
;
; Prototype in	  local
;
; Description	  ___exit is an	internal routine used by the various flavors
;		  of exit.  If the "quick" flag	is false, buffered output
;		  (waiting to be output) is written to files, any registered
;		  "exit	functions"  (posted with atexit) are called, and
;		  #pragma exit functions are called.
;
;		  In all cases,	interrupt vectors taken	by the RTL are
;		  restored, and	in small and medium models, stray NULL pointers
;		  are checked for by seeing if the copyright message
;		  got zapped.
;
;		  Finally, if the "dontexit" flag is false, all	files
;		  are closed, and the program is terminated with the
;		  error	code "errcode".
;
; Return value	  If dontexit is false,	___exit	never returns; otherwise
;		  it returns no	value.
;
; *----------------------------------------------------------------------------*/
; static void pascal near ___exit(int quick, int dontexit, int errcode)
; {
;     if (!quick)
;     {
;	  /* Execute "atexit" functions
;	   */
;	  while	(_atexitcnt)
;	      (*_atexittbl[--_atexitcnt])();
;
;	  /* Run #pragma exit routines
;	   */
;	  _cleanup();
;
;	  /* Flush files.
;	   */
;	  (*_exitbuf)();
;     }
;
;
;     /* Restore interrupt vectors.
;      */
;     _restorezero();
;
;     /* Check for stray NULL pointers zapping the copyright message.
;      */
;     _checknull();
;
;     if (!dontexit)
;     {
;	  if (!quick)
;	  {
;	      (*_exitfopen)();	  /* close stream files	*/
;	      (*_exitopen)();	  /* close handle files	*/
;	  }
;	  _terminate(errcode);	  /* terminate program */
;     }
; }
;
; Attributes: library function bp-based	frame

; int __stdcall	_exit_2of2(int quick, int dontexit, int	errcode)
proc __exit_2of2 near	; CODE XREF: _exit+Ap
			; __exit__1of2+Dp
			; __cexit+Ap
			; __c_exit+8p

quick= word ptr	 4
dontexit= word ptr  6
errcode= word ptr  8

push	bp
mov	bp, sp
push	si
mov	si, [bp+errcode]
or	si, si		; if (!quick)
jnz	short loc_10599	; /* Execute "atexit" functions	*/

NotQuick:		; Jump
jmp	short loc_10589

Loop_Next_AtExitTbl:	; CODE XREF: __exit_2of2+22j
dec	[_atexitcnt]	; while	(_atexitcnt)
			;
			;     (*_atexittbl[--_atexitcnt])();
			;
mov	bx, [_atexitcnt] ; ...
mov	cl, 2		; e.g.,
			; _atexittabl =	[ptr1, ptr2, ptr3]
			;
			; _atexitcnt = 2
			;
			; _atexitcnt = 1
			;
			; _atexitcnt = 0
			;
shl	bx, cl		; ...
			;
call	[dword ptr _atexittbl+bx] ; Indirect Call Far Procedure

loc_10589:		; CODE XREF: __exit_2of2:NotQuickj
cmp	[_atexitcnt], 0	; while	(_atexitcnt)
jnz	short Loop_Next_AtExitTbl ; Jump if Not	Zero (ZF=0)
nop			;     /* Run #pragma exit routines */
			;     _cleanup();
			;     /* Flush files. */
			;     (*_exitbuf)();
push	cs
call	__cleanup	; Call Procedure
call	[ptr_exitbuf]	; Indirect Call	Far Procedure

loc_10599:		; CODE XREF: __exit_2of2+9j
nop			; /* Restore interrupt vectors.	*/
			; _restorezero();
			;
			; /* Check for stray NULL pointers zapping the copyright message. */
			; _checknull();
push	cs
call	near ptr __restorezero ; Call Procedure
nop			; No Operation
push	cs
call	near ptr __checknull ; Call Procedure
cmp	[bp+dontexit], 0 ; if (!dontexit)
jnz	short DO_NOT_TERMINATE ; Jump if Not Zero (ZF=0)
or	si, si		; if (!quick)
jnz	short NotDontExitIsQuick ; Jump	if Not Zero (ZF=0)

NotDontExitNotQuick:	; (*_exitfopen)();  /* close stream files */
call	[ptr_exitfopen]	; (*_exitopen)();   /* close handle files */
call	[ptr_exitopen]	; Indirect Call	Far Procedure

NotDontExitIsQuick:	; CODE XREF: __exit_2of2+3Fj
push	[bp+quick]
nop			; No Operation
push	cs
call	__terminate	; Call Procedure
db  59h	; Y

DO_NOT_TERMINATE:	; CODE XREF: __exit_2of2+3Bj
pop	si
pop	bp
retn	6		; Return Near from Procedure
endp __exit_2of2



; BORLANDC\LIB\STARTUP\C0.ASM
;
; _exit
;
; Function
;	   Terminates program.
;
; Syntax#
;	   #include <stdlib.h>
;	  void _exit(int status);
;
; Remarks
;	   _exit terminates execution without closing any files, flushing any output, or calling any exit functions.
;	   The calling process uses status as the exit status of the process.
;	   Typically a value of	a is used to indicate a	normal exit, and a nonzero value indicates some	error.
;
; Return value
;		None.
; Attributes: library function noreturn	bp-based frame

; void __cdecl exit(int	status)
proc _exit far		; CODE XREF: STARTX+160p

quick= word ptr	 6

push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax		; errcode
push	ax		; dontexit
push	[bp+quick]	; quick
call	__exit_2of2	;   arg_0 = 1
			;   arg_2 = 0
			;   arg_4 = 3
pop	bp
retf			; Return Far from Procedure
endp _exit



; BORLANDC\LIB\STARTUP\C0.ASM
;
; This is just BCpp30 __exit with defaults
; (dontexit=1, quick=0)
; Attributes: library function noreturn	bp-based frame

; void __cdecl _exit__1of2(int status)
proc __exit__1of2 far	; CODE XREF: STARTX+2C1p
			; CHUNK_OverlayHalt:loc_13205p

quick= word ptr	 6

push	bp
mov	bp, sp
mov	ax, 1
push	ax		; errcode
xor	ax, ax		; Logical Exclusive OR
push	ax		; dontexit

loc_105DC:		; quick
push	[bp+quick]
call	__exit_2of2	;   arg_0 = 1
			;   arg_2 = 0
			;   arg_4 = 3
pop	bp
retf			; Return Far from Procedure
endp __exit__1of2



; Attributes: library function

; void _cexit(void)
proc __cexit far	; CODE XREF: __exec+207p
xor	ax, ax		; Logical Exclusive OR
push	ax		; errcode
mov	ax, 1
push	ax		; dontexit
xor	ax, ax		; Logical Exclusive OR
push	ax		; quick
call	__exit_2of2	;   arg_0 = 1
			;   arg_2 = 0
			;   arg_4 = 3
retf			; Return Far from Procedure
endp __cexit



; Attributes: library function

; void _c_exit(void)
proc __c_exit far
mov	ax, 1
push	ax		; errcode
push	ax		; dontexit
xor	ax, ax		; Logical Exclusive OR
push	ax		; quick
call	__exit_2of2	;   arg_0 = 1
			;   arg_2 = 0
			;   arg_4 = 3
retf			; Return Far from Procedure
endp __c_exit

; [00000017 BYTES: COLLAPSED FUNCTION LXMUL@. PRESS KEYPAD "+" TO EXPAND]
; [0000001C BYTES: COLLAPSED FUNCTION SCOPY@. PRESS KEYPAD "+" TO EXPAND]
; [00000003 BYTES: COLLAPSED FUNCTION N_LDIV@. PRESS KEYPAD "+"	TO EXPAND]
; [00000004 BYTES: COLLAPSED FUNCTION LDIV@. PRESS KEYPAD "+" TO EXPAND]
; [00000008 BYTES: COLLAPSED FUNCTION N_LUDIV@.	PRESS KEYPAD "+" TO EXPAND]
; [00000003 BYTES: COLLAPSED FUNCTION N_LMOD@. PRESS KEYPAD "+"	TO EXPAND]
; [0000009C BYTES: COLLAPSED FUNCTION F_LMOD@. PRESS KEYPAD "+"	TO EXPAND]
; [00000003 BYTES: COLLAPSED FUNCTION N_LXLSH@.	PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function

proc LXLSH@ far		; CODE XREF: ST_AllocateSpace+10P
			; ST_FarMalloc+DP
			; malloc_s14954+DP
			; LBX_EmsMapMem+B2P
			; LBX_EmsMapMem+C2P
			; LBX_s16F45+49P
			; idk_PreEmmPgCnt+4FP
			; EMS_s17408+4BP
			; idk_VidLib_s1FBBF:loc_1FDCFP
			; idk_VidLib_s1FBBF:loc_1FDEFP
			; idk_VidLib_s1FBBF+26DP
			; idk_VidLib_s1FBBF:loc_1FE54P
			; idk_VidLib_s1FBBF:loc_1FE8DP
			; idk_VidLib_s1FBBF:loc_1FEB4P
			; idk_VidLib_s1FBBF+327P
			; idk_VidLib_s1FBBF+5D3P
			; idk_VidLib_s1FBBF:loc_201BAP
			; idk_VidLib_s1FBBF:loc_201F4P
			; idk_VidLib_s1FBBF+66CP
			; idk_VidLib_s1FBBF:loc_2025FP
			; idk_VidLib_s1FBBF+6D7P
			; idk_VidLib_s1FBBF+6EEP
			; idk_VidLib_s1FBBF+716P
			; idk_VidLib_s1FBBF:loc_2034AP
			; idk_VidLib_s1FBBF:loc_203A0P
			; idk_VidLib_s1FBBF:loc_203EFP
			; idk_VidLib_s1FBBF+87AP
			; sub_21C86+43P
			; sub_467A7+6D9P
cmp	cl, 10h		; Compare Two Operands
jnb	short loc_106F7	; Jump if Not Below (CF=0)
mov	bx, ax
shl	ax, cl		; Shift	Logical	Left
shl	dx, cl		; Shift	Logical	Left
neg	cl		; Two's Complement Negation
add	cl, 10h		; Add
shr	bx, cl		; Shift	Logical	Right
or	dx, bx		; Logical Inclusive OR
retf			; Return Far from Procedure

loc_106F7:		; CODE XREF: LXLSH@+3j
sub	cl, 10h		; Integer Subtraction
xchg	ax, dx		; Exchange Register/Memory with	Register
xor	ax, ax		; Logical Exclusive OR
shl	dx, cl		; Shift	Logical	Left
retf			; Return Far from Procedure
endp LXLSH@

; [00000003 BYTES: COLLAPSED FUNCTION N_LXURSH@. PRESS KEYPAD "+" TO EXPAND]
; [0000001E BYTES: COLLAPSED FUNCTION LXURSH@. PRESS KEYPAD "+"	TO EXPAND]
; [00000060 BYTES: COLLAPSED FUNCTION N_PADD@. PRESS KEYPAD "+"	TO EXPAND]


; BORLANDC\CRTL\CLIB\IOERROR.CAS
; /*-----------------------------------------------------------------------*
;
; Name		  __IOerror - set error	variables
;
; Usage		  #include <_io.h>
;		  int  pascal  __IOerror (int dosErr);
;
; Prototype in	  _io.h
;
; Description	  dosErr  is  a	 MSDOS	error  number,	or,  if	negative, the
;		  negative of a	System V error number.
;
;		  __IOerror  sets the  error  number  into  _doserrno. If not
;		  negative then	 translate it into  System V equivalent.  Put
;		  (translated) value into _errno.
;
; Return value	  __IOerror returns -1,	the usual RTL error return.
;
; *------------------------------------------------------------------------*/
; int pascal near __IOerror(int	dosErr)
; {
;	  int	  val =	dosErr;
;
;	  if (val < 0)
;		  goto ser_maybeSVerr;
;
;	  if (val <= e_dosFinalError)
;		  goto ser_dosError;
;
; /*
;   Being defensive, we	must assume that the error routine can be passed
;   a bad argument.  In	such circumstances, complaining	about the
;   parameter seems the	most reasonable	thing to do.
; */
; ser_errorFault:
;	  val =	e_parameter;
;
; ser_dosError:
;	  _doserrno = val;
;
;	  val =	_dosErrorToSV[val];
;	  goto ser_end;
;
; /*
;   This function may be called	with a negated System V	error code when
;   no appropriate MSDOS error code exists.  In	such cases the doserrno
;   is set to non-zero,	but using a number which has no	known cause.
; */
;
; ser_maybeSVerr:
;	  val =	-val;
;	  if (val > _sys_nerr)
;		  goto ser_errorFault;
;
;	  _doserrno = -1;
;
; ser_end:
;	  errno	= val;
;	  return -1;
; }
; Attributes: library function bp-based	frame

proc __IOERROR near	; CODE XREF: __DOSERROR+8p
			; _lseek+23p
			; __read:loc_10B1Bp
			; _unlink+11p
			; __exec+228p
			; _ioctl+22p
			; _setblock+16p
			; __chmod+16p
			; _close+10p
			; __close+19p
			; _eof:loc_11E86p
			; DOS_CreateFileWithHandle+12p
			; _open+41p
			; _open:loc_12718p
			; __open+46p
			; ___read+15p
			; ___write:loc_1305Ap
			; __write:loc_13184p

argErrorCode= word ptr	4

push	bp
mov	bp, sp
push	si
mov	si, [bp+argErrorCode]
or	si, si		; Logical Inclusive OR
jl	short ser_maybeSVerr_1of2 ; Jump if Less (SF!=OF)
cmp	si, e_dosFinalError ; Compare Two Operands
jle	short ser_dosError ; Jump if Less or Equal (ZF=1 | SF!=OF)

ser_errorFault:		; CODE XREF: __IOERROR+25j
mov	si, e_parameter

ser_dosError:		; CODE XREF: __IOERROR+Ej
mov	[_doserrno], si
mov	al, [_dosErrorToSV+si] ; val = _dosErrorToSV[val];
cbw			; AL ->	AX (with sign)
mov	si, ax
jmp	short ser_end	; Jump

ser_maybeSVerr_1of2:	; CODE XREF: __IOERROR+9j
neg	si		; Two's Complement Negation
cmp	si, sys_nerr	; Compare Two Operands
jg	short ser_errorFault ; Jump if Greater (ZF=0 & SF=OF)

ser_maybeSVerr_2of2:
mov	[_doserrno], -1

ser_end:		; CODE XREF: __IOERROR+1Ej
mov	[errno], si
mov	ax, -1
pop	si
pop	bp
retn	2		; Return Near from Procedure
endp __IOERROR

; [00000012 BYTES: COLLAPSED FUNCTION __DOSERROR. PRESS	KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isalnum.	PRESS KEYPAD "+" TO EXPAND]
; [00000013 BYTES: COLLAPSED FUNCTION _isascii.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isalpha.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _iscntrl.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isdigit.	PRESS KEYPAD "+" TO EXPAND]
; [00000019 BYTES: COLLAPSED FUNCTION _isgraph.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _islower.	PRESS KEYPAD "+" TO EXPAND]
; [00000019 BYTES: COLLAPSED FUNCTION _isprint.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _ispunct.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isspace.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isupper.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isxdigit. PRESS KEYPAD "+" TO EXPAND]
; [00000021 BYTES: COLLAPSED FUNCTION _getc. PRESS KEYPAD "+" TO EXPAND]
; [0000001F BYTES: COLLAPSED FUNCTION _getchar.	PRESS KEYPAD "+" TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION _putc. PRESS KEYPAD "+" TO EXPAND]
; [0000002A BYTES: COLLAPSED FUNCTION _putchar.	PRESS KEYPAD "+" TO EXPAND]
; [00000010 BYTES: COLLAPSED FUNCTION _feof. PRESS KEYPAD "+" TO EXPAND]
; [00000010 BYTES: COLLAPSED FUNCTION _ferror. PRESS KEYPAD "+"	TO EXPAND]


; Attributes: library function bp-based	frame

; int __cdecl isatty(int handle)
proc _isatty far	; CODE XREF: __setupio+3Bp
			; __setupio+73p
			; __OPENFP+55p

handle=	word ptr  6

push	bp
mov	bp, sp
mov	ax, 4400h
mov	bx, [bp+handle]
int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
xchg	ax, dx		; Exchange Register/Memory with	Register
and	ax, 80h		; Logical AND
pop	bp
retf			; Return Far from Procedure
endp _isatty

; [0000007D BYTES: COLLAPSED FUNCTION __LONGTOA. PRESS KEYPAD "+" TO EXPAND]
; [0000001D BYTES: COLLAPSED FUNCTION __UTOA. PRESS KEYPAD "+" TO EXPAND]
; [00000029 BYTES: COLLAPSED FUNCTION _lseek. PRESS KEYPAD "+" TO EXPAND]
; [0000003F BYTES: COLLAPSED FUNCTION __MKNAME.	PRESS KEYPAD "+" TO EXPAND]
; [00000043 BYTES: COLLAPSED FUNCTION __TMPNAM.	PRESS KEYPAD "+" TO EXPAND]
; [00000017 BYTES: COLLAPSED FUNCTION N_LXMUL@.	PRESS KEYPAD "+" TO EXPAND]
; [00000021 BYTES: COLLAPSED FUNCTION N_PCMP@. PRESS KEYPAD "+"	TO EXPAND]
; [0000002D BYTES: COLLAPSED FUNCTION __read. PRESS KEYPAD "+" TO EXPAND]
; [00000026 BYTES: COLLAPSED FUNCTION fncCopyToUpperCase. PRESS	KEYPAD "+" TO EXPAND]


; DOS -	2+ - GET CURRENT DIRECTORY
;   DL = drive (0=default, 1=A,	etc.)
;   DS:SI points to 64-byte buffer area
; -
;   mov	    dl,	[bp+arg_2]
;   mov	    si,	[bp+arg_0]
; Attributes: library function bp-based	frame

proc DOS_GetCurrDir far	; CODE XREF: sub_10B5F+4Ep

arg_0= word ptr	 6
arg_2= byte ptr	 8

push	bp
mov	bp, sp
push	si
mov	ah, 47h
mov	dl, [bp+arg_2]
mov	si, [bp+arg_0]
int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default, 1=A, etc.)
			; DS:SI	points to 64-byte buffer area
jb	short loc_10B5A	; Jump if Below	(CF=1)
xor	ax, ax		; Logical Exclusive OR
jmp	short $+2	; Jump

loc_10B5A:		; CODE XREF: DOS_GetCurrDir+Ej
pop	si
pop	bp
retf	4		; Return Far from Procedure
endp DOS_GetCurrDir



;   arg_0 =
;   arg_2 =
;   src	  =
;   arg_8 =
;   path  =
; -
;   push    di
;   mov	    ax,	0A9F1h
;   push    ax		    ; int
;   mov	    ax,	0A9AEh
;   push    ax		    ; int
;   mov	    ax,	0A9A4h
;   push    ax		    ; int
;   mov	    ax,	0A99Eh	    ; int
;   push    ax
;   push    word ptr [bp+path+2] ; path
; Attributes: library function bp-based	frame

; int __fastcall sub_10B5F(int,	int, int, int, int, int, int, int, char	*path)
proc sub_10B5F near	; CODE XREF: sub_10C20+91p
			; sub_10C20+BDp
			; sub_10C20+E2p

attrib=	word ptr -2Eh
drive= word ptr	-2
arg_0= word ptr	 4
arg_2= word ptr	 6
src= dword ptr	8
arg_8= word ptr	 0Ch
path= dword ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 2Eh		; dst
push	si
push	di		; dst
mov	dx, [bp+arg_8]
mov	di, [word ptr bp+src+2]
mov	si, [word ptr bp+path]
mov	bx, dx
cmp	[byte ptr bx], 0 ; If ([BX] == 0) Then Set (ZF = 1)
jnz	short Arg8_ZERO	; Jump if Not Zero (ZF=0)
lea	ax, [bp+drive]	; Load Effective Address
push	ax		; drive
nop			; No Operation
push	cs
call	near ptr __dos_getdrive	;   mov	    si,	[bp+drive]
			;   mov	    ah,	19h	  ; DOS	- GET DEFAULT DISK NUMBER
			;   int	    21h
			;   mov	    ah,	0
			;   inc	    ax
			;   mov	    [si], ax
pop	cx
jmp	short loc_10B8E	; Jump

Arg8_ZERO:		; CODE XREF: sub_10B5F+16j
mov	bx, dx
mov	al, [bx]
cbw			; AL ->	AX (with sign)
and	ax, 11111b	; Logical AND
mov	[bp+drive], ax

loc_10B8E:		; CODE XREF: sub_10B5F+22j
mov	al, [byte ptr bp+drive]
add	al, 64		; Convert Drive	Number to Drive	Letter
mov	[si], al
inc	si		; Increment by 1
mov	[byte ptr si], ':'
inc	si		; Increment by 1
cmp	[byte ptr di], '\' ; Compare Two Operands
jz	short loc_10BCC	; Jump if Zero (ZF=1)
cmp	[byte ptr di], '/' ; Compare Two Operands
jz	short loc_10BCC	; Jump if Zero (ZF=1)
mov	[byte ptr si], 5Ch ; '\'
inc	si		; Increment by 1
push	[bp+drive]
push	si
push	cs
call	near ptr DOS_GetCurrDir	; DOS -	2+ - GET CURRENT DIRECTORY
			;   DL = drive (0=default, 1=A,	etc.)
			;   DS:SI points to 64-byte buffer area
			; -
			;   mov	    dl,	[bp+arg_2]
			;   mov	    si,	[bp+arg_0]
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jz	short loc_10BB9	; Jump if Zero (ZF=1)
mov	ax, 3
jmp	short loc_10C18	; Jump

loc_10BB9:		; CODE XREF: sub_10B5F+53j
push	si		; s
nop			; No Operation
push	cs
call	near ptr _strlen ; Call	Procedure
pop	cx
mov	dx, ax
or	dx, dx		; Logical Inclusive OR
jz	short loc_10BCC	; Jump if Zero (ZF=1)
add	si, dx		; Add
mov	[byte ptr si], 5Ch ; '\'
inc	si		; Increment by 1

loc_10BCC:		; CODE XREF: sub_10B5F+3Ej
			; sub_10B5F+43j
			; sub_10B5F+65j
push	si		; dst
push	di		; src
call	fncCopyToUpperCase ; Call Procedure
mov	si, ax
cmp	[byte ptr si-1], 5Ch ; '\' ; Compare Two Operands
jz	short loc_10BE3	; Jump if Zero (ZF=1)
cmp	[byte ptr si-1], 2Fh ; '/' ; Compare Two Operands
jz	short loc_10BE3	; Jump if Zero (ZF=1)
mov	[byte ptr si], 5Ch ; '\'
inc	si		; Increment by 1

loc_10BE3:		; CODE XREF: sub_10B5F+78j
			; sub_10B5F+7Ej
push	si		; dst
push	[word ptr bp+src] ; src
call	fncCopyToUpperCase ; Call Procedure
mov	si, ax
cmp	[bp+arg_2], 0	; Compare Two Operands
jz	short loc_10BF9	; Jump if Zero (ZF=1)
push	ax		; dst
push	[bp+arg_2]	; src
call	fncCopyToUpperCase ; Call Procedure

loc_10BF9:		; CODE XREF: sub_10B5F+91j
lea	ax, [bp+attrib]	; Load Effective Address
push	ax		; attrib
test	[bp+arg_0], 2	; Logical Compare
jz	short loc_10C09	; Jump if Zero (ZF=1)
mov	ax, 27h	; '''
jmp	short loc_10C0C	; Jump

loc_10C09:		; CODE XREF: sub_10B5F+A3j
mov	ax, 37h	; '7'

loc_10C0C:		; CODE XREF: sub_10B5F+A8j
push	ax
push	[word ptr bp+path] ; path
nop			; No Operation
push	cs
call	near ptr __dos_findfirst ; Call	Procedure
add	sp, 6		; Add

loc_10C18:		; CODE XREF: sub_10B5F+58j
pop	di
pop	si
mov	sp, bp
pop	bp
retn	0Ch		; Return Near from Procedure
endp sub_10B5F ; sp-analysis failed

; [0000015E BYTES: COLLAPSED FUNCTION sub_10C20. PRESS KEYPAD "+" TO EXPAND]
; [00000014 BYTES: COLLAPSED FUNCTION __SEARCHPATH. PRESS KEYPAD "+" TO	EXPAND]
; [00000033 BYTES: COLLAPSED FUNCTION __searchenv. PRESS KEYPAD	"+" TO EXPAND]
; [00000033 BYTES: COLLAPSED FUNCTION __searchstr. PRESS KEYPAD	"+" TO EXPAND]


; Attributes: library function

proc __setupio near
mov	dx, 5
cmp	dx, [__nfile]	; Compare Two Operands
jnb	short loc_10E2C	; Jump if Not Below (CF=0)

loc_10E01:		; CODE XREF: __setupio+32j
mov	bx, dx
shl	bx, 1		; Shift	Logical	Left

loc_10E05:
mov	[word ptr bx+51CCh], 0
mov	bx, dx
mov	cl, 4
shl	bx, cl		; Shift	Logical	Left
mov	[byte ptr bx+508Eh], 0FFh
mov	ax, dx
shl	ax, cl		; Shift	Logical	Left
add	ax, 508Ah	; Add
mov	bx, dx
shl	bx, cl		; Shift	Logical	Left
mov	[bx+5098h], ax
inc	dx		; Increment by 1
cmp	dx, [__nfile]	; Compare Two Operands
jb	short loc_10E01	; Jump if Below	(CF=1)

loc_10E2C:		; CODE XREF: __setupio+7j
mov	al, [byte_36D9E]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _isatty ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_10E41	; Jump if Not Zero (ZF=0)
and	[word_36D9C], 0FDFFh ; Logical AND

loc_10E41:		; CODE XREF: __setupio+41j
mov	ax, 200h
push	ax
test	[word_36D9C], 200h ; Logical Compare
jz	short loc_10E52	; Jump if Zero (ZF=1)
mov	ax, 1
jmp	short loc_10E54	; Jump

loc_10E52:		; CODE XREF: __setupio+53j
xor	ax, ax		; Logical Exclusive OR

loc_10E54:		; CODE XREF: __setupio+58j
push	ax		; argBuffer
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 508Ah
push	ax		; argStream
nop			; No Operation
push	cs
call	near ptr _setvbuf ; argStream,argBuffer,arg_6,argType,argSize
add	sp, 8		; Add
mov	al, [byte_36DAE]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _isatty ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_10E79	; Jump if Not Zero (ZF=0)
and	[word_36DAC], 0FDFFh ; Logical AND

loc_10E79:		; CODE XREF: __setupio+79j
mov	ax, 200h
push	ax
test	[word_36DAC], 200h ; Logical Compare
jz	short loc_10E8A	; Jump if Zero (ZF=1)
mov	ax, 2
jmp	short loc_10E8C	; Jump

loc_10E8A:		; CODE XREF: __setupio+8Bj
xor	ax, ax		; Logical Exclusive OR

loc_10E8C:		; CODE XREF: __setupio+90j
push	ax		; argBuffer
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 509Ah
push	ax		; argStream
nop			; No Operation
push	cs
call	near ptr _setvbuf ; argStream,argBuffer,arg_6,argType,argSize
add	sp, 8		; Add
retn			; Return Near from Procedure
endp __setupio ; sp-analysis failed



; Attributes: bp-based frame

proc idk_ctype_s10E9D far
			; CODE XREF: idk_Env_BLASTER_s3095D+B2P

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	dx, [bp+arg_0]
db 83h,0FAh,0FFh ; <BAD>cmp	dx, 0FFFFh ; Compare Two Operands
jnz	short loc_10EAD	; Jump if Not Zero (ZF=0)
mov	ax, 0FFFFh
jmp	short loc_10EC7	; Jump

loc_10EAD:		; CODE XREF: idk_ctype_s10E9D+9j
mov	al, dl
mov	ah, 0
mov	bx, ax
test	[(__ctype+1)+bx], 8 ; .\BORLAND\CTRL\CLIB\CTYPE.C
			; Usage
			; char _ctype[257];
			; Description
			; _ctype is an array of	257 characters used by the character
			; classification and character conversion macros
			; (such	as isalpha and toascii).
jz	short loc_10EC3	; Jump if Zero (ZF=1)
mov	al, dl
mov	ah, 0
add	ax, 0FFE0h	; Add
jmp	short loc_10EC7	; Jump

loc_10EC3:		; CODE XREF: idk_ctype_s10E9D+1Bj
mov	al, dl
mov	ah, 0

loc_10EC7:		; CODE XREF: idk_ctype_s10E9D+Ej
			; idk_ctype_s10E9D+24j
pop	bp
retf			; Return Far from Procedure
endp idk_ctype_s10E9D

; [00000016 BYTES: COLLAPSED FUNCTION _unlink. PRESS KEYPAD "+"	TO EXPAND]
; [00000029 BYTES: COLLAPSED FUNCTION _stpcpy. PRESS KEYPAD "+"	TO EXPAND]
; [00000022 BYTES: COLLAPSED FUNCTION ___brk. PRESS KEYPAD "+" TO EXPAND]


; BORLANDC\CRTL\CLIB\BRK.CAS
; /*--------------------------------------------------------------------------*
;
; Name		  __sbrk - changes data-segment	space allocation on the
;			 near heap
;
; Usage		  void *__sbrk(long incr);
;
; Prototype in	  alloc.h
;
; Description	  sbrk adds incr bytes to the break value and changes the
;		  allocated space accordingly. incr can	be negative, in
;		  which	case the amount	of allocated space is decreased.
;
; Return value	  success : the	old break value
;		  failure : -1 and errno set to	ENOMEM (Not enough core)
;
; *---------------------------------------------------------------------------*/
; void * near __sbrk(long incr)
; {
; asm	  mov	  ax, W0(incr)
; asm	  mov	  dx, W1(incr)
; asm	  add	  ax, word ptr __brklvl
; asm	  adc	  dx, 0
; asm	  mov	  cx, ax
; asm	  or	  dx, dx
; asm	  jnz	  sbrkErr
;
; asm	  add	  cx, MARGIN
; asm	  jc	  sbrkErr
; asm	  cmp	  cx, sp
; asm	  jnb	  sbrkErr
;
; asm	  xchg	  word ptr __brklvl, ax
;	  return (void *)_AX;
; sbrkErr:
;	  errno	= ENOMEM;
;	  return((void *)-1);
; }
;
; Attributes: library function bp-based	frame

; void *__cdecl	__sbrk(__int32 incr)
proc ___sbrk near	; CODE XREF: _sbrk+9p
			; LibMalloc_s11A85+5p
			; LibMalloc_s11A85+13p
			; LibMalloc_s11A85+1Ep
			; LibMalloc_s11AC5+5p

incr= dword ptr	 4

push	bp
mov	bp, sp
mov	ax, [word ptr bp+incr]
mov	dx, [word ptr bp+incr+2]
add	ax, [__brklvl]	; Add
adc	dx, 0		; Add with Carry
mov	cx, ax
or	dx, dx		; Logical Inclusive OR
jnz	short loc_10F50	; Jump if Not Zero (ZF=0)
add	cx, 200h	; Add
jb	short loc_10F50	; Jump if Below	(CF=1)
cmp	cx, sp		; Compare Two Operands
jnb	short loc_10F50	; Jump if Not Below (CF=0)
xchg	ax, [__brklvl]	; Exchange Register/Memory with	Register
jmp	short loc_10F59	; Jump

loc_10F50:		; CODE XREF: ___sbrk+14j
			; ___sbrk+1Aj
			; ___sbrk+1Ej
mov	[errno], 8
mov	ax, 0FFFFh

loc_10F59:		; CODE XREF: ___sbrk+24j
pop	bp
retn			; Return Near from Procedure
endp ___sbrk

; [0000000C BYTES: COLLAPSED FUNCTION _brk. PRESS KEYPAD "+" TO	EXPAND]
; [00000010 BYTES: COLLAPSED FUNCTION _sbrk. PRESS KEYPAD "+" TO EXPAND]


; returns the amount of	available heap
; tiny,small,medium sized memory modal:	unsigned int
; compact,large,huge sized memory model: unsigned long
; Attributes: library function

; unsigned __int32 coreleft(void)
proc _coreleft far	; CODE XREF: ST_ExitWithMemDiag+15P
mov	ax, sp
sub	ax, [__brklvl]	; Integer Subtraction
sub	ax, 220h	; Integer Subtraction
jnb	short loc_10F84	; Jump if Not Below (CF=0)
xor	ax, ax		; Logical Exclusive OR

loc_10F84:		; CODE XREF: _coreleft+9j
and	al, 11110000b	; Logical AND
retf			; Return Far from Procedure
endp _coreleft

LoaderDatas BCpp30_LdDesc <0>
			; DATA XREF: __exec+F7o
			; __exec+1CBo
db  33h	; 3
db 0FFh
db  8Ch	; 
db 0C8h	; 
db  8Eh	; 
db 0D8h	; 
db  8Eh	; 
db 0C0h	; 
db 0FAh	; 
db  8Eh	; 
db 0D0h	; 
db  8Dh	; 
db 0A5h	; 
db  8Fh	; 
db    0
db 0FBh	; 
db  51h	; Q
db  52h	; R
db 0B8h	; 
db    3
db  4Bh	; K
db  8Dh	; 
db  9Dh	; 
db 0FBh	; 
db    0
db  8Dh	; 
db  95h	; 
db  91h	; 
db    0
db 0CDh	; 
db  21h	; !
db  5Ah	; Z
db  59h	; Y
db  72h	; r
db  2Dh	; -
db  33h	; 3
db 0FFh
db 0FAh	; 
db  8Eh	; 
db  95h	; 
db 0F1h	; 
db    0
db  8Bh	; 
db 0A5h	; 
db 0F3h	; 
db    0
db 0FBh	; 
db  8Bh	; 
db 0ECh	; 
db  33h	; 3
db 0C0h	; 
db  50h	; P
db  8Bh	; 
db  85h	; 
db  8Fh	; 
db    0
db  8Eh	; 
db 0D8h	; 
db  8Eh	; 
db 0C0h	; 
db  26h	; &
db  89h	; 
db  16h
db    2
db    0
db  26h	; &
db  89h	; 
db  0Eh
db  2Ch	; ,
db    0
db  2Eh	; .
db  8Bh	; 
db  85h	; 
db 0E1h	; 
db    0
db  2Eh	; .
db 0FFh
db  2Eh	; .
db 0F7h	; 
db    0
db 0B4h	; 
db  40h	; @
db 0BBh	; 
db    2
db    0
db 0B9h	; 
db  0Fh
db    0
db  33h	; 3
db 0D2h	; 
db 0CDh	; 
db  21h	; !
db 0B8h	; 
db    2
db  4Ch	; L
db 0CDh	; 
db  21h	; !
LoaderVector dd	0FFh	; DATA XREF: __exec+21Er
			; __exec+1C1w
			; .\BORLANDC\CRTL\CLIB\EXEC.ASM:
			; LoaderVector	  dd	  _Loader - LoaderDatas
OldEnvSave dw 0		; DATA XREF: __exec+Ew
			; __exec:ReUseEnvr
			; __exec:CopyEnv_2of2r
byte_110ED db 1		; DATA XREF: __exec:SetEnvSize_2of2w
			; __exec+1D8r
			; __exec:loc_112FAr
; [0000022F BYTES: COLLAPSED FUNCTION __exec. PRESS KEYPAD "+" TO EXPAND]
; [0000001A BYTES: COLLAPSED FUNCTION _execl. PRESS KEYPAD "+" TO EXPAND]
LibMalloc____first dw 0	; DATA XREF: LibMalloc_s11343r
			; LibMalloc_s11343+1Dr
			; LibMalloc_s11343:loc_1137Cr
			; LibMalloc_s11343:loc_11381w
			; sub_113A6+11r
			; LibMalloc_s114A0+48w
			; _farmalloc+2Cr
___last	dw 0		; DATA XREF: LibMalloc_s11343+14w
			; LibMalloc_s11343+27w
			; LibMalloc_s11343+45w
			; _farfree+11r
			; LibMalloc_s114A0+4Dw
			; LibMalloc_s11504:loc_11527r
			; LibMalloc_s11504+28w
			; idk_FarFreeOrBrkr
LibMalloc____rover dw 0	; DATA XREF: LibMalloc_s11343+4Cw
			; LibMalloc_s11417+19w
			; LibMalloc_s11417:loc_11438w
			; sub_11440r
			; sub_11440:loc_11469w
			; _farmalloc+35r
LibMalloc_w1133D dw 0	; DATA XREF: LibMalloc_s11343+32r
			; LibMalloc_s11343:loc_11396r
			; _farfree+5w
			; _farfree:loc_11497r
			; LibMalloc_s114A0+1r
			; LibMalloc_s114A0+1Cr
			; LibMalloc_s114A0+35r
			; LibMalloc_s11504+Br
			; _farmalloc+Fw
			; _farmalloc:loc_115F5r
			; LibMalloc_FarReAlloc_s115FE:loc_11669r
			; _farrealloc+Ew
			; _farrealloc:loc_1174Fr
LibMalloc_FarReAlloc_w1133F dw 0
			; DATA XREF: LibMalloc_FarReAlloc_s115FE+1r
			; _farrealloc+13w
; unsigned __int32 nbytes
nbytes dw 0		; DATA XREF: LibMalloc_FarReAlloc_s115FE+7r
			; _farrealloc+18w


; Attributes: library function

proc LibMalloc_s11343 near ; CODE XREF:	_farfree+18p
cmp	dx, [cs:LibMalloc____first] ; Compare Two Operands
jz	short loc_11381	; Jump if Zero (ZF=1)
mov	ds, dx
mov	ds, [LibMalloc_w31D12]
cmp	[LibMalloc_w31D12], 0 ;	Compare	Two Operands
jz	short loc_1135E	; Jump if Zero (ZF=1)
mov	[cs:___last], ds
jmp	short loc_11396	; Jump

loc_1135E:		; CODE XREF: LibMalloc_s11343+12j
mov	ax, ds
cmp	ax, [cs:LibMalloc____first] ; Compare Two Operands
jz	short loc_1137C	; Jump if Zero (ZF=1)
mov	ax, [LibMalloc_w31D18]
mov	[cs:___last], ax
push	ds
xor	ax, ax		; Logical Exclusive OR
push	ax
call	LibMalloc_s11417 ; Call	Procedure
mov	ds, [cs:LibMalloc_w1133D]
jmp	short loc_1139F	; Jump

loc_1137C:		; CODE XREF: LibMalloc_s11343+22j
mov	dx, [cs:LibMalloc____first]

loc_11381:		; CODE XREF: LibMalloc_s11343+5j
mov	[cs:LibMalloc____first], 0
mov	[cs:___last], 0
mov	[cs:LibMalloc____rover], 0

loc_11396:		; CODE XREF: LibMalloc_s11343+19j
mov	ds, [cs:LibMalloc_w1133D]
push	dx
xor	ax, ax		; Logical Exclusive OR
push	ax		; addr

loc_1139F:		; CODE XREF: LibMalloc_s11343+37j
call	__brk		; Call Procedure
add	sp, 4		; Add
retn			; Return Near from Procedure
endp LibMalloc_s11343

; [00000071 BYTES: COLLAPSED FUNCTION sub_113A6. PRESS KEYPAD "+" TO EXPAND]
; [00000029 BYTES: COLLAPSED FUNCTION LibMalloc_s11417.	PRESS KEYPAD "+" TO EXPAND]
; [00000037 BYTES: COLLAPSED FUNCTION sub_11440. PRESS KEYPAD "+" TO EXPAND]
; [00000029 BYTES: COLLAPSED FUNCTION _farfree.	PRESS KEYPAD "+" TO EXPAND]
; [00000064 BYTES: COLLAPSED FUNCTION LibMalloc_s114A0.	PRESS KEYPAD "+" TO EXPAND]
; [0000005A BYTES: COLLAPSED FUNCTION LibMalloc_s11504.	PRESS KEYPAD "+" TO EXPAND]
; [00000023 BYTES: COLLAPSED FUNCTION LibMalloc_s1155E.	PRESS KEYPAD "+" TO EXPAND]


; ;-----------------------------------------------------------------------------
; ; C callable function	to allocates a given number of bytes from the far heap
; ;-----------------------------------------------------------------------------
; ; Args:		  Number of bytes requested (long, stack)
; ; Returns:		  Address of the first byte of user space available
; ;			  from the heap	if successful (dx:ax)
; ;			  NULL if failure (ds:ax)
; ;-----------------------------------------------------------------------------
;
;
; void far *__cdecl farmalloc(unsigned __int32 nbytes);
; Return:
; DX:AX
; -address of allocate space on	far heap
; -NULL	if failure (DX = AX = 0)
;
; Attributes: library function bp-based	frame

; void far *__cdecl farmalloc(unsigned __int32 nbytes)
proc _farmalloc	far	; CODE XREF: LibMalloc_FarReAlloc_s115FE+Ep
			; _farrealloc+5Dp
			; ST_AllocateSpace+1DP
			; ST_FarMalloc+1AP
			; malloc_s14954+1AP
			; __OvrPrepare+32P

nbytes=	dword ptr  6

push	bp
mov	bp, sp
mov	dx, [word ptr bp+nbytes+2]
mov	ax, [word ptr bp+nbytes]
mov	cx, ax
or	cx, dx		; Logical Inclusive OR
push	si
push	di
mov	[cs:LibMalloc_w1133D], ds
jz	short loc_115F5	; Jump if Zero (ZF=1)
add	ax, 19		; Add
adc	dx, 0		; Add with Carry
jb	short loc_115E0	; Jump if Below	(CF=1)
test	dx, 1111111111110000b ;	Logical	Compare
jnz	short loc_115E0	; Jump if Not Zero (ZF=0)
mov	cl, 4
shr	ax, cl		; / 16
shl	dx, cl		; * 16
or	ah, dl		; Logical Inclusive OR
mov	dx, [cs:LibMalloc____first]
or	dx, dx		; Logical Inclusive OR
jz	short loc_115D6	; Jump if Zero (ZF=1)
mov	dx, [cs:LibMalloc____rover]
or	dx, dx		; Logical Inclusive OR
jz	short loc_115D1	; Jump if Zero (ZF=1)
mov	bx, dx

loc_115C1:		; CODE XREF: _farmalloc+4Ej
mov	ds, dx
cmp	[LibMalloc_w31D10], ax ; Compare Two Operands
jnb	short loc_115E5	; Jump if Not Below (CF=0)
mov	dx, [LibMalloc_w31D16]
cmp	dx, bx		; Compare Two Operands
jnz	short loc_115C1	; Jump if Not Zero (ZF=0)

loc_115D1:		; CODE XREF: _farmalloc+3Cj
call	LibMalloc_s11504 ; Call	Procedure
jmp	short loc_115F5	; Jump

loc_115D6:		; CODE XREF: _farmalloc+33j
call	LibMalloc_s114A0 ; Call	Procedure
jmp	short loc_115F5	; Jump

loc_115DB:		; CODE XREF: _farmalloc:loc_115E5j
call	LibMalloc_s1155E ; Call	Procedure
jmp	short loc_115F5	; Jump

loc_115E0:		; CODE XREF: _farmalloc+1Cj
			; _farmalloc+22j
xor	ax, ax		; Logical Exclusive OR
cwd			; AX ->	DX:AX (with sign)
jmp	short loc_115F5	; Jump

loc_115E5:		; CODE XREF: _farmalloc+46j
ja	short loc_115DB	; Jump if Above	(CF=0 &	ZF=0)
call	LibMalloc_s11417 ; Call	Procedure
mov	bx, [LibMalloc_w31D18]
mov	[LibMalloc_w31D12], bx
mov	ax, offset LibMalloc_w31D14

loc_115F5:		; CODE XREF: _farmalloc+14j
			; _farmalloc+53j
			; _farmalloc+58j
			; _farmalloc+5Dj
			; _farmalloc+62j
mov	ds, [cs:LibMalloc_w1133D]
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp _farmalloc

; [0000007C BYTES: COLLAPSED FUNCTION LibMalloc_FarReAlloc_s115FE. PRESS KEYPAD	"+" TO EXPAND]
; [00000064 BYTES: COLLAPSED FUNCTION idk_FarFreeOrBrk.	PRESS KEYPAD "+" TO EXPAND]
; [0000007A BYTES: COLLAPSED FUNCTION _farrealloc. PRESS KEYPAD	"+" TO EXPAND]


; Attributes: library function bp-based	frame

; int __stdcall	idk_InBrkSbrk(void *addr)
proc idk_InBrkSbrk near	; CODE XREF: __brk+2Fp
			; __sbrk+7Ap

addr= dword ptr	 4

push	bp
mov	bp, sp
push	si
mov	si, [word ptr bp+addr+2]
inc	si		; Increment by 1
sub	si, [_psp@]	; Integer Subtraction
add	si, 63		; Add
mov	cl, 6
shr	si, cl		; SI = SI * 64
cmp	si, [SegX_w36F82] ; Compare Two	Operands
jnz	short loc_11783	; Jump if Not Zero (ZF=0)

loc_11771:		; CODE XREF: idk_InBrkSbrk+5Fj
mov	ax, [word ptr bp+addr+2]
mov	dx, [word ptr bp+addr]
mov	[word ptr _brklvl@+2], ax
mov	[word ptr _brklvl@], dx
mov	ax, 1
jmp	short loc_117C9	; Jump

loc_11783:		; CODE XREF: idk_InBrkSbrk+17j
mov	cl, 6
shl	si, cl		; Shift	Logical	Left
mov	dx, [word ptr _heaptop@+2]
mov	ax, si
add	ax, [_psp@]	; Add
cmp	ax, dx		; Compare Two Operands
jbe	short loc_1179B	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	si, dx
sub	si, [_psp@]	; Integer Subtraction

loc_1179B:		; CODE XREF: idk_InBrkSbrk+3Bj
push	si		; newsize
push	[_psp@]		; segx
nop			; No Operation
push	cs
call	near ptr _setblock ; Call Procedure
pop	cx
pop	cx
mov	dx, ax
db 83h,0FAh,0FFh ; <BAD>cmp	dx, 0FFFFh ; Compare Two Operands
jnz	short loc_117B9	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	cl, 6
shr	ax, cl		; Shift	Logical	Right
mov	[SegX_w36F82], ax
jmp	short loc_11771	; Jump

loc_117B9:		; CODE XREF: idk_InBrkSbrk+54j
mov	ax, [_psp@]
add	ax, dx		; Add
mov	[word ptr _heaptop@+2],	ax
mov	[word ptr _heaptop@], 0
xor	ax, ax		; Logical Exclusive OR

loc_117C9:		; CODE XREF: idk_InBrkSbrk+29j
pop	si
pop	bp
retn	4		; Return Near from Procedure
endp idk_InBrkSbrk ; sp-analysis failed



; BORLANDC\CRTL\CLIB\BRK.CAS
; /*---------------------------------------------------------------------------
;  * filename -	brk.cas
;  *
;  * function(s)
;  *	    brk	   - memory model dependent hook to _brk or __brk
;  *	    sbrk   - memory model dependent hook to _sbrk or __sbrk
;  *	    __brk  - changes data-segment space	allocation on the near heap
;  *	    __sbrk - changes data-segment space	allocation on the near heap
;  *--------------------------------------------------------------------------*/
; /*--------------------------------------------------------------------------*
;    In	the large data models brk and sbrk are hooks to	_brk and
;    _sbrk respectively.  _brk and _sbrk work with the far heap.
;    _brk and _sbrk are	found in fbrk.c
; *---------------------------------------------------------------------------*/
;
; Attributes: library function bp-based	frame

; int __cdecl _brk(void	*addr)
proc __brk near		; CODE XREF: LibMalloc_s11343:loc_1139Fp
			; idk_FarFreeOrBrk+59p

addr= dword ptr	 4

push	bp
mov	bp, sp
mov	cx, [word ptr _heapbase@+2]
mov	bx, [word ptr _heapbase@]
mov	dx, [word ptr bp+addr+2]
mov	ax, [word ptr bp+addr]
call	N_PCMP@		; Call Procedure
jb	short loc_11804	; Jump if Below	(CF=1)
mov	cx, [word ptr _heaptop@+2]
mov	bx, [word ptr _heaptop@]
mov	dx, [word ptr bp+addr+2]
mov	ax, [word ptr bp+addr]
call	N_PCMP@		; Call Procedure
ja	short loc_11804	; Jump if Above	(CF=0 &	ZF=0)
push	[word ptr bp+addr+2]
push	[word ptr bp+addr] ; addr
call	idk_InBrkSbrk	; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_11809	; Jump if Not Zero (ZF=0)

loc_11804:		; CODE XREF: __brk+14j
			; __brk+27j
mov	ax, -1
jmp	short loc_1180B	; Jump

loc_11809:		; CODE XREF: __brk+34j
xor	ax, ax		; Logical Exclusive OR

loc_1180B:		; CODE XREF: __brk+39j
pop	bp
retn			; Return Near from Procedure
endp __brk

; [0000008B BYTES: COLLAPSED FUNCTION __sbrk. PRESS KEYPAD "+" TO EXPAND]
; [00000027 BYTES: COLLAPSED FUNCTION _ioctl. PRESS KEYPAD "+" TO EXPAND]
; [00000097 BYTES: COLLAPSED FUNCTION __LoadProg. PRESS	KEYPAD "+" TO EXPAND]
; [0000001D BYTES: COLLAPSED FUNCTION _free. PRESS KEYPAD "+" TO EXPAND]
; [0000003A BYTES: COLLAPSED FUNCTION sub_11973. PRESS KEYPAD "+" TO EXPAND]
; [00000039 BYTES: COLLAPSED FUNCTION sub_119AD. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function

proc LibMalloc_s119E6 near
			; CODE XREF: sub_11973+1Cp
			; _malloc+53p
mov	di, [bx+6]
cmp	bx, di		; Compare Two Operands
jz	short loc_119FB	; Jump if Zero (ZF=1)
mov	[LibMalloc_w36F88], di
mov	si, [bx+4]
mov	[di+4],	si
mov	[si+6],	di
retn			; Return Near from Procedure

loc_119FB:		; CODE XREF: LibMalloc_s119E6+5j
mov	[LibMalloc_w36F88], 0
retn			; Return Near from Procedure
endp LibMalloc_s119E6

; [00000023 BYTES: COLLAPSED FUNCTION sub_11A02. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function

; void *__cdecl	malloc(size_t size)
proc _malloc far	; CODE XREF: __DOSCMD+53p
			; __DOSENV+5Ap
			; sub_11B07+7p
			; _realloc+42p
			; unknown_libname_2+9p
			; unknown_libname_2+29p
			; _setvbuf+A5p

size= word ptr	8

push	si
push	di
mov	si, sp
mov	ax, [si+8]
or	ax, ax		; Logical Inclusive OR
jz	short loc_11A82	; Jump if Zero (ZF=1)
add	ax, 5		; Add
jb	short loc_11A6B	; Jump if Below	(CF=1)
and	ax, 1111111111111110b ;	Logical	AND
cmp	ax, 8		; Compare Two Operands
jnb	short loc_11A40	; Jump if Not Below (CF=0)
mov	ax, 8

loc_11A40:		; CODE XREF: _malloc+16j
cmp	[LibMalloc_w36F84], 0 ;	Compare	Two Operands
jz	short loc_11A66	; Jump if Zero (ZF=1)
mov	bx, [LibMalloc_w36F88]
or	bx, bx		; Logical Inclusive OR
jz	short loc_11A5C	; Jump if Zero (ZF=1)
mov	dx, bx

loc_11A51:		; CODE XREF: _malloc+35j
cmp	[bx], ax	; Compare Two Operands
jnb	short loc_11A6F	; Jump if Not Below (CF=0)
mov	bx, [bx+6]
cmp	bx, dx		; Compare Two Operands
jnz	short loc_11A51	; Jump if Not Zero (ZF=0)

loc_11A5C:		; CODE XREF: _malloc+28j
call	LibMalloc_s11AC5 ; Call	Procedure
jmp	short loc_11A82	; Jump

loc_11A61:		; CODE XREF: _malloc+51j
call	LibMalloc_s11AEE ; Call	Procedure
jmp	short loc_11A82	; Jump

loc_11A66:		; CODE XREF: _malloc+20j
call	LibMalloc_s11A85 ; Call	Procedure
jmp	short loc_11A82	; Jump

loc_11A6B:		; CODE XREF: _malloc+Ej
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_11A82	; Jump

loc_11A6F:		; CODE XREF: _malloc+2Ej
mov	si, ax
add	si, 8		; Add
cmp	[bx], si	; Compare Two Operands
jnb	short loc_11A61	; Jump if Not Below (CF=0)
call	LibMalloc_s119E6 ; Call	Procedure
inc	[word ptr bx]	; Increment by 1
mov	ax, bx
add	ax, 4		; Add

loc_11A82:		; CODE XREF: _malloc+9j
			; _malloc+3Aj
			; _malloc+3Fj
			; _malloc+44j
			; _malloc+48j
pop	di
pop	si
retf			; Return Far from Procedure
endp _malloc



; Attributes: library function

proc LibMalloc_s11A85 near
			; CODE XREF: _malloc:loc_11A66p
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	ax		; incr
call	___sbrk		; Call Procedure
pop	bx
pop	bx
and	ax, 1		; Logical AND
jz	short loc_11A9D	; Jump if Zero (ZF=1)
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax		; incr
call	___sbrk		; Call Procedure
pop	bx
pop	bx

loc_11A9D:		; CODE XREF: LibMalloc_s11A85+Dj
pop	ax
push	ax
xor	bx, bx		; Logical Exclusive OR
push	bx
push	ax		; incr
call	___sbrk		; Call Procedure
pop	bx
pop	bx
cmp	ax, 0FFFFh	; Compare Two Operands
jz	short loc_11AC1	; Jump if Zero (ZF=1)
mov	bx, ax
mov	[LibMalloc_w36F84], bx
mov	[word_36F86], bx
pop	ax
inc	ax		; Increment by 1
mov	[bx], ax
add	bx, 4		; Add
mov	ax, bx
retn			; Return Near from Procedure

loc_11AC1:		; CODE XREF: LibMalloc_s11A85+26j
pop	bx
xor	ax, ax		; Logical Exclusive OR
retn			; Return Near from Procedure
endp LibMalloc_s11A85



; Attributes: library function

proc LibMalloc_s11AC5 near
			; CODE XREF: _malloc:loc_11A5Cp
push	ax
xor	bx, bx		; Logical Exclusive OR
push	bx
push	ax		; incr
call	___sbrk		; Call Procedure
pop	bx
pop	bx
cmp	ax, 0FFFFh	; Compare Two Operands
jz	short loc_11AEA	; Jump if Zero (ZF=1)
mov	bx, ax
mov	ax, [word_36F86]
mov	[bx+2],	ax
mov	[word_36F86], bx
pop	ax
inc	ax		; Increment by 1
mov	[bx], ax
add	bx, 4		; Add
mov	ax, bx
retn			; Return Near from Procedure

loc_11AEA:		; CODE XREF: LibMalloc_s11AC5+Dj
pop	ax
xor	ax, ax		; Logical Exclusive OR
retn			; Return Near from Procedure
endp LibMalloc_s11AC5



; Attributes: library function

proc LibMalloc_s11AEE near
			; CODE XREF: _malloc:loc_11A61p
sub	[bx], ax	; Integer Subtraction
mov	si, bx
add	si, [bx]	; Add
mov	di, si
add	di, ax		; Add
inc	ax		; Increment by 1
mov	[si], ax
mov	[si+2],	bx
mov	[di+2],	si
add	si, 4		; Add
mov	ax, si
retn			; Return Near from Procedure
endp LibMalloc_s11AEE

; [00000035 BYTES: COLLAPSED FUNCTION sub_11B07. PRESS KEYPAD "+" TO EXPAND]
; [00000042 BYTES: COLLAPSED FUNCTION sub_11B3C. PRESS KEYPAD "+" TO EXPAND]
; [00000053 BYTES: COLLAPSED FUNCTION _realloc.	PRESS KEYPAD "+" TO EXPAND]
byte_11BD1 db 2	dup(0)	; DATA XREF: seg000:1BDFw
			; seg000:1C96r
			; seg000:1CC5r

unknown_libname_1:	; TCC/TCC++/BCC++ 16 bit DOS
pop	[word_36F8E]
pop	[word_36F90]
pop	[word_36F92]
mov	[word ptr cs:byte_11BD1], ds
mov	[word_36F94], si
mov	[word_36F96], di
cld			; Clear	Direction Flag
mov	es, [_psp@]
assume es:nothing
mov	si, 80h	; ''
xor	ah, ah		; Logical Exclusive OR
lods	[byte ptr es:si] ; Load	String
inc	ax		; Increment by 1
mov	bp, es
xchg	dx, si		; Exchange Register/Memory with	Register
xchg	ax, bx		; Exchange Register/Memory with	Register
mov	si, [_envLng@]
inc	si		; Increment by 1
inc	si		; Increment by 1
mov	cx, 1
cmp	[_version@], 3	; Compare Two Operands

loc_11C0C:		; Jump if Below	(CF=1)
jb	short loc_11C1F
mov	es, [_envseg@]
mov	di, si
mov	cl, 7Fh	; ''
xor	al, al		; Logical Exclusive OR
repne scasb		; Compare String
jcxz	short loc_11C8E	; Jump if CX is	0
xor	cl, 7Fh		; Logical Exclusive OR

loc_11C1F:		; CODE XREF: seg000:loc_11C0Cj
push	ax
mov	ax, cx
add	ax, bx		; Add
inc	ax		; Increment by 1
and	ax, 0FFFEh	; Logical AND
mov	di, sp
sub	di, ax		; Integer Subtraction
jb	short loc_11C8E	; Jump if Below	(CF=1)
mov	sp, di
push	es
pop	ds
push	ss
pop	es
assume es:dseg
push	cx
dec	cx		; Decrement by 1
rep movsb		; Move Byte(s) from String to String
xor	al, al		; Logical Exclusive OR
stosb			; Store	String
mov	ds, bp
xchg	si, dx		; Exchange Register/Memory with	Register
xchg	bx, cx		; Exchange Register/Memory with	Register
mov	ax, bx
mov	dx, ax
inc	bx		; Increment by 1

loc_11C46:		; CODE XREF: seg000:1C60j
			; seg000:1C64j
call	sub_11C66	; Call Procedure
ja	short loc_11C56	; Jump if Above	(CF=0 &	ZF=0)

loc_11C4B:		; CODE XREF: seg000:1C54j
jb	short loc_11C93	; Jump if Below	(CF=1)
cmp	al, 0Dh		; Compare Two Operands
jz	short loc_11C62	; Jump if Zero (ZF=1)
call	sub_11C66	; Call Procedure
ja	short loc_11C4B	; Jump if Above	(CF=0 &	ZF=0)

loc_11C56:		; CODE XREF: seg000:1C49j
cmp	al, 20h	; ' '   ; Compare Two Operands
jz	short loc_11C62	; Jump if Zero (ZF=1)
cmp	al, 0Dh		; Compare Two Operands
jz	short loc_11C62	; Jump if Zero (ZF=1)
cmp	al, 9		; Compare Two Operands
jnz	short loc_11C46	; Jump if Not Zero (ZF=0)

loc_11C62:		; CODE XREF: seg000:1C4Fj
			; seg000:1C58j
			; seg000:1C5Cj
xor	al, al		; Logical Exclusive OR
jmp	short loc_11C46	; Jump



proc sub_11C66 near	; CODE XREF: seg000:loc_11C46p
			; seg000:1C51p
or	ax, ax		; Logical Inclusive OR
jz	short loc_11C71	; Jump if Zero (ZF=1)
inc	dx		; Increment by 1
stosb			; Store	String
or	al, al		; Logical Inclusive OR
jnz	short loc_11C71	; Jump if Not Zero (ZF=0)
inc	bx		; Increment by 1

loc_11C71:		; CODE XREF: sub_11C66+2j
			; sub_11C66+8j
xchg	ah, al		; Exchange Register/Memory with	Register
xor	al, al		; Logical Exclusive OR
stc			; Set Carry Flag
jcxz	short locret_11C8D ; Jump if CX	is 0
lodsb			; Load String
dec	cx		; Decrement by 1
sub	al, 22h	; '"'   ; Integer Subtraction
jz	short locret_11C8D ; Jump if Zero (ZF=1)
add	al, 22h	; '"'   ; Add
cmp	al, 5Ch	; '\'   ; Compare Two Operands
jnz	short loc_11C8B	; Jump if Not Zero (ZF=0)
cmp	[byte ptr si], 22h ; '"' ; Compare Two Operands
jnz	short loc_11C8B	; Jump if Not Zero (ZF=0)
lodsb			; Load String
dec	cx		; Decrement by 1

loc_11C8B:		; CODE XREF: sub_11C66+1Cj
			; sub_11C66+21j
or	si, si		; Logical Inclusive OR

locret_11C8D:		; CODE XREF: sub_11C66+10j
			; sub_11C66+16j
retn			; Return Near from Procedure
endp sub_11C66


loc_11C8E:		; CODE XREF: seg000:1C1Aj
			; seg000:1C2Cj
			; seg000:1CA8j
nop			; No Operation
nop			; No Operation
jmp	_abort		; Jump

loc_11C93:		; CODE XREF: seg000:loc_11C4Bj
pop	cx
add	cx, dx		; Add
mov	ds, [word ptr cs:byte_11BD1]
mov	[word_36F8A], bx
inc	bx		; Increment by 1
add	bx, bx		; Add
mov	si, sp
mov	bp, sp
sub	bp, bx		; Integer Subtraction
jb	short loc_11C8E	; Jump if Below	(CF=1)
mov	sp, bp
mov	[word_36F8C], bp

loc_11CB0:		; CODE XREF: seg000:1CBEj
jcxz	short loc_11CC0	; Jump if CX is	0
mov	[bp+0],	si
add	bp, 2		; Add

loc_11CB8:		; CODE XREF: seg000:1CBCj
lods	[byte ptr ss:si] ; Load	String
or	al, al		; Logical Inclusive OR
loopne	loc_11CB8	; Loop while rCX != 0 and ZF=0
jz	short loc_11CB0	; Jump if Zero (ZF=1)

loc_11CC0:		; CODE XREF: seg000:loc_11CB0j
xor	ax, ax		; Logical Exclusive OR
mov	[bp+0],	ax
mov	ds, [word ptr cs:byte_11BD1]
mov	si, [word_36F94]
mov	di, [word_36F96]
push	[word_36F92]
push	[word_36F90]
mov	ax, [word_36F8A]
mov	[argc],	ax
mov	ax, [word_36F8C]
mov	[argv],	ax
jmp	[word_36F8E]	; Indirect Near	Jump


; Attributes: library function bp-based	frame

; int __cdecl setblock(unsigned	int segx, unsigned int newsize)
proc _setblock far	; CODE XREF: idk_InBrkSbrk+4Ap

segx= word ptr	6
newsize= word ptr  8

push	bp
mov	bp, sp
mov	ah, 4Ah
mov	bx, [bp+newsize]
mov	es, [bp+segx]
assume es:nothing
int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
jb	short loc_11CFE	; Jump if Below	(CF=1)
mov	ax, 0FFFFh
jmp	short loc_11D04	; Jump

loc_11CFE:		; CODE XREF: _setblock+Dj
push	bx
push	ax
call	__IOERROR	; Call Procedure
pop	ax

loc_11D04:		; CODE XREF: _setblock+12j
pop	bp
retf			; Return Far from Procedure
endp _setblock



; TCC/TCC++/BCC++ 16 bit DOS
; Attributes: library function

proc unknown_libname_2 far
push	si
push	di
mov	cx, [_envLng@]
push	cx		; size
nop			; No Operation
push	cs
call	near ptr _malloc ; void	*__cdecl malloc(size_t size);
			; NOTE:	It appears to no use the "size"	variable.
pop	cx
mov	di, ax
or	ax, ax		; Logical Inclusive OR
jz	short loc_11D3D	; Jump if Zero (ZF=1)
push	ds
push	ds
pop	es
assume es:dseg
mov	ds, [_envseg@]
xor	si, si		; Logical Exclusive OR
cld			; Clear	Direction Flag
rep movsb		; Move Byte(s) from String to String
pop	ds
mov	di, ax
push	es
push	[_envSize@]	; size
nop			; No Operation
push	cs
call	near ptr _malloc ; void	*__cdecl malloc(size_t size);
			; NOTE:	It appears to not use the "size" variable.
pop	bx
mov	bx, ax
pop	es
assume es:nothing
mov	[word_36F98], ax
or	ax, ax		; Logical Inclusive OR
jnz	short loc_11D42	; Jump if Not Zero (ZF=0)

loc_11D3D:		; CODE XREF: unknown_libname_2+11j
nop			; No Operation
nop			; No Operation
jmp	_abort		; Jump

loc_11D42:		; CODE XREF: unknown_libname_2+35j
xor	ax, ax		; Logical Exclusive OR
mov	cx, 0FFFFh
cmp	[byte ptr di], 0 ; Compare Two Operands
jz	short loc_11D58	; Jump if Zero (ZF=1)

loc_11D4C:		; CODE XREF: unknown_libname_2+50j
mov	[bx], di
add	bx, 2		; Add
repne scasb		; Compare String
cmp	[es:di], al	; Compare Two Operands
jnz	short loc_11D4C	; Jump if Not Zero (ZF=0)

loc_11D58:		; CODE XREF: unknown_libname_2+44j
mov	[bx], ax
pop	di
pop	si
mov	ax, [word_36F98]
mov	[envp],	ax
retn			; Return Near from Procedure
endp unknown_libname_2 ; sp-analysis failed

; [0000001B BYTES: COLLAPSED FUNCTION __chmod. PRESS KEYPAD "+"	TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION _close. PRESS KEYPAD "+" TO EXPAND]
; [0000001E BYTES: COLLAPSED FUNCTION __close. PRESS KEYPAD "+"	TO EXPAND]
; [00000052 BYTES: COLLAPSED FUNCTION _fcloseall. PRESS	KEYPAD "+" TO EXPAND]
; [00000077 BYTES: COLLAPSED FUNCTION _eof. PRESS KEYPAD "+" TO	EXPAND]
; [00000081 BYTES: COLLAPSED FUNCTION _fclose. PRESS KEYPAD "+"	TO EXPAND]
; [00000081 BYTES: COLLAPSED FUNCTION _fflush. PRESS KEYPAD "+"	TO EXPAND]
; [0000003A BYTES: COLLAPSED FUNCTION _flushall. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function bp-based	frame

proc hrmCheckAccessMode	near
			; CODE XREF: __OPENFP+15p

var_2= word ptr	-2
arg_0= word ptr	 4
arg_2= word ptr	 6
arg4mode= word ptr  8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg4mode]
mov	[bp+var_2], 0
mov	bx, si
inc	si		; Increment by 1
mov	cl, [bx]
mov	al, cl
cmp	al, 'r'         ; Compare Two Operands
jnz	short loc_11FEC	; Jump if Not Zero (ZF=0)
mov	dx, 1
mov	di, 1
jmp	short loc_1200C	; Jump

loc_11FEC:		; CODE XREF: hrmCheckAccessMode+19j
cmp	cl, 'w'         ; Compare Two Operands
jnz	short loc_11FF6	; Jump if Not Zero (ZF=0)
mov	dx, 302h
jmp	short loc_11FFE	; Jump

loc_11FF6:		; CODE XREF: hrmCheckAccessMode+26j
cmp	cl, 'a'         ; Compare Two Operands
jnz	short loc_12008	; Jump if Not Zero (ZF=0)
mov	dx, 902h

loc_11FFE:		; CODE XREF: hrmCheckAccessMode+2Bj
mov	[bp+var_2], 80h	; ''
mov	di, 2
jmp	short loc_1200C	; Jump

loc_12008:		; CODE XREF: hrmCheckAccessMode+30j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1207B	; Jump

loc_1200C:		; CODE XREF: hrmCheckAccessMode+21j
			; hrmCheckAccessMode+3Dj
mov	cl, [si]
inc	si		; Increment by 1
cmp	cl, '+'         ; Compare Two Operands
jz	short loc_12023	; Jump if Zero (ZF=1)
cmp	[byte ptr si], '+' ; Compare Two Operands
jnz	short loc_12038	; Jump if Not Zero (ZF=0)
cmp	cl, 't'         ; Compare Two Operands
jz	short loc_12023	; Jump if Zero (ZF=1)
cmp	cl, 'b'         ; Compare Two Operands
jnz	short loc_12038	; Jump if Not Zero (ZF=0)

loc_12023:		; CODE XREF: hrmCheckAccessMode+49j
			; hrmCheckAccessMode+53j
cmp	cl, '+'         ; Compare Two Operands
jnz	short loc_1202A	; Jump if Not Zero (ZF=0)
mov	cl, [si]

loc_1202A:		; CODE XREF: hrmCheckAccessMode+5Dj
db 83h,0E2h,0FCh ; <BAD>and	dx, 0FFFCh ; Logical AND
or	dx, 4		; Logical Inclusive OR
mov	[bp+var_2], 180h
mov	di, 3

loc_12038:		; CODE XREF: hrmCheckAccessMode+4Ej
			; hrmCheckAccessMode+58j
cmp	cl, 't'         ; Compare Two Operands
jnz	short loc_12043	; Jump if Not Zero (ZF=0)
or	dx, 4000h	; Logical Inclusive OR
jmp	short loc_12060	; Jump

loc_12043:		; CODE XREF: hrmCheckAccessMode+72j
cmp	cl, 'b'         ; Compare Two Operands
jnz	short loc_1204E	; Jump if Not Zero (ZF=0)
or	dx, 8000h	; Logical Inclusive OR
jmp	short loc_1205D	; Jump

loc_1204E:		; CODE XREF: hrmCheckAccessMode+7Dj
mov	ax, [word_36F04]
and	ax, 0C000h	; Logical AND
or	dx, ax		; Logical Inclusive OR
mov	ax, dx
test	ax, 8000h	; Logical Compare
jz	short loc_12060	; Jump if Zero (ZF=1)

loc_1205D:		; CODE XREF: hrmCheckAccessMode+83j
or	di, 40h		; Logical Inclusive OR

loc_12060:		; CODE XREF: hrmCheckAccessMode+78j
			; hrmCheckAccessMode+92j
mov	[word ptr ptr_exitfopen+2], seg	seg000
mov	[word ptr ptr_exitfopen], offset __xfclose
mov	bx, [bp+arg_2]
mov	[bx], dx
mov	bx, [bp+arg_0]
mov	ax, [bp+var_2]

loc_12077:
mov	[bx], ax
mov	ax, di

loc_1207B:		; CODE XREF: hrmCheckAccessMode+41j
pop	di
pop	si
mov	sp, bp
pop	bp
retn	6		; Return Near from Procedure
endp hrmCheckAccessMode



; int arg_0,int	arg_2,char *argPathName
; Attributes: library function bp-based	frame

; int __fastcall _OPENFP(int, int, char	*argPathName)
proc __OPENFP near	; CODE XREF: _fopen+1Ap

varAccessMode= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 4
arg_2= word ptr	 6
argPathName= dword ptr	8

push	bp
mov	bp, sp
sub	sp, 4		; argSize
push	si		; argType
mov	si, [word ptr bp+argPathName+2]
push	[bp+arg_2]
lea	ax, [bp+var_2]	; Load Effective Address
push	ax
lea	ax, [bp+varAccessMode] ; Load Effective	Address
push	ax
call	hrmCheckAccessMode ; Call Procedure
mov	[si+2],	ax
or	ax, ax		; Logical Inclusive OR
jz	short loc_120C4	; Jump if Zero (ZF=1)
cmp	[byte ptr si+4], 0 ; Compare Two Operands
jge	short loc_120D1	; Jump if Greater or Equal (SF=OF)
push	[bp+varAccessMode] ; argAccessMode
mov	ax, [bp+var_2]
or	ax, [bp+arg_0]	; Logical Inclusive OR
push	ax
push	[word ptr bp+argPathName] ; argPathName
nop			; No Operation
push	cs
call	near ptr _open	; argPathName,argAccessMode
add	sp, 6		; Add
mov	[si+4],	al
or	al, al		; Logical Inclusive OR
jge	short loc_120D1	; Jump if Greater or Equal (SF=OF)

loc_120C4:		; CODE XREF: __OPENFP+1Dj
mov	[byte ptr si+4], 255
mov	[word ptr si+2], 0

loc_120CD:		; CODE XREF: __OPENFP+8Cj
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_12118	; Jump

loc_120D1:		; CODE XREF: __OPENFP+23j
			; __OPENFP+3Fj
mov	al, [si+4]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _isatty ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_120E5	; Jump if Zero (ZF=1)
or	[word ptr si+2], 512 ; Logical Inclusive OR

loc_120E5:		; CODE XREF: __OPENFP+5Bj
mov	ax, 512
push	ax
test	[word ptr si+2], 512 ; Logical Compare
jz	short loc_120F5	; Jump if Zero (ZF=1)
mov	ax, 1
jmp	short loc_120F7	; Jump

loc_120F5:		; CODE XREF: __OPENFP+6Bj
xor	ax, ax		; Logical Exclusive OR

loc_120F7:		; CODE XREF: __OPENFP+70j
push	ax		; argBuffer
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si		; argStream
nop			; No Operation
push	cs
call	near ptr _setvbuf ; argStream,argBuffer,arg_6,argType,argSize
add	sp, 8		; Add
or	ax, ax		; Logical Inclusive OR
jz	short loc_12111	; Jump if Zero (ZF=1)
push	si		; argFileStream
nop			; No Operation
push	cs
call	near ptr _fclose ; FILE	*argFileStream
pop	cx
jmp	short loc_120CD	; Jump

loc_12111:		; CODE XREF: __OPENFP+83j
mov	[word ptr si+0Ch], 0 ;
			; i.e. SI + 3 Bytes ...	array ref?
mov	ax, si

loc_12118:		; CODE XREF: __OPENFP+4Cj
pop	si
mov	sp, bp
pop	bp
retn	8		; Return Near from Procedure
endp __OPENFP ;	sp-analysis failed



; Attributes: library function

proc __GETFP near	; CODE XREF: _fopen+3p
push	si
mov	si, offset word_36D9A

loc_12123:		; CODE XREF: __GETFP+1Bj
cmp	[byte ptr si+4], 0 ; Compare Two Operands
jl	short loc_1213C	; Jump if Less (SF!=OF)
mov	ax, [__nfile]
mov	cl, 4
shl	ax, cl		; AX = AX / 16?
add	ax, offset word_36D9A ;	Add
mov	dx, si
add	si, 16		; Add
cmp	ax, dx		; Compare Two Operands
ja	short loc_12123	; Jump if Above	(CF=0 &	ZF=0)

loc_1213C:		; CODE XREF: __GETFP+8j
cmp	[byte ptr si+4], 0 ; Compare Two Operands
jl	short loc_12146	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_12148	; Jump

loc_12146:		; CODE XREF: __GETFP+21j
mov	ax, si

loc_12148:		; CODE XREF: __GETFP+25j
pop	si
retn			; Return Near from Procedure
endp __GETFP



; argPathFileName,argMode
; Attributes: library function bp-based	frame

; FILE *__cdecl	fopen(const char *argPathFileName, const char *argMode)
proc _fopen far		; CODE XREF: _f010109_main+33P
			; _f010109_main+245P
			; _f010309_RUN:loc_1366CP
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+51P
			; ST_ScreenDump+DBP
			; OVR_SaveGame_MagicSet+3C8P
			; sub_3CFC0+E2P
			; sub_3CFC0+2C0P
			; ST_MagicSet_ReadCreateWrite+3BP
			; ST_MagicSet_ReadCreateWrite+60P
			; ST_MagicSet_ReadCreateWrite+FCP
			; sub_3E1DE:loc_3E32EP
			; sub_3E1DE+33DP

argPathFileName= dword ptr  6
argMode= dword ptr  0Ah

push	bp
mov	bp, sp
call	__GETFP		; Call Procedure
mov	dx, ax		; int
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1215A	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_12167	; Jump

loc_1215A:		; CODE XREF: _fopen+Aj
push	dx		; int
push	[word ptr bp+argPathFileName] ;	int
push	[word ptr bp+argPathFileName+2]
xor	ax, ax		; int
push	ax		; path
call	__OPENFP	; int arg_0,int	arg_2,char *argPathName

loc_12167:		; CODE XREF: _fopen+Ej
pop	bp
retf			; Return Far from Procedure
endp _fopen ; sp-analysis failed



; Attributes: library function bp-based	frame

; int __fastcall _FGETN_jwb(int, int, int, FILE	*stream, void *buf)
proc __FGETN_jwb near	; CODE XREF: _fread+34p

stream=	dword ptr  4
buf= dword ptr	8

push	bp
mov	bp, sp
push	si
push	di		; len
jmp	loc_1222E	; Jump

loc_12171:		; CODE XREF: __FGETN_jwb+CBj
inc	[word ptr bp+stream+2] ; Increment by 1
mov	bx, [word ptr bp+stream]
mov	ax, [bx+6]
cmp	ax, [word ptr bp+stream+2] ; Compare Two Operands
jbe	short loc_12184	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	ax, [word ptr bp+stream+2]
jmp	short loc_1218A	; Jump

loc_12184:		; CODE XREF: __FGETN_jwb+14j
mov	bx, [word ptr bp+stream]
mov	ax, [bx+6]

loc_1218A:		; CODE XREF: __FGETN_jwb+19j
mov	di, ax
mov	bx, [word ptr bp+stream]
test	[word ptr bx+2], 40h ; Logical Compare
jz	short loc_121F9	; Jump if Zero (ZF=1)
cmp	[word ptr bx+6], 0 ; Compare Two Operands
jz	short loc_121F9	; Jump if Zero (ZF=1)
mov	ax, [bx+6]
cmp	ax, [word ptr bp+stream+2] ; Compare Two Operands
jnb	short loc_121F9	; Jump if Not Below (CF=0)
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_121F9	; Jump if Not Zero (ZF=0)
dec	[word ptr bp+stream+2] ; Decrement by 1
xor	di, di		; Logical Exclusive OR
jmp	short loc_121BC	; Jump

loc_121B0:		; CODE XREF: __FGETN_jwb+5Cj
mov	bx, [word ptr bp+stream]
add	di, [bx+6]	; Add
mov	ax, [bx+6]
sub	[word ptr bp+stream+2],	ax ; Integer Subtraction

loc_121BC:		; CODE XREF: __FGETN_jwb+45j
mov	bx, [word ptr bp+stream]
mov	ax, [bx+6]
cmp	ax, [word ptr bp+stream+2] ; Compare Two Operands
jbe	short loc_121B0	; Jump if Below	or Equal (CF=1 | ZF=1)
push	di
push	[word ptr bp+buf] ; buf
mov	al, [bx+4]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr __read	; Call Procedure
add	sp, 6		; Add
mov	dx, ax
add	[word ptr bp+buf], dx ;	Add
cmp	dx, di		; Compare Two Operands
jz	short loc_1222E	; Jump if Zero (ZF=1)
mov	ax, di
sub	ax, dx		; Integer Subtraction
add	[word ptr bp+stream+2],	ax ; Add

loc_121E8:		; CODE XREF: __FGETN_jwb+C3j
mov	bx, [word ptr bp+stream]
or	[word ptr bx+2], 20h ; Logical Inclusive OR
jmp	short loc_12237	; Jump

loc_121F1:		; CODE XREF: __FGETN_jwb+BEj
mov	bx, [word ptr bp+buf]
mov	[bx], dl
inc	[word ptr bp+buf] ; Increment by 1

loc_121F9:		; CODE XREF: __FGETN_jwb+2Bj
			; __FGETN_jwb+31j
			; __FGETN_jwb+39j
			; __FGETN_jwb+3Ej
dec	[word ptr bp+stream+2] ; Decrement by 1
mov	ax, [word ptr bp+stream+2]
or	ax, ax		; Logical Inclusive OR
jz	short loc_12229	; Jump if Zero (ZF=1)
dec	di		; Decrement by 1
jz	short loc_12229	; Jump if Zero (ZF=1)
mov	bx, [word ptr bp+stream]
dec	[word ptr bx]	; Decrement by 1
jl	short loc_12219	; Jump if Less (SF!=OF)
mov	si, [bx+0Ah]
inc	[word ptr bx+0Ah] ; Increment by 1
mov	al, [si]
mov	ah, 0
jmp	short loc_12222	; Jump

loc_12219:		; CODE XREF: __FGETN_jwb+A2j
push	[word ptr bp+stream] ; stream
nop			; No Operation
push	cs
call	near ptr __fgetc ; Call	Procedure
pop	cx

loc_12222:		; CODE XREF: __FGETN_jwb+AEj
mov	dx, ax
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_121F1	; Jump if Not Zero (ZF=0)

loc_12229:		; CODE XREF: __FGETN_jwb+98j
			; __FGETN_jwb+9Bj
db 83h,0FAh,0FFh ; <BAD>cmp	dx, 0FFFFh ; Compare Two Operands
jz	short loc_121E8	; Jump if Zero (ZF=1)

loc_1222E:		; CODE XREF: __FGETN_jwb+5j
			; __FGETN_jwb+76j
cmp	[word ptr bp+stream+2],	0 ; Compare Two	Operands
jz	short loc_12237	; Jump if Zero (ZF=1)
jmp	loc_12171	; Jump

loc_12237:		; CODE XREF: __FGETN_jwb+86j
			; __FGETN_jwb+C9j
mov	ax, [word ptr bp+stream+2]
pop	di
pop	si
pop	bp
retn	6		; Return Near from Procedure
endp __FGETN_jwb ; sp-analysis failed

; [0000004B BYTES: COLLAPSED FUNCTION _fread. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function bp-based	frame

proc sub_1228B near	; CODE XREF: _fseek+26p
			; _ftell+A5p
			; _ftell+B2p

arg_0= word ptr	 4

push	bp
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]
cmp	[word ptr si], 0 ; Compare Two Operands
jge	short loc_122A2	; Jump if Greater or Equal (SF=OF)
mov	dx, [si+6]
add	dx, [si]	; Add
inc	dx		; Increment by 1
mov	di, dx
jmp	short loc_122AD	; Jump

loc_122A2:		; CODE XREF: sub_1228B+Bj
mov	ax, [si]
cwd			; AX ->	DX:AX (with sign)
xor	ax, dx		; Logical Exclusive OR
sub	ax, dx		; Integer Subtraction
mov	dx, ax
mov	di, ax

loc_122AD:		; CODE XREF: sub_1228B+15j
test	[word ptr si+2], 1000000b ; Logical Compare
jnz	short loc_122E0	; Jump if Not Zero (ZF=0)
mov	cx, [si+0Ah]
cmp	[word ptr si], 0 ; Compare Two Operands
jge	short loc_122D9	; Jump if Greater or Equal (SF=OF)
jmp	short loc_122C7	; Jump

loc_122BE:		; CODE XREF: sub_1228B+41j
dec	cx		; Decrement by 1
mov	bx, cx
cmp	[byte ptr bx], 0Ah ; Compare Two Operands
jnz	short loc_122C7	; Jump if Not Zero (ZF=0)
inc	di		; Increment by 1

loc_122C7:		; CODE XREF: sub_1228B+31j
			; sub_1228B+39j
mov	ax, dx
dec	dx		; Decrement by 1
or	ax, ax		; Logical Inclusive OR
jnz	short loc_122BE	; Jump if Not Zero (ZF=0)
jmp	short loc_122E0	; Jump

loc_122D0:		; CODE XREF: sub_1228B+53j
mov	bx, cx
inc	cx		; Increment by 1
cmp	[byte ptr bx], 0Ah ; Compare Two Operands
jnz	short loc_122D9	; Jump if Not Zero (ZF=0)
inc	di		; Increment by 1

loc_122D9:		; CODE XREF: sub_1228B+2Fj
			; sub_1228B+4Bj
mov	ax, dx
dec	dx		; Decrement by 1
or	ax, ax		; Logical Inclusive OR
jnz	short loc_122D0	; Jump if Not Zero (ZF=0)

loc_122E0:		; CODE XREF: sub_1228B+27j
			; sub_1228B+43j
mov	ax, di
pop	di
pop	si
pop	bp
retn	2		; Return Near from Procedure
endp sub_1228B



; Attributes: library function bp-based	frame

; int __cdecl fseek(FILE *stream, __int32 offset, int whence)
proc _fseek far		; CODE XREF: _setvbuf+5Cp

stream=	dword ptr  6
fromwhere= word	ptr  0Ch
whence=	word ptr  0Eh

push	bp
mov	bp, sp
push	si
push	di
mov	si, [word ptr bp+stream]
mov	di, [bp+fromwhere]
push	si		; stream
nop			; No Operation
push	cs
call	near ptr _fflush ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_12303	; Jump if Zero (ZF=1)
mov	ax, 0FFFFh
jmp	short loc_1234C	; Jump

loc_12303:		; CODE XREF: _fseek+14j
cmp	di, 1		; Compare Two Operands
jnz	short loc_12318	; Jump if Not Zero (ZF=0)
cmp	[word ptr si], 0 ; Compare Two Operands
jle	short loc_12318	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	si
call	sub_1228B	; Call Procedure
cwd			; AX ->	DX:AX (with sign)
sub	[word ptr bp+stream+2],	ax ; Integer Subtraction
sbb	[bp+0Ah], dx	; Integer Subtraction with Borrow

loc_12318:		; CODE XREF: _fseek+1Ej
			; _fseek+23j
and	[word ptr si+2], 0FE5Fh	; Logical AND
mov	[word ptr si], 0
mov	ax, [si+8]
mov	[si+0Ah], ax
push	di		; fromwhere
push	[word ptr bp+0Ah]
push	[word ptr bp+stream+2] ; offset
mov	al, [si+4]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _lseek	; Call Procedure
add	sp, 8		; Add
db 83h,0FAh,0FFh ; <BAD>cmp	dx, 0FFFFh ; Compare Two Operands
jnz	short loc_1234A	; Jump if Not Zero (ZF=0)
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_1234A	; Jump if Not Zero (ZF=0)
mov	ax, 0FFFFh
jmp	short loc_1234C	; Jump

loc_1234A:		; CODE XREF: _fseek+56j
			; _fseek+5Bj
xor	ax, ax		; Logical Exclusive OR

loc_1234C:		; CODE XREF: _fseek+19j
			; _fseek+60j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp _fseek ; sp-analysis failed

; [000000C7 BYTES: COLLAPSED FUNCTION _ftell. PRESS KEYPAD "+" TO EXPAND]


; argPtrBuffer,argSize,argNumber,argPtrFile
; Attributes: library function bp-based	frame

; size_t __cdecl fwrite(const void *argPtrWriteBuffer, size_t argSize, size_t argNumber, FILE *argPtrFileStream)
proc _fwrite far	; CODE XREF: _f010109_main+25EP
			; ST_ScreenDump+FBP
			; ST_ScreenDump+115P
			; ST_ScreenDump+12FP
			; ST_ScreenDump+149P
			; ST_ScreenDump+163P
			; ST_ScreenDump+17DP
			; ST_ScreenDump+197P
			; ST_ScreenDump+1B1P
			; ST_ScreenDump+1CFP
			; ST_ScreenDump+1F4P
			; ST_ScreenDump+20EP
			; ST_ScreenDump+228P
			; ST_ScreenDump+247P
			; ST_ScreenDump+25CP
			; ST_ScreenDump+27BP
			; ST_ScreenDump+295P
			; ST_ScreenDump+2AFP
			; ST_ScreenDump+2C9P
			; ST_ScreenDump+2F0P
			; ST_ScreenDump+315P
			; ST_ScreenDump+32FP
			; ST_ScreenDump+356P
			; ST_ScreenDump+37CP
			; ST_ScreenDump+396P
			; ST_ScreenDump+3BAP
			; ST_ScreenDump+3CFP
			; ST_ScreenDump+3E4P
			; OVR_SaveGame_MagicSet+3E1P
			; sub_3CFC0+2D9P
			; ST_MagicSet_ReadCreateWrite+51P
			; ST_MagicSet_ReadCreateWrite+112P
			; sub_3E1DE+353P

var_4= word ptr	-4
var_2= word ptr	-2
argPtrWriteBuffer= dword ptr  6
argSize= word ptr  0Ah
argNumber= word	ptr  0Ch
argPtrFileStream= dword	ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	si, [word ptr bp+argPtrWriteBuffer+2]
mov	di, [bp+argSize]
or	si, si		; If (SI == 0) Then Set	(ZF = 1)
jnz	short SOURCE_NOT_NULL ;	Jump if	Not Zero (ZF=0)
mov	ax, di
jmp	short loc_1245D	; Jump

SOURCE_NOT_NULL:	; CODE XREF: _fwrite+10j
mov	bx, si
xor	cx, cx		; CX = 0
mov	ax, di
xor	dx, dx		; DX = 0
call	N_LXMUL@	; Call Procedure
mov	[bp+var_2], dx
mov	[bp+var_4], ax
cmp	dx, 1		; Compare Two Operands
ja	short FAILURE	; Jump if Above	(CF=0 &	ZF=0)
jb	short loc_12449	; Jump if Below	(CF=1)
or	ax, ax		; argNumber
jnb	short FAILURE	; Jump if Not Below (CF=0)

loc_12449:		; CODE XREF: _fwrite+2Cj
push	[word ptr bp+argPtrWriteBuffer]	; stream
push	[bp+var_4]	; int
push	[bp+argNumber]	; int
call	__FPUTN		; Call Procedure
xor	dx, dx		; Logical Exclusive OR
div	si		; Unsigned Divide
jmp	short loc_1245D	; Jump

FAILURE:		; CODE XREF: _fwrite+2Aj
			; _fwrite+30j
xor	ax, ax		; Logical Exclusive OR

loc_1245D:		; CODE XREF: _fwrite+14j
			; _fwrite+42j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp _fwrite ; sp-analysis failed

; [00000029 BYTES: COLLAPSED FUNCTION sub_12463. PRESS KEYPAD "+" TO EXPAND]
; [00000059 BYTES: COLLAPSED FUNCTION sub_1248C. PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION __fgetc. PRESS KEYPAD "+"	TO EXPAND]

__Nfgetc:
pop	ax
push	cs
push	ax
; [000000AF BYTES: COLLAPSED FUNCTION _fgetc. PRESS KEYPAD "+" TO EXPAND]
; [0000000A BYTES: COLLAPSED FUNCTION _fgetchar. PRESS KEYPAD "+" TO EXPAND]
; [0000005F BYTES: COLLAPSED FUNCTION _getenv. PRESS KEYPAD "+"	TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION _itoa. PRESS KEYPAD "+" TO EXPAND]
; [0000001A BYTES: COLLAPSED FUNCTION _ultoa. PRESS KEYPAD "+" TO EXPAND]


; char *LtoA(long value, char ^string, int radix)
;   converts value to a	null-terminated	string and stores the result in	string
; Parameters:
;   value   long integer to be converted
;   string  pointer to character array
;   radix   the	base to	be used	in converting
; Return:
;   LtoA returns a pointer to string.
;
; Attributes: library function bp-based	frame

; char *__cdecl	ltoa(__int32 value, char *string, int radix)
proc _ltoa far		; CODE XREF: ST_ExitWithMemDiag+4AP
			; sub_1967E+14P
			; sub_19794+14P
			; sub_19804+14P
			; sub_198E4+14P
			; sub_19F09+22P

value= word ptr	 6
arg_2= word ptr	 8
string=	word ptr  0Ah
arg_6= word ptr	 0Ch
radix= word ptr	 0Eh

push	bp
mov	bp, sp
mov	ax, [bp+arg_6]
push	[bp+arg_2]
push	[bp+value]
push	[bp+string]
push	ax
cmp	ax, 0Ah		; Compare Two Operands
jnz	short loc_1266E	; Jump if Not Zero (ZF=0)
mov	ax, 1
jmp	short loc_12670	; Jump

loc_1266E:		; CODE XREF: _ltoa+13j
xor	ax, ax		; Logical Exclusive OR

loc_12670:		; CODE XREF: _ltoa+18j
push	ax
mov	al, 61h	; 'a'
push	ax
call	__LONGTOA	; arg0:
			;   push    dx
			; arg2:
			;   push    ax
			; arg4:
			;   push    [bp+string]
			; arg6:
			;   push    cx
			; arg8
			;   mov	    al,	1
			;   push    ax
			; argA
			;   mov	    al,	61h ; 'a'
			;   push    ax
pop	bp
retf			; Return Far from Procedure
endp _ltoa

; [0000001F BYTES: COLLAPSED FUNCTION _memcpy. PRESS KEYPAD "+"	TO EXPAND]


; argAttributes,argFileName
; Attributes: library function bp-based	frame

; int __stdcall	DOS_CreateFileWithHandle(int argAttributes, int	argFileName)
proc DOS_CreateFileWithHandle near
			; CODE XREF: _open+85p
			; _open+A0p

argAttributes= word ptr	 4
argFileName= word ptr  6

push	bp
mov	bp, sp
mov	cx, [bp+argAttributes]
mov	ah, 3Ch
mov	dx, [bp+argFileName]
int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
			; CX = attributes for file
			; DS:DX	-> ASCIZ filename (may include drive and path)
jb	short FAILURE	; Jump if Below	(CF=1)
jmp	short loc_126AD	; Jump

FAILURE:		; CODE XREF: DOS_CreateFileWithHandle+Dj
push	ax
call	__IOERROR	; Call Procedure

loc_126AD:		; CODE XREF: DOS_CreateFileWithHandle+Fj
pop	bp
retn	4		; Return Near from Procedure
endp DOS_CreateFileWithHandle

; [00000012 BYTES: COLLAPSED FUNCTION DOS_WriteToFileWithHandle. PRESS KEYPAD "+" TO EXPAND]
; [00000158 BYTES: COLLAPSED FUNCTION _open. PRESS KEYPAD "+" TO EXPAND]
; [0000004D BYTES: COLLAPSED FUNCTION __open. PRESS KEYPAD "+" TO EXPAND]
; [00000019 BYTES: COLLAPSED FUNCTION __fputc. PRESS KEYPAD "+"	TO EXPAND]
; [00000136 BYTES: COLLAPSED FUNCTION _fputc. PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _fputchar. PRESS KEYPAD "+" TO EXPAND]


;   push    word ptr [bp+argPointer]
;   push    [bp+var_4]
;   push    [bp+argNumber]
; Attributes: library function bp-based	frame

; int __fastcall _FPUTN(int argNumber, int argSize, FILE *argStream)
proc __FPUTN near	; CODE XREF: _fwrite+3Bp

varOriginalSize= word ptr -2
argNumber= word	ptr  4
argSize= word ptr  6
argStream= word	ptr  8
dest= dword ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si		; n
push	di		; len
mov	di, [bp+argNumber]
mov	ax, [bp+argSize]
mov	[bp+varOriginalSize], ax
test	[word ptr di+2], 8 ; Logical Compare
jz	short loc_12A0B	; Jump if Zero (ZF=1)
jmp	short loc_129FE	; Jump

LOOP_xSIZE:		; CODE XREF: __FPUTN+3Dj
push	di		; stream
mov	bx, [bp+argStream]
inc	[bp+argStream]	; Increment by 1
mov	al, [bx]
cbw			; AL ->	AX (with sign)
push	ax		; c
push	cs
call	near ptr _fputc	; Call Procedure
pop	cx
pop	cx
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_129FE	; Jump if Not Zero (ZF=0)

FAILURE:		; CODE XREF: __FPUTN+6Bj
			; __FPUTN:loc_12A78j
			; __FPUTN+D6j
			; __FPUTN+139j
			; __FPUTN+173j
			; __FPUTN+19Aj
xor	ax, ax		; Logical Exclusive OR
jmp	RETURN		; Jump

loc_129FE:		; CODE XREF: __FPUTN+18j
			; __FPUTN+2Ej
mov	ax, [bp+argSize]
dec	[bp+argSize]	; Decrement by 1
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short LOOP_xSIZE ; Jump	if Not Zero (ZF=0)
jmp	SUCCESS		; Jump

loc_12A0B:		; CODE XREF: __FPUTN+16j
test	[di+FILE.flags], 1000000b ; Logical Compare
jnz	short loc_12A15	; Jump if Not Zero (ZF=0)
jmp	loc_12B07	; Jump

loc_12A15:		; CODE XREF: __FPUTN+47j
cmp	[di+argSize], 0	; If (argSize == 0) Then Set (ZF = 1)
jnz	short loc_12A1E	; Jump if Not Zero (ZF=0)
jmp	loc_12AC3	; Jump

loc_12A1E:		; CODE XREF: __FPUTN+50j
mov	ax, [di+argSize]
cmp	ax, [bp+argSize] ; Compare Two Operands
jnb	short loc_12A7E	; Jump if Not Below (CF=0)
cmp	[word ptr di], 0 ; Compare Two Operands
jz	short loc_12A36	; Jump if Zero (ZF=1)
push	di		; stream
nop			; No Operation
push	cs
call	near ptr _fflush ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short FAILURE	; Jump if Not Zero (ZF=0)

loc_12A36:		; CODE XREF: __FPUTN+60j
mov	al, [di+4]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
test	[word ptr bx+51CCh], 800h ; Logical Compare
jz	short loc_12A5D	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax		; fromwhere
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx		; offset
mov	al, [byte ptr di+argNumber]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _lseek	; Call Procedure
add	sp, 8		; Add

loc_12A5D:		; CODE XREF: __FPUTN+7Bj
push	[bp+argSize]
push	[bp+argStream]	; buf
mov	al, [byte ptr di+argNumber]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr __write ; Call	Procedure
add	sp, 6		; Add
cmp	ax, [bp+argSize] ; Compare Two Operands
jnz	short loc_12A78	; Jump if Not Zero (ZF=0)
jmp	SUCCESS		; Jump

loc_12A78:		; CODE XREF: __FPUTN+AAj
jmp	FAILURE		; Jump
jmp	SUCCESS		; Jump

loc_12A7E:		; CODE XREF: __FPUTN+5Bj
mov	ax, [di]
add	ax, [bp+argSize] ; Add
jl	short MEM_COPY	; Jump if Less (SF!=OF)
cmp	[word ptr di], 0 ; Compare Two Operands
jnz	short loc_12A94	; Jump if Not Zero (ZF=0)
mov	ax, 0FFFFh
sub	ax, [di+argSize] ; Integer Subtraction
mov	[di], ax
jmp	short MEM_COPY	; Jump

loc_12A94:		; CODE XREF: __FPUTN+BFj
push	di		; stream
nop			; No Operation
push	cs
call	near ptr _fflush ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short MEM_COPY	; Jump if Zero (ZF=1)
jmp	FAILURE		; Jump

MEM_COPY:		; CODE XREF: __FPUTN+BAj
			; __FPUTN+C9j
			; __FPUTN+D4j
push	[bp+argSize]	; src
push	[bp+argStream]
push	[word ptr di+dest] ; dest
nop			; No Operation
push	cs
call	near ptr _memcpy ; Call	Procedure
add	sp, 6		; Add
mov	ax, [di]
add	ax, [bp+argSize] ; Add
mov	[di], ax

loc_12ABA:
mov	ax, [bp+argSize]
add	[word ptr di+dest], ax ; Add
jmp	SUCCESS		; Jump

loc_12AC3:		; CODE XREF: __FPUTN+52j
mov	al, [di+4]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
test	[word ptr bx+51CCh], 800h ; Logical Compare
jz	short loc_12AEA	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax		; fromwhere
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx		; offset
mov	al, [byte ptr di+argNumber]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _lseek	; Call Procedure
add	sp, 8		; Add

loc_12AEA:		; CODE XREF: __FPUTN+108j
push	[bp+argSize]
push	[bp+argStream]	; buf
mov	al, [byte ptr di+argNumber]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr __write ; Call	Procedure
add	sp, 6		; Add
cmp	ax, [bp+argSize] ; Compare Two Operands
jz	short SUCCESS	; Jump if Zero (ZF=1)
jmp	FAILURE		; Jump
jmp	short SUCCESS	; Jump

loc_12B07:		; CODE XREF: __FPUTN+49j
cmp	[di+argSize], 0	; Compare Two Operands
jz	short loc_12B4B	; Jump if Zero (ZF=1)
jmp	short loc_12B3F	; Jump

loc_12B0F:		; CODE XREF: __FPUTN+17Ej
inc	[word ptr di]	; Increment by 1
jge	short loc_12B27	; Jump if Greater or Equal (SF=OF)
mov	bx, [word ptr di+dest]
inc	[word ptr di+dest] ; Increment by 1
mov	si, [bp+argStream]
inc	[bp+argStream]	; Increment by 1
mov	al, [si]
mov	[bx], al
mov	ah, 0
jmp	short loc_12B37	; Jump

loc_12B27:		; CODE XREF: __FPUTN+148j
push	di		; stream
mov	bx, [bp+argStream]
inc	[bp+argStream]	; Increment by 1
mov	al, [bx]
push	ax		; c
push	cs
call	near ptr __fputc ; Call	Procedure
pop	cx
pop	cx

loc_12B37:		; CODE XREF: __FPUTN+15Cj
cmp	ax, 0FFFFh	; If (AX == 65535) Then	Set (ZF	= 1)
jnz	short loc_12B3F	; Jump if Not Zero (ZF=0)
jmp	FAILURE		; Jump

loc_12B3F:		; CODE XREF: __FPUTN+144j
			; __FPUTN+171j
mov	ax, [bp+argSize]
dec	[bp+argSize]	; Decrement by 1
or	ax, ax		; Logical Inclusive OR
jnz	short loc_12B0F	; Jump if Not Zero (ZF=0)
jmp	short SUCCESS	; Jump

loc_12B4B:		; CODE XREF: __FPUTN+142j
push	[bp+argSize]	; int
push	[bp+argStream]	; int
mov	al, [byte ptr di+argNumber]
cbw			; int
push	ax		; int
nop			; No Operation
push	cs
call	near ptr ___write ; Call Procedure
add	sp, 6		; Add
cmp	ax, [bp+argSize] ; Compare Two Operands
jz	short SUCCESS	; Jump if Zero (ZF=1)
jmp	FAILURE		; Jump

SUCCESS:		; CODE XREF: __FPUTN+3Fj
			; __FPUTN+ACj
			; __FPUTN+B2j
			; __FPUTN+F7j
			; __FPUTN+137j
			; __FPUTN+13Cj
			; __FPUTN+180j
			; __FPUTN+198j
mov	ax, [bp+varOriginalSize] ; If (!FAILURE) Then Assume Bytes Written As Requested
			;   mov	    [bp+var_2],	ax

RETURN:			; CODE XREF: __FPUTN+32j
pop	di
pop	si
mov	sp, bp
pop	bp
retn	6		; Return Near from Procedure
endp __FPUTN ; sp-analysis failed

; [000000CE BYTES: COLLAPSED FUNCTION ___read. PRESS KEYPAD "+"	TO EXPAND]


; argStream,argBuffer,arg_6,argType,argSize
; Attributes: library function bp-based	frame

; int __cdecl setvbuf(FILE *argStream, char *argBuffer,	int argType, size_t argSize)
proc _setvbuf far	; CODE XREF: __setupio+66p
			; __setupio+9Ep
			; __OPENFP+7Bp

argStream= dword ptr  6
argBuffer= word	ptr  0Ah
arg_6= word ptr	 0Ch
argType= word ptr  0Eh
argSize= word ptr  10h

push	bp
mov	bp, sp
push	si
push	di		; whence
mov	si, [word ptr bp+argStream]
mov	di, [bp+arg_6]
cmp	[si+0Eh], si	; Compare Two Operands
jnz	short loc_12C5B	; Jump if Not Zero (ZF=0)
cmp	[bp+argBuffer],	2 ; Compare Two	Operands
jg	short loc_12C5B	; Jump if Greater (ZF=0	& SF=OF)
cmp	di, 7FFFh	; Compare Two Operands
jbe	short loc_12C61	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_12C5B:		; CODE XREF: _setvbuf+Ej
			; _setvbuf+14j
			; _setvbuf+B0j
			; _setvbuf+B9j
mov	ax, 0FFFFh
jmp	loc_12D13	; Jump

loc_12C61:		; CODE XREF: _setvbuf+1Aj
cmp	[word_36F9E], 0	; Compare Two Operands
jnz	short loc_12C76	; Jump if Not Zero (ZF=0)
cmp	si, offset word_36DAA ;	Compare	Two Operands
jnz	short loc_12C76	; Jump if Not Zero (ZF=0)
mov	[word_36F9E], 1
jmp	short loc_12C89	; Jump

loc_12C76:		; CODE XREF: _setvbuf+27j
			; _setvbuf+2Dj
cmp	[word_36F9C], 0	; Compare Two Operands
jnz	short loc_12C89	; Jump if Not Zero (ZF=0)
cmp	si, offset word_36D9A ;	Compare	Two Operands
jnz	short loc_12C89	; Jump if Not Zero (ZF=0)
mov	[word_36F9C], 1

loc_12C89:		; CODE XREF: _setvbuf+35j
			; _setvbuf+3Cj
			; _setvbuf+42j
cmp	[word ptr si], 0 ; Compare Two Operands
jz	short loc_12CA1	; Jump if Zero (ZF=1)
mov	ax, 1
push	ax
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax		; offset
push	dx
push	si		; stream
nop			; No Operation
push	cs
call	near ptr _fseek	; Call Procedure
add	sp, 8		; Add

loc_12CA1:		; CODE XREF: _setvbuf+4Dj
test	[word ptr si+2], 4 ; Logical Compare
jz	short loc_12CB1	; Jump if Zero (ZF=1)
push	[word ptr si+8]	; block
nop			; No Operation
push	cs
call	near ptr _free	; Call Procedure
pop	cx

loc_12CB1:		; CODE XREF: _setvbuf+67j
db 83h,64h,2,0F3h ; <BAD>and	 [word ptr si+2], 0FFF3h ; Logical AND
mov	[word ptr si+6], 0
mov	ax, si
add	ax, 5		; Add
mov	[si+8],	ax
mov	[si+0Ah], ax
cmp	[bp+argBuffer],	2 ; Compare Two	Operands
jz	short loc_12D11	; Jump if Zero (ZF=1)
or	di, di		; Logical Inclusive OR
jbe	short loc_12D11	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	[word ptr ptr_exitbuf+2], seg seg000
mov	[word ptr ptr_exitbuf],	31B1h
cmp	[word ptr bp+argStream+2], 0 ; Compare Two Operands
jnz	short loc_12CFB	; Jump if Not Zero (ZF=0)
push	di		; size
nop			; No Operation
push	cs
call	near ptr _malloc ; Call	Procedure
pop	cx
mov	[word ptr bp+argStream+2], ax
or	ax, ax		; Logical Inclusive OR
jnz	short loc_12CF2	; Jump if Not Zero (ZF=0)
jmp	loc_12C5B	; Jump

loc_12CF2:		; CODE XREF: _setvbuf+AEj
or	[word ptr si+2], 4 ; Logical Inclusive OR
jmp	short loc_12CFB	; Jump
jmp	loc_12C5B	; Jump

loc_12CFB:		; CODE XREF: _setvbuf+A0j
			; _setvbuf+B7j
mov	ax, [word ptr bp+argStream+2]
mov	[si+0Ah], ax
mov	[si+8],	ax
mov	[si+6],	di
cmp	[bp+argBuffer],	1 ; Compare Two	Operands
jnz	short loc_12D11	; Jump if Not Zero (ZF=0)
or	[word ptr si+2], 1000b ; Logical Inclusive OR

loc_12D11:		; CODE XREF: _setvbuf+8Aj
			; _setvbuf+8Ej
			; _setvbuf+CCj
xor	ax, ax		; Logical Exclusive OR

loc_12D13:		; CODE XREF: _setvbuf+1Fj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp _setvbuf ;	sp-analysis failed

; [0000003F BYTES: COLLAPSED FUNCTION sub_12D17. PRESS KEYPAD "+" TO EXPAND]
; [00000047 BYTES: COLLAPSED FUNCTION sub_12D56. PRESS KEYPAD "+" TO EXPAND]
word_12D9D dw	   0,	2Fh,   3Ah,   5Ch
			; DATA XREF: sub_12D56+1Do
			; value	table for switch statement
dw offset loc_12D8F	; jump table for switch	statement
dw offset loc_12D8F
dw offset loc_12D89
dw offset loc_12D8F
; [0000015C BYTES: COLLAPSED FUNCTION __fnsplit. PRESS KEYPAD "+" TO EXPAND]
word_12F09 dw	   0,	2Ah,   2Eh,   2Fh
			; DATA XREF: __fnsplit+82o
dw    3Ah,   3Fh,   5Ch	; value	table for switch statement
off_12F17 dw offset loc_12E7B ;	jump table for switch statement
dw offset loc_12ED5
dw offset loc_12E45
dw offset loc_12E9C
dw offset loc_12E74
dw offset loc_12ED5
dw offset loc_12E9C
; [0000001B BYTES: COLLAPSED FUNCTION __splitpath. PRESS KEYPAD	"+" TO EXPAND]
; [00000039 BYTES: COLLAPSED FUNCTION _strcat. PRESS KEYPAD "+"	TO EXPAND]


; argDest,argSrc
; Attributes: library function bp-based	frame

; char *__cdecl	strcpy(char *argDest, const char *argSrc)
proc _strcpy far	; CODE XREF: __searchenv+29p
			; __searchstr+29p
			; sub_12D17+34p
			; _f010109_main+1E1P
			; _f010109_main+236P
			; _f010509_MainMenuScreen+DCP
			; ST_ExitWithMemDiag+25P
			; ST_execl_WizardsExe+6BP
			; EXIT_AllocationError+BP
			; MemBlocksErrorExit+1CP
			; MemBlocksErrorExit+7CP
			; MemBlocksErrorExit+CEP
			; MemBlocksErrorExit+10FP
			; MemBlocksErrorExit:loc_14DB1P
			; LBX_Load_Entry+B7P
			; LBX_Load_Entry+C3P
			; LBX_Load_Entry+10AP
			; LBX_Load_s15453+AAP
			; LBX_Load_s15453+B6P
			; LBX_Load_s15453+FEP
			; LBX_Load_HelpNewTerrCity+A7P
			; LBX_Load_HelpNewTerrCity+B3P
			; LBX_Load_HelpNewTerrCity+FAP
			; LBX_Load_Entry_4bytes+98P
			; LBX_Load_Entry_4bytes+A4P
			; LBX_Load_Entry_4bytes+EBP
			; ST_Set_LbxDirectoryPath+AP
			; LBX_Load_ErrorHandler+10P
			; LBX_Load_ErrorHandler+8BP
			; LBX_Load_ErrorHandler+117P
			; idk_Setup_EMM+8FP
			; idk_Setup_EMM:loc_16552P
			; LBX_LoadFileMemory+18P
			; LBX_LoadFileMemory+9CP
			; LBX_AllocMem+18P
			; LBX_AllocMem+26P
			; LBX_s16A80:loc_16A98P
			; LBX_s16A80+26P
			; sub_17671+FP
			; sub_17671+33P
			; sub_17671+99P
			; EMM_Allocate+61P
			; EMM_Allocate+BAP
			; EMM_Allocate+116P
			; EMM_Allocate+1C7P
			; sub_17BB8+FP
			; fncBldMsgInsuffEMS:loc_17D49P
			; LBX_Load_FontsStyleData+DP
			; sub_1A576+24P
			; ST_ScreenDump+2DP
			; ST_ScreenDump+47P
			; ST_ScreenDump+92P
			; LBX_Intro_MemAndReadAndMem+AP
			; sub_24DAE+2F5P
			; sub_24DAE+353P
			; sub_24DAE+38EP
			; sub_24DAE+3F4P
			; sub_24DAE:loc_25209P
			; sub_24DAE+8B9P
			; sub_24DAE+8F9P
			; sub_24DAE:loc_25711P
			; sub_24DAE+9B6P
			; sub_24DAE+CFCP
			; sub_24DAE+D3BP
			; sub_24DAE+DA6P
			; sub_26026:loc_2630BP
			; sub_26026+31FP
			; sub_26026+395P
			; rschKBD_s2669B:loc_269A1P
			; rschKBD_s2669B+447P
			; sub_28141+D1P
			; sub_28141+124P
			; sub_28141+3EAP
			; sub_28583+97P
			; sub_28583:loc_288F7P
			; sub_28963:loc_289A0P
			; sub_292B9+10P
			; ST_LoadSoundDrivers+597P
			; ST_SoundErrorHandler+20P
			; ST_SoundErrorHandler+2FP
			; ST_SoundErrorHandler+5DP
			; ST_SoundErrorHandler+8CP
			; OVR_SaveGame_MagicSet+27P
			; ST_LoadSaveGamByNbr+25P
			; ST_MagicSet_ReadCreateWrite+E7P
			; ST_DefaultMagicSet+D5P
			; sub_3DBA6+1D6P
			; sub_3EDD1+507P
			; sub_3F3C6+19DP
			; idk_Load_NEWGAME_LBX+86P
			; idk_Load_NEWGAME_LBX+DFP
			; idk_Load_NEWGAME_LBX+EEP
			; sub_4043A+63P
			; sub_4067D+417P
			; sub_4067D+42FP
			; LBX_NewGame_s41A5F+6ECP
			; sub_4276F+E6P
			; sub_4276F+224P
			; sub_4276F+4ADP
			; sub_4276F+738P
			; sub_430A4+298P
			; sub_5301E+B6P
			; idk_HoF_s565F2+10P
			; idk_HoF_s565F2:loc_5668FP
			; idk_HoF_s565F2+176P
			; idk_HoF_s565F2+1ABP
			; idk_HoF_s565F2+249P

argDest= word ptr  6
argSrc=	byte ptr  8

push	bp
mov	bp, sp
push	si
push	di
push	ds
pop	es
cld			; Clear	Direction Flag
mov	di, [word ptr bp+argSrc]
mov	si, di
xor	al, al		; AL = 0
mov	cx, 65535
repne scasb		; Compare String
not	cx		; Count	of Bytes Scanned
mov	di, [bp+argDest]
rep movsb		; Move Byte(s) from String to String
mov	ax, [bp+argDest]
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp _strcpy



; Case-Insensitive String Comparison (i.e. strcasecmp)
; int stricmp (	const char * str1, const char *	str2 );
;   str1  C string to be compared.
;   str2  C string to be compared.
; Return Value
;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
;   =0	  the contents of both strings are equal
;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
; Attributes: library function bp-based	frame

; int __cdecl stricmp(const char *str1,	const char *str2)
proc _stricmp far	; CODE XREF: LBX_Load_Entry+85P
			; LBX_Load_s15453+78P
			; LBX_Load_HelpNewTerrCity+75P
			; LBX_Load_Entry_4bytes+66P
			; DOS_OpenFileModeCheck+CP
			; DOS_OpenFileModeCheck+1CP
			; DOS_OpenFileModeCheck+39P
			; DOS_OpenFileModeCheck+49P
			; idk_Setup_EMM:loc_16475P
			; LBX_LoadFileMemory+50P
			; LBX_AllocMem+5EP
			; LBX_s16A80:loc_16ADEP
			; Emm_PgCnt_s175B1+19P
			; EMM_Allocate+2EP
			; LBX_Cityname_s4B973+7BP

str1= dword ptr	 6
str2= dword ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
mov	ax, ds
mov	es, ax
cld			; Clear	Direction Flag
mov	si, [word ptr bp+str1]
mov	di, [word ptr bp+str1+2]
xor	ax, ax		; AX = 0
mov	bx, ax		; BX = 0

loc_12FAF:		; CH = "a" CL =	"z"
mov	cx, 'az'

LOOP_TO_EOS:		; CODE XREF: _stricmp+1Fj
			; _stricmp+38j
lodsb			; Load String
mov	bl, [di]
or	al, al		; If (AL == 0) Then Set	(ZF = 1)
jz	short GOT_EOS_OR_DIFF ;	Jump if	Zero (ZF=1)
scasb			; Compare String
jz	short LOOP_TO_EOS ; Jump if Zero (ZF=1)

STR1:			; Is AL	>= "a"?
cmp	al, ch
jb	short STR2	; Jump if Below	(CF=1)
cmp	al, cl		; Is AH	<= "z"?
ja	short STR2	; Jump if Above	(CF=0 &	ZF=0)
sub	al, 32		; Convert to UpperCase

STR2:			; CODE XREF: _stricmp+23j
			; _stricmp+27j
cmp	bl, ch		; Compare Two Operands
jb	short COMPARE_BYTE ; Jump if Below (CF=1)
cmp	bl, cl		; Compare Two Operands
ja	short COMPARE_BYTE ; Jump if Above (CF=0 & ZF=0)
sub	bl, 32		; Convert to UpperCase

COMPARE_BYTE:		; CODE XREF: _stricmp+2Dj
			; _stricmp+31j
cmp	al, bl		; If (AL == BL)	Then Set (ZF = 1)
jz	short LOOP_TO_EOS ; Jump if Zero (ZF=1)

GOT_EOS_OR_DIFF:	; CODE XREF: _stricmp+1Cj
sub	ax, bx		; AX = AX - BX (<,=,>)
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp _stricmp

; [0000001A BYTES: COLLAPSED FUNCTION _strlen. PRESS KEYPAD "+"	TO EXPAND]
; [0000002C BYTES: COLLAPSED FUNCTION _strncpy.	PRESS KEYPAD "+" TO EXPAND]
; [00000020 BYTES: COLLAPSED FUNCTION _strupr. PRESS KEYPAD "+"	TO EXPAND]
; [0000010E BYTES: COLLAPSED FUNCTION ___write.	PRESS KEYPAD "+" TO EXPAND]
; [0000003A BYTES: COLLAPSED FUNCTION __write. PRESS KEYPAD "+"	TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION __xfclose. PRESS KEYPAD "+" TO EXPAND]
; [00000023 BYTES: COLLAPSED FUNCTION __xfflush. PRESS KEYPAD "+" TO EXPAND]
byte_131D4 db 52h, 75h,	6Eh, 74h, 69h, 6Dh, 65h, 20h
db 6Fh,	76h, 65h, 72h, 6Ch, 61h, 79h, 20h
db 65h,	2 dup(72h), 6Fh, 72h, 0Dh, 0Ah
; START	OF FUNCTION CHUNK FOR CHUNK_OverlayHalt

__OverlayHalt:		; CODE XREF: seg037:04FFJ
			; CHUNK_OverlayHalt:loc_3118CJ
mov	cx, 23
mov	dx, 31D4h
push	cs
pop	ds
assume ds:seg000

loc_131F3:
mov	ah, 40h

loc_131F5:		; File Handle 2	is StdErr
mov	bx, 2

loc_131F8:		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
int	21h		; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

loc_131FA:
mov	ax, 4
push	ax		; status

loc_131FE:
mov	ax, seg	dseg
mov	ds, ax
assume ds:dseg
nop			; No Operation
push	cs

loc_13205:		; Call Procedure
call	near ptr __exit__1of2
; END OF FUNCTION CHUNK	FOR CHUNK_OverlayHalt
; [00000001 BYTES: COLLAPSED FUNCTION nullsub_2. PRESS KEYPAD "+" TO EXPAND]

; Segment type:	Pure code
segment	seg001 byte public 'CODE' use16
assume cs:seg001
;org 9
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

; int __cdecl f010109_main(int argc, const char	**argv,	const char *envp)
proc _f010109_main far	; CODE XREF: STARTX:CallMainP

varFileName= byte ptr -5Ch
varDestination=	byte ptr -3Eh
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_Itr_SaveGam= word ptr -6
varFilePtrStream= word ptr -4
var_2= word ptr	-2
argc= word ptr	6
argv= dword ptr	 8
envp= dword ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 5Ch		; Integer Subtraction
push	si
push	di		; argConversionBase


mov	[ST_HeapBase], offset _heapbase@


lea	ax, [bp+varFileName] ; Load Effective Address
push	ax
mov	ax, offset strCONFIG_MOM ; "CONFIG.MOM"
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx


or	ax, ax		; If = 0,
jnz	short OPEN_READ_ConfigMom ; Jump Not Zero / Jump Equal

MISSING_CONFIG_MOM:	; "Run INSTALL to configure MASTER OF MAGI"...
mov	ax, offset strRunInstall
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure

loc_13233:
pop	cx

OPEN_READ_ConfigMom:	; CODE XREF: _f010109_main+1Fj
mov	ax, offset strRBr1 ; "rb"
push	ax
mov	ax, offset strCONFIG_MOM ; "CONFIG.MOM"
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	[bp+varFilePtrStream], ax
push	[bp+varFilePtrStream] ;	argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 18
push	ax
mov	ax, offset arrConfigMomSettings
push	ax		; argPtrReadBuffer
call	_fread		; argPtrReadBuffer,argSize,argNumber,argPtrFileStream
add	sp, 8		; Add
push	[bp+varFilePtrStream] ;	argFileStream
call	_fclose		; FILE *argFileStream
pop	cx



call	j_ST_MagicSet_ReadCreateWrite ;	Call Procedure



mov	ax, [arrConfigMomSettings.field_0]
mov	[bp+var_8], ax	;
			;
mov	ax, [arrConfigMomSettings.field_4]
mov	[bp+var_A], ax	;
			;
			;
mov	di, 0FFFFh	;
			;
			;
mov	ax, [arrConfigMomSettings.field_2]

varCfgMom_02:		;
mov	[bp+var_14], ax	;
mov	cx, 12		; switch 12 cases
mov	bx, offset idk_enum_w1360A

loc_13286:		; CODE XREF: _f010109_main+88j
mov	ax, [cs:bx]
cmp	ax, [bp+var_14]	; Compare Two Operands
jz	short loc_13295	; Jump if Zero (ZF=1)

loc_1328E:		; Add
add	bx, 2
loop	loc_13286	; Loop while CX	!= 0
jmp	short loc_132DE	; default

loc_13295:		; CODE XREF: _f010109_main+83j
jmp	[word ptr cs:bx+18h] ; switch jump

loc_13299:		; DATA XREF: seg001:0422o
xor	si, si		; case 0x0

loc_1329B:		; CODE XREF: _f010109_main+A4j
			; _f010109_main+A9j
			; _f010109_main+BDj
			; _f010109_main+C2j
			; _f010109_main+C7j
mov	[bp+var_8], 0FFFFh

loc_132A0:		; CODE XREF: _f010109_main+AEj
			; _f010109_main+B3j
			; _f010109_main+B8j
mov	[bp+var_A], 0FFFFh

loc_132A5:		; CODE XREF: _f010109_main+CEj
			; _f010109_main+D3j
mov	di, 0FFFFh
jmp	short loc_132DE	; default

loc_132AA:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 1		; case 0x1
jmp	short loc_1329B	; Jump

loc_132AF:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 2		; case 0x10
jmp	short loc_1329B	; Jump

loc_132B4:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 3		; case 0x12
jmp	short loc_132A0	; Jump

loc_132B9:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 4		; case 0x18
jmp	short loc_132A0	; Jump

loc_132BE:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 5		; case 0x20
jmp	short loc_132A0	; Jump

loc_132C3:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 6		; case 0x19
jmp	short loc_1329B	; Jump

loc_132C8:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 7		; case 0x21
jmp	short loc_1329B	; Jump

loc_132CD:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 8		; case 0x22
jmp	short loc_1329B	; Jump

loc_132D2:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
jmp	short $+2	; case 0x30

loc_132D4:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 9		; case 0x31
jmp	short loc_132A5	; Jump

loc_132D9:		; CODE XREF: _f010109_main:loc_13295j
			; DATA XREF: seg001:0422o
mov	si, 10		; case 0x38
jmp	short loc_132A5	; Jump

loc_132DE:		; CODE XREF: _f010109_main+8Aj
			; _f010109_main+9Fj
cmp	si, SNDRV_9_ROLAND ; default
jl	short loc_132FC	; Jump if Less (SF!=OF)

INIT_ROLAND_DRIVERS:	; "Initializing	Roland Drivers...$"
mov	ax, offset strInitRoland
push	ax
call	DOS_PrintString	; Call Procedure
pop	cx


call	_f020105_bios_timeofday	; Call Procedure


mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_132FC:		; CODE XREF: _f010109_main+D8j
mov	ax, [arrConfigMomSettings.field_6]
mov	[bp+var_E], ax


mov	ax, [arrConfigMomSettings.field_A]
mov	[bp+var_10], ax


mov	ax, [arrConfigMomSettings.field_C]
mov	[bp+var_12], ax


mov	ax, [arrConfigMomSettings.field_8]
mov	[bp+var_16], ax


mov	cx, 12		; switch 12 cases
mov	bx, offset idk_enum_w135DA

loc_1331A:		; CODE XREF: _f010109_main+11Cj
mov	ax, [cs:bx]
cmp	ax, [bp+var_16]	; Compare Two Operands
jz	short loc_13329	; Jump if Zero (ZF=1)
add	bx, 2		; Add
loop	loc_1331A	; Loop while CX	!= 0

loc_13327:		; default
jmp	short loc_13394

loc_13329:		; CODE XREF: _f010109_main+117j
jmp	[word ptr cs:bx+18h] ; switch jump

loc_1332D:		; CODE XREF: _f010109_main:loc_1334Aj
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 0	; case 0x0

loc_13332:		; CODE XREF: _f010109_main+13Fj
			; _f010109_main+182j
			; _f010109_main+189j
mov	[bp+var_E], 0FFFFh
mov	[bp+var_10], 0FFFFh
mov	[bp+var_12], 0FFFFh
jmp	short loc_13394	; default

loc_13343:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 1	; case 0x1
jmp	short loc_13332	; Jump

loc_1334A:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
jmp	short loc_1332D	; case 0x10

loc_1334C:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 3	; case 0x12
jmp	short loc_13394	; default

loc_13353:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 4	; case 0x18
jmp	short loc_13394	; default

loc_1335A:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 5	; case 0x20
mov	ax, [bp+var_10]
mov	[bp+var_A], ax
mov	di, [bp+var_12]
jmp	short loc_13394	; default

loc_1336A:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 6	; case 0x19
jmp	short loc_13376	; Jump

loc_13371:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 7	; case 0x21

loc_13376:		; CODE XREF: _f010109_main+166j
mov	[bp+var_E], 0FFFFh
jmp	short loc_13394	; default

loc_1337D:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 8	; case 0x22
jmp	short loc_13394	; default

loc_13384:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
jmp	short $+2	; case 0x30

loc_13386:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 9	; case 0x31
jmp	short loc_13332	; Jump

loc_1338D:		; CODE XREF: _f010109_main:loc_13329j
			; DATA XREF: seg001:03F2o
mov	[bp+var_C], 0Ah	; case 0x38
jmp	short loc_13332	; Jump

loc_13394:		; CODE XREF: _f010109_main:loc_13327j
			; _f010109_main+138j
			; _f010109_main+148j
			; _f010109_main+14Fj
			; _f010109_main+15Fj
			; _f010109_main+172j
			; _f010109_main+179j
cmp	si, 2		; default
jnz	short loc_1339E	; Jump if Not Zero (ZF=0)
mov	[bp+var_C], 2

loc_1339E:		; CODE XREF: _f010109_main+18Ej
cmp	[LBX_FONTS_w3A508], 2 ;	Compare	Two Operands
jg	short loc_133AC	; Jump if Greater (ZF=0	& SF=OF)
cmp	[LBX_FONTS_w3A508], 0 ;	Compare	Two Operands
jge	short loc_133B2	; Jump if Greater or Equal (SF=OF)

loc_133AC:		; CODE XREF: _f010109_main+19Aj
mov	[LBX_FONTS_w3A508], 0

loc_133B2:		; CODE XREF: _f010109_main+1A1j
mov	[LBX_FONTS_w3A50A], 1


mov	[bp+var_Itr_SaveGam], 1
jmp	LOOP_x9_SaveGam	; Jump

loc_133C0:		; CODE XREF: _f010109_main+278j
mov	bx, [bp+var_Itr_SaveGam]
shl	bx, 1		;
			; ? BX = var_Itr_SaveGam * 2 ?
			; 1 * 2	= 2
			; 2 * 2	= 4
			; ...
			; 9 * 2	= 18
			;
cmp	[MagSet_22+bx],	0 ;
			; MagSet22[2]
			; MagSet22[4]
			; ...
			; MagSet22[18]
			;
jnz	short SAVEGAM	; Jump if Not Zero (ZF=0)
jmp	ITR_SaveGam	; Jump

SAVEGAM:		; CODE XREF: _f010109_main+1C1j
mov	ax, 10
push	ax		; argBaseRadix
lea	ax, [bp+varFileName] ; Load Effective Address
push	ax		; argPtrCharArr
push	[bp+var_Itr_SaveGam] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, offset strSAVE ; "SAVE"
push	ax
lea	ax, [bp+varDestination]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+varFileName] ; Load Effective Address
push	ax
lea	ax, [bp+varDestination]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strGAM ; ".GAM"
push	ax
lea	ax, [bp+varDestination]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varFileName] ; Load Effective Address
push	ax
lea	ax, [bp+varDestination]	; Load Effective Address
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx
cmp	[bp+varFileName], 0 ; Compare Two Operands
jnz	short ITR_SaveGam ; Jump if Not	Zero (ZF=0)
mov	bx, [bp+var_Itr_SaveGam]
shl	bx, 1		; Shift	Logical	Left
mov	[MagSet_22+bx],	0 ;
			;
			;
			;
mov	ax, 8311
push	ax		; argSrc
mov	ax, [bp+var_Itr_SaveGam]
mov	dx, 20
imul	dx		; DX:AX	= DX * AX
			; DX:AX	= 20 * 8311 = 166,220
			; Performs a signed multiplication of two operands.
			; -One-operand form.
			; the source operand is	multiplied by the value	in the AL or AX, register (depending on	the operand size)
			;  and the product is stored in	the AX or DX:AX, registers, respectively.
			;
add	ax, offset MagSet_23 ; Add
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx		;
			;
			;
			;
mov	ax, offset strWBr1 ;
			; File Access Mode: Write Binary
push	ax
mov	ax, offset strMAGIC_SETr1 ; "MAGIC.SET"
push	ax		; argPathFileName
call	_fopen		; fopen(const char *path,const char *mode)
			; filename  C string containing	the name of the	file to	be opened.
			; mode	    C string containing	a file access mode.
			;	    (r)	read (w) write (a) append (?+) ?/update	(?b/?b+/?+b) ?Binary
			; returns a pointer to a FILE object
			;
pop	cx
pop	cx
mov	[bp+varFilePtrStream], ax ; Pointer to the File	Object:	fopen(MAGIC.SET, WB)
push	[bp+varFilePtrStream] ;	argNumber
mov	ax, 1		; Count	of Elements
push	ax		; argSize
mov	ax, 466		; Size,	in bytes, of each Element (466*1=SizeOf(MAGIC.SET)
push	ax
mov	ax, offset MagSet_01 ; Offset to Word_3A4E4?
push	ax		; argPtrWriteBuffer
call	_fwrite		; fwrite(const void *ptr,size_t	size,size_t n,FILE *stream)
			; ptr	 Pointer to the	array of elements to be	written, converted to a	const void*.
			; size	 Size in bytes of each element to be written.
			; count	 Number	of elements, each one with a size of size bytes.
			; stream Pointer to a FILE object that specifies an output stream.
			;
add	sp, 8		; Add
push	[bp+varFilePtrStream] ;	argFileStream
call	_fclose		; FILE *argFileStream
pop	cx

ITR_SaveGam:		; CODE XREF: _f010109_main+1C3j
			; _f010109_main+219j
inc	[bp+var_Itr_SaveGam] ; Increment by 1

LOOP_x9_SaveGam:	; CODE XREF: _f010109_main+1B4j
cmp	[bp+var_Itr_SaveGam], 9	; Compare Two Operands
jge	short loc_13484	; Jump if Greater or Equal (SF=OF)
jmp	loc_133C0	; Jump

loc_13484:		; CODE XREF: _f010109_main+276j
mov	ax, 2700
push	ax		; arg_0
call	setRequiredEMS	; Call Procedure
pop	cx
mov	ax, 583
push	ax
call	ST_SetRequiredMEM ; Call Procedure
pop	cx


mov	[LBX_FONTS_w3A50A], 1 ;	Resource Type 1?
mov	[LBX_FONTS_w3A508], 2 ;	Resource Type 2?
push	[bp+var_12]	; int
push	[bp+var_10]	; int
push	[bp+var_E]	; int
push	[bp+var_C]	; int
push	di		; int
push	[bp+var_A]	; int
push	[bp+var_8]	; int
push	si		; ILSE:	"si_sound_driver_nr"
mov	ax, offset strFONTSLBXr1 ; "FONTS.LBX"
push	ax		; argFontsFileName
push	[LBX_FONTS_w3A508] ; argLbxFonts2
push	[LBX_FONTS_w3A50A] ; argLbxFonts1
call	Load_Fonts_SndDrv ; ILSe: "load_fonts_lbx_2"
add	sp, 16h		; Add


call	ST_SetDebugModeTrue ; Call Procedure


mov	ax, offset unk_334E4 ; This appears to be the only reference to	this anywhere.
push	ax
call	j_idk_Ems_TileFigureCont_s553B0	; ILSe:	j_s_553B0_alloc_all_game_data
pop	cx


call	SetFlag_1_CfgMom_w36A54	; ILSe:	"s_25E46_set_want_input"


mov	ax, -1
push	ax		; argColorIndex
xor	ax, ax		; Logical Exclusive OR
push	ax		; argPaletteNumber
call	ILSe_prepare_palette ; ILSe: prepare_palette
pop	cx
pop	cx


call	idk_SetPalette_s1C4F4 ;	ILSe: "video_related_??"


mov	bx, [word ptr bp+argv]
mov	bx, [bx+2]
cmp	[byte ptr bx], 74 ; Compare Two	Operands
jnz	short loc_13530	; Jump if Not Zero (ZF=0)

loc_134FE:
mov	bx, [word ptr bp+argv]
mov	bx, [bx+2]
cmp	[byte ptr bx+1], 69 ; Compare Two Operands
jnz	short loc_13530	; Jump if Not Zero (ZF=0)

loc_1350A:
mov	bx, [word ptr bp+argv]
mov	bx, [bx+2]
cmp	[byte ptr bx+2], 78 ; Compare Two Operands
jnz	short loc_13530	; Jump if Not Zero (ZF=0)
mov	bx, [word ptr bp+argv]
mov	bx, [bx+2]
cmp	[byte ptr bx+3], 'N' ; Compare Two Operands
jnz	short loc_13530	; Jump if Not Zero (ZF=0)
mov	bx, [word ptr bp+argv]
mov	bx, [bx+2]
cmp	[byte ptr bx+4], 'Y' ; Compare Two Operands
jnz	short loc_13530	; Jump if Not Zero (ZF=0)
jmp	short loc_13535	; Jump

loc_13530:		; CODE XREF: _f010109_main+2F3j
			; _f010109_main+2FFj
			; _f010109_main+30Bj
			; _f010109_main+317j
			; _f010109_main+323j
call	j_ST_LoadMusicSoundfxIntro ; ILSe: "j_play_intro"

loc_13535:		; CODE XREF: _f010109_main+325j
nop			; No Operation
push	cs


call	near ptr _f010409_LoadVortexAnimationImages ; ILSe: "load_vortex_animation_images"
nop			; No Operation
push	cs


call	near ptr fncLoadTERRSTAT ; Call	Procedure
nop			; No Operation
push	cs


call	near ptr LBX_SpellDat ;	Call Procedure


call	j_sub_56413	; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 10		; Add


call	idk_VGA_s1E4BA	; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 10		; Add


call	VGA_MathThenSetVarToVgaLoc ; Call Procedure


call	AIL_someSequence ; Call	Procedure


mov	ax, 104		; int
push	ax		; argLbxEntryNumber
mov	ax, offset strMUSIC ; "music"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx


mov	[bp+var_2], ax
cmp	[MagSet_02], 1	; Compare Two Operands
jnz	short KICK_OFF	; Jump if Not Zero (ZF=0)
push	[bp+var_2]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

KICK_OFF:		; CODE XREF: _f010109_main+398j
mov	ax, -1
push	ax		; argColorIndex
xor	ax, ax		; Logical Exclusive OR
push	ax		; argPaletteNumber
call	ILSe_prepare_palette ; ILSe: "prepare_palette"
pop	cx
pop	cx


call	idk_SetPalette_s1C4F4 ;	ILSe: "video_related_??"
nop			; No Operation
push	cs


call	near ptr _f010309_RUN ;	ILSe: "RUN"


mov	ax, 8		; int
push	ax		; int
call	j_OVR_SaveGame_MagicSet	; ILSe:	"j_SAVE"
pop	cx


call	ST_ExitWithMemDiag ; ILSe: "EXIT_with_memory_status"
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp _f010109_main ; sp-analysis failed

align 2
idk_enum_w135DA	dw	0,     1,   10h,   12h
			; DATA XREF: _f010109_main+10Eo
dw    18h,   19h,   20h,   21h ; value table for switch	statement
dw    22h,   30h,   31h,   38h
dw offset loc_1332D	; jump table for switch	statement
dw offset loc_13343
dw offset loc_1334A
dw offset loc_1334C
dw offset loc_13353
dw offset loc_1336A
dw offset loc_1335A
dw offset loc_13371
dw offset loc_1337D
dw offset loc_13384
dw offset loc_13386
dw offset loc_1338D
idk_enum_w1360A	dw	0,     1,   10h,   12h
			; DATA XREF: _f010109_main+7Ao
dw    18h,   19h,   20h,   21h ; value table for switch	statement
dw    22h,   30h,   31h,   38h
dw offset loc_13299	; jump table for switch	statement
dw offset loc_132AA
dw offset loc_132AF
dw offset loc_132B4
dw offset loc_132B9
dw offset loc_132C3
dw offset loc_132BE
dw offset loc_132C8
dw offset loc_132CD
dw offset loc_132D2
dw offset loc_132D4
dw offset loc_132D9
; [00000005 BYTES: COLLAPSED FUNCTION filebuf::terminate(void).	PRESS KEYPAD "+" TO EXPAND]


; Borrowed from	ILSe
; "RUN"
;
; Attributes: bp-based frame

proc _f010309_RUN far	; CODE XREF: _f010109_main+3B8p

varConfigMomArray= byte	ptr -20h
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 20h		; Integer Subtraction
push	si
push	di		; argDestination
lea	ax, [bp+varConfigMomArray] ; Load Effective Address
push	ax
mov	ax, offset strCONFIG_MOM ; "CONFIG.MOM"
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short ConfigMomFound ; Jump if Not Zero	(ZF=0)

ConfigMomMissing:	; "Run INSTALL to configure MASTER OF MAGI"...
mov	ax, offset strRunInstall
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx

ConfigMomFound:		; CODE XREF: _f010309_RUN+19j
mov	ax, offset strRBr1 ; "rb"
push	ax
mov	ax, offset strCONFIG_MOM ; "CONFIG.MOM"
push	ax		; argPathFileName

loc_1366C:		; fopen("CONFIG.MOM", "rb")
call	_fopen
pop	cx
pop	cx


mov	si, ax
push	si		; argPtrFileStream
mov	ax, 1
push	ax		; argNumber
mov	ax, 18
push	ax		; argSize
mov	ax, offset arrConfigMomSettings
push	ax		; argPtrReadBuffer
call	_fread		; argPtrReadBuffer,argSize,argNumber,argPtrFileStream
add	sp, 8		; Add
push	si		; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx


xor	di, di		; Logical Exclusive OR
mov	[idk_CfgMom_w381BE], 1
mov	[idk_CfgMom_w3700C], 0FFFFh
call	SetFlag_1_CfgMom_w36A54	; Call Procedure
jmp	short loc_1370C	; default

loc_136A6:		; CODE XREF: _f010309_RUN+CFj
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_SetConfigMomFlagValue_s1930B ; Call	Procedure
pop	cx


call	idk_SetThreeFlags_s25E89 ; Call	Procedure
nop			; No Operation
push	cs


call	near ptr _f010509_MainMenuScreen ; Call	Procedure


mov	[bp+var_2], ax
call	idk_SetThreeFlags_s25E89 ; Call	Procedure


mov	[idk_CfgMom_w381BE], 0
mov	bx, [bp+var_2]
cmp	bx, 4		; switch 5 cases
ja	short loc_1370C	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_13720+bx] ; switch jump

loc_136D6:		; DATA XREF: seg001:off_13720o
call	AIL_someSequence ; case	0x0
mov	ax, 8
push	ax
call	sub_318CA	; Call Procedure
db  59h	; Y

loc_136E5:		; CODE XREF: _f010309_RUN+BAj
			; _f010309_RUN+BFj
mov	[word_3461A], 0FFFFh
jmp	short loc_1370C	; default

loc_136ED:		; CODE XREF: _f010309_RUN+92j
			; DATA XREF: seg001:off_13720o
call	sub_318D4	; case 0x1
jmp	short loc_1370C	; default

loc_136F4:		; CODE XREF: _f010309_RUN+92j
			; DATA XREF: seg001:off_13720o
call	sub_3189D	; case 0x2
jmp	short loc_136E5	; Jump

loc_136FB:		; CODE XREF: _f010309_RUN+92j
			; DATA XREF: seg001:off_13720o
mov	di, 1		; case 0x3
jmp	short loc_136E5	; Jump

loc_13700:		; CODE XREF: _f010309_RUN+92j
			; DATA XREF: seg001:off_13720o
call	j_s56450	; case 0x4
call	j_sub_56413	; Call Procedure
jmp	short $+2	; Jump

loc_1370C:		; CODE XREF: _f010309_RUN+65j
			; _f010309_RUN+8Ej
			; _f010309_RUN+ACj
			; _f010309_RUN+B3j
or	di, di		; default
jz	short loc_136A6	; Jump if Zero (ZF=1)

ThankYouExit:		; "Thank you for playing Master	of Magic!"
mov	ax, offset strThankYou
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp _f010309_RUN

off_13720 dw offset loc_136D6
			; DATA XREF: _f010309_RUN+92r
dw offset loc_136ED	; jump table for switch	statement
dw offset loc_136F4
dw offset loc_136FB
dw offset loc_13700


; Borrowed from	ILSe
; "load_vortex_animation_images"
;
; Attributes: bp-based frame

proc _f010409_LoadVortexAnimationImages	far
			; CODE XREF: _f010109_main+32Ep
push	bp
mov	bp, sp
push	si
mov	ax, offset strMAINSCRN ; "MAINSCRN"
push	ax		; argLbxFileName
call	LBX_LoadFileIndex1 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax		; argLbxEntryNumber
mov	ax, offset strMAINSCRN ; "MAINSCRN"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[word_36FF8], ax
mov	ax, 1
push	ax		; argLbxEntryNumber
mov	ax, offset strVORTEX ; "VORTEX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[word_37000], ax
mov	ax, 2
push	ax		; argLbxEntryNumber
mov	ax, offset strVORTEX ; "VORTEX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[word_36FCE], ax
mov	ax, 5
push	ax		; argLbxEntryNumber
mov	ax, offset strVORTEX ; "VORTEX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[word_36FD2], ax
mov	ax, 4
push	ax		; argLbxEntryNumber
mov	ax, offset strVORTEX ; "VORTEX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[word_36FFC], ax
mov	ax, 3
push	ax		; argLbxEntryNumber
mov	ax, offset strVORTEX ; "VORTEX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[word_36FCA], ax
mov	ax, 5
push	ax		; argLbxEntryNumber
mov	ax, offset strMAINSCRN ; "MAINSCRN"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[word_37004], ax
mov	ax, offset strWIZARDS ;	"WIZARDS"
push	ax		; argLbxFileName
call	LBX_LoadFileIndex1 ; Call Procedure
pop	cx
xor	si, si		; Logical Exclusive OR
jmp	short LOOP_WIZARDS ; Jump

LOAD_WIZARDS_0_TO_13:	; CODE XREF: _f010409_LoadVortexAnimationImages+B1j
push	si		; argLbxEntryNumber
mov	ax, offset strWIZARDS ;	"WIZARDS"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word_36FD6+bx], ax
inc	si		; Increment by 1

LOOP_WIZARDS:		; CODE XREF: _f010409_LoadVortexAnimationImages+97j
cmp	si, 14		; Compare Two Operands
jl	short LOAD_WIZARDS_0_TO_13 ; Jump if Less (SF!=OF)
mov	ax, offset strSPELLDAT ; "SPELLDAT"
push	ax		; argLbxFileName
call	LBX_LoadFileIndex1 ; Call Procedure
pop	cx
pop	si
pop	bp
retf			; Return Far from Procedure
endp _f010409_LoadVortexAnimationImages



; Borrowed from	ILSe
; "MAINMENU_screen"
;
; Attributes: bp-based frame

proc _f010509_MainMenuScreen far
			; CODE XREF: _f010309_RUN+77p

var_6C=	word ptr -6Ch
argPtrCharArr= byte ptr	-4Eh
argCharPtrFileName= byte ptr -30h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
argNumber= word	ptr -2

push	bp
mov	bp, sp
sub	sp, 6Ch		; Integer Subtraction
push	si
push	di		; argConversionBase
db 83h,3Eh,0FCh,52h,0FFh ; <BAD>cmp	[idk_CfgMom_w3700C], 0FFFFh ; Compare Two Operands
jz	short loc_1380B	; Jump if Zero (ZF=1)
mov	ax, [idk_CfgMom_w3700C]
mov	[bp+argNumber],	ax
mov	[idk_CfgMom_w3700C], 0FFFFh
mov	ax, [bp+argNumber]

loc_13808:		; CODE XREF: _f010509_MainMenuScreen+4C7j
jmp	loc_13CB4	; Jump

loc_1380B:		; CODE XREF: _f010509_MainMenuScreen+Dj
mov	[word_3461A], 0FFFFh
mov	[bp+var_C], 0
mov	[word_37002], 0
mov	[word_36FD4], 0FFFFh
mov	[word_36FF4], 0
mov	[word_33D7C], 0
xor	di, di		; Logical Exclusive OR
mov	[idk_CfgMom_w381BE], 1
cmp	[idk_CfgMom_w381BE], 0 ; Compare Two Operands
jz	short loc_13842	; Jump if Zero (ZF=1)

loc_1383D:		; Call Procedure
call	sub_318CF

loc_13842:		; CODE XREF: _f010509_MainMenuScreen+51j
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add


call	idk_VGA_s1E4BA	; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add


call	VGA_MathThenSetVarToVgaLoc ; Call Procedure


mov	ax, -1
push	ax		; argColorIndex
mov	ax, 2
push	ax		; argPaletteNumber
call	ILSe_prepare_palette ; Call Procedure
pop	cx
pop	cx


call	j_ST_MagicSet_ReadCreateWrite ;	Call Procedure


mov	[word_3A2C0], 0FFFFh
mov	[word_3A2CA], 0FFFFh
mov	[word_3A2D4], 0FFFFh
mov	[word_3A2DE], 0FFFFh
mov	[word_3A2E8], 0FFFFh
mov	[word_3700E], 0
mov	[bp+argNumber],	1
jmp	loc_13942	; Jump

SAVE_GAM:		; CODE XREF: _f010509_MainMenuScreen+15Ej
mov	ax, offset strSAVE ; "SAVE"
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strGAM ; ".GAM"
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+var_6C]	; Load Effective Address
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_13933	; Jump if Zero (ZF=1)
cmp	[bp+argNumber],	9 ; Maximum Saved Game Count
jge	short loc_1392B	; Jump if Greater or Equal (SF=OF)
mov	bx, [word_3700E]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+argNumber]
dec	ax		; Decrement by 1
mov	[word_37010+bx], ax

loc_13925:		; Increment by 1
inc	[word_3700E]
jmp	short loc_13931	; Jump

loc_1392B:		; CODE XREF: _f010509_MainMenuScreen+12Bj
mov	[word_37002], 1

loc_13931:		; CODE XREF: _f010509_MainMenuScreen+13Fj
jmp	short loc_1393F	; Jump

loc_13933:		; CODE XREF: _f010509_MainMenuScreen+125j
mov	bx, [word_3700E]
shl	bx, 1		; Shift	Logical	Left
mov	[word_37010+bx], 0FFFFh

loc_1393F:		; CODE XREF: _f010509_MainMenuScreen:loc_13931j
inc	[bp+argNumber]	; Increment by 1

loc_13942:		; CODE XREF: _f010509_MainMenuScreen+D1j
cmp	[bp+argNumber],	10 ; Compare Two Operands
jge	short loc_1394B	; Jump if Greater or Equal (SF=OF)
jmp	SAVE_GAM	; Jump

loc_1394B:		; CODE XREF: _f010509_MainMenuScreen+15Cj
cmp	[word_3700E], 0	; Compare Two Operands
jle	short loc_13958	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[word_36FF4], 1

loc_13958:		; CODE XREF: _f010509_MainMenuScreen+166j
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	[bp+var_4], 0
cmp	[word_36FF4], 0	; Compare Two Operands
jz	short loc_139AC	; Jump if Zero (ZF=1)
mov	ax, 0FFFFh
push	ax
mov	ax, 2077h
push	ax
mov	ax, 0A1h ; ''
push	ax
mov	ax, 0D3h ; ''
push	ax
mov	ax, 96h	; ''
push	ax
mov	ax, 6Ch	; 'l'
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add


mov	[word_36FC6], ax
mov	[word_3A2C0], 275h
mov	[word_3A2C2], 6Ch ; 'l'
mov	[word_3A2C4], 94h ; ''
mov	[word_3A2C6], 0D3h ; ''
mov	[word_3A2C8], 0A2h ; ''
jmp	short loc_139B7	; Jump

loc_139AC:		; CODE XREF: _f010509_MainMenuScreen+17Dj
mov	[word_36FC6], 0FC18h
mov	[bp+var_4], 1

loc_139B7:		; CODE XREF: _f010509_MainMenuScreen+1C0j
cmp	[word_37002], 0	; Compare Two Operands
jz	short loc_13A21	; Jump if Zero (ZF=1)
mov	ax, 0FFFFh
push	ax
mov	ax, 2077h
push	ax
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, 95h	; ''   ; Add
push	ax
mov	ax, 0D3h ; ''
push	ax
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, 8Ah	; ''   ; Add
push	ax
mov	ax, 6Ch	; 'l'
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add


mov	[word_36FFE], ax
mov	[word_3A2CA], 274h
mov	[word_3A2CC], 6Ch ; 'l'
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, 8Ah	; ''   ; Add
mov	[word_3A2CE], ax
mov	[word_3A2D0], 0D3h ; ''
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, 95h	; ''   ; Add
mov	[word_3A2D2], ax
jmp	short loc_13A27	; Jump

loc_13A21:		; CODE XREF: _f010509_MainMenuScreen+1D2j
mov	[word_36FFE], 0FC18h

loc_13A27:		; CODE XREF: _f010509_MainMenuScreen+235j
mov	ax, 0FFFFh
push	ax
mov	ax, 2077h
push	ax
mov	ax, 0ADh ; ''
push	ax
mov	ax, 0D3h ; ''
push	ax
mov	ax, 0A2h ; ''
push	ax
mov	ax, 6Ch	; 'l'
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add


mov	[word_36FFA], ax
mov	[word_3A2D4], 276h
mov	[word_3A2D6], 6Ch ; 'l'
mov	[word_3A2D8], 0A2h ; ''
mov	[word_3A2DA], 0D3h ; ''
mov	[word_3A2DC], 0ADh ; ''
mov	ax, 0FFFFh
push	ax
mov	ax, 2077h
push	ax
mov	ax, 0B9h ; ''
push	ax
mov	ax, 0D3h ; ''
push	ax
mov	ax, 0AEh ; ''
push	ax
mov	ax, 6Ch	; 'l'
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add


mov	[word_36FCC], ax
mov	[word_3A2DE], 31Eh
mov	[word_3A2E0], 6Ch ; 'l'
mov	[word_3A2E2], 0AEh ; ''
mov	[word_3A2E4], 0D3h ; ''
mov	[word_3A2E6], 0B9h ; ''
mov	ax, 0FFFFh
push	ax
mov	ax, 2077h
push	ax
mov	ax, 0C7h ; ''
push	ax
mov	ax, 0D3h ; ''
push	ax
mov	ax, 0BAh ; ''
push	ax
mov	ax, 6Ch	; 'l'
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add


mov	[word_36FD0], ax
mov	[word_3A2E8], 277h
mov	[word_3A2EA], 6Ch ; 'l'
mov	[word_3A2EC], 0BAh ; ''
mov	[word_3A2EE], 0D3h ; ''
mov	[word_3A2F0], 0C7h ; ''
cmp	[word_37002], 0	; Compare Two Operands
jz	short loc_13B05	; Jump if Zero (ZF=1)
mov	ax, 0FFFFh
push	ax
mov	ax, offset strC	; "C"
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
pop	cx

loc_13B00:
mov	[bp+var_6], ax
jmp	short loc_13B0A	; Jump

loc_13B05:		; CODE XREF: _f010509_MainMenuScreen+305j
mov	[bp+var_6], 0FC18h

loc_13B0A:		; CODE XREF: _f010509_MainMenuScreen+319j
cmp	[word_36FF4], 0	; Compare Two Operands
jz	short loc_13B25	; Jump if Zero (ZF=1)
mov	ax, 0FFFFh
push	ax
mov	ax, offset strL	; "L"
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_12], ax
jmp	short loc_13B2A	; Jump

loc_13B25:		; CODE XREF: _f010509_MainMenuScreen+325j
mov	[bp+var_12], 0FC18h

loc_13B2A:		; CODE XREF: _f010509_MainMenuScreen+339j
mov	ax, 0FFFFh
push	ax
mov	ax, (offset strMAINSCRN+7)
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_8], ax
mov	ax, 0FFFFh
push	ax
mov	ax, offset strH	; "H"
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_10], ax
mov	ax, 0FFFFh
push	ax
mov	ax, offset strQ	; "Q"
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_A], ax
mov	ax, 0FFFFh
push	ax
mov	ax, offset strESC ; "\x1B"
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_E], ax
mov	ax, offset unk_33D6E
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24648	; Call Procedure
pop	cx
pop	cx
push	[word_36FFA]
call	sub_27913	; Call Procedure
pop	cx
push	[word_36FF8]
call	sub_1FAD4	; Call Procedure
pop	cx
mov	[word_36FD4], 0FFFFh
mov	ax, 2
push	ax
mov	ax, seg	seg001
push	ax
mov	ax, offset _f010609_DrawMainMenuScreen
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
mov	ax, 5
push	ax
mov	ax, offset word_3A2C0
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
mov	ax, 4
push	ax
call	sub_2B9C4	; Call Procedure
pop	cx
jmp	loc_13C9D	; Jump

loc_13BDE:		; CODE XREF: _f010509_MainMenuScreen+4B7j
call	_f020105_bios_timeofday	; Call Procedure


call	sub_2B97A	; Call Procedure


mov	si, ax
or	si, si		; Logical Inclusive OR
jz	short loc_13BF1	; Jump if Zero (ZF=1)
mov	di, 1

loc_13BF1:		; CODE XREF: _f010509_MainMenuScreen+402j
cmp	si, [bp+var_6]	; Compare Two Operands
jz	short loc_13BFC	; Jump if Zero (ZF=1)
cmp	si, [word_36FFE] ; Compare Two Operands
jnz	short loc_13C05	; Jump if Not Zero (ZF=0)

loc_13BFC:		; CODE XREF: _f010509_MainMenuScreen+40Aj
mov	di, 1
mov	[word_36FD4], 0

loc_13C05:		; CODE XREF: _f010509_MainMenuScreen+410j
cmp	si, [bp+var_12]	; Compare Two Operands
jz	short loc_13C10	; Jump if Zero (ZF=1)
cmp	si, [word_36FC6] ; Compare Two Operands
jnz	short loc_13C19	; Jump if Not Zero (ZF=0)

loc_13C10:		; CODE XREF: _f010509_MainMenuScreen+41Ej
mov	di, 1
mov	[word_36FD4], 1

loc_13C19:		; CODE XREF: _f010509_MainMenuScreen+424j
cmp	si, [bp+var_8]	; Compare Two Operands
jz	short loc_13C24	; Jump if Zero (ZF=1)
cmp	si, [word_36FFA] ; Compare Two Operands
jnz	short loc_13C2D	; Jump if Not Zero (ZF=0)

loc_13C24:		; CODE XREF: _f010509_MainMenuScreen+432j
mov	di, 1
mov	[word_36FD4], 2

loc_13C2D:		; CODE XREF: _f010509_MainMenuScreen+438j
cmp	si, [bp+var_A]	; Compare Two Operands
jz	short loc_13C3D	; Jump if Zero (ZF=1)
cmp	si, [word_36FD0] ; Compare Two Operands
jz	short loc_13C3D	; Jump if Zero (ZF=1)
cmp	si, [bp+var_E]	; Compare Two Operands
jnz	short loc_13C46	; Jump if Not Zero (ZF=0)

loc_13C3D:		; CODE XREF: _f010509_MainMenuScreen+446j
			; _f010509_MainMenuScreen+44Cj
mov	di, 1
mov	[word_36FD4], 3

loc_13C46:		; CODE XREF: _f010509_MainMenuScreen+451j
cmp	si, [bp+var_10]	; Compare Two Operands
jz	short loc_13C51	; Jump if Zero (ZF=1)
cmp	si, [word_36FCC] ; Compare Two Operands
jnz	short loc_13C5A	; Jump if Not Zero (ZF=0)

loc_13C51:		; CODE XREF: _f010509_MainMenuScreen+45Fj
mov	di, 1
mov	[word_36FD4], 4

loc_13C5A:		; CODE XREF: _f010509_MainMenuScreen+465j
db 83h,3Eh,0C4h,52h,0FFh ; <BAD>cmp	[word_36FD4], 0FFFFh ; Compare Two Operands
jnz	short loc_13C63	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR

loc_13C63:		; CODE XREF: _f010509_MainMenuScreen+475j
or	di, di		; Logical Inclusive OR
jnz	short loc_13C9D	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr _f010609_DrawMainMenuScreen ; Call Procedure
call	sub_2E303	; Call Procedure
cmp	[idk_CfgMom_w381BE], 0 ; Compare Two Operands
jz	short loc_13C93	; Jump if Zero (ZF=1)
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_13C93	; Jump if Not Zero (ZF=0)
call	sub_318DE	; Call Procedure
call	sub_1E525	; Call Procedure

loc_13C88:
mov	[bp+var_C], 1
mov	[idk_CfgMom_w381BE], 0

loc_13C93:		; CODE XREF: _f010509_MainMenuScreen+48Cj
			; _f010509_MainMenuScreen+492j
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_13C9D:		; CODE XREF: _f010509_MainMenuScreen+3F1j
			; _f010509_MainMenuScreen+47Bj
or	di, di		; Logical Inclusive OR
jnz	short loc_13CA4	; Jump if Not Zero (ZF=0)
jmp	loc_13BDE	; Jump

loc_13CA4:		; CODE XREF: _f010509_MainMenuScreen+4B5j
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	ax, [word_36FD4]
jmp	loc_13808	; Jump

loc_13CB4:		; CODE XREF: _f010509_MainMenuScreen:loc_13808j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp _f010509_MainMenuScreen



; Borrowed from	ILSe
; "draw_mainmenu_screen"
;
; Attributes: bp-based frame

proc _f010609_DrawMainMenuScreen far
			; CODE XREF: _f010509_MainMenuScreen+47Fp
			; DATA XREF: _f010509_MainMenuScreen+3CCo

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction
push	si
push	di


mov	si, 123
mov	di, 141


call	sub_27AFB	; Call Procedure
mov	[bp+var_2], ax


call	VGA_MathThenSetVarToVgaLoc ; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add


push	[word_36FF8]
call	sub_1FAEB	; Call Procedure
pop	cx


mov	[bp+var_8], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_36FF8]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx


mov	[bp+var_6], 0
jmp	short loc_13D25	; Jump

loc_13D10:		; CODE XREF: _f010609_DrawMainMenuScreen+71j
push	[word_36FF8]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_13D22:		; Increment by 1
inc	[bp+var_6]

loc_13D25:		; CODE XREF: _f010609_DrawMainMenuScreen+54j
mov	ax, [bp+var_6]
cmp	ax, [bp+var_8]	; Compare Two Operands
jle	short loc_13D10	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[word_37004]
mov	ax, 41
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
cmp	[idk_CfgMom_w381BE], 0 ; Compare Two Operands
jnz	short loc_13D4C	; Jump if Not Zero (ZF=0)
call	sub_31CD0	; Call Procedure

loc_13D4C:		; CODE XREF: _f010609_DrawMainMenuScreen+8Bj
mov	[bp+var_4], 0
cmp	[word_36FF4], 0	; Compare Two Operands
jz	short loc_13D91	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]
cmp	ax, [word_36FC6] ; Compare Two Operands
jnz	short loc_13D6D	; Jump if Not Zero (ZF=0)
push	[word_36FD2]
call	sub_1FAD4	; Call Procedure
pop	cx
jmp	short loc_13D7C	; Jump

loc_13D6D:		; CODE XREF: _f010609_DrawMainMenuScreen+A5j
mov	ax, 1
push	ax
push	[word_36FD2]
call	sub_1FA6E	; Call Procedure
pop	cx

loc_13D7B:
pop	cx

loc_13D7C:		; CODE XREF: _f010609_DrawMainMenuScreen+B1j
push	[word_36FD2]
mov	ax, di
add	ax, 0Ch		; Add
push	ax
push	si
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
jmp	short loc_13D96	; Jump

loc_13D91:		; CODE XREF: _f010609_DrawMainMenuScreen+9Cj
mov	[bp+var_4], 1

loc_13D96:		; CODE XREF: _f010609_DrawMainMenuScreen+D5j
cmp	[word_37002], 0	; Compare Two Operands
jz	short loc_13DDB	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]

loc_13DA0:		; Compare Two Operands
cmp	ax, [word_36FFE]
jnz	short loc_13DB2	; Jump if Not Zero (ZF=0)
push	[word_37000]
call	sub_1FAD4	; Call Procedure
pop	cx
jmp	short loc_13DC1	; Jump

loc_13DB2:		; CODE XREF: _f010609_DrawMainMenuScreen+EAj
mov	ax, 1
push	ax
push	[word_37000]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_13DC1:		; CODE XREF: _f010609_DrawMainMenuScreen+F6j
push	[word_37000]
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
mov	dx, di
add	dx, ax		; Add
push	dx
push	si
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_13DDB:		; CODE XREF: _f010609_DrawMainMenuScreen+E1j
mov	ax, [bp+var_2]
cmp	ax, [word_36FFA] ; Compare Two Operands
jnz	short loc_13DF0	; Jump if Not Zero (ZF=0)
push	[word_36FFC]
call	sub_1FAD4	; Call Procedure
pop	cx
jmp	short loc_13DFF	; Jump

loc_13DF0:		; CODE XREF: _f010609_DrawMainMenuScreen+128j
mov	ax, 1
push	ax
push	[word_36FFC]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_13DFF:		; CODE XREF: _f010609_DrawMainMenuScreen+134j
push	[word_36FFC]
mov	ax, di
add	ax, 18h		; Add
push	ax
push	si
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_2]
cmp	ax, [word_36FCC] ; Compare Two Operands
jnz	short loc_13E27	; Jump if Not Zero (ZF=0)
push	[word_36FCE]
call	sub_1FAD4	; Call Procedure
pop	cx
jmp	short loc_13E36	; Jump

loc_13E27:		; CODE XREF: _f010609_DrawMainMenuScreen+15Fj
mov	ax, 1
push	ax
push	[word_36FCE]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_13E36:		; CODE XREF: _f010609_DrawMainMenuScreen+16Bj
push	[word_36FCE]
mov	ax, di
add	ax, 24h	; '$'   ; Add
push	ax
push	si
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_2]
cmp	ax, [word_36FD0] ; Compare Two Operands
jnz	short loc_13E5E	; Jump if Not Zero (ZF=0)
push	[word_36FCA]
call	sub_1FAD4	; Call Procedure
pop	cx
jmp	short loc_13E6D	; Jump

loc_13E5E:		; CODE XREF: _f010609_DrawMainMenuScreen+196j
mov	ax, 1
push	ax
push	[word_36FCA]
call	sub_1FA6E	; Call Procedure
pop	cx

loc_13E6C:
pop	cx

loc_13E6D:		; CODE XREF: _f010609_DrawMainMenuScreen+1A2j
push	[word_36FCA]
mov	ax, di
add	ax, 30h	; '0'   ; Add
push	ax
push	si
call	sub_1F655	; Call Procedure
add	sp, 6		; Add


mov	ax, [word_33D7C]
inc	ax		; Increment by 1
mov	bx, 14h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[word_33D7C], dx


pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp _f010609_DrawMainMenuScreen



; Attributes: bp-based frame

proc fncLoadTERRSTAT far
			; CODE XREF: _f010109_main+333p
push	bp
mov	bp, sp


mov	ax, 6
push	ax
mov	ax, 770
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset strTERRSTAT ; "TERRSTAT"
push	ax
call	LBX_PreLoad_s15453 ; Call Procedure
add	sp, 0Ah		; Add


push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_378BC+2], dx
mov	[word ptr dword_378BC],	ax


pop	bp
retf			; Return Far from Procedure
endp fncLoadTERRSTAT



; Attributes: bp-based frame

proc LBX_SpellDat far	; CODE XREF: _f010109_main+338p
push	bp
mov	bp, sp
mov	ax, 36
push	ax
mov	ax, 215
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset strSPELLDAT ; "SPELLDAT"
push	ax
call	LBX_PreLoad_s15453 ; Call Procedure

loc_13EDB:		; Add
add	sp, 10
push	ax

loc_13EDF:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3833C+2], dx
mov	[word ptr dword_3833C],	ax
pop	bp
retf			; Return Far from Procedure
endp LBX_SpellDat



; Attributes: bp-based frame

proc LBX_HelpEntry_s13EEE far
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 4
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, offset word_3A2C0
push	ax		; int
mov	ax, 19h
push	ax		; int

loc_13F04:		; "hlpentry"
mov	ax, offset strHLPENTRY
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure

loc_13F0D:		; Add
add	sp, 0Ch
mov	ax, 4
push	ax

loc_13F14:
mov	ax, offset word_3A2C0
push	ax

loc_13F18:		; Call Procedure
call	idk_SetThreeFlagsOrValues_s25E72
pop	cx

loc_13F1E:
pop	cx
pop	bp

locret_13F20:		; Return Far from Procedure
retf
endp LBX_HelpEntry_s13EEE ; sp-analysis	failed

ends seg001


; Segment type:	Pure code
segment	seg002 byte public 'CODE' use16
assume cs:seg002
;org 2
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


;
; http://www.husseinsspace.com/teaching/udw/1996/asmnotes/chapsix.htm
;
; mov ax,0040h ; set ES	to point to BIOS data area
; mov es,ax
; mov ax,es:[006Ch] ; get system clock value
; mov dx,es:[006Eh]
; mov word ptr TimerStart,ax ; store clock value in TimerStart
; mov word ptr TimerStart+2,dx
; mov Running,1	; set timer flag
;
; https://stanislavs.org/helppc/int_1a-0.html
; INT 1A,0 - Read System Clock Counter
; AH = 00
; on return:
; AL = midnight	flag, 1	if 24 hours passed since reset
; CX = high order word of tick count
; DX = low order word of tick count
; - incremented	approximately 18.206 times per second
; - at midnight	CX:DX is zero
; - this function can be called	in a program to	assure the date	is
; updated after	midnight;  this	will avoid the passing two midnights
; date problem
;
; Borland C++ Library Reference
; Page 59 (PDF Page 72)
; Function: _bios_timeofday
; #include <bios. h>
; #include <time.h>
; long bios_time;
; _bios_timeofday(_TIME_GETCLOCK, &bios_time);

proc _f020105_bios_timeofday far
			; CODE XREF: _f010109_main+E4P
			; _f010509_MainMenuScreen:loc_13BDEP
			; sub_1CBCF+3P
			; sub_1D40D:loc_1D484P
			; sub_28963+8P
			; sub_2A755:loc_2A9CBP
			; sub_2B1F9:loc_2B39DP
			; sub_2E27D+AP
			; sub_2E2B7:loc_2E2C1P
			; sub_3CFC0:loc_3D25DP
			; sub_3DBA6+304P
			; sub_3E1DE+314P
			; sub_3EBA0+19DP
			; sub_3F3C6+156P
			; sub_3F7D8:loc_3F951P
			; sub_3FBE0:loc_3FD96P
			; sub_3FBE0:loc_3FE92P
			; sub_4067D+386P
			; LBX_NewGame_s41A5F:loc_41DA7P
			; sub_43349:loc_43352P
			; sub_43381:loc_4338AP
			; sub_4F44D:loc_4F5BDP
			; ST_LoadMusicSoundfxIntro:loc_558C3P
			; sub_55B7F:loc_55B88P
			; sub_55BB7:loc_55BC0P
			; sub_55BEF:loc_55BF8P
			; sub_55C27:loc_55C30P
			; sub_55C5E:loc_55C67P
			; sub_56450:loc_5650AP
es_BIOS_Data_Area = es	; BIOS Data Area (BDA) @ 0x0400
push	es_BIOS_Data_Area
mov	ax, 0
mov	es_BIOS_Data_Area, ax ;	Point ES at Page-Zero
assume es:nothing
mov	ax, [es_BIOS_Data_Area:DAILY_TIMER_COUNTER_lw] ; Get current timer count
mov	[bios_time_lw],	ax
mov	ax, [es_BIOS_Data_Area:DAILY_TIMER_COUNTER_hw]
mov	[bios_time_hw],	ax
pop	es_BIOS_Data_Area
assume es:nothing
retf			; Return Far from Procedure
endp _f020105_bios_timeofday




proc _f020205_idk_DIFF_bios_time_lw far
push	es
mov	ax, 0
mov	es, ax
assume es:nothing
mov	ax, [es:DAILY_TIMER_COUNTER_lw]
sub	ax, [bios_time_lw] ; Integer Subtraction
pop	es
assume es:nothing
retf			; Return Far from Procedure
endp _f020205_idk_DIFF_bios_time_lw



; _main
;   mov	    ax,	2
;   push    ax
; Attributes: bp-based frame

proc _f020305_idk_SleepWaitPause far
			; CODE XREF: _f010109_main+EDP
			; _f010509_MainMenuScreen+4ADP
			; sub_1CBCF:loc_1CBDBP
			; sub_1D40D+173P
			; sub_28963:loc_28D3EP
			; sub_2A755+A56P
			; sub_2B1F9+22FP
			; sub_2E27D+26P
			; sub_2E2B7+26P
			; sub_3CFC0+386P
			; sub_3DBA6+3C9P
			; sub_3E1DE+41BP
			; sub_3EBA0+21CP
			; sub_3F3C6+1D2P
			; sub_3F7D8+206P
			; sub_3FBE0+29EP
			; sub_3FBE0+432P
			; sub_4067D+811P
			; LBX_NewGame_s41A5F+74FP
			; sub_43349+27P
			; sub_43381+27P
			; sub_4F44D+347P
			; ST_LoadMusicSoundfxIntro+365P
			; sub_55B7F+27P
			; sub_55BB7+27P
			; sub_55BEF+27P
			; sub_55C27:loc_55C4EP
			; sub_55C5E+27P
			; sub_56450+10AP

arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	es
push	ds
push	si
push	di
jmp	short LOOP	; Jump
db 90h

loc_13F55:		; CODE XREF: _f020305_idk_SleepWaitPause+22j
			; _f020305_idk_SleepWaitPause+27j
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

LOOP:			; CODE XREF: _f020305_idk_SleepWaitPause+Aj
			; _f020305_idk_SleepWaitPause+2Cj
mov	ax, 0
mov	es, ax
assume es:nothing
mov	ax, [es:DAILY_TIMER_COUNTER_lw]
sub	ax, [bios_time_lw] ; Integer Subtraction
js	short loc_13F55	; Jump if Sign (SF=1)

loc_13F6C:		; Compare Two Operands
cmp	ax, 4
jns	short loc_13F55	; Jump if Not Sign (SF=0)
sub	ax, [bp+arg_0]	; Integer Subtraction
js	short LOOP	; Jump if Sign (SF=1)
pop	di
pop	si
pop	ds
pop	es
assume es:nothing
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp _f020305_idk_SleepWaitPause



; Attributes: bp-based frame

proc _f020405_idk_CheckInputOrSleep_s13F7E far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	es
cmp	[idk_bios_time_w359CC],	0 ; BAIL, if 0
jnz	short loc_13F8C	; Jump if Not Zero (ZF=0)

loc_13F89:		; CODE XREF: _f020405_idk_CheckInputOrSleep_s13F7E+48j
			; _f020405_idk_CheckInputOrSleep_s13F7E+4Dj
			; _f020405_idk_CheckInputOrSleep_s13F7E+52j
			; _f020405_idk_CheckInputOrSleep_s13F7E+57j
pop	es
pop	bp
retf			; Return Far from Procedure

loc_13F8C:		; CODE XREF: _f020405_idk_CheckInputOrSleep_s13F7E+9j
			; _f020405_idk_CheckInputOrSleep_s13F7E+5Cj
call	_f331647_TestKeyPress ;	Call Procedure
cmp	ax, 0		; Compare Two Operands
jz	short loc_13F99	; Jump if Zero (ZF=1)
pop	es
pop	bp
retf			; Return Far from Procedure

loc_13F99:		; CODE XREF: _f020405_idk_CheckInputOrSleep_s13F7E+16j
call	_f330547_GetMouseButtonsStatus ; Call Procedure
cmp	ax, 0		; Compare Two Operands
jnz	short loc_13FAD	; Jump if Not Zero (ZF=0)
call	_f332647_Get_w360B4_Set0 ; Call	Procedure
cmp	ax, 0		; Compare Two Operands
jz	short loc_13FB0	; Jump if Zero (ZF=1)

loc_13FAD:		; CODE XREF: _f020405_idk_CheckInputOrSleep_s13F7E+23j
pop	es
pop	bp
retf			; Return Far from Procedure

loc_13FB0:		; CODE XREF: _f020405_idk_CheckInputOrSleep_s13F7E+2Dj
mov	ax, 0
mov	es, bx
mov	ax, [es:DAILY_TIMER_COUNTER_lw]
mov	dx, [es:DAILY_TIMER_COUNTER_hw]
sub	ax, [bios_time_lw] ; Integer Subtraction
sbb	dx, [bios_time_hw] ; Integer Subtraction with Borrow
js	short loc_13F89	; Jump if Sign (SF=1)
cmp	dx, 0		; Compare Two Operands
jnz	short loc_13F89	; Jump if Not Zero (ZF=0)

loc_13FCD:		; Compare Two Operands
cmp	ax, 0
js	short loc_13F89	; Jump if Sign (SF=1)

loc_13FD2:		; Compare Two Operands
cmp	ax, 400
jns	short loc_13F89	; Jump if Not Sign (SF=0)

loc_13FD7:		; Integer Subtraction
sub	ax, [bp+arg_0]
js	short loc_13F8C	; Jump if Sign (SF=1)
pop	es
pop	bp
retf			; Return Far from Procedure
endp _f020405_idk_CheckInputOrSleep_s13F7E




proc _f020505_WaitForVsync far
			; CODE XREF: idk_VGA_CRTR_s1E4F1+26P
push	es
mov	dx, INPUT_STATUS

loc_13FE3:		; CODE XREF: _f020505_WaitForVsync+7j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jnz	short loc_13FE3	; Jump if Not Zero (ZF=0)

loc_13FE8:		; CODE XREF: _f020505_WaitForVsync+Cj
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jz	short loc_13FE8	; Jump if Zero (ZF=1)

loc_13FED:
pop	es
retf			; Return Far from Procedure
endp _f020505_WaitForVsync

ends seg002


; Segment type:	Pure code
segment	seg003 byte public 'CODE' use16
assume cs:seg003
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
byte_13FF0 db 0B0h, 0, 0CFh


; Attributes: bp-based frame

proc idk_IntVec_s13FF3 far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	es
push	di
push	si
push	ds


mov	al, 24h		;
			; Get Interrupt	Vector:	24h, Error Handler
			; Return: ES:BX	-> current interrupt handler
mov	ah, 35h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	[offOldInt24ErrorHandler], bx ;
			; Store	Segment	Offset of original vector
mov	[segOldInt24ErrorHandler], es ;	Store Segment Address of original vector
mov	ax, cs		;
			; CS = ?Code Segment?
mov	ds, ax		;
			; DS = ?CS?
assume ds:seg003
mov	dx, 0		;
			; Offset of new	handler
			; DS:DX	= ?CS:0?
mov	al, 24h		;
			; Set Interrupt	Vector:	24h, Error Handler
			; DS:DX	-> new interrupt handler
mov	ah, 25h
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
mov	dx, [bp+arg_0]
cmp	dx, 3		; Compare Two Operands
js	short loc_14023	; Jump if Sign (SF=1)

loc_1401D:
mov	dx, 1
jmp	short loc_1402B	; Jump
byte_14022 db 90h	; One-byte nop (0x90) is synonymous with xchg (e)ax,(e)ax.

loc_14023:		; CODE XREF: idk_IntVec_s13FF3+28j
cmp	dx, 0		; Compare Two Operands
jnz	short loc_1402B	; Jump if Not Zero (ZF=0)

loc_14028:
mov	dx, 1

loc_1402B:		; CODE XREF: idk_IntVec_s13FF3+2Dj
			; idk_IntVec_s13FF3+33j
mov	ah, 36h
int	21h		; DOS -	2+ - GET DISK SPACE
			; DL = drive code (0 = default,	1 = A, 2 = B, etc.)
push	ax
mov	dx, [ds:3CBEh]
mov	ds, [word ptr ds:3CC0h]
assume ds:seg012
mov	al, 24h		;
			; Set Interrupt	Vector:	24h, Error Handler
			; DS:DX	-> new interrupt handler
mov	ah, 25h
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ax
cmp	ax, 0FFFFh	; Compare Two Operands
jz	short loc_14047	; Jump if Zero (ZF=1)

loc_14044:
mov	ax, 0

loc_14047:		; CODE XREF: idk_IntVec_s13FF3+4Fj
pop	ds
assume ds:dseg
pop	si
pop	di
pop	es
pop	bp
retf			; Return Far from Procedure
endp idk_IntVec_s13FF3

byte_1404D db 6, 1Eh, 56h, 57h,	0B4h, 19h, 0CDh, 21h
db 32h,	0E4h, 5Fh, 5Eh,	1Fh, 7,	0CBh


; Attributes: bp-based frame

proc DOS_DeleteFile far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	es
push	di
push	ds
push	si


mov	dx, [bp+arg_0]
mov	ah, 41h
int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
			; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
xor	ah, ah		; Logical Exclusive OR


pop	si
pop	ds
pop	di
pop	es
pop	bp
retf			; Return Far from Procedure
endp DOS_DeleteFile



; char *argFileName {AX	= FileSize DX =	FileName}
; Attributes: bp-based frame

; int __cdecl __far DOS_FindFirst(BCpp30_DOSH_dosSearchInfo *argFileName)
proc DOS_FindFirst far	; CODE XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+29P
			; LBX_LoadFileMemory+B6P
			; sub_17BB8+3DP
			; ST_LoadSaveGamByNbr+50P
			; ST_MagicSet_ReadCreateWrite+1FP
			; sub_3E1DE+132P

varDTA_BX26= BCpp30_DOSH_dosSearchInfo ptr -4

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	es
push	di
push	ds
push	si
push	ds
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
mov	ah, 2Fh
int	21h		; DOS -	GET DISK TRANSFER AREA ADDRESS
			; Return: ES:BX	-> DTA
add	bx, 26		; Add
mov	[word ptr bp+varDTA_BX26.ds_drive], bx
mov	bx, es
mov	[word ptr bp+varDTA_BX26.ds_pattern+1],	bx
push	ds
mov	ah, 4Eh
mov	cx, 0
mov	dx, [word ptr bp+varDTA_BX26.ds_pattern+9]
int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive, path,	and wildcards allowed)
pop	ds
jb	short NOT_FOUND	; Jump if Below	(CF=1)

loc_1409F:
mov	ax, [word ptr bp+varDTA_BX26.ds_pattern+1]
mov	es, ax

loc_140A4:
mov	di, [word ptr bp+varDTA_BX26.ds_drive]

loc_140A7:		; AX = DTA offset 26 = File size in bytes
mov	ax, [es:di]

loc_140AA:		; Add
add	di, 2
mov	dx, [es:di]	; DX = DTA offset 30 = Filename	with extension

loc_140B0:
pop	ds
push	ax
push	dx

loc_140B3:		; FLAG_w3609E =	FLAG_w360BE
call	Restore_Set_FLAG_Mouse_Skip

loc_140B8:
pop	dx
pop	ax
pop	si
pop	ds
pop	di

loc_140BD:
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

NOT_FOUND:		; CODE XREF: DOS_FindFirst+2Bj
mov	ax, 0

loc_140C5:
mov	dx, 0
pop	ds
push	ax
push	dx
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE

loc_140D0:
pop	dx
pop	ax
pop	si

loc_140D3:
pop	ds
pop	di

loc_140D5:
pop	es

loc_140D6:
mov	sp, bp

loc_140D8:
pop	bp
retf			; Return Far from Procedure
endp DOS_FindFirst



; Attributes: bp-based frame

proc NoXrefs_DosGetDtaFindFirst	far

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp

loc_140DB:
mov	bp, sp

loc_140DD:		; Integer Subtraction
sub	sp, 4

loc_140E0:
push	es

loc_140E1:
push	di
push	ds
push	si
push	ds

loc_140E5:		; FLAG_w360BE =	FLAG_w3609E, FLAG_w3609E = 0
call	Disable_Set_FLAG_Mouse_Skip

loc_140EA:
mov	ah, 2Fh

loc_140EC:		; DOS -	GET DISK TRANSFER AREA ADDRESS
int	21h		; Return: ES:BX	-> DTA

loc_140EE:		; Add
add	bx, 16h

loc_140F1:
mov	[bp+var_4], bx

loc_140F4:
mov	bx, es
mov	[bp+var_2], bx
push	ds
mov	ah, 4Eh
mov	cx, 0
mov	dx, [bp+arg_0]
int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive, path,	and wildcards allowed)
pop	ds
mov	ax, [bp+var_2]

loc_14108:
mov	es, ax
mov	di, [bp+var_4]
mov	ax, [es:di]
add	di, 2		; Add
mov	dx, [es:di]

loc_14116:
pop	ds
push	ax
push	dx
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	dx
pop	ax

loc_14120:
pop	si
pop	ds
pop	di
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp NoXrefs_DosGetDtaFindFirst



; Attributes: bp-based frame

proc idk_DOS_SelectDisk_s14128 far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	es
push	ds
push	si
push	di
mov	ax, [bp+arg_0]
push	ax
mov	ah, 19h
int	21h		; DOS -	GET DEFAULT DISK NUMBER
pop	dx
push	ax
push	dx
mov	al, dl
mov	ah, 0Eh
int	21h		; DOS -	SELECT DISK
			; DL = new default drive number	(0 = A,	1 = B, etc.)
			; Return: AL = number of logical drives
mov	ah, 19h
int	21h		; DOS -	GET DEFAULT DISK NUMBER
pop	bx
pop	dx
cmp	al, bl		; Compare Two Operands
jnz	short loc_14150	; Jump if Not Zero (ZF=0)
mov	bx, 0FFFFh
jmp	short loc_14153	; Jump
nop			; No Operation

loc_14150:		; CODE XREF: idk_DOS_SelectDisk_s14128+20j
mov	bx, 0

loc_14153:		; CODE XREF: idk_DOS_SelectDisk_s14128+25j
push	bx
mov	ah, 0Eh
int	21h		; DOS -	SELECT DISK
			; DL = new default drive number	(0 = A,	1 = B, etc.)
			; Return: AL = number of logical drives
pop	ax
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp idk_DOS_SelectDisk_s14128



; Attributes: bp-based frame

proc idk_GetDir_Adrive_s1415F far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds


mov	ah, 19h
int	21h		; DOS -	GET DEFAULT DISK NUMBER


mov	si, [bp+arg_0]
add	al, 'A'         ; Add
mov	ah, ':'
mov	[si], ax
add	si, 2		; Add
mov	al, '\'
mov	[si], al
add	si, 1		; Add


mov	dx, 0		; ? odd	that it	hard-codes "A:",
			;  but sets drive to default ?
mov	ah, 47h
int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default, 1=A, etc.)
			; DS:SI	points to 64-byte buffer area
xor	ah, ah		; Logical Exclusive OR
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_GetDir_Adrive_s1415F

ends seg003


; Segment type:	Pure code
segment	seg004 byte public 'CODE' use16
assume cs:seg004
;org 0Ch
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; char *argFileName,char *argDestination
; Return
;   -1 SUCCESS
;    0 FAILURE
; Sets FLAG_w3609E = 0,	while its working
;
; Attributes: bp-based frame

; int __cdecl __far f040101_DosFindFile(char *argCharPtrFileName, char *argCharPtrDestinationBuffer)
proc _f040101_DosFindFile far
			; CODE XREF: _f010109_main+16P
			; _f010109_main+20EP
			; _f010309_RUN+10P
			; _f010509_MainMenuScreen+11CP
			; sub_17671+58P
			; ST_ScreenDump+C4P
			; sub_3CFC0+C8P
			; ST_MagicSet_ReadCreateWrite+10P
			; sub_3DBA6+214P
			; sub_3E1DE+123P

varDosDtaPspAsciizFileNameAddr=	word ptr -4
varDTA_ES= word	ptr -2
argCharPtrFileName= dword ptr  6
argCharPtrDestinationBuffer= dword ptr	0Ah

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	es
push	di
push	ds
push	si


push	ds
call	Disable_Set_FLAG_Mouse_Skip ;
			;
mov	ah, 2Fh
int	21h		; DOS -	GET DISK TRANSFER AREA ADDRESS
			; Return: ES:BX	-> DTA
			;
			; Function 4Eh	Find First file
			;    Inputs:	  It needs a DTA set.
			;		  DS:DX	= Filespec
			;		  BX	= Attribute
			;    Outputs:	  DTA +	1Eh = Filename + 0 byte
			; Function 4Fh	Find next file
			;    Inputs:	  By function 4Eh or 4Fh pre-initiated DTA
			;    Outputs:	  DTA +	1Eh = Filename + 0 byte
			;
add	bx, BCpp30_DOSH_dosSearchInfo.ds_nameZ ; MS-DOS	PSP DTA	Offset to the ASCIIZ of	the File Name
mov	[bp+varDosDtaPspAsciizFileNameAddr], bx
mov	bx, es
mov	[bp+varDTA_ES],	bx
mov	si, [word ptr bp+argCharPtrFileName]
lodsb			; Load byte at address DS:SI into AL
			; AL = [DS:SI]
cmp	al, 0		; If (AL == 0) Then Set	(ZF = 1)
jz	short FIND_NEXT	; Jump if Zero (ZF=1)

FIND_FIRST:
push	ds
mov	ah, 4Eh		; DOS Function
mov	cx, 0
mov	dx, [word ptr bp+argCharPtrFileName]
int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive, path,	and wildcards allowed)
			; CF clear if successful
pop	ds
jb	short FILE_NOT_FOUND ; Jump if Below (CF=1)

j_FILE_FOUND:		; Jump
jmp	short FILE_FOUND
align 2

FIND_NEXT:		; CODE XREF: _f040101_DosFindFile+25j
mov	ah, 4Fh		; WTF, Mate?
			; Is there a FileName to be had	elsewhere?
int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
			; [DTA]	= data block from
			; last AH = 4Eh/4Fh call
jb	short FILE_NOT_FOUND ; Jump if Below (CF=1)

FILE_FOUND:		; CODE XREF: _f040101_DosFindFile:j_FILE_FOUNDj
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, [word ptr bp+argCharPtrFileName+2]
mov	si, [bp+varDosDtaPspAsciizFileNameAddr]
mov	ax, [bp+varDTA_ES]
mov	ds, ax		; ?";setting up	stack"?

ASCIIZ_COPY_SI_TO_DI:	; CODE XREF: _f040101_DosFindFile+51j
lodsb			; Load byte at address DS:SI into AL
			; AL = [DS:SI]
stosb			; Store	  byte in AL at	address	ES:DI
			; [ES:DI] = AL
cmp	al, 0		; If (AL == 0) Then Set	(ZF = 1)
jnz	short ASCIIZ_COPY_SI_TO_DI ; Jump if Not Zero (ZF=0)

RET_FILE_FOUND:		; ?set the EOF flag?
mov	ax, -1
pop	ds		; ?restore regs?
push	ax
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	ax


pop	si
pop	ds
pop	di
pop	es
assume es:nothing
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

FILE_NOT_FOUND:		; CODE XREF: _f040101_DosFindFile+33j
			; _f040101_DosFindFile+3Cj
mov	al, 0
mov	si, [word ptr bp+argCharPtrFileName+2]
mov	[si], al	; set the first	byte of	argPtrFileName to 0
			; AKA empty string
mov	ax, 0
pop	ds
push	ax
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	ax
pop	si
pop	ds
pop	di
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp _f040101_DosFindFile

byte_1420C db 6, 57h, 1Eh, 56h,	0BAh, 2	dup(0),	0B4h
db 36h,	0CDh, 21h, 3Dh,	2 dup(0FFh), 74h
db 7, 0F7h, 0E1h, 0F7h,	0E3h, 0EBh, 7, 90h
db 0BAh, 2 dup(0FFh), 0B8h, 2 dup(0FFh)
db 5Eh,	1Fh, 5Fh, 7, 0CBh
ends seg004


; Segment type:	Pure code
segment	seg005 byte public 'CODE' use16
assume cs:seg005
;org 0Eh
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: noreturn bp-based	frame

proc ST_ExitWithMemDiag	far
			; CODE XREF: _f010109_main+3C5P
			; IfDebugExitWithMemDiag:loc_1DB50P

varPtrCharArr= byte ptr	-92h
varPrintString=	byte ptr -7Eh
varHeapMemAvail= word ptr -6
varLargest4bytePageBlock= word ptr -4
varCountOf4bytePages= word ptr -2

push	bp
mov	bp, sp

loc_14231:		; argSrc
sub	sp, 146
call	ST_GetDosMemAvail_KB ; DOS - Allocate Memory
			; Return:
			;   BX = size of largest available block
			;   mov	    ax,	bx
			;   shr	    ax,	1	    ; Divide by	2?
			;   shr	    ax,	1	    ; Divide by	4?
			;   shr	    ax,	1	    ; Divide by	8?
			;   shr	    ax,	1	    ; Divide by	16?
			;   shr	    ax,	1	    ; Divide by	32?
			;   shr	    ax,	1	    ; Divide by	64? (e.g. 1024 / 64 = 16)
mov	[bp+varCountOf4bytePages], ax ;	Number of 64k Blocks?
mov	ax, [ptrWorstFreeKb]
mov	[bp+varLargest4bytePageBlock], ax
call	_coreleft	; returns amount of available heap memory
mov	[bp+varHeapMemAvail], ax
mov	ax, offset aData ; "Data"
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset aFree ; " Free: "
push	ax		; source
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; destination (argDst)
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, 10
push	ax		; radix	conversion base
lea	ax, [bp+varPtrCharArr] ; Load Effective	Address
push	ax		; character array pointer
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+varHeapMemAvail] ; value
call	_ltoa		; char *LtoA(long value, char ^string, int radix)
			;   converts value to a	null-terminated	string and stores the result in	string
			; Parameters:
			;   value   long integer to be converted
			;   string  pointer to character array
			;   radix   the	base to	be used	in converting
			; Return:
			;   LtoA returns a pointer to string.
			;
add	sp, 8		; Add
lea	ax, [bp+varPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aBytesMemory	; " bytes   Memory"
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aFree ; " Free: "
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+varCountOf4bytePages] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+varPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aKWorst ; "k	  Worst"
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aFree ; " Free: "
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+varLargest4bytePageBlock] ;	argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+varPtrCharArr] ; Load Effective	Address
push	ax		; argSrc
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aKEmm ; "k	EMM: "
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[ST_HeapBase]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+varPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aBlocks ; " blocks"
push	ax
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varPrintString]	; Load Effective Address
push	ax		; arg0_PrintString
nop			; No Operation
push	cs
call	near ptr _f050207_EXIT_CleanUp ; Call Procedure
pop	cx
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_ExitWithMemDiag



; Attributes: noreturn bp-based	frame

; int __cdecl __far f050207_EXIT_CleanUp(char *arg0_PrintString)
proc _f050207_EXIT_CleanUp far
			; CODE XREF: _f010109_main+25P
			; _f010309_RUN+1FP
			; _f010309_RUN+D5P
			; ST_ExitWithMemDiag+12Fp
			; ST_execl_WizardsExe:loc_14468p
			; EXIT_AllocationError:loc_14863P
			; MemBlocksErrorExit+5BP
			; MemBlocksErrorExit:loc_14DFEP
			; LBX_Load_ErrorHandler+194P
			; idk_Setup_EMM+D2P
			; idk_Setup_EMM+15AP
			; idk_Setup_EMM:loc_165DBP
			; EMM_Allocate+15AP
			; EMM_Allocate+22CP
			; sub_17BB8+A7P
			; idk_Arg_0Fail_ElseMathyDiSi:loc_1CC96P
			; ST_SoundErrorHandler+ABP

arg0_PrintString= word ptr  6

push	bp
mov	bp, sp
call	AIL_someSequence ; Call	Procedure
call	DOS_MouseReset	; Call Procedure
call	Call_AIL_shutdown ; mov	    word_36A90,	0FFFFh
			; mov	  word_36A92, 0FFFFh
			; mov	  word_36A8E, 0
call	Chk_RelMemHandle ; Call	Procedure
call	idk_PushPop_EsDsSiDi ;
			; push	  es
			; push	  ds
			; push	  si
			; push	  di
			; pop	  di
			; pop	  si
			; pop	  ds
			; pop	  es
call	ST_SetVideoMode_TEXT ; Call Procedure
push	[bp+arg0_PrintString] ;	arg0_PrintString
call	_f060206_DOS_PrintAndExit ; Call Procedure
db  59h	; Y
db  5Dh	; ]
db 0CBh	; 
endp _f050207_EXIT_CleanUp



; Attributes: noreturn bp-based	frame

proc idk_CleanupPrintExit_s14391 far

arg0_PrintString= byte ptr -0Ah
argNumber= word	ptr  6

push	bp
mov	bp, sp
sub	sp, 0Ah		; argConversionBase
mov	ax, 0Ah
push	ax
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
call	AIL_someSequence ; Call	Procedure
call	DOS_MouseReset	; Call Procedure
call	Call_AIL_shutdown ; Call Procedure
call	Chk_RelMemHandle ; Call	Procedure
call	idk_PushPop_EsDsSiDi ; Call Procedure
call	ST_SetVideoMode_TEXT ; Call Procedure
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; arg0_PrintString
call	_f060206_DOS_PrintAndExit ; Call Procedure
db  59h	; Y
db  8Bh	; 
db 0E5h	; 
db  5Dh	; ]
db 0CBh	; 
endp idk_CleanupPrintExit_s14391



; Attributes: noreturn bp-based	frame

; int __fastcall __far ST_execl_WizardsExe(int,	int, int, int argExeFileName, char *arg0, int)
proc ST_execl_WizardsExe far
			; CODE XREF: sub_3DB5F+3CP

arg0_PrintString= byte ptr -52h
filehandle= word ptr -2
arg0= word ptr	6
argExeFileName=	word ptr  0Ch

push	bp
mov	bp, sp
sub	sp, 52h		; Integer Subtraction
push	si		; argSrc
mov	si, [bp+arg0]
call	AIL_someSequence ; Call	Procedure
call	sub_1E4E2	; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_143F8	; Jump if Not Zero (ZF=0)

loc_143EE:		; Call Procedure
call	sub_1E525
call	sub_2E303	; Call Procedure

loc_143F8:		; CODE XREF: ST_execl_WizardsExe+16j
call	DOS_MouseReset	; Call Procedure
call	Call_AIL_shutdown ; Call Procedure
call	_fcloseall	; Call Procedure
mov	[bp+filehandle], 5
jmp	short loc_14418	; Jump

loc_1440E:		; CODE XREF: ST_execl_WizardsExe+46j
mov	ah, 3Eh
mov	bx, [bp+filehandle]
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
inc	[bp+filehandle]	; Increment by 1

loc_14418:		; CODE XREF: ST_execl_WizardsExe+36j
cmp	[bp+filehandle], BCpp30_DOSH_dosSearchInfo.ds_nameZ ; Compare Two Operands
jl	short loc_1440E	; Jump if Less (SF!=OF)

loc_1441E:		; Call Procedure
call	EMM_LoopRelease
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+argExeFileName]
push	[word ptr bp+0Ah]
push	[bp+arg0+2]	; arg0
push	si
push	si		; path
call	_execl		; Call Procedure
add	sp, 0Ch		; Add
mov	ax, offset aErrorGameFile ; "Error- game file "
push	ax
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
push	si
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aCouldNotBeFoun ; " could not be found"
push	ax
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; arg0_PrintString
push	cs

loc_14468:		; Call Procedure
call	near ptr _f050207_EXIT_CleanUp
pop	cx
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_execl_WizardsExe



; Attributes: bp-based frame

proc ST_UpdateWorstFreeKb far
			; CODE XREF: ST_AllocateSpace+90P
			; ST_FarMalloc+3CP
			; malloc_s14954+3CP
			; LBX_Load_Entry:loc_15443P
			; LBX_Load_s15453:loc_1590BP
			; LBX_Load_HelpNewTerrCity:loc_15C3FP
push	bp
mov	bp, sp
push	si
call	ST_GetDosMemAvail_KB ; DOS - Allocate Memory
			; Return:
			;   BX = size of largest available block
			;   mov	    ax,	bx
			;   shr	    ax,	1	    ; Divide by	2?
			;   shr	    ax,	1	    ; Divide by	4?
			;   shr	    ax,	1	    ; Divide by	8?
			;   shr	    ax,	1	    ; Divide by	16?
			;   shr	    ax,	1	    ; Divide by	32?
			;   shr	    ax,	1	    ; Divide by	64? (e.g. 1024 / 64 = 16)
mov	si, ax
cmp	si, [ptrWorstFreeKb] ; (si - worst_free_kb)
			;
			; cmp ax,cx ~= sub ax,cx
			;
			; Compares the first source operand with the second source operand
			;  and sets the	status flags in	the FLAGS register according to	the results.
			; The comparison is performed by subtracting the second	operand	from the first operand
			;  and then setting the	status flags in	the same manner	as the SUB instruction.
			; The CF, OF, SF, ZF, AF, and PF flags are set according to the	result.
			;
			; Effects on the Flags
			; Assume result	= op1 -	op2
			; CF - 1 if unsigned op2 > unsigned op1
			; OF - 1 if sign bit of	OP1 != sign bit	of result
			; SF - 1 if MSB	(aka sign bit) of result = 1
			; ZF - 1 if Result = 0 (i.e. op1=op2)
			; AF - 1 if Carry in the low nibble of result
			; PF - 1 if Parity of Least significant	byte is	even
			;
jnb	short CURRENT_NOT_WORSE	; Jump if Not Below (CF=0)
			;
			; op1 >	op2
			;
			; si > worst_free_kb
			;
			; i.e.,
			; The current largest available	block of memory, in 4-byte units,
			;  is greater than
			;  whatever is stored in worst_free_kb
			;
			;

New_Worst_Free_Kb:
mov	[ptrWorstFreeKb], si

CURRENT_NOT_WORSE:	; CODE XREF: ST_UpdateWorstFreeKb+Fj
pop	si
pop	bp
retf			; Return Far from Procedure
endp ST_UpdateWorstFreeKb



; Attributes: noreturn bp-based	frame

; int __cdecl __far idk_Cleanup_PrintFileTextMode_Exit_s14489()
proc idk_Cleanup_PrintFileTextMode_Exit_s14489 far
push	bp
mov	bp, sp
sub	sp, 72h		; Integer Subtraction
push	si
push	di


call	AIL_someSequence ; Call	Procedure
call	DOS_MouseReset	; Call Procedure
call	Call_AIL_shutdown ; Call Procedure
call	Chk_RelMemHandle ; Call	Procedure
call	idk_PushPop_EsDsSiDi ; Call Procedure
call	ST_SetVideoMode_TEXT ; Call Procedure


push	[word ptr bp+6]	; argFileName
call	DOS_FindFirst	; char *argFileName {AX	= FileSize DX =	FileName}
pop	cx


mov	[bp-2],	dx
mov	[bp-4],	ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 52h	; 'R'
push	ax
push	dx
push	[word ptr bp-2]
push	[word ptr bp-4]	; argPtrFileStream
call	LDIV@		; xor	  cx, cx
			; jmp	  short	loc_1064E
mov	[bp-6],	ax
mov	ax, offset strRBr5 ; "rb"
push	ax
push	[word ptr bp+6]	; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx


mov	[bp-0Eh], ax
xor	si, si		; Logical Exclusive OR
mov	[word ptr bp-0Ah], 0Fh
mov	[word ptr bp-0Ch], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_14567	; Jump

loc_144F4:		; CODE XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+E1j
push	[word ptr bp-0Eh] ; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp-8]	; Load Effective Address
push	ax		; argPtrReadBuffer
call	_fread		; argPtrReadBuffer,argSize,argNumber,argPtrFileStream
add	sp, 8		; Add
push	[word ptr bp-0Eh] ; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 80
push	ax
lea	ax, [bp-72h]	; Load Effective Address
push	ax		; argPtrReadBuffer
call	_fread		; argPtrReadBuffer,argSize,argNumber,argPtrFileStream
add	sp, 8		; Add
cmp	[byte ptr bp-72h], 10h ; Compare Two Operands
jge	short loc_14539	; Jump if Greater or Equal (SF=OF)

loc_14528:
mov	al, [bp-72h]
cbw			; AL ->	AX (with sign)
mov	[bp-0Ah], ax
mov	al, [bp-71h]
cbw			; AL ->	AX (with sign)
mov	[bp-0Ch], ax
dec	si		; Decrement by 1
jmp	short loc_14565	; Jump

loc_14539:		; CODE XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+9Dj
cmp	[byte ptr bp-72h], 10h ; Compare Two Operands
jnz	short loc_14544	; Jump if Not Zero (ZF=0)
mov	si, 0FFFFh
jmp	short loc_14565	; Jump

loc_14544:		; CODE XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+B4j
cmp	[byte ptr bp-72h], 11h ; Compare Two Operands
jnz	short loc_1454C	; Jump if Not Zero (ZF=0)
jmp	short loc_14565	; Jump

loc_1454C:		; CODE XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+BFj
xor	ax, ax		; AX = 0
push	ax
lea	ax, [bp-72h]	; Load Effective Address
push	ax
push	[word ptr bp-0Ch]
push	[word ptr bp-0Ah]
push	si
push	[word ptr bp-8]
nop			; No Operation
push	cs
call	near ptr idk_OutputText_TextMode ; Call	Procedure
add	sp, 0Ch		; Add

loc_14565:		; CODE XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+AEj
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+B9j
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+C1j
inc	si		; Increment by 1
inc	di		; Increment by 1

loc_14567:		; CODE XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+69j
cmp	di, [bp-6]	; Compare Two Operands
jl	short loc_144F4	; Jump if Less (SF!=OF)

CLRSCR_EXIT:		; argFileStream
push	[word ptr bp-0Eh]
call	_fclose		; FILE *argFileStream
pop	cx
mov	ax, offset strCRLF20 ; "\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r"...
push	ax		; arg0_PrintString
call	_f060206_DOS_PrintAndExit ; Call Procedure
db  59h	; Y
db  5Fh	; _
db  5Eh	; ^
db  8Bh	; 
db 0E5h	; 
db  5Dh	; ]
db 0CBh	; 
endp idk_Cleanup_PrintFileTextMode_Exit_s14489



; ?
;   xor	    ax,	ax
;   push    ax
; arg_0
;   lea	    ax,	[bp-72h]
; push	  ax
; arg_2
;   push    word ptr [bp-0Ch]
; arg_4
;   push    word ptr [bp-0Ah]
; arg_6
;   push    si
; arg_8
;   push    word ptr [bp-8]
; arg_A
;   nop
;   push    cs
; Attributes: bp-based frame

proc idk_OutputText_TextMode far
			; CODE XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+D6p

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
cmp	[bp+arg_A], 0	; Compare Two Operands
jnz	short loc_14598	; Jump if Not Zero (ZF=0)
mov	ax, ds
mov	[bp+arg_A], ax

loc_14598:		; CODE XREF: idk_OutputText_TextMode+Cj
mov	ax, [bp+arg_6]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, [bp+arg_4]	; Add
mov	[bp+var_2], ax
mov	ax, [bp+arg_2]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, [bp+arg_2]	; Add
shl	ax, 1		; Shift	Logical	Left
add	ax, TEXT_MODE_VIDEO_RAM	; Add
mov	es, ax
mov	di, [bp+arg_0]
shl	di, 1		; Shift	Logical	Left
push	ds
mov	si, [bp+arg_8]
mov	bx, [bp+var_2]
mov	ax, [bp+arg_A]
mov	ds, ax

loc_145CB:		; CODE XREF: idk_OutputText_TextMode+4Fj
lodsb			; AX = SI
cmp	al, 0		; ? null terminator ?
jz	short loc_145D6	; Jump if Zero (ZF=1)

loc_145D0:		; Store	String
stosb
mov	al, bl
stosb			; Store	String
jmp	short loc_145CB	; Jump

loc_145D6:		; CODE XREF: idk_OutputText_TextMode+49j
pop	ds
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_OutputText_TextMode

ends seg005


; Segment type:	Pure code
segment	seg006 byte public 'CODE' use16
assume cs:seg006
;org 0Eh
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing



proc ST_SetVideoMode_TEXT far
			; CODE XREF: _f050207_EXIT_CleanUp+1CP
			; idk_CleanupPrintExit_s14391+32P
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+21P
mov	ax, 3		; AH=00h
			; AL=03h, Text Mode, ~80x25
int	10h		; - VIDEO - SET	VIDEO MODE
			; AL = mode
retf			; Return Far from Procedure
endp ST_SetVideoMode_TEXT



; Attributes: noreturn bp-based	frame

; int __cdecl __far f060206_DOS_PrintAndExit(char *arg0_PrintString)
proc _f060206_DOS_PrintAndExit far
			; CODE XREF: _f050207_EXIT_CleanUp+24P
			; idk_CleanupPrintExit_s14391+3BP
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+F0P

arg0_PrintString= dword	ptr  6

push	bp
mov	bp, sp

loc_145E7:
mov	si, [word ptr bp+arg0_PrintString]

LOOP_LoadSB:		; CODE XREF: _f060206_DOS_PrintAndExit+9j
lodsb			; AX = SI
cmp	al, 0		; Compare Two Operands
jnz	short LOOP_LoadSB ; Jump if Not	Zero (ZF=0)
dec	si		; Decrement by 1
mov	[byte ptr si], 0Dh ; Carriage Return (CR)(\r)
inc	si		; Increment by 1
mov	[byte ptr si], 0Ah ; Line Feed (LF)(\n)
inc	si		; Increment by 1
mov	[byte ptr si], 0Dh ; Carriage Return (CR)(\r)
inc	si		; Increment by 1
mov	[byte ptr si], 0Ah ; Line Feed (LF)(\n)
inc	si		; Increment by 1
mov	[byte ptr si], '$' ; DOS String Terminator
inc	si		; Increment by 1
mov	dx, [word ptr bp+arg0_PrintString]
mov	ah, 9
int	21h		; DOS -	PRINT STRING
			; DS:DX	-> string terminated by	"$"
mov	ah, 4Ch
int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
			; AL = exit code

loc_1460F:
pop	bp

locret_14610:		; Return Far from Procedure
retf
endp _f060206_DOS_PrintAndExit



; Attributes: bp-based frame

proc sub_14611 far

arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_14614:
mov	si, [bp+arg_0]

loc_14617:		; CODE XREF: sub_14611:loc_1461Aj
lodsb			; Load String

loc_14618:		; Compare Two Operands
cmp	al, 0

loc_1461A:		; Jump if Not Zero (ZF=0)
jnz	short loc_14617

loc_1461C:		; Decrement by 1
dec	si

loc_1461D:
mov	[byte ptr si], 0Dh

loc_14620:		; Increment by 1
inc	si

loc_14621:
mov	[byte ptr si], 0Ah
inc	si		; Increment by 1

loc_14625:
mov	[byte ptr si], 0Dh

loc_14628:		; Increment by 1
inc	si
mov	[byte ptr si], 0Ah

loc_1462C:		; Increment by 1
inc	si

loc_1462D:
mov	[byte ptr si], 24h ; '$'

loc_14630:		; Increment by 1
inc	si

loc_14631:
mov	dx, [bp+arg_0]

loc_14634:
mov	ah, 9

loc_14636:		; DOS -	PRINT STRING
int	21h		; DS:DX	-> string terminated by	"$"

loc_14638:
pop	bp

locret_14639:		; Return Far from Procedure
retf
endp sub_14611



; DOS -	Allocate Memory
; Return:
;   BX = size of largest available block
;   mov	    ax,	bx
;   shr	    ax,	1	    ; Divide by	2?
;   shr	    ax,	1	    ; Divide by	4?
;   shr	    ax,	1	    ; Divide by	8?
;   shr	    ax,	1	    ; Divide by	16?
;   shr	    ax,	1	    ; Divide by	32?
;   shr	    ax,	1	    ; Divide by	64? (e.g. 1024 / 64 = 16)

proc ST_GetDosMemAvail_KB far
			; CODE XREF: ST_ExitWithMemDiag+7P
			; ST_UpdateWorstFreeKb+4P
push	es
push	ds
push	si
push	di
mov	ah, 48h
mov	bx, 0FFFFh	; Requesting 65,535 paragraphs of memory will always fail
			;  and indicates that the intent is only
			;  to get the size of the largest available memory block.
			;
			; MS-DOS
			; -"paragraph" is 16 bytes
			; --AKA	"block"
			;
			; 65535	* 16 = 1MB
			; (1MB is the limit of the 80x86 20 line address bus)
			;
			;
			;
int	21h		; DOS -	2+ - ALLOCATE MEMORY
			;   BX = number	of 16-byte paragraphs desired
			; Return:
			;   CF clear if	successful
			;   AX = segment of allocated block
			;   CF set on error
			;   AX = error code
			;   BX = size of largest available block
			;
			;
			;

loc_14645:
mov	ax, bx
shr	ax, 1		; Divide by 2?
shr	ax, 1		; Divide by 4?
shr	ax, 1		; Divide by 8?

loc_1464D:		; Divide by 16?
shr	ax, 1
shr	ax, 1		; Divide by 32?
shr	ax, 1		; Divide by 64?	(e.g. 1024 / 64	= 16)
pop	di

loc_14654:
pop	si
pop	ds

loc_14656:
pop	es
retf			; Return Far from Procedure
endp ST_GetDosMemAvail_KB




proc idk_PushPopEsDsSiDiRetF far
			; CODE XREF: Load_Fonts_SndDrv+7P
			; idk_Load_FntSty_SndDrv_Mos+7P
push	es
push	ds

loc_1465A:
push	si
push	di

loc_1465C:
pop	di
pop	si

loc_1465E:
pop	ds
pop	es

locret_14660:		; Return Far from Procedure
retf
endp idk_PushPopEsDsSiDiRetF




proc idk_PushPop_EsDsSiDi far
			; CODE XREF: _f050207_EXIT_CleanUp+17P
			; idk_CleanupPrintExit_s14391+2DP
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+1CP
push	es
push	ds
push	si

loc_14664:
push	di
pop	di

loc_14666:
pop	si
pop	ds

loc_14668:
pop	es
retf			; Return Far from Procedure
endp idk_PushPop_EsDsSiDi

ends seg006


; Segment type:	Pure code
segment	seg007 byte public 'CODE' use16
assume cs:seg007
;org 0Ah
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_1466A far

arg_0= word ptr	 6

push	bp

loc_1466B:
mov	bp, sp

loc_1466D:
push	si

loc_1466E:
push	di

loc_1466F:
push	es

loc_14670:
push	ds

loc_14671:
mov	bx, [bp+arg_0]

loc_14674:		; Increment by 1
inc	bx

loc_14675:
mov	ah, 48h

loc_14677:		; DOS -	2+ - ALLOCATE MEMORY
int	21h		; BX = number of 16-byte paragraphs desired

loc_14679:		; Jump if Below	(CF=1)
jb	short loc_14699

loc_1467B:
mov	es, ax

loc_1467D:
mov	di, 0

loc_14680:
mov	ax, 12FAh

loc_14683:		; Store	String
stosw

loc_14684:
mov	ax, 4ECFh
stosw			; Store	String

loc_14688:
mov	ax, [bp+arg_0]

loc_1468B:		; Increment by 1
inc	ax

loc_1468C:		; Store	String
stosw

loc_1468D:
mov	ax, 1

loc_14690:		; Store	String
stosw

loc_14691:
mov	ax, es

loc_14693:
pop	ds
pop	es
pop	di
pop	si

loc_14697:
pop	bp

locret_14698:		; Return Far from Procedure
retf

loc_14699:		; CODE XREF: sub_1466A:loc_14679j
mov	ax, 0

loc_1469C:
pop	ds

loc_1469D:
pop	es

loc_1469E:
pop	di

loc_1469F:
pop	si

loc_146A0:
pop	bp

locret_146A1:		; Return Far from Procedure
retf
endp sub_1466A



; Attributes: bp-based frame

proc sub_146A2 far

arg_0= word ptr	 6

; FUNCTION CHUNK AT 0058 SIZE 00000009 BYTES

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	bx, [bp+arg_0]
mov	ah, 48h
int	21h		; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
jb	short loc_146B8	; Jump if Below	(CF=1)

loc_146B2:
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_146A2

; START	OF FUNCTION CHUNK FOR sub_146A2

loc_146B8:		; CODE XREF: sub_146A2+Ej
mov	ax, 0
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
; END OF FUNCTION CHUNK	FOR sub_146A2


; Attributes: bp-based frame

proc sub_146C1 far

arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_146C4:
push	si

loc_146C5:
push	di

loc_146C6:
push	es

loc_146C7:
mov	bx, [bp+arg_0]

loc_146CA:		; Decrement by 1
dec	bx

loc_146CB:
mov	es, bx

loc_146CD:
mov	bx, 0

loc_146D0:
mov	[word ptr es:bx], 0
mov	ah, 49h
int	21h		; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
pop	es

loc_146DA:
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_146C1



; 12FA or 4ECF
;
; Attributes: bp-based frame

; int __cdecl __far ST_Chk_12FA_4ECF(int argPtrBuffer)
proc ST_Chk_12FA_4ECF far
			; CODE XREF: idk_Mem_StoSW_s149FA+2AP
			; sub_14AF8+14P
			; LBX_Load_Entry+2A1P
			; LBX_Load_Entry+310P
			; LBX_Load_s15453+353P
			; LBX_Load_s15453+3C2P
			; LBX_EmsMapMem+17CP
			; LBX_EmsMapMem+1C3P
			; LBX_s16F45+B7P
			; LBX_s16F45+120P
			; idk_PreEmmPgCnt+19CP
			; idk_PreEmmPgCnt+1E4P

argPtrBuffer= word ptr	6

push	bp
mov	bp, sp
push	ds
push	si
mov	ax, [bp+argPtrBuffer] ;
			; Blarg! IDGI.
			; Sometimes this is a 'push word ptr',
			;  others 'push SI',
			;  and a few 'if ... push 0 or push 1'
			;
mov	ds, ax
mov	si, 4		; ?offset at 4?
lodsw			; AX = DS:SI
cmp	ax, 12FAh	; ? FLC	files have a MagSig of AF12 ?
jnz	short Is_12FA_4ECF ; Jump if Not Zero (ZF=0)

loc_146F1:		; AX = DS:SI
lodsw
cmp	ax, 4ECFh	;
			; ?
			; coincidence
			; 20175	/ 4858 = 4
			; ?
			;
jnz	short Is_12FA_4ECF ; Jump if Not Zero (ZF=0)

Not_12FA_4ECF:
mov	ax, 0FFFFh
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure

Is_12FA_4ECF:		; CODE XREF: ST_Chk_12FA_4ECF+11j
			; ST_Chk_12FA_4ECF+17j
mov	ax, 0
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp ST_Chk_12FA_4ECF



; Attributes: bp-based frame

proc idk_LODSB_Arg2_Arg1 far
			; CODE XREF: sub_19454:loc_19467P
			; sub_19454:loc_1947FP
			; sub_19454:loc_19491P
			; sub_19454+4FP
			; sub_19454+61P
			; sub_19958+16P
			; sub_19958+1C3P
			; sub_19D2A:loc_19D35P
			; sub_19D51+BP
			; sub_19F94+7DP
			; sub_19F94:loc_1A068P
			; sub_1A0DC:loc_1A0F2P
			; sub_1A0DC:loc_1A272P
			; sub_1A542+EP
			; sub_1A5F1+16P
			; sub_1A5F1+1E4P
			; sub_1B341+26P
			; sub_1B341+38P
			; sub_1B654+36P
			; sub_1B654+48P
			; sub_1B654+5AP
			; sub_1B984+12P
			; sub_1BC1A+18P
			; sub_1BC1A:loc_1BC52P
			; sub_1BF79+34P
			; sub_1BF79+46P
			; sub_1BF79+56P
			; sub_1BF79+63P
			; sub_1BFF7+56P
			; sub_1BFF7+68P
			; sub_1BFF7:loc_1C06FP
			; sub_1BFF7+85P
			; sub_1F8FD+76P
			; idk_VidLib_s1FBBF+12P
			; sub_21C86:loc_21C96P
			; sub_21C86+27P
			; sub_21C86+38P

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	ds
push	si
mov	si, [bp+arg_2]
mov	ax, [bp+arg_0]
mov	ds, ax
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp idk_LODSB_Arg2_Arg1



; Attributes: bp-based frame

; int __cdecl __far ST_Read_2B_From_Buffer_At_Offset(char *argOffset, char *argPtrSrcBuf)
proc ST_Read_2B_From_Buffer_At_Offset far
			; CODE XREF: idk_LoadSw10_StoreSw14+FP
			; idk_LoadSw14_StoreSw10+FP
			; idk_Mem_StoSW_s149FA+1DP
			; sub_14AC3+15P
			; sub_14AF8+51P
			; sub_14AF8+62P
			; fncSub2ndW1stW+FP
			; fncSub2ndW1stW+1CP
			; LBX_Load_Entry+19EP
			; LBX_Load_Entry+1BFP
			; LBX_Load_Entry+2C0P
			; LBX_Load_Entry+2D4P
			; LBX_Load_Entry+35AP
			; LBX_Load_Entry+370P
			; LBX_Load_s15453+196P
			; LBX_Load_s15453+1B7P
			; LBX_Load_s15453+372P
			; LBX_Load_s15453+386P
			; LBX_Load_s15453+40CP
			; LBX_Load_s15453+422P
			; LBX_Load_HelpNewTerrCity+17BP
			; LBX_Load_HelpNewTerrCity+19CP
			; LBX_Load_Entry_4bytes+17FP
			; LBX_Load_Entry_4bytes+1A0P
			; LBX_EmsMapMem+18EP
			; LBX_EmsMapMem+1E4P
			; LBX_EmsMapMem+1F6P
			; LBX_s16F45+D8P
			; LBX_s16F45+163P
			; LBX_s16F45+175P
			; idk_PreEmmPgCnt+1AEP
			; idk_PreEmmPgCnt+205P
			; idk_PreEmmPgCnt+218P
			; sub_19316:loc_19321P
			; ILSe_display_text+107P
			; sub_19D78+25P
			; sub_1A296+25P
			; sub_1A542+1EP
			; sub_1A7FF+102P
			; sub_1BB5F+14P
			; sub_1BB5F+25P
			; sub_1BBF9+EP
			; sub_1EE71:loc_1EE7FP
			; sub_1EE71:loc_1EE8CP
			; sub_1EF3C+EP
			; sub_1EF3C:loc_1EF5BP
			; sub_1F13F+EP
			; sub_1F13F+1FP
			; sub_1F290+EP
			; sub_1F290+1FP
			; sub_1F47D+EP
			; sub_1F47D:loc_1F49CP
			; sub_1F51B+EP
			; sub_1F51B+1FP
			; sub_1F5BF+EP
			; sub_1F5BF+1FP
			; sub_1FA6E+1AP
			; sub_1FA6E:loc_1FA97P
			; sub_1FAEB+AP
			; seg028:0C9AP
			; sub_1FB15:loc_1FB1EP
			; sub_1FB29:loc_1FB33P
			; seg028:0CDDP
			; seg028:0CECP
			; sub_20C7A+11P
			; sub_20C7A:loc_20C9CP
			; sub_20C7A:loc_20CACP
			; sub_21014+FP
			; sub_21014+1BP
			; idk_VidLib_s2104D+27P
			; idk_VidLib_s2104D:loc_21085P
			; sub_2117A+EP
			; sub_2117A+1FP
			; sub_2117A+46P
			; sub_2117A+65P
			; sub_2117A:loc_21298P
			; sub_2117A+138P
			; sub_212E2+EP
			; sub_212E2+1FP
			; sub_212E2+46P
			; sub_212E2:loc_21347P
			; sub_212E2+11EP
			; sub_212E2:loc_2141AP
			; sub_2144A+EP
			; sub_2144A+1FP
			; sub_214B0+11P
			; sub_214B0:loc_214D2P
			; sub_215D8+EP
			; sub_215D8:loc_215F7P
			; sub_21829:loc_2183DP
			; sub_21829:loc_2184EP
			; LBX_Load_IntroLbx_s21977+10P
			; LBX_Load_IntroLbx_s21977+26P
			; LBX_Load_IntroLbx_s21977+39P
			; LBX_Load_IntroLbx_s21977+5CP
			; sub_21C58+BP
			; sub_21C86+4FP
			; sub_21D2E+EP
			; sub_21D2E+1FP
			; sub_21E08+EP
			; sub_21E08+1FP
			; sub_21EEA+EP
			; sub_21EEA:loc_21F09P
			; sub_21F59+EP
			; sub_21F59+1FP
			; sub_220AA+14P
			; sub_220AA:loc_220CFP
			; ST_LoadSound+2DP
			; ST_LoadSound+55P
			; ST_LoadSound+1E0P
			; ST_LoadSound+275P
			; ST_LoadSound+29DP
			; ST_LoadSound+2E5P
			; sub_50203+11P
			; sub_50203+22P

argOffset= dword ptr  6
argPtrSrcBuf= dword ptr	 0Ah

push	bp
mov	bp, sp
push	ds
push	si		;
			;
			;
			;
mov	si, [word ptr bp+argOffset+2] ;	FIXME(JWB): ? this should be argPtrSrcBuf
mov	ax, [word ptr bp+argOffset]
mov	ds, ax
lodsw			; Load word at address DS:SI into AX
			;
			; AX = DS:[SI];	SI = SI	+/- 2;
			;
			; NOTE:
			; The segment register can be overriden
			;  with	a segment prefix,
			;  as LODS ES:DATA4
			;
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp ST_Read_2B_From_Buffer_At_Offset



;
; Return:
;   Word 1: AX
;   Word 2: DX
; Attributes: bp-based frame

proc ST_Read_4B_From_Buffer_At_Offset far
			; CODE XREF: LBX_Load_Entry+1F0P
			; LBX_Load_Entry+208P
			; LBX_Load_s15453+1E8P
			; LBX_Load_s15453+200P
			; LBX_Load_HelpNewTerrCity+1CDP
			; LBX_Load_HelpNewTerrCity+1E5P
			; LBX_Load_Entry_4bytes+1D1P
			; LBX_Load_Entry_4bytes+1EBP

argOffset= word	ptr  6
argSrc=	word ptr  8

push	bp
mov	bp, sp
push	ds
push	si
mov	si, [bp+argSrc]
mov	ax, [bp+argOffset]
mov	ds, ax
lodsw			; AX = SI
mov	bx, ax
lodsw			; AX = SI
mov	dx, ax
mov	ax, bx
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp ST_Read_4B_From_Buffer_At_Offset



; Store	AX in word ES:DI, update DI
; ES = argSegment
; DI = argOffset
; AX = argValue
; Attributes: bp-based frame

proc fncStoSB far	; CODE XREF: LBX_s16F45+1CFP
			; LBX_s16F45+1DFP
			; LBX_Load_FontsStyleData+99P
			; LBX_Load_FontsStyleData+B5P
			; sub_1922A+23P
			; sub_19257:loc_1927AP
			; sub_19284:loc_192A7P
			; sub_192B1:loc_192D4P
			; sub_192DE:loc_19301P
			; sub_1933E+EP
			; sub_19399+23P
			; sub_193DD:loc_193FDP
			; sub_193DD:loc_19413P
			; sub_193DD+47P
			; sub_193DD+58P
			; sub_193DD:loc_19446P
			; sub_194C2:loc_194DBP
			; sub_194C2+33P
			; sub_194C2+48P
			; sub_194C2:loc_1951FP
			; sub_194C2:loc_19534P
			; sub_19958+3BP
			; sub_19D78+4BP
			; sub_1A0DC+3BP
			; sub_1A5F1+3BP
			; idk_Set_FontsLbx1_256arr_to_1+12P
			; idk_Set_FontsLbx1_256arr_to_0+11P
			; sub_1C40F+68P
			; sub_1C40F:loc_1C48BP
			; sub_1C40F:loc_1C4A1P
			; sub_21D16+EP

argSegment= word ptr  6
argOffset= word	ptr  8
argValue= word ptr  0Ah

push	bp
mov	bp, sp
push	es
push	di
mov	ax, [bp+argSegment]
mov	es, ax
mov	di, [bp+argOffset]
mov	ax, [bp+argValue]
stosb			; Store	String
pop	di
pop	es
pop	bp
retf			; Return Far from Procedure
endp fncStoSB



; Attributes: bp-based frame

; int __cdecl __far fncStoSW(int argSegment, int argOffset, int	argValue)
proc fncStoSW far	; CODE XREF: ST_AllocateSpace+52P
			; ST_AllocateSpace+65P
			; ST_AllocateSpace+75P
			; ST_AllocateSpace+88P
			; idk_LoadSw10_StoreSw14+21P
			; idk_LoadSw14_StoreSw10+21P
			; idk_Mem_StoSW_s149FA+61P
			; idk_Mem_StoSW_s149FA+72P
			; idk_Mem_StoSW_s149FA+83P
			; idk_Mem_StoSW_s149FA+94P
			; idk_Mem_StoSW_s149FA+A5P
			; idk_Mem_StoSW_s149FA+B6P
			; sub_14AC3+28P
			; sub_14AF8+71P
			; sub_14AF8+84P
			; sub_14AF8+97P
			; sub_14AF8+AAP
			; sub_14AF8+BDP
			; LBX_Load_Entry+303P
			; LBX_Load_s15453+3B5P
			; LBX_EmsMapMem+1ADP
			; LBX_s16F45+10AP
			; LBX_s16F45+1EFP
			; idk_PreEmmPgCnt+1CEP
			; sub_17A50+4CP
			; sub_17A50+5DP
			; sub_17A50+6EP
			; sub_17A50+7FP
			; sub_17A50:loc_17AE0P
			; sub_17AFA+4AP
			; sub_17AFA+5BP
			; sub_17AFA+6CP
			; sub_17AFA+7DP
			; sub_17AFA+8EP
			; sub_19316+1EP
			; sub_19356+EP
			; sub_1936E+1AP
			; sub_19D78+32P
			; hrmStoreSWSB:loc_1EECAP
			; hrmStoreSWSB:loc_1EEDCP
			; hrmStoreSWSB+37P
			; hrmStoreSWSB:loc_1EF01P
			; hrmStoreSWSB+5BP
			; idk_WriteImageHeader_s1F3F8+12P
			; idk_WriteImageHeader_s1F3F8+24P
			; idk_WriteImageHeader_s1F3F8+37P
			; idk_WriteImageHeader_s1F3F8+49P
			; idk_WriteImageHeader_s1F3F8+5BP
			; sub_1F655+47P
			; idk_VidLib_s1F743+F2P
			; sub_1F8FD+3EP
			; sub_1FA6E+58P
			; sub_1FAD4+DP
			; LBX_Intro_MemAndReadAndMem+58P
			; LBX_Intro_MemAndReadAndMem+6BP
			; LBX_Load_IntroLbx_s21977+4CP
			; sub_21C58+24P
			; ST_LoadSound+210P
			; ST_LoadSound+32DP
			; idk_ResourceLbx+25P

argSegment= word ptr  6
argOffset= word	ptr  8
argValue= word ptr  0Ah

push	bp
mov	bp, sp
push	es
push	di
mov	ax, [bp+argSegment]
mov	es, ax
mov	di, [bp+argOffset]
mov	ax, [bp+argValue]
stosw			; ES:DI	= AX
pop	di
pop	es
pop	bp
retf			; Return Far from Procedure
endp fncStoSW



; Attributes: bp-based frame

proc fncStoSWx2	far

argSegment= word ptr  6
argOffset= word	ptr  8
argValue1= word	ptr  0Ah
argValue2= word	ptr  0Ch

push	bp
mov	bp, sp
push	es
push	di

loc_14773:
mov	ax, [bp+argSegment]

loc_14776:
mov	es, ax

loc_14778:
mov	di, [bp+argOffset]

loc_1477B:
mov	ax, [bp+argValue1]

loc_1477E:		; Store	String
stosw

loc_1477F:
mov	ax, [bp+argValue2]
stosw			; Store	String
pop	di
pop	es
pop	bp

locret_14786:		; Return Far from Procedure
retf
endp fncStoSWx2

ends seg007


; Segment type:	Pure code
segment	seg008 byte public 'CODE' use16
assume cs:seg008
;org 7
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_14787 far	; CODE XREF: idk_OVR_LoadLbxHelp:loc_55D4CP
push	bp

loc_14788:
mov	bp, sp

loc_1478A:
mov	ax, [idk_OVL_w35A64]

loc_1478D:
mov	[idl_OVL_w3B19E], ax
pop	bp
retf			; Return Far from Procedure
endp sub_14787



; Attributes: bp-based frame

proc sub_14792 far	; CODE XREF: idk_OVR_LoadLbxHelp+523P
push	bp
mov	bp, sp
mov	ax, [idl_OVL_w3B19E]
mov	[idk_OVL_w35A64], ax
pop	bp
retf			; Return Far from Procedure
endp sub_14792



; Attributes: bp-based frame

proc sub_1479D far
push	bp

loc_1479E:
mov	bp, sp

loc_147A0:
mov	[idk_OVL_w35A64], 100h

loc_147A6:
mov	[idl_OVL_w3B19E], 100h

loc_147AC:
pop	bp
retf			; Return Far from Procedure
endp sub_1479D



; Attributes: bp-based frame

; int __cdecl __far EMM_CheckAllocation(int arg_0)
proc EMM_CheckAllocation far
			; CODE XREF: LBX_Terrtype_s472C7+CP
			; LBX_Terrtype_s4763F+CP
			; LBX_Terrtype_s48821+CP
			; LBX_Cityname_s4B973+CP
			; idk_OVR_LoadLbxHelp:loc_55D55P
			; sub_56450+87P

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
mov	si, [bp+arg_0]
cmp	si, 1030h	; Compare Two Operands
jbe	short loc_147CA	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_147BB:
mov	ax, si
sub	ax, 1130h	; Integer Subtraction
add	ax, 256		; int
push	ax		; argIntAllocationOverage
nop			; No Operation
push	cs
call	near ptr EXIT_AllocationError ;	Call Procedure
pop	cx

loc_147CA:		; CODE XREF: EMM_CheckAllocation+Bj
mov	ax, si
add	ax, 256		; Add
mov	[idk_OVL_w35A64], ax
mov	ax, si
add	ax, 256		; Add
mov	[idl_OVL_w3B19E], ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
add	ax, 256		; Add
jmp	short $+2	; Jump
pop	si
pop	bp
retf			; Return Far from Procedure
endp EMM_CheckAllocation ; sp-analysis failed



; Attributes: bp-based frame

proc sub_147E5 far	; CODE XREF: sub_56450+94P

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp

loc_147E6:
mov	bp, sp

loc_147E8:		; Integer Subtraction
sub	sp, 2
push	si

loc_147EC:
mov	si, [bp+arg_0]

loc_147EF:
mov	ax, 4400

loc_147F2:		; Integer Subtraction
sub	ax, [idk_OVL_w35A64]
cmp	ax, si		; Compare Two Operands
jnb	short loc_1480A	; Jump if Not Below (CF=0)

loc_147FA:
mov	ax, si

loc_147FC:		; Integer Subtraction
sub	ax, 4400

loc_147FF:		; int
add	ax, [idk_OVL_w35A64]
push	ax		; argIntAllocationOverage
nop			; No Operation
push	cs
call	near ptr EXIT_AllocationError ;	Call Procedure
pop	cx

loc_1480A:		; CODE XREF: sub_147E5+13j
mov	ax, [idk_OVL_w35A64]

loc_1480D:
mov	[bp+var_2], ax

loc_14810:		; Add
add	[idk_OVL_w35A64], si

loc_14814:
mov	ax, offset idk_EmmRsrvExcdErrMsg

loc_14817:		; Add
add	ax, [bp+var_2]
jmp	short $+2	; Jump
pop	si

loc_1481D:
mov	sp, bp

loc_1481F:
pop	bp

locret_14820:		; Return Far from Procedure
retf
endp sub_147E5 ; sp-analysis failed



; Attributes: noreturn bp-based	frame

; int __fastcall __far EXIT_AllocationError(int, int, int, int argIntAllocationOverage)
proc EXIT_AllocationError far
			; CODE XREF: EMM_CheckAllocation+18p
			; sub_147E5+21p

argIntAllocationOverage= word ptr  6

push	bp		; argConversionBase
mov	bp, sp
mov	ax, offset aNearAllocation ; "Near Allocation too large	by "
push	ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx

loc_14832:
pop	cx

loc_14833:
mov	ax, 10
push	ax

loc_14837:
mov	ax, offset idk_ItoAbuf_w3B204

loc_1483A:		; argPtrCharArr
push	ax

loc_1483B:		; argNumber
push	[bp+argIntAllocationOverage]
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add

loc_14846:
mov	ax, offset idk_ItoAbuf_w3B204
push	ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_14855:		; " bytes"
mov	ax, offset argDst
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx

loc_1485F:
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; arg0_PrintString

loc_14863:		; Call Procedure
call	_f050207_EXIT_CleanUp
pop	cx
pop	bp
retf			; Return Far from Procedure
endp EXIT_AllocationError



; Attributes: bp-based frame

proc ST_AllocateSpace far
			; CODE XREF: LBX_Load_FontsStyleData+35P
			; LBX_Load_FontsStyleData+42P
			; LBX_Load_FontsStyleData+58P
			; LBX_Load_FontsStyleData+65P
			; LBX_Load_FontsStyleData+72P
			; LBX_Load_FontsStyleData+7FP
			; hrmLotsOfFarMallocStoreSW+EP
			; hrmLotsOfFarMallocStoreSW+28P
			; hrmLotsOfFarMallocStoreSW+42P
			; hrmLotsOfFarMallocStoreSW:loc_1BE61P
			; sub_25D7A+15P
			; idk_Mouse_s2B8B1+7P
			; ST_LoadSoundDrivers+576P
			; ST_LoadSoundDrivers+5EDP
			; ST_LoadSoundDrivers+622P
			; idk_EmsPgNm_TileFigureCont_s553B0+3FP
			; idk_EmsPgNm_TileFigureCont_s553B0+4CP
			; idk_EmsPgNm_TileFigureCont_s553B0+59P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55416P
			; idk_EmsPgNm_TileFigureCont_s553B0+206P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_555CEP
			; idk_EmsPgNm_TileFigureCont_s553B0+236P
			; idk_EmsPgNm_TileFigureCont_s553B0+24EP
			; idk_EmsPgNm_TileFigureCont_s553B0+266P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5562EP
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55646P
			; idk_EmsPgNm_TileFigureCont_s553B0+2AEP
			; idk_EmsPgNm_TileFigureCont_s553B0+2C6P
			; idk_EmsPgNm_TileFigureCont_s553B0+2DEP
			; idk_EmsPgNm_TileFigureCont_s553B0+2F6P
			; idk_EmsPgNm_TileFigureCont_s553B0+30EP
			; idk_EmsPgNm_TileFigureCont_s553B0+326P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_556EEP
			; idk_EmsPgNm_TileFigureCont_s553B0+356P
			; idk_EmsPgNm_TileFigureCont_s553B0+36EP
			; idk_EmsPgNm_TileFigureCont_s553B0+386P
			; idk_EmsPgNm_TileFigureCont_s553B0+39EP
			; idk_EmsPgNm_TileFigureCont_s553B0+3ABP

varSegment= word ptr -2
arg_NbrBlocks_16byte= word ptr	6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si


mov	si, [bp+arg_NbrBlocks_16byte]
mov	ax, si
xor	dx, dx		; Logical Exclusive OR
mov	cl, 4
call	LXLSH@		; Left-Shift 2^4 (* 16)
add	ax, 16		; ...to	allow for alignment, as	16 byte	"blocks"
adc	dx, 0		; argMemErrorCode
push	dx
push	ax		; nbytes
call	_farmalloc	;
			; void far *__cdecl farmalloc(unsigned __int32 nbytes);
			; Return:
			; DX:AX
			; -address of allocate space on	far heap
			; -NULL	if failure (DX = AX = 0)
			;
pop	cx
pop	cx
mov	[g_FarHeapAllocSegment], dx
mov	[g_FarHeapAllocOffset],	ax
mov	ax, [g_FarHeapAllocOffset]
or	ax, [g_FarHeapAllocSegment] ; Logical Inclusive	OR
jnz	short NOT_NULL	; Jump if Not Zero (ZF=0)

DynamicAllocationTooSmallForAllocateSpace: ; argMemAmount
push	si
mov	ax, enum_MEM_Error_Type_1 ; argMemAmount
push	ax		; argMemErrorCode
nop			; No Operation
push	cs
call	near ptr MemBlocksErrorExit ; Call Procedure
pop	cx
pop	cx

NOT_NULL:		; CODE XREF: ST_AllocateSpace+32j
mov	ax, [g_FarHeapAllocSegment]
inc	ax		; Increment by 1
mov	[bp+varSegment], ax


mov	ax, 12FAh
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
push	[bp+varSegment]	; argSegment
call	fncStoSW	; arg0_DestES
			; arg2_DestDI
			; arg4_SrcStr
add	sp, 6		; Add


mov	ax, 4ECFh
push	ax		; argValue
mov	ax, 6
push	ax		; argOffset
push	[bp+varSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


push	si		; argValue
mov	ax, 8
push	ax		; argOffset
push	[bp+varSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, 1
push	ax		; argValue
mov	ax, 10
push	ax		; argOffset
push	[bp+varSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


call	ST_UpdateWorstFreeKb ; Call Procedure


mov	ax, [bp+varSegment]


jmp	short $+2	; Jump
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_AllocateSpace ;	sp-analysis failed



; Attributes: bp-based frame

; int __cdecl __far ST_FarMalloc(int argKiloBytes)
proc ST_FarMalloc far	; CODE XREF: LBX_Load_Entry+31P
			; LBX_Load_s15453+32P
			; LBX_Load_HelpNewTerrCity+32P
			; LBX_Load_Entry_4bytes+31P

varBytesAllocated= word	ptr -2
argKiloBytes= word ptr	6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
mov	ax, [bp+argKiloBytes]
xor	dx, dx		; Logical Exclusive OR
mov	cl, 4
call	LXLSH@		; Call Procedure
add	ax, 16		; Add
adc	dx, 0		; Add with Carry
push	dx
push	ax		; nbytes
call	_farmalloc	; DX:AX	- segment:offset address of allocated far heap
pop	cx
pop	cx
mov	[g_FarHeapAllocSegment], dx
mov	[g_FarHeapAllocOffset],	ax
mov	ax, [g_FarHeapAllocOffset]
or	ax, [g_FarHeapAllocSegment] ; Logical Inclusive	OR
jnz	short loc_1493F	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR

loc_1493D:		; CODE XREF: ST_FarMalloc+44j
jmp	short loc_14950	; Jump

loc_1493F:		; CODE XREF: ST_FarMalloc+2Fj
mov	ax, [g_FarHeapAllocSegment]
inc	ax		; Increment by 1
mov	[bp+varBytesAllocated],	ax
call	ST_UpdateWorstFreeKb ; Call Procedure
mov	ax, [bp+varBytesAllocated]
jmp	short loc_1493D	; Jump

loc_14950:		; CODE XREF: ST_FarMalloc:loc_1493Dj
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_FarMalloc



; Attributes: bp-based frame

proc malloc_s14954 far	; CODE XREF: LBX_Load_Entry+27EP
			; LBX_Load_s15453+330P
			; LBX_EmsMapMem+169P
			; LBX_s16F45+95P
			; idk_PreEmmPgCnt+186P

varMallocSizeOrStatus= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction

xor	dx,dx
mov	ax,[R2]
;dx:ax = size requested	(long)

mov	ax, [bp+arg_0]
xor	dx, dx		; Logical Exclusive OR


mov	cl, 4
call	LXLSH@		;
			;
			;
			;
add	ax, 16		; ?add a paragraph?
adc	dx, 0		; BORLANDC\CTRL\CLIB\FARHEAP.ASM
			; ;add the header size and
			; ;force paragraph boundary
			;
			;
push	dx
push	ax		; unsigned int32 nbytes
call	_farmalloc	; #include <alloc.h>
			; void far * farmalloc(unsigned	long nbytes);
			; farmalloc allocates a	block of memory	nbytes bytes long from the far heap.
			; farmalloc returns a pointer to the newly allocated block,
			;  or null if not enough space exists for the new block.
			; ...
			; char far *fptr;
			; unsigned long	nbytes;
			; nbytes = 32768;
			; fptr = (char far *) farmalloc(nbytes);
			; ...
			;
pop	cx
pop	cx
mov	[g_FarHeapAllocSegment], dx ;
			; Address of the first byte of user space available
			; from the heap	if successful (dx:ax)
mov	[g_FarHeapAllocOffset],	ax
mov	ax, [g_FarHeapAllocOffset]
or	ax, [g_FarHeapAllocSegment] ; Logical Inclusive	OR
jnz	short loc_14989	; Jump if Not Zero (ZF=0)

@@NoCanDo:		; Logical Exclusive OR
xor	ax, ax

@@AllDone:		; CODE XREF: malloc_s14954+44j
jmp	short @@Exit	; Jump

loc_14989:		; CODE XREF: malloc_s14954+2Fj
mov	ax, [g_FarHeapAllocSegment]
inc	ax		; Increment by 1
mov	[bp+varMallocSizeOrStatus], ax ;
			;
			;
call	ST_UpdateWorstFreeKb ;
			;
			;
mov	ax, [bp+varMallocSizeOrStatus]
jmp	short @@AllDone	; Jump

@@Exit:			; CODE XREF: malloc_s14954:@@AllDonej
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp malloc_s14954



; Attributes: bp-based frame

proc idk_LoadSw10_StoreSw14 far
			; CODE XREF: sub_4F44D+C8P
			; ST_LoadMusicSoundfxIntro+2BP
			; ST_LoadMusicSoundfxIntro+189P
			; ST_LoadMusicSoundfxIntro+1FEP
			; ST_LoadMusicSoundfxIntro+259P
			; ST_LoadMusicSoundfxIntro+2B5P

argValue= word ptr -2
arg0_DestES= dword ptr	6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si		; arg2_SI
mov	si, [word ptr bp+arg0_DestES]
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+argValue], ax
push	[bp+argValue]	; argValue
mov	ax, 14
push	ax		; argOffset
push	si		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_LoadSw10_StoreSw14



; Attributes: bp-based frame

proc idk_LoadSw14_StoreSw10 far
			; CODE XREF: sub_4F44D+35AP
			; ST_LoadMusicSoundfxIntro+17FP
			; ST_LoadMusicSoundfxIntro+1F4P
			; ST_LoadMusicSoundfxIntro+24FP
			; ST_LoadMusicSoundfxIntro+2ABP

argValue= word ptr -2
arg0_DestES= dword ptr	6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si		; arg2_SI
mov	si, [word ptr bp+arg0_DestES]
mov	ax, 14
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+argValue], ax
push	[bp+argValue]	; argValue
mov	ax, 10
push	ax		; argOffset
push	si		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_LoadSw14_StoreSw10



; Attributes: bp-based frame

proc idk_Mem_StoSW_s149FA far
			; CODE XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_55427P
			; idk_OVR_LoadLbxHelp:loc_55D17P
			; sub_56413+17P

var_2= word ptr	-2
arg0_DestES= dword ptr	6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di		; arg2_SI


mov	si, [word ptr bp+arg0_DestES+2]
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax
mov	ax, [word ptr bp+arg0_DestES]
inc	ax		; Increment by 1
mov	di, ax
mov	ax, 8
push	ax
push	[word ptr bp+arg0_DestES] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx


mov	[bp+var_2], ax
push	[word ptr bp+arg0_DestES] ; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx


or	ax, ax		; Logical Inclusive OR
jnz	short loc_14A3A	; Jump if Not Zero (ZF=0)

loc_14A2E:		; argMemAmount
push	si
mov	ax, enum_MEM_Error_Type_3 ; argMemAmount
push	ax		; argMemErrorCode
nop			; No Operation
push	cs
call	near ptr MemBlocksErrorExit ; Call Procedure
pop	cx
pop	cx

loc_14A3A:		; CODE XREF: idk_Mem_StoSW_s149FA+32j
cmp	[bp+var_2], si	; Compare Two Operands
jnb	short loc_14A50	; Jump if Not Below (CF=0)
mov	ax, si
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; argMemAmount
mov	ax, enum_MEM_Error_Type_2 ; argMemAmount
push	ax		; argMemErrorCode
nop			; No Operation
push	cs
call	near ptr MemBlocksErrorExit ; Call Procedure
pop	cx
pop	cx

loc_14A50:		; CODE XREF: idk_Mem_StoSW_s149FA+43j
mov	ax, si
inc	ax		; Increment by 1
push	ax		; argValue
mov	ax, 10
push	ax		; argOffset
push	[word ptr bp+arg0_DestES] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, 12FAh
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, 4ECFh
push	ax		; argValue
mov	ax, 6
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, si
dec	ax		; Decrement by 1
push	ax		; argValue
mov	ax, 8
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, 1
push	ax		; argValue
mov	ax, 10
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, 1
push	ax		; argValue
mov	ax, 14
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, di
inc	ax		; Increment by 1
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_Mem_StoSW_s149FA ; sp-analysis	failed



; Attributes: bp-based frame

proc sub_14AC3 far

var_4= word ptr	-4
var_2= word ptr	-2
argSegment= dword ptr  6

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si

loc_14ACA:
mov	si, [word ptr bp+argSegment]

loc_14ACD:
mov	ax, si
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	ax, 8
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx

loc_14ADF:
mov	[bp+var_2], ax
mov	ax, 1
push	ax		; argValue
mov	ax, 10
push	ax		; argOffset
push	si		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_14AC3



; Attributes: bp-based frame

proc sub_14AF8 far	; CODE XREF: sub_4F44D+D6P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55441P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5545BP
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55475P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5548FP
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_554A9P
			; idk_EmsPgNm_TileFigureCont_s553B0+113P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_554DDP
			; idk_EmsPgNm_TileFigureCont_s553B0+147P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55511P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55530P
			; idk_OVR_LoadLbxHelp+A2P

argSegment= word ptr -2
argSI= word ptr	 6
argAX= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di		; arg2_SI
mov	si, [bp+argSI]
mov	di, [bp+argAX]
mov	ax, di
inc	ax		; Increment by 1
mov	di, ax
push	si		; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_14B22	; Jump if Not Zero (ZF=0)
push	di		; argMemAmount
mov	ax, enum_MEM_Error_Type_3 ; argMemAmount
push	ax		; argMemErrorCode
nop			; No Operation
push	cs
call	near ptr MemBlocksErrorExit ; Call Procedure
pop	cx
pop	cx

loc_14B22:		; CODE XREF: sub_14AF8+1Cj
push	si
nop			; No Operation
push	cs
call	near ptr fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
cmp	ax, di		; Compare Two Operands
jnb	short loc_14B44	; Jump if Not Below (CF=0)
push	si
nop			; No Operation
push	cs
call	near ptr fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
mov	dx, di
sub	dx, ax		; argMemErrorCode
push	dx		; argMemAmount
mov	ax, 2		; argMemAmount
push	ax		; argMemErrorCode
nop			; No Operation
push	cs
call	near ptr MemBlocksErrorExit ; Call Procedure
pop	cx
pop	cx

loc_14B44:		; CODE XREF: sub_14AF8+33j
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
add	ax, si		; Add
mov	[bp+argSegment], ax
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
add	ax, di		; Add
push	ax		; argValue
mov	ax, 10
push	ax		; argOffset
push	si		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 12FAh
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 4ECFh
push	ax		; argValue
mov	ax, 6
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, di
dec	ax		; Decrement by 1
push	ax		; argValue
mov	ax, 8
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 1
push	ax		; argValue
mov	ax, 10
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+argSegment]
inc	ax		; Increment by 1
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_14AF8 ; sp-analysis failed



;   mov	    si,	[bp+arg_0]
;   mov	    ax,	8
;   push    ax
;   push    si
;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
;   push    ax
;   mov	    ax,	10
;   push    ax
;   push    si
;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
;   pop	    dx
;   sub	    dx,	ax
;   mov	    [bp+var_2],	dx
;   mov	    ax,	[bp+var_2]
;   jmp	    short $+2
; Attributes: bp-based frame

proc fncSub2ndW1stW far	; CODE XREF: sub_14AF8+2Dp
			; sub_14AF8+38p
			; LBX_Load_Entry+32BP
			; LBX_Load_Entry+339P
			; LBX_Load_s15453+3DDP
			; LBX_Load_s15453+3EBP
			; LBX_EmsMapMem+1D1P
			; LBX_s16F45+13DP
			; idk_PreEmmPgCnt+1F2P
			; idk_EmsPgNm_TileFigureCont_s553B0+177P

var_2= word ptr	-2
argOffset= dword ptr  6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si		; arg2_SI
mov	si, [word ptr bp+argOffset]
mov	ax, 8
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
push	ax		; Put the result of the	1st fnLoadSW on	the stack...
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx

loc_14BEC:		; ...Get the result of the 1st fncLoadSW off the stack
pop	dx

loc_14BED:		; Subtract the result of the 2nd fncLoadSW
sub	dx, ax		;   from the result of the 1st fncLoadSW...
mov	[bp+var_2], dx
mov	ax, [bp+var_2]
jmp	short $+2	; Jump
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp fncSub2ndW1stW



;   mov	    ax,	[bp+arg_0]
;   mov	    [bp+var_6],	ax
;   mov	    ax,	[bp+var_6]
;   mov	    [bp+var_2],	ax
;   mov	    [bp+var_4],	0
;   mov	    dx,	[bp+var_2]
;   mov	    ax,	[bp+var_4]
;   jmp	    short $+2
; Attributes: bp-based frame

proc idk_DxAxBpSp_s14BFC far
			; CODE XREF: fncLoadTERRSTAT+1EP
			; LBX_SpellDat:loc_13EDFP
			; sub_1B341+CP
			; sub_1B654+1CP
			; hrmLotsOfFarMallocStoreSW+17P
			; hrmLotsOfFarMallocStoreSW+31P
			; hrmLotsOfFarMallocStoreSW+4BP
			; hrmLotsOfFarMallocStoreSW:loc_1BE6AP
			; sub_1EF3C:loc_1F000P
			; sub_1F13F:loc_1F16DP
			; sub_1F290+2DP
			; sub_21F59:loc_21F8EP
			; sub_220AA:loc_220E5P
			; idk_Mouse_s2B8B1+EP
			; ST_LoadSoundDrivers+14BP
			; ST_LoadSoundDrivers+173P
			; ST_LoadSoundDrivers+582P
			; ST_LoadSoundDrivers+5F9P
			; ST_LoadSoundDrivers+62EP
			; ST_LoadSound+76P
			; ST_LoadSound+1ABP
			; ST_LoadSound+2B0P
			; idk_BuildingWorlds+20P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5542FP
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55449P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55463P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5547DP
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55497P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_554B1P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_554CBP
			; idk_EmsPgNm_TileFigureCont_s553B0+135P
			; idk_EmsPgNm_TileFigureCont_s553B0+14FP
			; idk_EmsPgNm_TileFigureCont_s553B0+169P
			; idk_EmsPgNm_TileFigureCont_s553B0+195P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5555DP
			; idk_EmsPgNm_TileFigureCont_s553B0+1C5P
			; idk_EmsPgNm_TileFigureCont_s553B0+1DDP
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_555A5P
			; idk_EmsPgNm_TileFigureCont_s553B0+20DP
			; idk_EmsPgNm_TileFigureCont_s553B0+225P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_555EDP
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55605P
			; idk_EmsPgNm_TileFigureCont_s553B0+26DP
			; idk_EmsPgNm_TileFigureCont_s553B0+285P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5564DP
			; idk_EmsPgNm_TileFigureCont_s553B0+2B5P
			; idk_EmsPgNm_TileFigureCont_s553B0+2CDP
			; idk_EmsPgNm_TileFigureCont_s553B0+2E5P
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_556ADP
			; idk_EmsPgNm_TileFigureCont_s553B0+315P
			; idk_EmsPgNm_TileFigureCont_s553B0+32DP
			; idk_EmsPgNm_TileFigureCont_s553B0+345P
			; idk_EmsPgNm_TileFigureCont_s553B0+35DP
			; idk_EmsPgNm_TileFigureCont_s553B0+375P
			; idk_EmsPgNm_TileFigureCont_s553B0+38DP

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
mov	ax, [bp+arg_0]
mov	[bp+var_6], ax	; var_6	= arg_0;
mov	ax, [bp+var_6]
mov	[bp+var_2], ax
mov	[bp+var_4], 0
mov	dx, [bp+var_2]
mov	ax, [bp+var_4]
jmp	short $+2	; ?skip	'mov sp, bp'?
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_DxAxBpSp_s14BFC



; Attributes: bp-based frame

proc sub_14C1F far
push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction

loc_14C25:
mov	ax, [bp+6]
mov	[bp-6],	ax
mov	ax, [bp+8]

loc_14C2E:
mov	[bp-8],	ax
mov	ax, [bp-6]
xor	dx, dx		; Logical Exclusive OR
add	dx, [bp-8]	; Add
adc	ax, 0		; Add with Carry

loc_14C3C:
mov	[bp-2],	ax
mov	[bp-4],	dx
mov	dx, [bp-2]
mov	ax, [bp-4]

loc_14C48:		; Jump
jmp	short $+2
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_14C1F



; Attributes: bp-based frame

proc CALL_farfree far
push	bp
mov	bp, sp
mov	ax, [bp+6]
dec	ax		; Decrement by 1
mov	[g_FarHeapAllocSegment], ax
mov	[g_FarHeapAllocOffset],	4
push	[g_FarHeapAllocSegment]
push	[g_FarHeapAllocOffset] ; block
call	_farfree	; Call Procedure
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp CALL_farfree



; Attributes: bp-based frame

; int __fastcall __far MemBlocksErrorExit(int argMemAmount, int	argMemErrorCode)
proc MemBlocksErrorExit	far
			; CODE XREF: ST_AllocateSpace+3Bp
			; idk_Mem_StoSW_s149FA+3Bp
			; idk_Mem_StoSW_s149FA+51p
			; sub_14AF8+25p
			; sub_14AF8+47p
			; sub_17A50+3CP
			; sub_17AFA+3AP

varChar20= byte	ptr -8Ch
varChar120= byte ptr -78h
argMemErrorCode= word ptr  6
argMemAmount= word ptr	8

push	bp
mov	bp, sp
sub	sp, 140		; Integer Subtraction
push	si		; argConversionBase
mov	si, [bp+argMemAmount]
call	fncCheckDebugMode ; Call Procedure
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jz	short DEBUG_MODE ; Jump	if Zero	(ZF=1)
mov	ax, offset strInsfMem1 ; "Insufficient memory. You need	at least "...
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varChar20] ; Load Effective Address
push	ax		; argPtrCharArr
push	[g_RequiredMEM_583B] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+varChar20] ; Load Effective Address
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strInsfMem2 ; "K free. Try removing all TSR's."
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx

DEBUG_MODE:		; CODE XREF: MemBlocksErrorExit+12j
mov	bx, [bp+argMemErrorCode]
dec	bx		; Decrement by 1
cmp	bx, 3		; switch 4 cases
jbe	short loc_14CDC	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_14DFA	; default

loc_14CDC:		; CODE XREF: MemBlocksErrorExit+68j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_14E09+bx] ; switch jump

DynAllocTooSmallForAllocSpace:
			; DATA XREF: seg008:off_14E09o
mov	ax, offset aDynamicAllocat ; case 0x0
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varChar20] ; Load Effective Address
push	ax		; argPtrCharArr
push	si		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add

loc_14D04:		; CODE XREF: MemBlocksErrorExit:loc_14DA6j
mov	ax, offset aOf	; " of "
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_14D13:		; CODE XREF: MemBlocksErrorExit+105j
			; MemBlocksErrorExit:loc_14DF7j
lea	ax, [bp+varChar20] ; Load Effective Address
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aBlocks_0 ; " blocks"
push	ax

loc_14D27:		; Load Effective Address
lea	ax, [bp+varChar120]
push	ax		; argDst

loc_14D2B:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
jmp	loc_14DFA	; default

loc_14D35:		; CODE XREF: MemBlocksErrorExit+6Fj
			; DATA XREF: seg008:off_14E09o
mov	ax, offset aFailedToReload ; case 0x1
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset aAllocate_next_ ; " Allocate_Next_Block()"
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst

loc_14D4C:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
mov	ax, offset aShortBy ; ": Short by "
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst

loc_14D5B:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varChar20] ; Load Effective Address
push	ax		; argPtrCharArr
push	si		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
jmp	short loc_14D13	; Jump

AllocationSpaceCorrupted:
			; CODE XREF: MemBlocksErrorExit+6Fj
			; DATA XREF: seg008:off_14E09o
mov	ax, offset aAllocationSpac ; case 0x2
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx

loc_14D84:
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varChar20] ; Load Effective Address
push	ax		; argPtrCharArr
push	si		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add

loc_14D97:		; " Allocate_Next_Block()"
mov	ax, offset aAllocate_next_
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst

loc_14D9F:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx

loc_14DA6:		; Jump
jmp	loc_14D04

loc_14DA9:		; CODE XREF: MemBlocksErrorExit+6Fj
			; DATA XREF: seg008:off_14E09o
mov	ax, offset aFailedToReload ; case 0x3
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDest

loc_14DB1:		; argDest,argSrc
call	_strcpy
pop	cx
pop	cx

loc_14DB8:		; " (EMM) "
mov	ax, offset aEmm

loc_14DBB:
push	ax

loc_14DBC:		; Load Effective Address
lea	ax, [bp+varChar120]
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aAllocate_next_ ; " Allocate_Next_Block()"
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst

loc_14DCF:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
mov	ax, offset aShortBy ; ": Short by "
push	ax
lea	ax, [bp+varChar120] ; Load Effective Address
push	ax		; argDst

loc_14DDE:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varChar20] ; Load Effective Address
push	ax		; argPtrCharArr
push	si		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase

loc_14DF4:		; Add
add	sp, 6

loc_14DF7:		; Jump
jmp	loc_14D13

loc_14DFA:		; CODE XREF: MemBlocksErrorExit+6Aj
			; MemBlocksErrorExit+C3j
lea	ax, [bp+varChar120] ; default
push	ax		; arg0_PrintString

loc_14DFE:		; Call Procedure
call	_f050207_EXIT_CleanUp
pop	cx

loc_14E04:
pop	si

loc_14E05:
mov	sp, bp
pop	bp

locret_14E08:		; Return Far from Procedure
retf
endp MemBlocksErrorExit

off_14E09 dw offset DynAllocTooSmallForAllocSpace
			; DATA XREF: MemBlocksErrorExit+6Fr
dw offset loc_14D35	; jump table for switch	statement
dw offset AllocationSpaceCorrupted
dw offset loc_14DA9
ends seg008


; Segment type:	Pure code
segment	seg009 byte public 'CODE' use16
assume cs:seg009
;org 2
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
;   argFileName
; Return:
;   AX = file handle
; Attributes: bp-based frame

proc DOS_OpenFile far	; CODE XREF: LBX_Load_Entry+DDP
			; LBX_Load_Entry+124P
			; LBX_Load_s15453+D0P
			; LBX_Load_s15453+11AP
			; LBX_Load_HelpNewTerrCity+CDP
			; LBX_Load_HelpNewTerrCity+114P
			; LBX_Load_Entry_4bytes+BEP
			; LBX_Load_Entry_4bytes+105P
			; LBX_LoadFileMemory+14EP
			; sub_17BB8:loc_17C7EP

argFileName= word ptr  6

push	bp

loc_14E13:
mov	bp, sp
push	si

loc_14E16:
push	di
push	es

loc_14E18:
push	ds

loc_14E19:
mov	ax, 3D00h

loc_14E1C:
mov	dx, [bp+argFileName]
int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read
			; CF: Set if Error
			;
jb	short CF1_ErrorSet ; Jump if Below (CF=1)
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

CF1_ErrorSet:		; CODE XREF: DOS_OpenFile+Fj
mov	ax, 0
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp DOS_OpenFile



; DOS -	2+ - CLOSE A FILE WITH HANDLE
;   argFileHandle = BX = file handle
; Attributes: bp-based frame

proc DOS_CloseFileWithHandle far
			; CODE XREF: LBX_Load_Entry+ACP
			; LBX_Load_s15453+9FP
			; LBX_Load_HelpNewTerrCity+9CP
			; LBX_Load_Entry_4bytes+8DP
			; LBX_LoadFileMemory:loc_167F3P
			; sub_17BB8:loc_17D0FP

argFileHandle= word ptr	 6

push	bp

loc_14E33:
mov	bp, sp
push	si

loc_14E36:
push	di
push	es

loc_14E38:
push	ds
mov	ah, 3Eh

loc_14E3B:
mov	bx, [bp+argFileHandle]
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle

loc_14E40:
pop	ds
pop	es
pop	di

loc_14E43:
pop	si
pop	bp
retf			; Return Far from Procedure
endp DOS_CloseFileWithHandle



; Attributes: bp-based frame

; int __cdecl __far ST_DOS_fseek_BOF(int arg0_OffsetLow, int arg2_OffsetHigh, char *arg4_FileHandle)
proc ST_DOS_fseek_BOF far
			; CODE XREF: LBX_Load_Entry+169P
			; LBX_Load_Entry+231P
			; LBX_Load_s15453+161P
			; LBX_Load_s15453+229P
			; LBX_Load_s15453+2CEP
			; LBX_Load_HelpNewTerrCity+146P
			; LBX_Load_HelpNewTerrCity+20EP
			; LBX_Load_HelpNewTerrCity+2B6P
			; LBX_Load_Entry_4bytes+14AP
			; LBX_AllocMem+C8P
			; LBX_s16A80+11FP
			; LBX_MemAndRead+9EP

arg0_OffsetLow=	word ptr  6
arg2_OffsetHigh= word ptr  8
arg4_FileHandle= word ptr  0Ah

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, 4200h	; AH = 42h, LSEEK - Set	Current	File Position
			; AL = 00h, Origin - Start of File
mov	bx, [bp+arg4_FileHandle]
mov	cx, [bp+arg2_OffsetHigh]
mov	dx, [bp+arg0_OffsetLow]
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from beginning of	file
			; CX:DX	= (signed) offset, from	origin,	of new file position
			;
			;
			; Return:
			; CF clear if successful
			; DX:AX	= new file position in bytes from start	of file
			; CF set on error
			; AX = error code (01h,06h) (see #01680	at AH=59h/BX=0000h)
			;
jb	short SUCCESS	; JMP IF CF=1, i.e. IfError(LSEEK)

FAILURE:
mov	ax, 0FFFFh
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

SUCCESS:		; CODE XREF: ST_DOS_fseek_BOF+15j
mov	ax, 0
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp ST_DOS_fseek_BOF



; Attributes: bp-based frame

proc sub_14E6F far

arg_0= word ptr	 6

push	bp

loc_14E70:
mov	bp, sp
push	si
push	di

loc_14E74:
push	es

loc_14E75:
push	ds

loc_14E76:
mov	ax, 4202h

loc_14E79:
mov	bx, [bp+arg_0]

loc_14E7C:
mov	cx, 0

loc_14E7F:
mov	dx, 0

loc_14E82:		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
int	21h		; AL = method: offset from end of file

loc_14E84:		; Jump if Below	(CF=1)
jb	short loc_14E8C
pop	ds
pop	es
pop	di
pop	si

loc_14E8A:
pop	bp
retf			; Return Far from Procedure

loc_14E8C:		; CODE XREF: sub_14E6F:loc_14E84j
mov	ax, 0

loc_14E8F:
mov	dx, 0
pop	ds
pop	es

loc_14E94:
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_14E6F



; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
;   DX = argBuffer = Buffer = word_35B78
;   CX = argBytes = Bytes  = 512
;   BX = argFileHandle = Handle	= word_3C2DA
; Return:
;  -1 =	Success
;   0 =	Failure
; Attributes: bp-based frame

; int __cdecl __far ST_DOS_fread(int argBuffer,	int argBytes, int argFileHandle)
proc ST_DOS_fread far	; CODE XREF: LBX_Load_Entry+18EP
			; LBX_Load_Entry+3A0P
			; LBX_Load_Entry+3ECP
			; LBX_Load_s15453+186P
			; LBX_Load_s15453+452P
			; LBX_Load_s15453+49EP
			; LBX_Load_HelpNewTerrCity+16BP
			; LBX_Load_Entry_4bytes+16FP
			; LBX_LoadFileMemory+190P
			; LBX_LoadFileMemory+1DDP
			; LBX_AllocMem+182P
			; LBX_AllocMem+1D5P
			; LBX_s16A80+1D5P
			; LBX_s16A80+219P
			; sub_17BB8+103P
			; sub_17BB8+14EP
			; LBX_MemAndRead+126P
			; LBX_MemAndRead+165P

argBuffer= word	ptr  6
argBytes= word ptr  8
argFileHandle= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ah, 3Fh
mov	bx, [bp+argFileHandle]
mov	cx, [bp+argBytes]
mov	dx, [bp+argBuffer] ;
			; DS:DX	-> buffer
			; DS = DX = [BP+argBuffer]
			; DX = 0
mov	ds, dx
mov	dx, 0
int	21h		;
			; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle
			; CX = number of bytes to read
			; DS:DX	-> buffer for data
			; Return:
			;   CF clear if	successful
			;   AX = number	of bytes actually read
			;   CF set on error
			;   AX = error code
jb	short ReadError	; Jump if Below	(CF=1)
mov	ax, 0FFFFh
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

ReadError:		; CODE XREF: ST_DOS_fread+19j
mov	ax, 0
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp ST_DOS_fread



; Attributes: bp-based frame

; int __cdecl __far ST_DOS_ReadFromFileHandle_1(int argBuffer, int argByteCount, int argFileHandle)
proc ST_DOS_ReadFromFileHandle_1 far
			; CODE XREF: LBX_Load_s15453+252P
			; LBX_Load_s15453+266P
			; LBX_Load_HelpNewTerrCity+237P
			; LBX_Load_HelpNewTerrCity+24BP
			; LBX_Load_HelpNewTerrCity+30AP

argBuffer= word	ptr  6
argByteCount= word ptr	8
argFileHandle= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ah, 3Fh
mov	bx, [bp+argFileHandle]
mov	cx, [bp+argByteCount]
mov	dx, [bp+argBuffer]
int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
jb	short loc_14EE4	; Jump if Below	(CF=1)

loc_14EDB:
mov	ax, -1
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_14EE4:		; CODE XREF: ST_DOS_ReadFromFileHandle_1+14j
mov	ax, 0
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp ST_DOS_ReadFromFileHandle_1



; Attributes: bp-based frame

proc idk_Get_FAT_FileExtension_s14EED far
			; CODE XREF: sub_1953F+10P
			; sub_1956B+10P
			; sub_19597+10P
			; sub_195C3+10P
			; sub_195EF+10P
			; sub_1961B+10P
			; sub_19E92+1EP
			; sub_1A525+13P
			; sub_1AA40+10P
			; sub_1AA6E+10P
			; sub_1AA9C+10P
			; sub_1AACA:loc_1AADAP
			; ST_LoadSoundDrivers+5B0P
			; LBX_Cityname_s4B973+62P
			; LBX_Cityname_s4B973+D2P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
cmp	[bp+arg_2], 0	; Compare Two Operands
jnz	short loc_14EFF	; Jump if Not Zero (ZF=0)

loc_14EFA:
mov	ax, ds
mov	[bp+arg_2], ax

loc_14EFF:		; CODE XREF: idk_Get_FAT_FileExtension_s14EED+Bj
cmp	[bp+arg_6], 0	; Compare Two Operands
jnz	short loc_14F0A	; Jump if Not Zero (ZF=0)

loc_14F05:
mov	ax, ds
mov	[bp+arg_6], ax

loc_14F0A:		; CODE XREF: idk_Get_FAT_FileExtension_s14EED+16j
mov	ax, [bp+arg_2]

loc_14F0D:
mov	es, ax
mov	si, [bp+arg_4]

loc_14F12:
mov	di, [bp+arg_0]

loc_14F15:
mov	ax, [bp+arg_6]

loc_14F18:
mov	ds, ax

loc_14F1A:		; CODE XREF: idk_Get_FAT_FileExtension_s14EED:loc_14F1Ej
lodsb			; Load String
stosb			; Store	String

loc_14F1C:		; Compare Two Operands
cmp	al, 0

loc_14F1E:		; Jump if Not Zero (ZF=0)
jnz	short loc_14F1A

loc_14F20:
pop	ds
pop	es
pop	di
pop	si

loc_14F24:
pop	bp
retf			; Return Far from Procedure
endp idk_Get_FAT_FileExtension_s14EED

ends seg009


; Segment type:	Pure code
segment	seg010 byte public 'CODE' use16
assume cs:seg010
;org 6
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

; int __cdecl __far LBX_Load_Entry_0_0_0(int argLbxFileName, int argLbxEntryNumber)
proc LBX_Load_Entry_0_0_0 far
			; CODE XREF: _f010109_main+389P
			; _f010409_LoadVortexAnimationImages+15P
			; _f010409_LoadVortexAnimationImages+27P
			; _f010409_LoadVortexAnimationImages+39P
			; _f010409_LoadVortexAnimationImages+4BP
			; _f010409_LoadVortexAnimationImages+5DP
			; _f010409_LoadVortexAnimationImages+6FP
			; _f010409_LoadVortexAnimationImages+81P
			; _f010409_LoadVortexAnimationImages+9EP
			; LBX_Load_FontsStyleData+18P
			; LBX_Load_FontsStyleData+27P
			; ST_LoadSoundDrivers+143P
			; ST_LoadSoundDrivers+16BP
			; ST_LoadSoundDrivers+64AP
			; ST_LoadSoundDrivers+678P

argLbxFileName=	word ptr  6
argLbxEntryNumber= word	ptr  8

push	bp
mov	bp, sp


xor	ax, ax		; Logical Exclusive OR
push	ax		; argSomethingElseOrZero
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg6_DI
xor	ax, ax		; argSrc
push	ax		; argPtrBuffer_EMS
push	[bp+argLbxEntryNumber] ; argLbxEntryNumber
push	[bp+argLbxFileName] ; argLbxFileName
nop			; No Operation
push	cs
call	near ptr LBX_Load_Entry	;
			; LBX_Load_Entry(argLbxFileName,
			;		 argLbxEntryNumber,
			;		 0,
			;		 0,
			;		 0)


add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_Entry_0_0_0 ; sp-analysis	failed



; Returns varLbxMemBuf,	from LBX_Load_Entry
;
; Attributes: bp-based frame

; int __cdecl __far LBX_Load_Entry_0_1(int argLbxFileName, int argEntryNumber, int argPtrBuffer_EMS)
proc LBX_Load_Entry_0_1	far
			; CODE XREF: ILSe_prepare_palette+17P
			; sub_3CFC0+26P
			; sub_3DBA6+13P
			; sub_3E1DE+6FP
			; sub_3EBA0+24P
			; sub_3F3C6+13P
			; idk_Load_NEWGAME_LBX+11P
			; sub_3F7D8+25P
			; sub_3FBE0+5BP
			; sub_4067D+3AP
			; LBX_NewGame_s41A5F:loc_41A85P
			; sub_4D5B0:loc_4D5DBP
			; sub_4D8FA+1BP
			; sub_4DB4D+28P
			; ST_LoadMusicSoundfxIntro+1CP
			; sub_56450+58P

argLbxFileName=	word ptr  6
argEntryNumber=	word ptr  8
argPtrBuffer_EMS= word ptr  0Ah

push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg 5
mov	ax, 1		; argSrc
push	ax		; arg 4
push	[bp+argPtrBuffer_EMS] ;	arg 3
push	[bp+argEntryNumber] ; arg 2
push	[bp+argLbxFileName] ; arg 1
nop			; No Operation
push	cs
call	near ptr LBX_Load_Entry	; Returns a pointer to a buffer	of the record data that	was read?
			;
			; LBX_Load_Entry(argLbxFileName,
			;		 argEntryNumber,
			;		 argPtrBuffer_EMS,
			;		 1,
			;		 0)
			;
			; LBX_Load_Entry(argLbxFileName,
			;		 argEntryNumber,
			;		 argPtrBuffer_EMS,
			;		 arg_idk_FLAG_0_1_2,
			;		 argSomethingElseOrZero)
			;
add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_Entry_0_1	; sp-analysis failed



; Attributes: bp-based frame

; int __cdecl __far LBX_Load_Entry_0_2(int argEntryNumber, int argFileName, int	arg4_Int)
proc LBX_Load_Entry_0_2	far
			; CODE XREF: sub_3CFC0+3DP
			; sub_3CFC0+5AP
			; sub_3CFC0+82P
			; sub_3CFC0+AAP
			; sub_3DBA6+2AP
			; sub_3DBA6+41P
			; sub_3DBA6+58P
			; sub_3DBA6+6FP
			; sub_3DBA6+86P
			; sub_3DBA6+9DP
			; sub_3DBA6+B4P
			; sub_3DBA6+CBP
			; sub_3E1DE+86P
			; sub_3E1DE+9DP
			; sub_3E1DE+B4P
			; sub_3E1DE+CBP
			; sub_3E1DE+E2P
			; sub_3E1DE+F9P
			; sub_3E1DE+110P
			; sub_3EBA0+41P
			; sub_3EBA0+70P
			; sub_3EBA0+8DP
			; sub_3F3C6+34P
			; sub_3F3C6+5AP
			; idk_Load_NEWGAME_LBX+28P
			; sub_3F7D8+3CP
			; sub_3F7D8+59P
			; sub_3F7D8+7BP
			; sub_3FBE0+72P
			; sub_3FBE0+89P
			; sub_3FBE0+A0P
			; sub_3FBE0+B7P
			; sub_3FBE0+D4P
			; sub_4067D+51P
			; sub_4067D+68P
			; sub_4067D+85P
			; sub_4067D+A7P
			; sub_4067D+BEP
			; sub_4067D+D5P
			; LBX_NewGame_s41A5F+3DP
			; LBX_NewGame_s41A5F+54P
			; LBX_NewGame_s41A5F:loc_41ACAP
			; LBX_NewGame_s41A5F+82P
			; LBX_NewGame_s41A5F:loc_41AF8P
			; LBX_NewGame_s41A5F:loc_41B0FP
			; LBX_NewGame_s41A5F:loc_41B26P
			; LBX_NewGame_s41A5F:loc_41B43P
			; LBX_NewGame_s41A5F+106P
			; LBX_NewGame_s41A5F+11DP
			; LBX_NewGame_s41A5F+134P
			; sub_4D5B0:loc_4D5F2P
			; sub_4D5B0:loc_4D609P
			; sub_4D5B0:loc_4D620P
			; sub_4D8FA+32P
			; sub_4D8FA+49P
			; sub_4D8FA+60P
			; sub_4DB4D:loc_4DB8CP
			; sub_4DB4D+56P
			; sub_4DB4D+6DP
			; sub_4DB4D+84P
			; sub_4DB4D+9BP
			; sub_4DB4D+B2P
			; sub_4DB4D+C9P
			; sub_4DB4D+E0P
			; sub_4DB4D+F7P
			; sub_4DB4D+10EP
			; sub_4DB4D+125P
			; sub_4DB4D+13CP
			; sub_4DB4D+159P
			; sub_4DB4D+175P
			; idk_ResourceLbx+4BP
			; idk_ResourceLbx+62P
			; idk_ResourceLbx+79P
			; idk_ResourceLbx+93P
			; idk_ResourceLbx+AAP
			; idk_ResourceLbx+C1P
			; idk_ResourceLbx+DBP
			; idk_ResourceLbx+F2P
			; idk_ResourceLbx+109P
			; idk_ResourceLbx+122P
			; idk_ResourceLbx+139P
			; idk_ResourceLbx+150P
			; idk_ResourceLbx+16FP
			; ST_LoadMusicSoundfxIntro+3DP
			; ST_LoadMusicSoundfxIntro+19BP
			; ST_LoadMusicSoundfxIntro+1B2P
			; ST_LoadMusicSoundfxIntro+210P
			; ST_LoadMusicSoundfxIntro+227P
			; ST_LoadMusicSoundfxIntro+26BP
			; ST_LoadMusicSoundfxIntro+282P
			; ST_LoadMusicSoundfxIntro+2C7P
			; idk_OVR_LoadLbxHelp+12AP
			; idk_OVR_LoadLbxHelp+215P
			; idk_OVR_LoadLbxHelp+22CP
			; idk_OVR_LoadLbxHelp+3B6P

argEntryNumber=	word ptr  6
argFileName= word ptr  8
arg4_Int= word ptr  0Ah

push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax		; argSomethingElseOrZero
mov	ax, 2		; argSrc
push	ax		; arg6_DI
push	[bp+arg4_Int]	; argPtrBuffer_EMS
push	[bp+argFileName] ; argLbxEntryNumber
push	[bp+argEntryNumber] ; argLbxFileName
nop			; No Operation
push	cs
call	near ptr LBX_Load_Entry	; Call Procedure
add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_Entry_0_2	; sp-analysis failed



; 52,  36, 0, 0, "BUILDDAT"
; 36, 215, 0, 0, "SPELLDAT"
;  6, 770, 0, 0, "TERRSTAT"
;
; BUILDDAT.LBX:	count 1, type 5
; SPELLDAT.LBX:	count 1, type 5
; TERRSTAT.LBX:	count 2, type 5
;
; NOTE:	There are other	LBX's
;  that	have the same/similar count and	type.
;
; All three trace back on a single path	to main().
; SPELLDAT and TERRSTAT	are called directly from main(),
; BUILDDAT follow a long series	of other calls.
; Attributes: bp-based frame

proc LBX_PreLoad_s15453	far
			; CODE XREF: fncLoadTERRSTAT+15P
			; LBX_SpellDat+15P
			; idk_BuildingWorlds+17P

argString_DI= word ptr	6
argLbxName_SI= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	[bp+arg_8]	; int
push	[bp+arg_6]	; int
push	[bp+arg_4]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; int
push	ax		; int
push	[bp+argLbxName_SI] ; argLbxName_SI
push	[bp+argString_DI] ; argString_DI
nop			; No Operation
push	cs
call	near ptr LBX_Load_s15453 ; Call	Procedure
add	sp, 0Eh		; Add
pop	bp
retf			; Return Far from Procedure
endp LBX_PreLoad_s15453	; sp-analysis failed



; Attributes: bp-based frame

proc LBX_Load_s14F9E far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	[bp+arg_A]
push	[bp+arg_8]
push	[bp+arg_6]
mov	ax, 1
push	ax
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr LBX_Load_s15453 ; Call	Procedure
add	sp, 0Eh		; Add
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_s14F9E ; sp-analysis failed



; Attributes: bp-based frame

proc LBX_Load_s14FC1 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	[bp+arg_A]
push	[bp+arg_8]
push	[bp+arg_6]
mov	ax, 2
push	ax
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr LBX_Load_s15453 ; Call	Procedure
add	sp, 0Eh		; Add
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_s14FC1 ; sp-analysis failed



; Attributes: bp-based frame

proc sub_14FE4 far

argLbxFileName=	word ptr  6
argLbxEntryNumber= word	ptr  8

push	bp
mov	bp, sp

loc_14FE7:
mov	ax, 1
push	ax		; argSomethingElseOrZero
xor	ax, ax		; Logical Exclusive OR

loc_14FED:		; arg6_DI
push	ax
xor	ax, ax		; Logical Exclusive OR

loc_14FF0:		; argPtrBuffer_EMS
push	ax
push	[bp+argLbxEntryNumber] ; argLbxEntryNumber

loc_14FF4:		; argLbxFileName
push	[bp+argLbxFileName]

loc_14FF7:		; No Operation
nop
push	cs
call	near ptr LBX_Load_Entry	; Call Procedure
add	sp, 0Ah		; Add
pop	bp

locret_15000:		; Return Far from Procedure
retf
endp sub_14FE4 ; sp-analysis failed



; Attributes: bp-based frame

proc sub_15001 far
push	bp

loc_15002:
mov	bp, sp

loc_15004:
mov	ax, 1

loc_15007:		; argSomethingElseOrZero
push	ax

loc_15008:		; argSrc
mov	ax, 1

loc_1500B:		; arg6_DI
push	ax

loc_1500C:		; argPtrBuffer_EMS
push	[word ptr bp+0Ah]

loc_1500F:		; argLbxEntryNumber
push	[word ptr bp+8]
push	[word ptr bp+6]	; argLbxFileName
nop			; No Operation
push	cs

loc_15017:		; Call Procedure
call	near ptr LBX_Load_Entry

loc_1501A:		; Add
add	sp, 0Ah

loc_1501D:
pop	bp

locret_1501E:		; Return Far from Procedure
retf

loc_1501F:
push	bp

loc_15020:
mov	bp, sp
mov	ax, 1
push	ax		; argSomethingElseOrZero

loc_15026:		; argSrc
mov	ax, 2
push	ax		; arg6_DI
push	[word ptr bp+0Ah] ; argPtrBuffer_EMS
push	[word ptr bp+8]	; argLbxEntryNumber

loc_15030:		; argLbxFileName
push	[word ptr bp+6]
nop			; No Operation
push	cs
call	near ptr LBX_Load_Entry	; Call Procedure
add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_15001 ; sp-analysis failed



; Returns varLbxMemBuf
;
; LBX_Load_Entry(argEntryNumber,
;		 argFileNameBase,
;		 argPtrBuffer_EMS,
;		 arg_idk_FLAG_0_1_2,
;		 argSomethingElseOrZero)
;
; Attributes: bp-based frame

; int __cdecl __far LBX_Load_Entry(int argLbxFileName, int argLbxEntryNumber, int argPtrBuffer_EMS, int	arg6_DI, int argSomethingElseOrZero)
proc LBX_Load_Entry far	; CODE XREF: LBX_Load_Entry_0_0_0+14p
			; LBX_Load_Entry_0_1+15p
			; LBX_Load_Entry_0_2+15p
			; sub_14FE4+15p
			; sub_15001:loc_15017p
			; sub_15001+34p

varDest= byte ptr -6Ch
varDst=	byte ptr -30h
var_idkMemberSize= word	ptr -1Ch
var2_SI= dword ptr -1Ah
varMemberOffsetEnd_Word2= word ptr -16h
varMemberOffsetStart_Word1= word ptr -14h
varMemberOffsetStart_Word2= word ptr -12h
var0_offsetDX= word ptr	-10h
var2_offsetCX= word ptr	-0Eh
varBytes= word ptr -0Ch
varBuffer= word	ptr -0Ah
varBytesToAllocate= word ptr -8
var8_SI= word ptr -6
varOffsetToMemberOffsetStart= word ptr -4
varLbxMemBuf= word ptr -2
argLbxFileName=	word ptr  6
argLbxEntryNumber= word	ptr  8
argPtrBuffer_EMS= word ptr  0Ah
arg6_DI= word ptr  0Ch
argSomethingElseOrZero=	word ptr  0Eh

si_argLbxFileName = si
push	bp
mov	bp, sp
sub	sp, 108		; Integer Subtraction
push	si_argLbxFileName
push	di


mov	si_argLbxFileName, [bp+argLbxFileName]
mov	di, [bp+argLbxEntryNumber]
or	di, di		; If (DI == 0) Then Set	(ZF = 1)
jge	short OK_StringNotEmpty	; Jump if Greater or Equal (SF=OF)

NoNameDefaultNotFound:
push	di
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

OK_StringNotEmpty:	; CODE XREF: LBX_Load_Entry+10j
cmp	[LBX_FLAG_NoMalloc], 0 ; Compare Two Operands
jnz	short loc_15077	; Jump if Not Zero (ZF=0)
mov	[LBX_FLAG_NoMalloc], 1
mov	ax, 32		; int
push	ax		; argKiloBytes
call	ST_FarMalloc	; Call Procedure
pop	cx
mov	[g_ptrBufferReadFile], ax

loc_15077:		; CODE XREF: LBX_Load_Entry+25j
push	si_argLbxFileName ; argNameCharArr
nop			; No Operation
push	cs
call	near ptr ST_RemoveExtensionUppercaseName ; Call	Procedure
pop	cx
cmp	[bp+argSomethingElseOrZero], 0 ; Compare Two Operands
jz	short NO_ArgNbr3 ; Jump	if Zero	(ZF=1)

loc_15084:		; Compare Two Operands
cmp	[LBX_Flag_w35B7A], 2
jnz	short loc_15092	; Jump if Not Zero (ZF=0)

NO_ArgNbr3:		; CODE XREF: LBX_Load_Entry+45j
mov	[bp+var8_SI], 0
jmp	short loc_15097	; Jump

loc_15092:		; CODE XREF: LBX_Load_Entry+4Cj
mov	[bp+var8_SI], 1

loc_15097:		; CODE XREF: LBX_Load_Entry+53j
push	[bp+var8_SI]	; int
push	[bp+arg6_DI]	; int
push	[bp+argPtrBuffer_EMS] ;	argPtrBuffer_EMS
push	di		; int
push	si_argLbxFileName ; int
call	LBX_EmsMapMem	; Return:
			; FAILURE: AX =	0
			; OR
			; SUCCESS: AX =	DI
add	sp, 0Ah		; Add
mov	[bp+varLbxMemBuf], ax
cmp	[bp+varLbxMemBuf], 0 ; Compare Two Operands
jz	short GOT_ZERO	; Jump if Zero (ZF=1)
jmp	loc_15443	; Jump

GOT_ZERO:		; CODE XREF: LBX_Load_Entry+74j
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     [g_CurrentLbxFileHandle], 0FFFFh	; Compare Two Operands
jz	short DIFFERENT_FILE_OPEN ; Jump if Zero (ZF=1)

idk_CurrentFileOpen:
mov	ax, offset g_CurrentLbxFileNameBase
push	ax
push	si_argLbxFileName ; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short DIFFERENT_FILE_OPEN ; Jump if Not	Zero (ZF=0)

idk_AlreadyReadHeader:
mov	ax, [g_CurrentLbxFilePosition]
cmp	ax, [bp+var8_SI] ;
			; var8_SI is still 0 or	1?
			;  based on var	of flag?
			;
jnz	short DIFFERENT_FILE_OPEN ; Jump if Not	Zero (ZF=0)
jmp	CheckEntryCount	; Jump

DIFFERENT_FILE_OPEN:	; CODE XREF: LBX_Load_Entry+7Ej
			; LBX_Load_Entry+8Ej
			; LBX_Load_Entry+96j
mov	ax, [bp+var8_SI]
mov	[g_CurrentLbxFilePosition], ax
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     [g_CurrentLbxFileHandle], 0FFFFh	; Compare Two Operands
jz	short loc_150EF	; Jump if Zero (ZF=1)
push	[g_CurrentLbxFileHandle]
call	DOS_CloseFileWithHandle	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   argFileHandle = BX = file handle
pop	cx

loc_150EF:		; CODE XREF: LBX_Load_Entry+A6j
push	si_argLbxFileName
mov	ax, offset g_CurrentLbxFileNameBase
push	ax		; argDest
call	_strcpy		; copy LBX File	Name Base
			;  from	SI to ptrLbxMemberName
			;
pop	cx
pop	cx
push	si_argLbxFileName
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; Copy LBX File	Name Base
			;  from	SI to local varDst
			;
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; Add ".LBX"
			;  to local copy of LBX	File Name Base
			;
pop	cx
pop	cx
lea	ax, [bp+varDst]	; Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[g_CurrentLbxFileHandle], ax
cmp	[g_CurrentLbxFileHandle], 0 ; 0	= Error;
			;
jnz	short SUCCESS_FILE_OPEN	; Jump if Not Zero (ZF=0)

COULD_NOT_OPEN_FILE:	; Compare Two Operands
cmp	[byte ptr g_LbxDirectoryPath], 0
jnz	short TRY_SOME_OTHER_FILENAME ;	Jump if	Not Zero (ZF=0)
push	di		; argLbxEntryNumber
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

TRY_SOME_OTHER_FILENAME:
			; CODE XREF: LBX_Load_Entry+F2j
mov	ax, offset g_LbxDirectoryPath
push	ax		; argSrc
lea	ax, [bp+varDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; copy idk_LBX_argSrc_w35B7C
			;  to varDest
			;
pop	cx
pop	cx
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argSrc
lea	ax, [bp+varDest] ; Load	Effective Address
push	ax		; argDst
call	_strcat		; Append LBX File Name
			;  to varDest
			;
pop	cx
pop	cx
lea	ax, [bp+varDest] ; Load	Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[g_CurrentLbxFileHandle], ax ; File Handle
cmp	[g_CurrentLbxFileHandle], 0 ; Compare Two Operands
jnz	short SUCCESS_FILE_OPEN	; Jump if Not Zero (ZF=0)

COULD_NOT_OPEN_FILE_STILL: ; argLbxEntryNumber
push	di
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SUCCESS_FILE_OPEN:	; CODE XREF: LBX_Load_Entry+EBj
			; LBX_Load_Entry+132j
cmp	[g_CurrentLbxFilePosition], 0 ;	Compare	Two Operands
jz	short FILE_POSITION_IS_ZERO ; Jump if Zero (ZF=1)
mov	[bp+var2_offsetCX], 0
mov	[bp+var0_offsetDX], LBX_HEADER_LENGTH
jmp	short loc_1519C	; Jump

FILE_POSITION_IS_ZERO:	; CODE XREF: LBX_Load_Entry+147j
mov	[bp+var2_offsetCX], 0
mov	[bp+var0_offsetDX], 0

loc_1519C:		; CODE XREF: LBX_Load_Entry+153j
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+var2_offsetCX] ; CX
push	[bp+var0_offsetDX] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; IF (AX == 0) Then Set	(ZF = 1)
jnz	short SEEK_SUCCESS1 ; Jump if Not Zero (ZF=0)

SEEK_FAILURE1:		; argLbxEntryNumber
push	di
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
jmp	short Check_Lbx_MagSig ; Jump

SEEK_SUCCESS1:		; CODE XREF: LBX_Load_Entry+173j
push	[g_CurrentLbxFileHandle] ; argFileHandle
mov	ax, LBX_HEADER_LENGTH
push	ax		; argBytes
push	[g_ptrBufferReadFile] ;	argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

Check_Lbx_MagSig:	; CODE XREF: LBX_Load_Entry+180j
add	sp, 6		; Add
mov	ax, 2
push	ax
push	[g_ptrBufferReadFile] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, e_LBX_MagSig ; Check SimTex	LBX File Type ID
jz	short GetEntryCount ; JZ: LBX_MagSig matched

noLbxMagSig:		; argLbxEntryNumber
push	di
mov	ax, e_NOT_AN_LBX ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

GetEntryCount:		; CODE XREF: LBX_Load_Entry+1A8j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[g_ptrBufferReadFile] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[g_CurrentLbxEntryCount], ax

CheckEntryCount:	; CODE XREF: LBX_Load_Entry+98j
cmp	di, [g_CurrentLbxEntryCount] ;
			; DI is	argEntryNumber
			;
jl	short GetEntryOffsets ;	Jump if	Less (SF!=OF)

EXCEEDS_ENTRY_COUNT:	; argLbxEntryNumber
push	di
mov	ax, e_EXCEEDS_LBX_ENTRIES ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

GetEntryOffsets:	; CODE XREF: LBX_Load_Entry+1CDj
mov	ax, di		; AX = LBX Entry Number	Requested
mov	cl, 2		; argLbxEntryNumber
shl	ax, cl		; Shift	Left (multiply by the power of 2)
			;
			; LBX Member Number * 2^2
			; e.g.,
			; LBX Member Number = 11
			; Shift	Left: 11 * 2^2 = 11 * 4	= 44
			;
			;   0 *	4 + 8 =	  8
			;   1 *	4 + 8 =	 12
			;   2 *	4 + 8 =	 16
			;   3 *	4 + 8 =	 20
			; ...
			; 125 *	4 + 8 =	508
			;

loc_15220:		;
add	ax, 8		; add 8	to offset from the 8 byte Header Preamble
			;
mov	[bp+varOffsetToMemberOffsetStart], ax
push	[bp+varOffsetToMemberOffsetStart]
push	[g_ptrBufferReadFile]
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+varMemberOffsetStart_Word2], dx
mov	[bp+varMemberOffsetStart_Word1], ax ;
			;
			;
mov	ax, [bp+varOffsetToMemberOffsetStart]
add	ax, 4		;
			; add 4	to move	offset to Entry	Offset End
			;
push	ax
push	[g_ptrBufferReadFile]
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+varMemberOffsetEnd_Word2], dx
mov	[word ptr bp+var2_SI+2], ax ; varMemberOffsetEnd_Word1
			;
			;
mov	ax, [bp+varMemberOffsetEnd_Word2]
mov	dx, [word ptr bp+var2_SI+2] ; varMemberOffsetEnd_Word1
			;
			; ...swapped AX	& DX
			;
sub	dx, [bp+varMemberOffsetStart_Word1] ; arg2_ErrNo
sbb	ax, [bp+varMemberOffsetStart_Word2] ; ~= Record	Size = (End - Start)
			;
mov	[word ptr bp+var2_SI], ax ;
			;
			; AX = OffsetEnd_Word2 - OffsetStart_Word2
			;
mov	[bp+var_idkMemberSize],	dx ;
			;
			; DX = OffsetEnd_Word1 - OffsetStart_Word1
			;
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+varMemberOffsetStart_Word2]	; arg2_OffsetHigh
push	[bp+varMemberOffsetStart_Word1]	; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short SEEK_SUCCESS2 ; Jump if Not Zero (ZF=0)

SEEK_FAILURE2:		; argLbxEntryNumber
push	di
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SEEK_SUCCESS2:		; CODE XREF: LBX_Load_Entry+23Bj
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16		; ?divide by 16	bytes/paragraph?
push	ax
push	dx		; argPtrSrcBuf
push	[word ptr bp+var2_SI] ;	argPtrSrcBuf
push	[bp+var_idkMemberSize]
call	LDIV@		; Long Division
			; ...
			; BCpp says
			; ldiv(long numerator, long denominator)
			;   returns struct ldiv_t {long	quotient, long remainder}
			; ...
			; not sure about the push 0, push 16
			; maybe	the 16 in the number base?
			;
inc	ax		; ?add a paragraph?
mov	[bp+varBytesToAllocate], ax
mov	ax, [bp+arg6_DI]
or	ax, ax		; Logical Inclusive OR
jz	short Srtgy0_Malloc ; Jump if Zero (ZF=1)

NOT_Srtgy0:		; Compare Two Operands
cmp	ax, 1
jz	short Srtgy1_check ; Jump if Zero (ZF=1)

NOT_Srtgy1:		; Compare Two Operands
cmp	ax, 2
jnz	short Srtgy3	; Jump if Not Zero (ZF=0)

Srtgy2_jmp:		; Jump
jmp	Srtgy2_check

Srtgy3:			; CODE XREF: LBX_Load_Entry+273j
jmp	loc_153BD	; Jump

Srtgy0_Malloc:		; CODE XREF: LBX_Load_Entry+269j
push	[bp+varBytesToAllocate]
call	malloc_s14954	; void*	malloc (size_t size);
			; Allocate memory block
			; Allocates a block of size bytes of memory, returning a pointer to the	beginning of the block.
pop	cx
mov	[bp+varLbxMemBuf], ax
cmp	[bp+varLbxMemBuf], 0 ; Compare Two Operands
jnz	short loc_152D8	; Jump if Not Zero (ZF=0)

FAILURE_MALLOC:		; argLbxEntryNumber
push	di
mov	ax, e_INSUFFICIENT_MEMORY ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_152D8:		; CODE XREF: LBX_Load_Entry+28Bj
jmp	loc_153BD	; int

Srtgy1_check:		; CODE XREF: LBX_Load_Entry+26Ej
push	[bp+argPtrBuffer_EMS] ;	argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short Srtgy1_g2g ; Jump	if Not Zero (ZF=0)
push	di		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

Srtgy1_g2g:		; CODE XREF: LBX_Load_Entry+2A9j
mov	ax, 8
push	ax
push	[bp+argPtrBuffer_EMS] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
dec	ax		; Decrement by 1
cmp	ax, [bp+varBytesToAllocate] ; Compare Two Operands
jnb	short loc_1532D	; Jump if Not Below (CF=0)
mov	ax, 8
push	ax
push	[bp+argPtrBuffer_EMS] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varBytesToAllocate]
sub	dx, ax		; Integer Subtraction
inc	dx		; arg2_ErrNo
push	dx		; int
push	di		; argLbxEntryNumber
mov	ax, e_MISALLOCATED ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 8		; Add

loc_1532D:		; CODE XREF: LBX_Load_Entry+2CBj
mov	ax, [bp+argPtrBuffer_EMS]
inc	ax		; Increment by 1
mov	[bp+varLbxMemBuf], ax
mov	ax, [bp+varBytesToAllocate]
inc	ax		; Increment by 1
push	ax		; argValue

loc_15339:		; CODE XREF: LBX_Load_Entry+37Dj
mov	ax, 10
push	ax		; argOffset
push	[bp+argPtrBuffer_EMS] ;	argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
jmp	short loc_153BD	; int

Srtgy2_check:		; CODE XREF: LBX_Load_Entry:Srtgy2_jmpj
push	[bp+argPtrBuffer_EMS] ;	argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short Srtgy2_g2g ; Jump	if Not Zero (ZF=0)
push	di		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

Srtgy2_g2g:		; CODE XREF: LBX_Load_Entry+318j
push	[bp+argPtrBuffer_EMS]
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
cmp	ax, [bp+varBytesToAllocate] ; Compare Two Operands
jnb	short loc_15390	; Jump if Not Below (CF=0)
push	[bp+argPtrBuffer_EMS]
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
mov	dx, [bp+varBytesToAllocate]
sub	dx, ax		; arg2_ErrNo
push	dx		; int
push	di		; argLbxEntryNumber
mov	ax, e_ALLOCATION_TOO_SMALL ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs

loc_1538A:		; Call Procedure
call	near ptr LBX_Load_ErrorHandler

loc_1538D:		; Add
add	sp, 8

loc_15390:		; CODE XREF: LBX_Load_Entry+334j
mov	ax, 10
push	ax
push	[bp+argPtrBuffer_EMS] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+argPtrBuffer_EMS]
add	dx, ax		; Add
mov	[bp+varLbxMemBuf], dx
mov	ax, 10
push	ax
push	[bp+argPtrBuffer_EMS] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varBytesToAllocate]
add	dx, ax		; arg2_ErrNo
push	dx
jmp	loc_15339	; int

loc_153BD:		; CODE XREF: LBX_Load_Entry:Srtgy3j
			; LBX_Load_Entry:loc_152D8j
			; LBX_Load_Entry+30Bj
mov	ax, [bp+varLbxMemBuf]
mov	[bp+varBuffer],	ax
mov	[bp+varBytes], 32768
jmp	short loc_153FC	; Jump

ReadLbxMemberData:	; CODE XREF: LBX_Load_Entry+3C3j
			; LBX_Load_Entry+3CCj
sub	[bp+var_idkMemberSize],	32768 ;	Maybe this is calculating how many 32K chunks to read, for the loop count?
			;
			; [NOTE(JWB): 32,768 (32KB) is the largest power of two	that can be represented	in 16 bits.]
			;
			; [bp+var_idkMemberSize] = ([bp+var_idkMemberSize] - 32,768)
			; sets the OF and CF flags to indicate a borrow	in the signed or unsigned result, respectively
			; SF flag indicates the	sign of	the signed result
			;
sbb	[word ptr bp+var2_SI], 0 ; Subtract with Borrow
			;
			;
			;
			;
push	[g_CurrentLbxFileHandle] ; Buffer
push	[bp+varBytes]	; Bytes
			; 064 mov     [bp+varBytes], 32768
push	[bp+varBuffer]	; Handle
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short SUCCESS_DOS_fread	; Jump if Not Zero (ZF=0)
push	di		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SUCCESS_DOS_fread:	; CODE XREF: LBX_Load_Entry+3AAj
add	[bp+varBuffer],	2048 ; Add

loc_153FC:		; CODE XREF: LBX_Load_Entry+38Bj
cmp	[word ptr bp+var2_SI], 0 ;
			; 2020-12-18:
			; ...still no thoughts on the 'add 2048'
			; Otherwise, now I am thinking that LDIV turns into
			;  the number of iterations and	the other one is the
			;  'bytes remaining'
			; Then,	they loop that many times at 32KB
			; and on-exit they check if 32KB remains and
			;  just	run that loop manually one more	time or
			;  they	change the 'byte to read' to exactly the
			;  'bytes remaining' and read the balance.
			; Not sure how that would look in-the-code, but
			; I did	something similar in the ATS CRC32 function.
jg	short ReadLbxMemberData	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_1540B	; Jump if Less (SF!=OF)
cmp	[bp+var_idkMemberSize],	32768 ;	32,768 - [bp+var_idkMemberSize]
jnb	short ReadLbxMemberData	; Jump if Not Below (CF=0)

loc_1540B:		; CODE XREF: LBX_Load_Entry+3C5j
cmp	[word ptr bp+var2_SI], 0 ; Compare Two Operands
jl	short loc_15443	; Jump if Less (SF!=OF)
jg	short Read_LTE_32KB ; Jump if Greater (ZF=0 & SF=OF)
cmp	[bp+var_idkMemberSize],	0 ; Compare Two	Operands
jbe	short loc_15443	; Jump if Below	or Equal (CF=1 | ZF=1)

Read_LTE_32KB:		; CODE XREF: LBX_Load_Entry+3D4j
mov	ax, [bp+var_idkMemberSize]
mov	[bp+varBytes], ax
push	[g_CurrentLbxFileHandle] ; argFileHandle
push	[bp+varBytes]	; argBytes
push	[bp+varBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15443	; Jump if Not Zero (ZF=0)

READ_FAILURE:		; argLbxEntryNumber
push	di
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15443:		; CODE XREF: LBX_Load_Entry+76j
			; LBX_Load_Entry+3D2j
			; LBX_Load_Entry+3DAj
			; LBX_Load_Entry+3F6j
call	ST_UpdateWorstFreeKb ; Call Procedure
mov	ax, [bp+varLbxMemBuf]
jmp	short $+2	; Jump
pop	di
pop	si_argLbxFileName
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_Entry ; sp-analysis failed



; Attributes: bp-based frame

proc LBX_Load_s15453 far
			; CODE XREF: LBX_PreLoad_s15453+1Ap
			; LBX_Load_s14F9E+1Bp
			; LBX_Load_s14FC1+1Bp

varDst=	byte ptr -84h
varChrPtrDst= byte ptr -34h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
varMbrOffEnd1= word ptr	-1Ah
varMbrOffBeg2= word ptr	-18h
varMbrOffBeg1= word ptr	-16h
var0_offsetDX= word ptr	-14h
var2_offsetCX= word ptr	-12h
varEntryOffsetEnd= word	ptr -10h
varBytes= word ptr -0Eh
varBuffer= word	ptr -0Ch
varBytesToAllocate= word ptr -0Ah
varEntryOffsetStart= word ptr -8
var_6= word ptr	-6
varMemberOffset= word ptr -4
var_2= word ptr	-2
argString_DI= word ptr	6
argLbxName_SI= word ptr	 8
arg0_DestES= dword ptr	0Ah
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
sub	sp, 84h		; argSrc
push	si		; src
push	di		; src


mov	di, [bp+argString_DI]
mov	si, [bp+argLbxName_SI]


or	si, si		; Logical Inclusive OR
jge	short loc_15474	; Jump if Greater or Equal (SF=OF)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15474:		; CODE XREF: LBX_Load_s15453+11j
cmp	[LBX_FLAG_NoMalloc], 0 ; Compare Two Operands
jnz	short loc_1548E	; Jump if Not Zero (ZF=0)
mov	[LBX_FLAG_NoMalloc], 1
mov	ax, 32
push	ax		; argKiloBytes
call	ST_FarMalloc	; Call Procedure
pop	cx
mov	[g_ptrBufferReadFile], ax

loc_1548E:		; CODE XREF: LBX_Load_s15453+26j
push	di		; argNameCharArr
nop			; No Operation
push	cs
call	near ptr ST_RemoveExtensionUppercaseName ; Call	Procedure
pop	cx
push	[bp+arg_C]
push	[bp+arg_A]
push	[bp+arg_8]
push	[word ptr bp+arg0_DestES+2]
push	[word ptr bp+arg0_DestES]
push	si
push	di
call	idk_PreEmmPgCnt	; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_2], ax
mov	[bp+var_6], 0
cmp	[bp+var_2], 0	; Compare Two Operands
jz	short loc_154BF	; Jump if Zero (ZF=1)
jmp	loc_1590B	; Jump

loc_154BF:		; CODE XREF: LBX_Load_s15453+67j
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     [g_CurrentLbxFileHandle], 0FFFFh	; Compare Two Operands
jz	short loc_154E1	; Jump if Zero (ZF=1)
mov	ax, offset g_CurrentLbxFileNameBase
push	ax
push	di		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_154E1	; Jump if Not Zero (ZF=0)
mov	ax, [g_CurrentLbxFilePosition]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_154E1	; Jump if Not Zero (ZF=0)

j_TEST_ENTRY_COUNT:	; Jump
jmp	TEST_ENTRY_COUNT

loc_154E1:		; CODE XREF: LBX_Load_s15453+71j
			; LBX_Load_s15453+81j
			; LBX_Load_s15453+89j
mov	ax, [bp+var_6]
mov	[g_CurrentLbxFilePosition], ax
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     [g_CurrentLbxFileHandle], 0FFFFh	; Compare Two Operands
jz	short loc_154F8	; Jump if Zero (ZF=1)
push	[g_CurrentLbxFileHandle]
call	DOS_CloseFileWithHandle	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   argFileHandle = BX = file handle
pop	cx

loc_154F8:		; CODE XREF: LBX_Load_s15453+99j
push	di
mov	ax, offset g_CurrentLbxFileNameBase ; argSrc
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
push	di		; argSrc
lea	ax, [bp+varChrPtrDst] ;	Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax		; argSrc
lea	ax, [bp+varChrPtrDst] ;	Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varChrPtrDst] ;	Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[g_CurrentLbxFileHandle], ax
cmp	[g_CurrentLbxFileHandle], 0 ; Compare Two Operands
jnz	short loc_1558B	; Jump if Not Zero (ZF=0)
cmp	[byte ptr g_LbxDirectoryPath], 0 ; Compare Two Operands
jnz	short loc_15548	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15548:		; CODE XREF: LBX_Load_s15453+E5j
mov	ax, offset g_LbxDirectoryPath
push	ax		; argSrc
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+varChrPtrDst] ;	Load Effective Address
push	ax		; argSrc
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varDst]	; Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[g_CurrentLbxFileHandle], ax
cmp	[g_CurrentLbxFileHandle], 0 ; Compare Two Operands
jnz	short loc_1558B	; Jump if Not Zero (ZF=0)

NOT_FOUND:		; argLbxEntryNumber
push	si
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1558B:		; CODE XREF: LBX_Load_s15453+DEj
			; LBX_Load_s15453+128j
cmp	[g_CurrentLbxFileHandle], 0 ; Compare Two Operands
jnz	short SEEK_0	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SEEK_0:			; CODE XREF: LBX_Load_s15453+13Dj
mov	[bp+var2_offsetCX], 0
mov	[bp+var0_offsetDX], 0
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+var2_offsetCX] ; arg2_OffsetHigh
push	[bp+var0_offsetDX] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short READ_LBX_HEADER ;	Jump if	Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
jmp	short READ_TEST_MAGSIG ; Jump

READ_LBX_HEADER:	; CODE XREF: LBX_Load_s15453+16Bj
push	[g_CurrentLbxFileHandle] ; argFileHandle
mov	ax, 512
push	ax		; argBytes
push	[g_ptrBufferReadFile] ;	argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

READ_TEST_MAGSIG:	; CODE XREF: LBX_Load_s15453+178j
add	sp, 6		; Add
mov	ax, 2
push	ax
push	[g_ptrBufferReadFile] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, e_LBX_MagSig ; Check SimTex	LBX File Type ID
jz	short READ_ENTRY_COUNT ; Jump if Zero (ZF=1)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_AN_LBX ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation

loc_155FC:
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

READ_ENTRY_COUNT:	; CODE XREF: LBX_Load_s15453+1A0j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[g_ptrBufferReadFile] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[g_CurrentLbxEntryCount], ax

TEST_ENTRY_COUNT:	; CODE XREF: LBX_Load_s15453:j_TEST_ENTRY_COUNTj
cmp	si, [g_CurrentLbxEntryCount] ; Compare Two Operands
jl	short MemberOffsetMath ; Jump if Less (SF!=OF)
push	si		; argLbxEntryNumber
mov	ax, e_EXCEEDS_LBX_ENTRIES ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

MemberOffsetMath:	; CODE XREF: LBX_Load_s15453+1C5j
mov	ax, si
mov	cl, 2		; arg4_LbxEntryNumber
shl	ax, cl		; Shift	Logical	Left
add	ax, 8		; Add
mov	[bp+varMemberOffset], ax
push	[bp+varMemberOffset]
push	[g_ptrBufferReadFile]
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+varMbrOffBeg1], dx
mov	[bp+varMbrOffBeg2], ax
mov	ax, [bp+varMemberOffset]
add	ax, 4		; Add
push	ax
push	[g_ptrBufferReadFile]
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+varMbrOffEnd1], dx
mov	[bp+var_1C], ax
mov	ax, [bp+varMbrOffEnd1]
mov	dx, [bp+var_1C]
sub	dx, [bp+varMbrOffBeg2] ; arg2_ErrNo
sbb	ax, [bp+varMbrOffBeg1] ; Integer Subtraction with Borrow
mov	[bp+var_1E], ax
mov	[bp+var_20], dx
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+varMbrOffBeg1] ; arg2_OffsetHigh
push	[bp+varMbrOffBeg2] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15699	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber

loc_15689:
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName

loc_15690:		; arg6_MemShort
push	ax
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15699:		; CODE XREF: LBX_Load_s15453+233j
push	[g_CurrentLbxFileHandle] ; argFileHandle
mov	ax, 2
push	ax		; argByteCount
lea	ax, [bp+varEntryOffsetStart] ; Load Effective Address
push	ax		; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
push	[g_CurrentLbxFileHandle] ; argFileHandle
mov	ax, 2
push	ax		; argByteCount
lea	ax, [bp+varEntryOffsetEnd] ; Load Effective Address
push	ax		; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
cmp	[bp+varEntryOffsetEnd],	0 ; Compare Two	Operands
jz	short loc_156CF	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_C]
cmp	ax, [bp+varEntryOffsetEnd] ; Compare Two Operands
jz	short loc_156E0	; Jump if Zero (ZF=1)

loc_156CF:		; CODE XREF: LBX_Load_s15453+272j
push	si		; argLbxEntryNumber
mov	ax, e_INCORRECT_RECORD_SIZE
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_156E0:		; CODE XREF: LBX_Load_s15453+27Aj
mov	ax, [bp+arg_8]
add	ax, [bp+arg_A]	; Add
cmp	ax, [bp+varEntryOffsetStart] ; Compare Two Operands
jbe	short loc_156FC	; Jump if Below	or Equal (CF=1 | ZF=1)
push	si		; argLbxEntryNumber
mov	ax, e_EXCEEDS_DEFINED_RECORDS
push	ax		; ErrNo

loc_156F0:		; arg0_LbxFileName
mov	ax, offset g_CurrentLbxFileNameBase
push	ax		; arg6_MemShort

loc_156F4:		; No Operation
nop
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_156FC:		; CODE XREF: LBX_Load_s15453+296j
mov	bx, [bp+arg_8]
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+varEntryOffsetEnd]
xor	dx, dx		; Logical Exclusive OR
call	LXMUL@		; Call Procedure
add	ax, 4		; Add
adc	dx, 0		; arg2_ErrNo
add	[bp+varMbrOffBeg2], ax ; Add
adc	[bp+varMbrOffBeg1], dx ; Add with Carry
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+varMbrOffBeg1] ; arg2_OffsetHigh
push	[bp+varMbrOffBeg2] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1573E	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1573E:		; CODE XREF: LBX_Load_s15453+2D8j
mov	bx, [bp+arg_A]
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+varEntryOffsetEnd]
xor	dx, dx		; Logical Exclusive OR
call	LXMUL@		; Call Procedure
mov	[bp+var_1E], dx
mov	[bp+var_20], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 10h		; arg2_ErrNo
push	ax
push	dx		; arg2_SI
push	[bp+var_1E]
push	[bp+var_20]	; int
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
inc	ax		; ?add a paragraph?
mov	[bp+varBytesToAllocate], ax
mov	ax, [word ptr bp+arg0_DestES+2]
or	ax, ax		; Logical Inclusive OR
jz	short loc_15780	; Jump if Zero (ZF=1)

loc_15770:		; Compare Two Operands
cmp	ax, 1
jz	short loc_157A3	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jnz	short loc_1577D	; Jump if Not Zero (ZF=0)
jmp	loc_15812	; Jump

loc_1577D:		; CODE XREF: LBX_Load_s15453+325j
jmp	loc_15885	; Jump

loc_15780:		; CODE XREF: LBX_Load_s15453+31Bj
push	[bp+varBytesToAllocate]
call	malloc_s14954	; Call Procedure
pop	cx
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_157A0	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_INSUFFICIENT_MEMORY ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_157A0:		; CODE XREF: LBX_Load_s15453+33Dj
jmp	loc_15885	; int

loc_157A3:		; CODE XREF: LBX_Load_s15453+320j
push	[word ptr bp+arg0_DestES] ; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_157BE	; Jump if Not Zero (ZF=0)

loc_157B0:		; argLbxEntryNumber
push	si
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_157BE:		; CODE XREF: LBX_Load_s15453+35Bj
mov	ax, 8
push	ax

loc_157C2:		; argOffset
push	[word ptr bp+arg0_DestES]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
dec	ax		; Decrement by 1
cmp	ax, [bp+varBytesToAllocate] ; Compare Two Operands
jnb	short loc_157F5	; Jump if Not Below (CF=0)
mov	ax, 8
push	ax
push	[word ptr bp+arg0_DestES] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varBytesToAllocate]
sub	dx, ax		; Integer Subtraction
inc	dx		; arg2_ErrNo
push	dx		; int
push	si		; argLbxEntryNumber
mov	ax, e_MISALLOCATED ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 8		; Add

loc_157F5:		; CODE XREF: LBX_Load_s15453+37Dj
mov	ax, [word ptr bp+arg0_DestES]
inc	ax		; Increment by 1
mov	[bp+var_2], ax
mov	ax, [bp+varBytesToAllocate]
inc	ax		; Increment by 1
push	ax		; argValue

loc_15801:		; CODE XREF: LBX_Load_s15453+42Fj
mov	ax, 10
push	ax		; argOffset
push	[word ptr bp+arg0_DestES] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
jmp	short loc_15885	; int

loc_15812:		; CODE XREF: LBX_Load_s15453+327j
push	[word ptr bp+arg0_DestES] ; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1582D	; Jump if Not Zero (ZF=0)

loc_1581F:		; argLbxEntryNumber
push	si

loc_15820:		; arg0_LbxFileName
mov	ax, e_CORRUPTED
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1582D:		; CODE XREF: LBX_Load_s15453+3CAj
push	[word ptr bp+arg0_DestES]
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
cmp	ax, [bp+varBytesToAllocate] ; Compare Two Operands
jnb	short loc_15858	; Jump if Not Below (CF=0)
push	[word ptr bp+arg0_DestES]
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
mov	dx, [bp+varBytesToAllocate]
sub	dx, ax		; arg2_ErrNo
push	dx		; int
push	si		; argLbxEntryNumber
mov	ax, e_ALLOCATION_TOO_SMALL ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 8		; Add

loc_15858:		; CODE XREF: LBX_Load_s15453+3E6j
mov	ax, 10
push	ax
push	[word ptr bp+arg0_DestES] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [word ptr bp+arg0_DestES]
add	dx, ax		; Add
mov	[bp+var_2], dx
mov	ax, 10
push	ax
push	[word ptr bp+arg0_DestES] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varBytesToAllocate]
add	dx, ax		; arg2_ErrNo
push	dx
jmp	loc_15801	; int

loc_15885:		; CODE XREF: LBX_Load_s15453:loc_1577Dj
			; LBX_Load_s15453:loc_157A0j
			; LBX_Load_s15453+3BDj
mov	ax, [bp+var_2]
mov	[bp+varBuffer],	ax
mov	[bp+varBytes], 32768

loc_15890:		; Jump
jmp	short loc_158C4

loc_15892:		; CODE XREF: LBX_Load_s15453+475j
			; LBX_Load_s15453+47Ej
sub	[bp+var_20], 32768 ; Integer Subtraction
sbb	[bp+var_1E], 0	; Integer Subtraction with Borrow

loc_1589B:		; argFileHandle
push	[g_CurrentLbxFileHandle]
push	[bp+varBytes]	; argBytes
push	[bp+varBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_158BF	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_158BF:		; CODE XREF: LBX_Load_s15453+45Cj
add	[bp+varBuffer],	2048 ; Add

loc_158C4:		; CODE XREF: LBX_Load_s15453:loc_15890j
cmp	[bp+var_1E], 0	; Compare Two Operands
jg	short loc_15892	; Jump if Greater (ZF=0	& SF=OF)

loc_158CA:		; Jump if Less (SF!=OF)
jl	short loc_158D3
cmp	[bp+var_20], 8000h ; Compare Two Operands
jnb	short loc_15892	; Jump if Not Below (CF=0)

loc_158D3:		; CODE XREF: LBX_Load_s15453:loc_158CAj
cmp	[bp+var_1E], 0	; Compare Two Operands
jl	short loc_1590B	; Jump if Less (SF!=OF)
jg	short loc_158E1	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_20], 0	; Compare Two Operands
jbe	short loc_1590B	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_158E1:		; CODE XREF: LBX_Load_s15453+486j
mov	ax, [bp+var_20]
mov	[bp+varBytes], ax
push	[g_CurrentLbxFileHandle] ; argFileHandle
push	[bp+varBytes]	; argBytes
push	[bp+varBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1590B	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1590B:		; CODE XREF: LBX_Load_s15453+69j
			; LBX_Load_s15453+484j
			; LBX_Load_s15453+48Cj
			; LBX_Load_s15453+4A8j
call	ST_UpdateWorstFreeKb ; Call Procedure
mov	ax, [bp+var_2]
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_s15453 ; sp-analysis failed



; Attributes: bp-based frame

; int __fastcall __far LBX_Load_HelpNewTerrCity(int, int, int, int, int, int, int, int,	int)
proc LBX_Load_HelpNewTerrCity far
			; CODE XREF: LBX_HelpEntry_s13EEE+1AP
			; LBX_HelpEntry_s3D9F3+1AP
			; LBX_NewGame_s41A5F+1B2P
			; LBX_HelpEntry_s433B8+1AP
			; LBX_HelpEntry_s433EB+1AP
			; LBX_HelpEntry_s4341E+1AP
			; LBX_HelpEntry_s43451+1AP
			; LBX_HelpEntry_s43484+1AP
			; LBX_HelpEntry_s434C3+1AP
			; LBX_HelpEntry_s434F6+1AP
			; LBX_Terrtype_s472C7+2AP
			; LBX_Terrtype_s4763F+2AP
			; LBX_Terrtype_s48821+2AP
			; LBX_Cityname_s4B973+27P
			; LBX_Cityname_s4B973+ADP
			; idk_OVR_LoadLbxHelp:loc_55D8DP
			; idk_OVR_LoadLbxHelp+268P
			; idk_OVR_LoadLbxHelp:loc_56014P

argDest= byte ptr -80h
argDst=	byte ptr -30h
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
arg0_OffsetLow=	word ptr -10h
arg2_OffsetHigh= word ptr -0Eh
var_C= word ptr	-0Ch
argByteCount= word ptr -0Ah
argBuffer= word	ptr -8
var_6_ZERO= word ptr -6
var_4= word ptr	-4
var_2= word ptr	-2
argString= word	ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 80h		; Integer Subtraction
push	si
push	di
mov	di, [bp+argString]
mov	si, [bp+arg_2]
or	si, si		; Logical Inclusive OR
jge	short loc_1593C	; Jump if Greater or Equal (SF=OF)
push	si		; argLbxEntryNumber

loc_1592F:		; arg0_LbxFileName
mov	ax, e_NOT_FOUND
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1593C:		; CODE XREF: LBX_Load_HelpNewTerrCity+11j
cmp	[LBX_FLAG_NoMalloc], 0 ; Compare Two Operands
jnz	short loc_15956	; Jump if Not Zero (ZF=0)
mov	[LBX_FLAG_NoMalloc], 1
mov	ax, 32
push	ax		; argKiloBytes
call	ST_FarMalloc	; Call Procedure
pop	cx
mov	[g_ptrBufferReadFile], ax

loc_15956:		; CODE XREF: LBX_Load_HelpNewTerrCity+26j
push	di		; argNameCharArr
nop			; No Operation
push	cs
call	near ptr ST_RemoveExtensionUppercaseName ; Call	Procedure
pop	cx
push	[bp+arg_A]
push	[bp+arg_8]
push	[bp+arg_6]
push	[bp+arg_4]
push	si
push	di
call	EMS_s17408	; Call Procedure
add	sp, 0Ch		; Add
mov	[bp+var_2], ax
mov	[bp+var_6_ZERO], 0
cmp	[bp+var_2], 0	; Compare Two Operands
jz	short loc_15984	; Jump if Zero (ZF=1)
jmp	loc_15C3F	; Jump

loc_15984:		; CODE XREF: LBX_Load_HelpNewTerrCity+64j
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     [g_CurrentLbxFileHandle], 0FFFFh	; Compare Two Operands
jz	short loc_159A6	; Jump if Zero (ZF=1)
mov	ax, offset g_CurrentLbxFileNameBase
push	ax
push	di		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_159A6	; Jump if Not Zero (ZF=0)
mov	ax, [g_CurrentLbxFilePosition]
cmp	ax, [bp+var_6_ZERO] ; Compare Two Operands
jnz	short loc_159A6	; Jump if Not Zero (ZF=0)
jmp	loc_15AC1	; Jump

loc_159A6:		; CODE XREF: LBX_Load_HelpNewTerrCity+6Ej
			; LBX_Load_HelpNewTerrCity+7Ej
			; LBX_Load_HelpNewTerrCity+86j
mov	ax, [bp+var_6_ZERO]
mov	[g_CurrentLbxFilePosition], ax
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     [g_CurrentLbxFileHandle], 0FFFFh	; Compare Two Operands
jz	short loc_159BD	; Jump if Zero (ZF=1)
push	[g_CurrentLbxFileHandle]
call	DOS_CloseFileWithHandle	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   argFileHandle = BX = file handle
pop	cx

loc_159BD:		; CODE XREF: LBX_Load_HelpNewTerrCity+96j
push	di
mov	ax, 0A5CCh
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
push	di
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[g_CurrentLbxFileHandle], ax
cmp	[g_CurrentLbxFileHandle], 0 ; Compare Two Operands
jnz	short loc_15A4D	; Jump if Not Zero (ZF=0)
cmp	[byte ptr g_LbxDirectoryPath], 0 ; Compare Two Operands
jnz	short loc_15A0D	; Jump if Not Zero (ZF=0)

loc_159FF:		; argLbxEntryNumber
push	si
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo

loc_15A04:		; arg6_MemShort
push	di

loc_15A05:		; No Operation
nop
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15A0D:		; CODE XREF: LBX_Load_HelpNewTerrCity+E2j
mov	ax, offset g_LbxDirectoryPath
push	ax		; argSrc
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argSrc
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[g_CurrentLbxFileHandle], ax
cmp	[g_CurrentLbxFileHandle], 0 ; Compare Two Operands
jnz	short loc_15A4D	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber

loc_15A40:		; arg0_LbxFileName
mov	ax, e_NOT_FOUND
push	ax		; ErrNo
push	di		; arg6_MemShort

loc_15A45:		; No Operation
nop
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15A4D:		; CODE XREF: LBX_Load_HelpNewTerrCity+DBj
			; LBX_Load_HelpNewTerrCity+122j
mov	[bp+arg2_OffsetHigh], 0
mov	[bp+arg0_OffsetLow], 0
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+arg2_OffsetHigh] ; arg2_OffsetHigh
push	[bp+arg0_OffsetLow] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15A7A	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
jmp	short loc_15A8B	; Jump

loc_15A7A:		; CODE XREF: LBX_Load_HelpNewTerrCity+150j
push	[g_CurrentLbxFileHandle] ; argFileHandle
mov	ax, 512
push	ax		; argBytes
push	[g_ptrBufferReadFile] ;	argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

loc_15A8B:		; CODE XREF: LBX_Load_HelpNewTerrCity+15Dj
add	sp, 6		; Add
mov	ax, 2
push	ax
push	[g_ptrBufferReadFile] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, e_LBX_MagSig ; Check SimTex	LBX File Type ID
jz	short loc_15AB0	; Jump if Zero (ZF=1)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_AN_LBX ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15AB0:		; CODE XREF: LBX_Load_HelpNewTerrCity+185j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[g_ptrBufferReadFile] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[g_CurrentLbxEntryCount], ax

loc_15AC1:		; CODE XREF: LBX_Load_HelpNewTerrCity+88j
cmp	si, [g_CurrentLbxEntryCount] ; Compare Two Operands
jl	short loc_15AD5	; Jump if Less (SF!=OF)
push	si		; argLbxEntryNumber
mov	ax, e_EXCEEDS_LBX_ENTRIES ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15AD5:		; CODE XREF: LBX_Load_HelpNewTerrCity+1AAj
mov	ax, si
mov	cl, 2		; arg4_LbxEntryNumber
shl	ax, cl		; Shift	Logical	Left
add	ax, 8		; Add
mov	[bp+var_4], ax
push	[bp+var_4]
push	[g_ptrBufferReadFile]
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_12], dx
mov	[bp+var_14], ax
mov	ax, [bp+var_4]
add	ax, 4		; Add
push	ax
push	[g_ptrBufferReadFile]
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_16], dx
mov	[bp+var_18], ax
mov	ax, [bp+var_16]
mov	dx, [bp+var_18]
sub	dx, [bp+var_14]	; arg2_ErrNo
sbb	ax, [bp+var_12]	; Integer Subtraction with Borrow
mov	[bp+var_1A], ax
mov	[bp+var_1C], dx
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+var_12]	; arg2_OffsetHigh
push	[bp+var_14]	; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short SEEK_SUCCESS ; Jump if Not Zero (ZF=0)

SEEK_FAILURE:		; argLbxEntryNumber
push	si
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SEEK_SUCCESS:		; CODE XREF: LBX_Load_HelpNewTerrCity+218j
push	[g_CurrentLbxFileHandle] ; argFileHandle
mov	ax, 2
push	ax		; argByteCount
lea	ax, [bp+argBuffer] ; Load Effective Address
push	ax		; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
push	[g_CurrentLbxFileHandle] ; argFileHandle
mov	ax, 2
push	ax		; argByteCount
lea	ax, [bp+var_C]	; Load Effective Address
push	ax		; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
cmp	[bp+var_C], 0	; Compare Two Operands
jz	short loc_15B7C	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_A]
cmp	ax, [bp+var_C]	; Compare Two Operands
jz	short loc_15B8D	; Jump if Zero (ZF=1)

loc_15B7C:		; CODE XREF: LBX_Load_HelpNewTerrCity+257j
push	si		; argLbxEntryNumber
mov	ax, e_INCORRECT_RECORD_SIZE
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15B8D:		; CODE XREF: LBX_Load_HelpNewTerrCity+25Fj
mov	ax, [bp+arg_6]
add	ax, [bp+arg_8]	; Add
cmp	ax, [bp+argBuffer] ; Compare Two Operands
jbe	short loc_15BA9	; Jump if Below	or Equal (CF=1 | ZF=1)
push	si		; argLbxEntryNumber
mov	ax, e_EXCEEDS_DEFINED_RECORDS
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15BA9:		; CODE XREF: LBX_Load_HelpNewTerrCity+27Bj
mov	ax, [bp+arg_6]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_C]
push	dx
xor	dx, dx		; Logical Exclusive OR
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
add	ax, 4		; Add
adc	dx, 0		; arg2_ErrNo
add	[bp+var_14], ax	; Add
adc	[bp+var_12], dx	; Add with Carry
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+var_12]	; arg2_OffsetHigh
push	[bp+var_14]	; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15BEE	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15BEE:		; CODE XREF: LBX_Load_HelpNewTerrCity+2C0j
mov	ax, [bp+arg_8]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_C]
push	dx
xor	dx, dx		; Logical Exclusive OR
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
mov	[bp+var_1A], dx
mov	[bp+var_1C], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 0EA60h	; arg2_ErrNo
push	ax
push	dx
push	[bp+var_1A]
push	[bp+var_1C]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
mov	[bp+argByteCount], ax
push	[g_CurrentLbxFileHandle] ; argFileHandle
push	[bp+argByteCount] ; argByteCount
push	[bp+arg_4]	; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15C3F	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15C3F:		; CODE XREF: LBX_Load_HelpNewTerrCity+66j
			; LBX_Load_HelpNewTerrCity+314j
call	ST_UpdateWorstFreeKb ; Call Procedure
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_HelpNewTerrCity ;	sp-analysis failed



; LBX_Load_Entry_4bytes(0,
;			var_E,
;			arg0_OffsetLow,
;			g_IntroLbxEntryNumber,
;			g_IntroLbxFileName)
; Attributes: bp-based frame

; int __fastcall __far LBX_Load_Entry_4bytes(int, int, int, int, int, int, int,	int)
proc LBX_Load_Entry_4bytes far
			; CODE XREF: LBX_AllocMem+B4P
			; LBX_s16A80+B4P
			; LBX_MemAndRead+35P

argDest= byte ptr -70h
argDst=	byte ptr -20h
arg0_OffsetLow=	word ptr -0Ch
arg2_OffsetHigh= word ptr -0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
varFlag_0_1= word ptr -2
arg_g_IntroLbxFileName=	word ptr  6
arg_g_IntroLbxEntryNumber= word	ptr  8
arg_RecordOffsetStart= word ptr	 0Ah
arg_RecordOffsetEnd= word ptr  0Ch
arg_8_ZERO= word ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 112		; argSrc
push	si		; src
push	di		; src
mov	si, [bp+arg_g_IntroLbxFileName]
mov	di, [bp+arg_g_IntroLbxEntryNumber]
or	di, di		; If (AX == 0) Then Set	(ZF = 1)
jge	short loc_15C6A	; Jump if Greater or Equal (SF=OF)
push	di		; argLbxName
mov	ax, e_NOT_FOUND	; Case 0x0: Not	Found
push	ax		; argLbxErrorNumber
push	si		; argLbxEntryNumber
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15C6A:		; CODE XREF: LBX_Load_Entry_4bytes+10j
cmp	[LBX_FLAG_NoMalloc], 0 ; If (AX	!= 0) Then Set (ZF = 1)
jnz	short UPPERCASE	; Jump if Not Zero (ZF=0)
mov	[LBX_FLAG_NoMalloc], 1
mov	ax, 32
push	ax		; argKiloBytes
call	ST_FarMalloc	; Call Procedure
pop	cx
mov	[g_ptrBufferReadFile], ax

UPPERCASE:		; CODE XREF: LBX_Load_Entry_4bytes+25j
push	si		; argNameCharArr
nop			; No Operation
push	cs
call	near ptr ST_RemoveExtensionUppercaseName ; Call	Procedure
pop	cx
cmp	[bp+arg_8_ZERO], 0 ; Compare Two Operands
jz	short loc_15C98	; Jump if Zero (ZF=1)
cmp	[LBX_Flag_w35B7A], 2 ; Compare Two Operands
jnz	short NOT_TWO	; Jump if Not Zero (ZF=0)

loc_15C98:		; CODE XREF: LBX_Load_Entry_4bytes+45j
mov	[bp+varFlag_0_1], 0
jmp	short loc_15CA4	; Jump

NOT_TWO:		; CODE XREF: LBX_Load_Entry_4bytes+4Cj
mov	[bp+varFlag_0_1], 1

loc_15CA4:		; CODE XREF: LBX_Load_Entry_4bytes+53j
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     [g_CurrentLbxFileHandle], 0FFFFh	; Compare Two Operands
jz	short OPEN_DIFFERENT_LBX ; Jump	if Zero	(ZF=1)
mov	ax, offset g_CurrentLbxFileNameBase
push	ax
push	si		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short OPEN_DIFFERENT_LBX ; Jump	if Not Zero (ZF=0)

REQUESTED_LBX_IS_GLOBAL_LBX:
mov	ax, [g_CurrentLbxFilePosition]
cmp	ax, [bp+varFlag_0_1] ; Compare Two Operands
jnz	short OPEN_DIFFERENT_LBX ; Jump	if Not Zero (ZF=0)

REQUESTED_POS_IS_GLOBAL_POS: ; Jump
jmp	CHECK_ENTRYCOUNT

OPEN_DIFFERENT_LBX:	; CODE XREF: LBX_Load_Entry_4bytes+5Fj
			; LBX_Load_Entry_4bytes+6Fj
			; LBX_Load_Entry_4bytes+77j
mov	ax, [bp+varFlag_0_1]
mov	[g_CurrentLbxFilePosition], ax
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     [g_CurrentLbxFileHandle], 0FFFFh	; Compare Two Operands
jz	short CONTINUE_NO_GLOBAL_LBX_HANDLE ; Jump if Zero (ZF=1)

CLOSE_GLOBAL_LBX_HANDLE:
push	[g_CurrentLbxFileHandle]
call	DOS_CloseFileWithHandle	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   argFileHandle = BX = file handle
pop	cx

CONTINUE_NO_GLOBAL_LBX_HANDLE:
			; CODE XREF: LBX_Load_Entry_4bytes+87j
push	si
mov	ax, offset g_CurrentLbxFileNameBase
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
push	si
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[g_CurrentLbxFileHandle], ax
cmp	[g_CurrentLbxFileHandle], 0 ; If (AX !=	0) Then	Set (ZF	= 1)
jnz	short SUCCESS_OPEN_FILE	; Jump if Not Zero (ZF=0)

FAILURE_OPEN_FILE:	; Compare Two Operands
cmp	[byte ptr g_LbxDirectoryPath], 0
jnz	short loc_15D2D	; Jump if Not Zero (ZF=0)
push	di
mov	ax, e_NOT_FOUND	; Case 0x0: Not	Found
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15D2D:		; CODE XREF: LBX_Load_Entry_4bytes+D3j
mov	ax, offset g_LbxDirectoryPath
push	ax
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[g_CurrentLbxFileHandle], ax
cmp	[g_CurrentLbxFileHandle], 0 ; If (AX !=	0) Then	Set (ZF	= 1)
jnz	short SUCCESS_OPEN_FILE	; Jump if Not Zero (ZF=0)
push	di
mov	ax, e_NOT_FOUND	; Case 0x0: Not	Found
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SUCCESS_OPEN_FILE:	; CODE XREF: LBX_Load_Entry_4bytes+CCj
			; LBX_Load_Entry_4bytes+113j
cmp	[g_CurrentLbxFilePosition], 0 ;	If (AX != 0) Then Set (ZF = 1)
jz	short loc_15D80	; Jump if Zero (ZF=1)
mov	[bp+arg2_OffsetHigh], 0
mov	[bp+arg0_OffsetLow], 512
jmp	short LSEEK	; Jump

loc_15D80:		; CODE XREF: LBX_Load_Entry_4bytes+128j
mov	[bp+arg2_OffsetHigh], 0
mov	[bp+arg0_OffsetLow], 0

LSEEK:			; CODE XREF: LBX_Load_Entry_4bytes+134j
push	[g_CurrentLbxFileHandle] ; arg4_FileHandle
push	[bp+arg2_OffsetHigh] ; arg2_OffsetHigh
push	[bp+arg0_OffsetLow] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ;
			; CX:DX	= (signed) offset, from	origin,	of new file position
			; CX:DX	     Offset, in	bytes (signed 32-bit integer)
			; cx = 0 - positive offset 0x0000FFFD (65533)
			;
add	sp, 6		; Add
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short LSEEK_SUCCESS ; Jump if Not Zero (ZF=0)

LSEEK_FAILURE:
push	di
mov	ax, e_CORRUPTED	; Case 0x1: Corrupted
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
jmp	short Check_LBX_MagSig ; Jump

LSEEK_SUCCESS:		; CODE XREF: LBX_Load_Entry_4bytes+154j
push	[g_CurrentLbxFileHandle] ; argFileHandle
mov	ax, 512
push	ax		; argBytes
push	[g_ptrBufferReadFile] ;	argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

Check_LBX_MagSig:	; CODE XREF: LBX_Load_Entry_4bytes+161j
add	sp, 6		; Add
mov	ax, 2
push	ax
push	[g_ptrBufferReadFile] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, e_LBX_MagSig ; Check SimTex	LBX File Type ID
jz	short VALID_LBX	; Jump if Zero (ZF=1)
push	di
mov	ax, e_NOT_AN_LBX ; Case	0x6: Invalid LBX
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

VALID_LBX:		; CODE XREF: LBX_Load_Entry_4bytes+189j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[g_ptrBufferReadFile] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[g_CurrentLbxEntryCount], ax

CHECK_ENTRYCOUNT:	; CODE XREF: LBX_Load_Entry_4bytes:REQUESTED_POS_IS_GLOBAL_POSj
cmp	di, [g_CurrentLbxEntryCount] ; Compare Two Operands
jl	short ENTRYCOUNT_OK ; Jump if Less (SF!=OF)
push	di
mov	ax, e_EXCEEDS_LBX_ENTRIES ; Case 0x7: Exceeds Entry Count
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add
Calculate offset into Offset Table, for	Entry Number
Read Record Offset Start
Read Record Offset End

ENTRYCOUNT_OK:		; CODE XREF: LBX_Load_Entry_4bytes+1AEj
mov	ax, di
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
add	ax, 8		; Add
mov	[bp+var_4], ax	; ...calculated	offset,	based on Entry Number
push	[bp+var_4]
push	[g_ptrBufferReadFile]
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	bx, [bp+arg_RecordOffsetStart]
mov	[bx+2],	dx	; ...something high offset/addres
mov	[bx], ax	; ...something low offset/addres
mov	ax, [bp+var_4]
add	ax, 4		; Add
push	ax
push	[g_ptrBufferReadFile]
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_6], dx
mov	[bp+var_8], ax
mov	bx, [bp+arg_RecordOffsetStart]
mov	ax, [bp+var_6]
mov	dx, [bp+var_8]
sub	dx, [bx]	; Integer Subtraction
sbb	ax, [bx+2]	; Integer Subtraction with Borrow
mov	bx, [bp+arg_RecordOffsetEnd]
mov	[bx+2],	ax
mov	[bx], dx
mov	ax, [g_CurrentLbxFileHandle]
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_Entry_4bytes ; sp-analysis failed



; Attributes: bp-based frame

proc ST_Set_LbxDirectoryPath far

argDirectoryPath= word ptr  6

push	bp
mov	bp, sp
push	[bp+argDirectoryPath]
mov	ax, offset g_LbxDirectoryPath
push	ax		; argDest
call	_strcpy		; String Copy
			;  from	argDirectoryPath
			;  to g_LbxDirectoryPath
			;
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp ST_Set_LbxDirectoryPath



; Attributes: noreturn bp-based	frame

; int __fastcall __far LBX_Load_ErrorHandler(char *arg0_LbxFileName, int arg2_ErrNo, int arg4_LbxEntryNumber, int arg6_MemShort)
proc LBX_Load_ErrorHandler far
			; CODE XREF: LBX_Load_Entry+1Ap
			; LBX_Load_Entry+FCp
			; LBX_Load_Entry+13Cp
			; LBX_Load_Entry+17Dp
			; LBX_Load_Entry+1B2p
			; LBX_Load_Entry+1D7p
			; LBX_Load_Entry+248p
			; LBX_Load_Entry+295p
			; LBX_Load_Entry+2B3p
			; LBX_Load_Entry+2EAp
			; LBX_Load_Entry+322p
			; LBX_Load_Entry:loc_1538Ap
			; LBX_Load_Entry+3B4p
			; LBX_Load_Entry+400p
			; LBX_Load_s15453+1Bp
			; LBX_Load_s15453+EFp
			; LBX_Load_s15453+132p
			; LBX_Load_s15453+147p
			; LBX_Load_s15453+175p
			; LBX_Load_s15453+1AAp
			; LBX_Load_s15453+1CFp
			; LBX_Load_s15453+240p
			; LBX_Load_s15453+287p
			; LBX_Load_s15453+2A3p
			; LBX_Load_s15453+2E5p
			; LBX_Load_s15453+347p
			; LBX_Load_s15453+365p
			; LBX_Load_s15453+39Cp
			; LBX_Load_s15453+3D4p
			; LBX_Load_s15453+3FFp
			; LBX_Load_s15453+466p
			; LBX_Load_s15453+4B2p
			; LBX_Load_HelpNewTerrCity+1Bp
			; LBX_Load_HelpNewTerrCity+ECp
			; LBX_Load_HelpNewTerrCity+12Cp
			; LBX_Load_HelpNewTerrCity+15Ap
			; LBX_Load_HelpNewTerrCity+18Fp
			; LBX_Load_HelpNewTerrCity+1B4p
			; LBX_Load_HelpNewTerrCity+225p
			; LBX_Load_HelpNewTerrCity+26Cp
			; LBX_Load_HelpNewTerrCity+288p
			; LBX_Load_HelpNewTerrCity+2CDp
			; LBX_Load_HelpNewTerrCity+31Ep
			; LBX_Load_Entry_4bytes+1Ap
			; LBX_Load_Entry_4bytes+DDp
			; LBX_Load_Entry_4bytes+11Dp
			; LBX_Load_Entry_4bytes+15Ep
			; LBX_Load_Entry_4bytes+193p
			; LBX_Load_Entry_4bytes+1B8p
			; LBX_LoadFileMemory+78P
			; LBX_LoadFileMemory+200P
			; LBX_AllocMem+86P
			; LBX_AllocMem+DFP
			; LBX_AllocMem+13BP
			; LBX_s16A80:loc_16B06P
			; LBX_s16A80+F0P
			; LBX_s16A80+136P
			; LBX_s16A80+18EP
			; LBX_EmsMapMem+56P
			; LBX_s16F45+3BP
			; LBX_s16F45+ABP
			; LBX_s16F45+CBP
			; LBX_s16F45+F3P
			; LBX_s16F45+134P
			; LBX_s16F45+156P
			; sub_17BB8+5BP
			; LBX_Load_IntroLbx_s21977+E5P
			; LBX_MemAndRead+1AP
			; LBX_MemAndRead+71P
			; LBX_MemAndRead+B6P

varString_itoa=	byte ptr -8Ch
varDestString= byte ptr	-78h
argLbxName= word ptr  6
argLbxErrorNumber= word	ptr  8
argLbxEntryNumber= word	ptr  0Ah
argAllocShortPages= word ptr  0Ch

push	bp
mov	bp, sp
sub	sp, 8Ch		; Integer Subtraction
push	si
mov	si, [bp+argLbxName]
push	si		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 10
push	ax		; argBaseRadix
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax		; argPtrCharArr
push	[bp+argLbxEntryNumber] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, offset strLbxEntryPrefix ; ".LBX [entry "
push	ax		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strLbxEntrySuffix ; "] "
push	ax		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	bx, [bp+argLbxErrorNumber]
dec	bx		; Decrement by 1
cmp	bx, 15		; switch 16 cases
jbe	short ErrNoLTE15 ; Jump	if Below or Equal (CF=1	| ZF=1)

UNKNOWN_ERROR:		; default
jmp	loc_16006

ErrNoLTE15:		; CODE XREF: LBX_Load_ErrorHandler+60j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_16015+bx] ; switch jump

LbxErrNo_1:		; DATA XREF: seg010:off_16015o
mov	ax, offset strNotFound ; case 0x0

loc_15EE5:		; CODE XREF: LBX_Load_ErrorHandler+81j
			; LBX_Load_ErrorHandler+BAj
			; LBX_Load_ErrorHandler+BFj
			; LBX_Load_ErrorHandler+F7j
			; LBX_Load_ErrorHandler+FDj
			; LBX_Load_ErrorHandler+103j
			; LBX_Load_ErrorHandler+109j
			; LBX_Load_ErrorHandler+10Fj
			; LBX_Load_ErrorHandler+130j
			; LBX_Load_ErrorHandler+136j
			; LBX_Load_ErrorHandler+13Cj
			; LBX_Load_ErrorHandler+17Ej
push	ax		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
jmp	loc_16006	; default

LbxErrNo_2:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strCorrupted	; case 0x1
jmp	short loc_15EE5	; Jump

CASE_0x2:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strInsuffMem	; case 0x2
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_15F08:
mov	ax, 0Ah
push	ax
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax		; argPtrCharArr
push	[g_RequiredMEM_583B] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strKFree ; "K free. Try removing all	TSR's."
jmp	short loc_15EE5	; Jump

CASE_0x3:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strNotAllocated ; case 0x3
jmp	short loc_15EE5	; Jump

LbxErrNo_5:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strAllocationTooSmall ; case	0x4
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax		; argPtrCharArr
push	[bp+argAllocShortPages]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strPages ; "	pages"
jmp	loc_15EE5	; Jump

LbxErrNo_7:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strNotAnLbx ; case 0x6
jmp	loc_15EE5	; Jump

LbxErrNo_8:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strExceedsCount ; case 0x7
jmp	loc_15EE5	; Jump

CASE_0x8:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strIncorrectSize ; case 0x8
jmp	loc_15EE5	; Jump

loc_15F82:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strExceedsRecords ; case 0x9
jmp	loc_15EE5	; Jump

loc_15F88:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
push	si		; case 0xA
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strCannotBeReloaded ; " cannot be reloaded into EMS w/o being "...
jmp	loc_15EE5	; Jump

CASE_0xB:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strInsuffEMM	; case 0xB
jmp	loc_15EE5	; Jump

CASE_0xC:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strOnlyPictures ; case 0xC
jmp	loc_15EE5	; Jump

loc_15FB5:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strInsuffEMM	; case 0xD
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strReservedEmm ; " (Reserved	EMM) "
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_15FD3:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strLbxTo ; case 0xE
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strInsuffEMM	; " EMM	loading	error. Insufficient EMM."
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strReservedEmm ; " (Reserved	EMM) "
jmp	loc_15EE5	; Jump

VGA_ANIM_FRAME_TOO_BIG:	; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strVgaAnimFrameTooBig ; case	0xF
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_16006:		; CODE XREF: LBX_Load_ErrorHandler:UNKNOWN_ERRORj
			; LBX_Load_ErrorHandler+67j
			; LBX_Load_ErrorHandler+7Bj
			; DATA XREF: seg010:off_16015o
lea	ax, [bp+varDestString] ; default
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_ErrorHandler

off_16015 dw offset LbxErrNo_1
			; DATA XREF: LBX_Load_ErrorHandler+67r
dw offset LbxErrNo_2	; jump table for switch	statement
dw offset CASE_0x2
dw offset CASE_0x3
dw offset LbxErrNo_5
dw offset loc_16006
dw offset LbxErrNo_7
dw offset LbxErrNo_8
dw offset CASE_0x8
dw offset loc_15F82
dw offset loc_15F88
dw offset CASE_0xB
dw offset CASE_0xC
dw offset loc_15FB5
dw offset loc_15FD3
dw offset VGA_ANIM_FRAME_TOO_BIG


; ~ASCII case folding
;
; for(i=0;str[i]!=0;i++)
;   if(str[i]<='z' && str[i]>='a')
;     str[i]-=32;
;
; Also,	this means they	are not	using the boolean operation approach.
; To upper case:
;
;  char	upperChar = 'l' & 0x5f
; To lower case:
;    char lowerChar = 'L' ^ 0x20
;
; Attributes: bp-based frame

; char *__cdecl	__far ST_RemoveExtensionUppercaseName(char *argNameCharArr)
proc ST_RemoveExtensionUppercaseName far
			; CODE XREF: LBX_Load_Entry+3Dp
			; LBX_Load_s15453+3Ep
			; LBX_Load_HelpNewTerrCity+3Ep
			; LBX_Load_Entry_4bytes+3Dp
			; LBX_LoadFileMemory+BP
			; LBX_AllocMem+BP
			; LBX_s16A80+BP
			; sub_17671+1AP

argNameCharArr=	dword ptr  6

push	bp
mov	bp, sp
mov	cx, [word ptr bp+argNameCharArr]
xor	dx, dx		; DX = 0
jmp	short WHILE_NOT_ZERO ; Jump

NOT_ZERO:		; CODE XREF: ST_RemoveExtensionUppercaseName+39j
mov	bx, cx
add	bx, dx		; Add
cmp	[byte ptr bx], 60h ;
			; If Below ASCII Value 61h ("a"), Then NOT_LOWERCASE
jle	short NOT_LOWERCASE ; Jump if Less or Equal (ZF=1 | SF!=OF)

TO_UPPERCASE:
mov	bx, cx
add	bx, dx		; Add
mov	al, [bx]
add	al, -20h	; Subtract 20h to convert to UPPERCASE
			; e.g. 61h(97)("a") - 20h(32) =	41h(61)("A")
mov	bx, cx
add	bx, dx		; Add
mov	[bx], al	; replace with upper-cased character

NOT_LOWERCASE:		; CODE XREF: ST_RemoveExtensionUppercaseName+11j
mov	bx, cx
add	bx, dx		; Add
cmp	[byte ptr bx], '.' ; Check for the period character in the filename
jnz	short NEXT_BYTE	; Jump if Not Zero (ZF=0)

GotTheDot:
mov	bx, cx
add	bx, dx		; Add
mov	[byte ptr bx], 0 ; replace . with 0 to force the loop exit condition

NEXT_BYTE:		; CODE XREF: ST_RemoveExtensionUppercaseName+28j
inc	dx		; Increment by 1

WHILE_NOT_ZERO:		; CODE XREF: ST_RemoveExtensionUppercaseName+8j
mov	bx, cx		; reset	to string value
add	bx, dx		; reset	to string position
cmp	[byte ptr bx], 0 ; Check for End of String (NULL)
jnz	short NOT_ZERO	; Jump if Not Zero (ZF=0)

STRING_END:
pop	bp
retf			; Return Far from Procedure
endp ST_RemoveExtensionUppercaseName



; [x] Rasm_MoM
;
; Attributes: bp-based frame

proc ST_SetRequiredMEM far
			; CODE XREF: _f010109_main+289P

argRequiredMem=	word ptr  6

push	bp		; ;preserve caller's stack frame
mov	bp, sp		; ;set our own stack frame


mov	ax, [bp+argRequiredMem]	; [bp+6]
mov	[g_RequiredMEM_583B], ax


pop	bp		; ;restore caller's stack frame
retf			; Return Far from Procedure
endp ST_SetRequiredMEM

ends seg010


; Segment type:	Pure code
segment	seg011 byte public 'CODE' use16
assume cs:seg011
;org 0Dh
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

; int __fastcall __far DOS_OpenFileModeCheck(int, int, int, int, char *asczFileName)
proc DOS_OpenFileModeCheck far
			; CODE XREF: sub_25DAB+15P
			; sub_25DFF+12P
			; ST_LoadSound+ECP
			; OVR_SaveGame_MagicSet+54P
			; ST_LoadSaveGamByNbr+6BP

asczFileName= word ptr	6
cAccessMode= word ptr  8

push	bp

loc_1607E:
mov	bp, sp
push	si		; str2
mov	si, [bp+cAccessMode]
mov	ax, offset strR	; "r"
push	ax
push	si		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		;
			; If (AX == 0) Then Set	(ZF = 1)
jz	short READ_MODE	; Jump If Zero (ZF = 1)
			; i.e. cAccessMode = "r"

loc_16094:		; "rb"
mov	ax, offset strRB
push	ax
push	si		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		;
			; If (AX == 0) Then Set	(ZF = 1)
jnz	short NotReadMode ; i.e. cAccessMode !=	("r" OR	"rw")

READ_MODE:		; CODE XREF: DOS_OpenFileModeCheck+15j
mov	ax, 3D00h
mov	dx, [bp+asczFileName]
int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read
mov	[ptrDosFileHandle], ax
jmp	short loc_160EC	; Jump

NotReadMode:		; CODE XREF: DOS_OpenFileModeCheck+25j
mov	ax, offset strW	; "w"
push	ax
push	si		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		;
			; If (AX == 0) Then Set	(ZF = 1)
jz	short CREATE	; i.e. cAccessMode = "w"

loc_160C1:		; "wb"
mov	ax, offset strWBr5
push	ax
push	si		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short WRITE_MODE ; Jump	if Not Zero (ZF=0)

CREATE:			; CODE XREF: DOS_OpenFileModeCheck+42j
mov	ax, 3C00h
mov	cx, 0
mov	dx, [bp+asczFileName]
int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
			; CX = attributes for file
			; DS:DX	-> ASCIZ filename (may include drive and path)
mov	[ptrDosFileHandle], ax
jmp	short loc_160EC	; Jump

WRITE_MODE:		; CODE XREF: DOS_OpenFileModeCheck+52j
mov	ax, 3D02h
mov	dx, [bp+asczFileName]
int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 2 - read & write
mov	[ptrDosFileHandle], ax

loc_160EC:		; CODE XREF: DOS_OpenFileModeCheck+32j
			; DOS_OpenFileModeCheck+62j
mov	ax, [ptrDosFileHandle]
jmp	short $+2	; Jump
pop	si
pop	bp
retf			; Return Far from Procedure
endp DOS_OpenFileModeCheck



;
;   arg_0=
;   arg_2=
;   arg_4=
;   arg_6=
;
; Attributes: bp-based frame

proc DOS_ReadFromFile_0	far
			; CODE XREF: sub_25DAB+32P
			; idk_DosReadFromFileHAndle_s2FC56+34P
			; idk_DosReadFromFileHAndle_s2FC56+81P
			; idk_DosReadFromFileHAndle_s2FC56+AAP
			; ST_LoadSaveGamByNbr+85P
			; ST_LoadSaveGamByNbr+9EP
			; ST_LoadSaveGamByNbr+B7P
			; ST_LoadSaveGamByNbr:loc_3CCA8P
			; ST_LoadSaveGamByNbr+E9P
			; ST_LoadSaveGamByNbr+102P
			; ST_LoadSaveGamByNbr+11AP
			; ST_LoadSaveGamByNbr+132P
			; ST_LoadSaveGamByNbr+14AP
			; ST_LoadSaveGamByNbr:loc_3CD3AP
			; ST_LoadSaveGamByNbr+17AP
			; ST_LoadSaveGamByNbr+192P
			; ST_LoadSaveGamByNbr+1AAP
			; ST_LoadSaveGamByNbr+1C2P
			; ST_LoadSaveGamByNbr+1DAP
			; ST_LoadSaveGamByNbr+1F3P
			; ST_LoadSaveGamByNbr+20CP
			; ST_LoadSaveGamByNbr+225P
			; ST_LoadSaveGamByNbr+23EP
			; ST_LoadSaveGamByNbr+257P
			; ST_LoadSaveGamByNbr+270P
			; ST_LoadSaveGamByNbr+289P
			; ST_LoadSaveGamByNbr+2A2P
			; ST_LoadSaveGamByNbr+2BBP
			; ST_LoadSaveGamByNbr+2D4P
			; ST_LoadSaveGamByNbr+2EDP
			; ST_LoadSaveGamByNbr+306P
			; ST_LoadSaveGamByNbr+31FP
			; ST_LoadSaveGamByNbr+33DP
			; ST_LoadSaveGamByNbr+356P
			; ST_LoadSaveGamByNbr+36FP
			; ST_LoadSaveGamByNbr+387P
			; ST_LoadSaveGamByNbr+3A0P
			; ST_LoadSaveGamByNbr+3BDP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp

loc_160F7:
mov	ax, [bp+arg_4]

loc_160FA:		; Signed Multiply
imul	[bp+arg_6]

loc_160FD:
mov	[SvGm_NbrBytWrt], ax

loc_16100:		; If ([bp+arg_2] != 0) Then Set	(ZF = 1)
cmp	[bp+arg_2], 0
jnz	short SKIP_SAVE_DS ; Jump if Not Zero (ZF=0)

loc_16106:
mov	ax, ds

loc_16108:
mov	[bp+arg_2], ax

SKIP_SAVE_DS:		; CODE XREF: DOS_ReadFromFile_0+10j
push	ds

loc_1610C:
mov	bx, [ptrDosFileHandle]
mov	cx, [SvGm_NbrBytWrt]
mov	ax, [bp+arg_2]
mov	ds, ax
mov	dx, [bp+arg_0]
mov	ah, 3Fh
int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
pop	ds
pop	bp
retf			; Return Far from Procedure
endp DOS_ReadFromFile_0



; I am assuming	this works like	fwrite,
;  where the 2 arguments are
;  count of bytes to write and
;  number of times to write them.
;
; Attributes: bp-based frame

proc OVR_DOS_WriteToFileWithHandle far
			; CODE XREF: sub_25DFF+2FP
			; OVR_SaveGame_MagicSet+6EP
			; OVR_SaveGame_MagicSet+87P
			; OVR_SaveGame_MagicSet+A0P
			; OVR_SaveGame_MagicSet+B9P
			; OVR_SaveGame_MagicSet+D2P
			; OVR_SaveGame_MagicSet+EBP
			; OVR_SaveGame_MagicSet+103P
			; OVR_SaveGame_MagicSet+11BP
			; OVR_SaveGame_MagicSet+133P
			; OVR_SaveGame_MagicSet+14BP
			; OVR_SaveGame_MagicSet+163P
			; OVR_SaveGame_MagicSet+17BP
			; OVR_SaveGame_MagicSet+193P
			; OVR_SaveGame_MagicSet+1ABP
			; OVR_SaveGame_MagicSet+1C3P
			; OVR_SaveGame_MagicSet+1DCP
			; OVR_SaveGame_MagicSet+1F5P
			; OVR_SaveGame_MagicSet+20EP
			; OVR_SaveGame_MagicSet+227P
			; OVR_SaveGame_MagicSet+240P
			; OVR_SaveGame_MagicSet+259P
			; OVR_SaveGame_MagicSet+272P
			; OVR_SaveGame_MagicSet+28BP
			; OVR_SaveGame_MagicSet+2A4P
			; OVR_SaveGame_MagicSet+2BDP
			; OVR_SaveGame_MagicSet+2D6P
			; OVR_SaveGame_MagicSet+2EFP
			; OVR_SaveGame_MagicSet+308P
			; OVR_SaveGame_MagicSet+326P
			; OVR_SaveGame_MagicSet+33FP
			; OVR_SaveGame_MagicSet+358P
			; OVR_SaveGame_MagicSet+370P
			; OVR_SaveGame_MagicSet+389P
			; OVR_SaveGame_MagicSet+3A2P

argWriteBuffer_DX= word	ptr  6
argWriteBuffer_DS= word	ptr  8
argByteCount= word ptr	0Ah
argWriteCount= word ptr	 0Ch

push	bp
mov	bp, sp
mov	ax, [bp+argByteCount]
imul	[bp+argWriteCount] ; AX	= AX * arg_6
mov	[SvGm_NbrBytWrt], ax
cmp	[bp+argWriteBuffer_DS],	0 ; Compare Two	Operands
jnz	short GOT_BYTES_TO_WRITE ; Jump	if Not Zero (ZF=0)
mov	ax, ds
mov	[bp+argWriteBuffer_DS],	ax

GOT_BYTES_TO_WRITE:	; CODE XREF: OVR_DOS_WriteToFileWithHandle+10j
push	ds
mov	bx, [ptrDosFileHandle]
mov	cx, [SvGm_NbrBytWrt]
mov	ax, [bp+argWriteBuffer_DS]
mov	ds, ax
mov	dx, [bp+argWriteBuffer_DX]
mov	ah, 40h
int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			;   BX = file handle
			;   CX = number	of bytes to write
			;   DS:DX -> buffer, data to write
			; Return:
			;   CF clear if	successful
			;   AX = number	of bytes actually written
			;   CF set on error
			;   AX = error code
pop	ds
pop	bp
retf			; Return Far from Procedure
endp OVR_DOS_WriteToFileWithHandle



; Attributes: bp-based frame

proc DOS_MoveFilePointer far
			; CODE XREF: idk_DosReadFromFileHAndle_s2FC56+1CP
			; idk_DosReadFromFileHAndle_s2FC56+66P

arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp

loc_16155:
mov	ax, [bp+arg_6]
mov	ah, 42h
mov	bx, [ptrDosFileHandle]

loc_1615E:
mov	dx, [bp+arg_2]
mov	cx, [bp+arg_4]

loc_16164:		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
int	21h		; AL = method:
			; 0-from beginnig,1-from current,2-from	end

loc_16166:
pop	bp
retf			; Return Far from Procedure
endp DOS_MoveFilePointer



; Attributes: bp-based frame

proc DOS_CloseFileHandle far
			; CODE XREF: sub_25DAB+3BP
			; sub_25DFF+38P
			; ST_LoadSound+180P
			; OVR_SaveGame_MagicSet+3ABP
			; ST_LoadSaveGamByNbr+3DCP
push	bp

loc_16169:
mov	bp, sp

loc_1616B:
mov	ah, 3Eh

loc_1616D:
mov	bx, [ptrDosFileHandle]
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
			; Return:
			;   CF clear if	successful
			;   AX destroyed
			;   CF set on error
			;   AX = error code
pop	bp

locret_16174:		; Return Far from Procedure
retf
endp DOS_CloseFileHandle

ends seg011


; Segment type:	Pure code
segment	seg012 byte public 'CODE' use16
assume cs:seg012
;org 6
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
nEmsLogicalPageNumber dw 0
			; DATA XREF: EMS_MapMemory_4+25w
			; EMS_MapMemory_4+3Br
			; EMS_MapMemory_4+49r
			; EMS_MapMemory_4+58r
			; idk_EmsMapMem_s16337+25w
			; idk_EmsMapMem_s16337:loc_16372r
			; idk_EmsMapMem_s16337+49r
			; idk_EmsMapMem_s16337:loc_1638Fr


; Stores EMM Page Frame	Address	in EMM_PageFrameSegmentAddress
; (segment address where the 64K-byte page frame is located)
; Return:
;   65535 Success
;   0 Failure

proc EMM_GetPageFrameAddress far
			; CODE XREF: idk_Setup_EMM:loc_1643EP
push	si
push	di
push	es

loc_1617B:
push	ds

loc_1617C:		; "EMMXXXX0"
mov	dx, offset emm_name
mov	ax, 3D00h
int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode, 00h	= Read Only Mode
			; Return:
			;   CF clear if	successful
			;   AX = file handle
			;   CF set on error
			;   AX = error code
jb	short EMM_FAIL	;
			; Could	not open EMMXXXX0, EMM Driver Not Present

TEST_IOCTL:
mov	bx, ax
mov	ax, 4400h
int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
			; Return:
			;   CF clear if	successful
			;   DX = device	information word (bit 7	set indicates device)
			;   AX destroyed
			;   CF set on error
			;   AX = error code
jb	short EMM_FAIL	;
			; Could	not use	device...

TEST_CHAR_DEV:		; Test Bit 7: Char Device
and	dx, 10000000b
jz	short EMM_FAIL	;
			; EMMXXXX0 is not a Device, must have been an actual file

TEST_EMM_AVAIL:
mov	ax, 4407h
int	21h		; DOS -	2+ - IOCTL - GET OUTPUT	STATUS (AX = 4407h)
			;   BX = file handle
			; Return:
			;   CF clear if	successful
			;   AL = input status (00h not ready, FFh ready)
			;   CF set on error
			;   AX = error code
jb	short EMM_FAIL	;
			; Could	not get	device status...

TEST_DEV_STAT:		; If (AL == 0) Then Set	(ZF = 1)
or	al, al
jz	short EMM_FAIL	; Device Status	was Not	Ready...

CLOSE_HANDLE:
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   BX = file handle
			; Return:
			;   CF clear if	successful
			;   AX destroyed
			;   CF set on error
			;   AX = error code
jb	short EMM_FAIL	; Could	not close device...

loc_161A6:
mov	ah, 46h
int	67h		; DOS -	LIM EMS	- GET EMM VERSION
			; Return:
			;   AH = status
			;   AL = EMM version number if AH=00h
			; Status:
			;   00h	   successful
			; Version:
			;   AL = Version # in BCD
			;	 Major revision	in upper 4 bits
			;	 Minor revision	in lower 4 bits
cmp	ah, 0		;
			; If (AH != 0) Then Set	(ZF = 1)
jnz	short EMM_FAIL	;
			; Could	not get	EMM Version...

TEST_EMM_VERSION:	; If (AL < 0100	0000) Then Set (SF = 1)
cmp	al, 40h		; Sign Flag: Set equal to high-order bit of result
			;	     (0	is positive, 1 if negative)
js	short EMM_FAIL	; EMM Version is less than 4.0 (1987!!)...

GET_PAGE_FRAME_ADDR:
mov	ah, 41h
int	67h		; DOS -	LIM EMS	- GET PAGE FRAME SEGMENT
			; Return:
			;   AH = status
			;   BX = segment address of page frame
			; Status:
			;   00h	successful
cmp	ah, 0		;
			; If (AH != 0) Then Set	(ZF = 1)
jnz	short EMM_FAIL	;
			; Could	not get	Page Frame Segment

EMM_SUCCESS:
mov	[EMM_PageFrameSegmentAddress], bx
mov	ax, 0FFFFh
pop	ds
pop	es
pop	di
pop	si
retf			; Return Far from Procedure

EMM_FAIL:		; CODE XREF: EMM_GetPageFrameAddress+Cj
			; EMM_GetPageFrameAddress+15j
			; EMM_GetPageFrameAddress+1Bj
			; EMM_GetPageFrameAddress+22j
			; EMM_GetPageFrameAddress+26j
			; EMM_GetPageFrameAddress+2Cj
			; EMM_GetPageFrameAddress+35j
			; EMM_GetPageFrameAddress+39j
			; EMM_GetPageFrameAddress+42j
mov	ax, 0
pop	ds
pop	es
pop	di
pop	si
retf			; Return Far from Procedure
endp EMM_GetPageFrameAddress



; returns the number of	unallocated pages (pages available to your program)
;  and the total number	of pages in expanded memory
; Return:
;   Number of EMM Handles
;   0, Failure

proc EMM_GetUnallocatedPageCount far
			; CODE XREF: idk_Setup_EMM:EMM_GotPageFrameAddressP
push	es

loc_161D1:
push	ds
push	si
push	di

loc_161D4:
mov	ah, 4Bh

loc_161D6:		; DOS -	LIM EMS	- GET NUMBER OF	EMM HANDLES
int	67h		; Return:
			;   AH = status
			;   BX = number	of EMM handles if AH=00h
			; Status:
			;   00h	= Successful

loc_161D8:		;
cmp	ah, 0		; If (AH != 0) Then Set	(ZF = 1)

loc_161DB:		; Could	not get	Number of EMM Handles...
jnz	short FAILURE

SUCCESS:
mov	ax, bx
pop	di

loc_161E0:
pop	si
pop	ds

loc_161E2:
pop	es
retf			; Return Far from Procedure

FAILURE:		; CODE XREF: EMM_GetUnallocatedPageCount:loc_161DBj
mov	ax, 0
pop	di
pop	si
pop	ds

loc_161EA:
pop	es
retf			; Return Far from Procedure
endp EMM_GetUnallocatedPageCount



; DOS -	LIM EMS	- GET NUMBER OF	PAGES
; Return:
;   AH = status, 00h function successful
;   BX = number	of unallocated pages
;   DX = total number of pages

proc DOS_GetNumberOfPages far
			; CODE XREF: idk_Setup_EMM:loc_16578P
			; LBX_LoadFileMemory+101P
push	es
push	ds
push	si
push	di

loc_161F0:
mov	ah, 42h
int	67h		; DOS -	LIM EMS	- GET NUMBER OF	PAGES
			; Return: AH = 00h function successful,	BX = number of unallocated pages
			; DX = total number of pages
			; AH = error code

loc_161F4:		; Compare Two Operands
cmp	ah, 0

loc_161F7:		; Jump if Not Zero (ZF=0)
jnz	short FAILURE

loc_161F9:
mov	ax, bx
pop	di
pop	si
pop	ds
pop	es

locret_161FF:		; Return Far from Procedure
retf

FAILURE:		; CODE XREF: DOS_GetNumberOfPages:loc_161F7j
mov	ax, 0
pop	di
pop	si
pop	ds

loc_16206:
pop	es
retf			; Return Far from Procedure
endp DOS_GetNumberOfPages



;
; DOS -	LIM EMS	- GET PAGES OWNED BY HANDLE
; Return:
;   AX = Pages Owned by	Handle
;   0, Failure
; Attributes: bp-based frame

; int __cdecl __far EMM_GetPagesOwnedByHandle(int argEmmHandle)
proc EMM_GetPagesOwnedByHandle far
			; CODE XREF: sub_17671+6EP
			; EMM_Allocate+172P

argEmmHandle= word ptr	6

push	bp

loc_16209:
mov	bp, sp
push	es
push	ds
push	si

loc_1620E:
push	di

loc_1620F:
mov	ah, 4Ch
mov	dx, [bp+argEmmHandle]
int	67h		; DOS -	LIM EMS	- GET PAGES OWNED BY HANDLE
			;   DX = EMM handle
			; Return:
			;   AH = status
			;   BX = number	of logical pages, if AH=00h
cmp	ah, 0		; If (AH != 0) Then Set	(ZF = 0)

loc_16219:		;
jnz	short EMM_FAILURE ; Could not get Pages	Owned by Handle...

loc_1621B:
mov	ax, bx
pop	di

loc_1621E:
pop	si
pop	ds
pop	es

loc_16221:
pop	bp
retf			; Return Far from Procedure

glb_16223:		; CODE XREF: EMM_GetPagesOwnedByHandle:loc_16219j
EMM_FAILURE:
mov	ax, 0
pop	di
pop	si
pop	ds

loc_16229:
pop	es

loc_1622A:
pop	bp

locret_1622B:		; Return Far from Procedure
retf
endp EMM_GetPagesOwnedByHandle



;
; Return:
;   AX = Handle
;   0, Failure
;
; argPagesToAllocate =
; argHandleName	     =
; Attributes: bp-based frame

proc EMS_GetHandleAllocMemSetName far
			; CODE XREF: EMM_Allocate+9DP

varHandle= word	ptr -2
argPagesToAllocate= word ptr  6
argHandleName= word ptr	 8

push	bp
mov	bp, sp

loc_1622F:		; Integer Subtraction
sub	sp, 2
push	es
push	ds
push	si
push	di

loc_16236:		; EMM Function:	67
mov	ah, 43h		; EMM Sub-Function: 43

loc_16238:
mov	bx, [bp+argPagesToAllocate]
int	67h		; DOS -	LIM EMS	- GET HANDLE AND ALLOCATE MEMORY
			;   BX = number	of logical pages to allocate
			; Return:
			;   AH = status
			;   DX = handle, if AH=00h

loc_1623D:		; If (AX != 0) Then Set	(ZF = 1)
cmp	ah, 0
jnz	short EMM_FAILURE ; Jump if Not	Zero (ZF=0)

loc_16242:
mov	[bp+varHandle],	dx

loc_16245:
mov	ax, 5301h

loc_16248:
mov	si, [bp+argHandleName]
int	67h		; DOS -	LIM EMS	4.0 - SET HANDLE NAME
			;   AL = 00h get handle	name, 01h set handle name
			;   DX = handle
			;   DS:SI -> 8-byte handle name
			; Return:
			;   AH = status
cmp	ah, 0		; If (AX != 0) Then Set	(ZF = 1)

loc_16250:		; Jump if Not Zero (ZF=0)
jnz	short EMM_FAILURE

loc_16252:
mov	ax, [bp+varHandle]

loc_16255:
pop	di
pop	si

loc_16257:
pop	ds

loc_16258:
pop	es
mov	sp, bp

loc_1625B:
pop	bp
retf			; Return Far from Procedure

glb_1625D:		; CODE XREF: EMS_GetHandleAllocMemSetName+14j
			; EMS_GetHandleAllocMemSetName:loc_16250j
EMM_FAILURE:
mov	ax, 0

loc_16260:
pop	di

loc_16261:
pop	si

loc_16262:
pop	ds
pop	es
mov	sp, bp
pop	bp

locret_16267:		; Return Far from Procedure
retf
endp EMS_GetHandleAllocMemSetName



;
; Return:
;   65535, Success
;	   var_66 = HandleNameBuffer (8*8+2)
;   0, Failure
; Attributes: bp-based frame

proc EMM_GetHandleName far
			; CODE XREF: idk_Setup_EMM:loc_16462P
			; idk_Setup_EMM+EBP

arg0_HandleNameBuffer= word ptr	 6
arg2_EmmHandle=	word ptr  8

push	bp

loc_16269:
mov	bp, sp

loc_1626B:
push	es
push	ds

loc_1626D:
push	si

loc_1626E:
push	di

loc_1626F:
mov	ax, 5300h
mov	dx, [bp+arg2_EmmHandle]
mov	di, [bp+arg0_HandleNameBuffer]
mov	bx, ds
mov	es, bx
assume es:dseg
int	67h		; DOS -	LIM EMS	4.0 - GET/SET HANDLE NAME
			;   AL = 00h get handle	name, 01h set handle name
			;   DX = handle
			;   ES:DI -> 8-byte buffer for handle name
			; Return:
			;   AH = status
cmp	ah, 0		; If (AH != 0) Then Set	(ZF = 1)
jnz	short EMM_FAILURE ; Jump if Not	Zero (ZF=0)
mov	di, [bp+arg0_HandleNameBuffer]
add	di, 8		; Add
mov	al, 0
stosb			; Store	AX in word ES:DI, update DI
			; i.e. Append 00 (8*8+2)
mov	ax, 0FFFFh
pop	di

loc_16290:
pop	si
pop	ds
pop	es
assume es:nothing
pop	bp
retf			; Return Far from Procedure

EMM_FAILURE:		; CODE XREF: EMM_GetHandleName+19j
mov	ax, 0

loc_16298:
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp EMM_GetHandleName



;
; DOS -	LIM EMS	- RELEASE HANDLE AND MEMORY
;   arg0_EmmHandle = DX	= EMM handle
; Attributes: bp-based frame

proc EMM_ReleaseHandleAndMemory	far
			; CODE XREF: Chk_RelMemHandle+15P
			; Chk_RelMemHandle+2DP
			; EMM_LoopRelease+25P
			; sub_17671+79P

arg0_EmmHandle=	word ptr  6

push	bp
mov	bp, sp
push	es
push	ds
push	si
push	di
cmp	[bp+arg0_EmmHandle], 0 ; If (arg0_EmmHandles ==	0) Then	Set (ZF	= 1)
jz	short ZERO_HANDLES ; Jump if Zero (ZF=1)
mov	ah, 45h

loc_162AD:
mov	dx, [bp+arg0_EmmHandle]

loc_162B0:		; DOS -	LIM EMS	- RELEASE HANDLE AND MEMORY
int	67h		;   DX = EMM handle
			; Return:
			;   AH = status

ZERO_HANDLES:		; CODE XREF: EMM_ReleaseHandleAndMemory+Bj
pop	di
pop	si
pop	ds
pop	es
pop	bp

locret_162B7:		; Return Far from Procedure
retf
endp EMM_ReleaseHandleAndMemory



; Returns?
;
; EMS_MapMemory_4(var_DI,
;		  0,
;		  6,
;		  0,
;		  2,
;		  varMemCntOrHandle)
;
; Attributes: bp-based frame

; int __cdecl __far EMS_MapMemory_4(int	arg1_DI, int arg2_ES, int arg3_4, int arg4_6, int arg5_ByteCount, int arg6_EmsHandle)
proc EMS_MapMemory_4 far
			; CODE XREF: LBX_EmsMapMem+3EP
			; LBX_EmsMapMem+91P
			; LBX_EmsMapMem+E7P
			; LBX_EmsMapMem+10BP
			; LBX_EmsMapMem+231P
			; LBX_EmsMapMem+28BP
			; LBX_s16F45+21P
			; LBX_s16F45+6EP
			; LBX_s16F45+1BFP
			; idk_PreEmmPgCnt+34P
			; idk_PreEmmPgCnt+72P
			; idk_PreEmmPgCnt+94P
			; idk_PreEmmPgCnt+DAP
			; idk_PreEmmPgCnt+FCP
			; idk_PreEmmPgCnt+256P
			; idk_PreEmmPgCnt+2AEP
			; EMS_s17408:loc_1743CP
			; EMS_s17408+6EP
			; EMS_s17408+90P
			; EMS_s17408+D6P
			; EMS_s17408+F8P
			; EMS_s17408+190P
			; sub_179C5:loc_179DDP
			; sub_17A12+1FP
			; sub_1D40D+8EP
			; sub_1D40D+AEP
			; LBX_Intro_MemAndReadAndMem+44P
			; LBX_Load_IntroLbx_s21977+8EP
			; LBX_Load_IntroLbx_s21977+B1P
			; sub_21C86:loc_21D03P

arg1_DI= word ptr  6
arg2_ES= word ptr  8
arg3_AX= word ptr  0Ah
arg4_DX= word ptr  0Ch
arg5_ByteCount=	word ptr  0Eh
arg6_EmsHandle=	word ptr  10h

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	es
push	ds
push	si
push	di


cmp	[bp+arg2_ES], 0	; Compare Two Operands
jnz	short loc_162CD	; Jump if Not Zero (ZF=0)
mov	ax, ds
mov	[bp+arg2_ES], ax

loc_162CD:		; CODE XREF: EMS_MapMemory_4+Ej
mov	ax, [bp+arg3_AX] ; e.g., AX = 6; DX = 0
mov	dx, [bp+arg4_DX]
shl	ax, 1		; Shift	Logical	Left
rcl	dx, 1		; Rotate Through Carry Left
shl	ax, 1		; Shift	Logical	Left
rcl	dx, 1		; Rotate Through Carry Left
mov	bx, dx
mov	[cs:nEmsLogicalPageNumber], bx


shr	ax, 1		; ? undo SHL above ?
shr	ax, 1		; Shift	Logical	Right
mov	si, ax		;
			;
			;
			;
mov	ax, 4400h
mov	dx, [bp+arg6_EmsHandle]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4401h
mov	bx, [cs:nEmsLogicalPageNumber]
inc	bx		; Increment by 1
mov	dx, [bp+arg6_EmsHandle]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4402h
mov	bx, [cs:nEmsLogicalPageNumber]
inc	bx		; Increment by 1
inc	bx		; Increment by 1
mov	dx, [bp+arg6_EmsHandle]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4403h
mov	bx, [cs:nEmsLogicalPageNumber]
inc	bx		; Increment by 1
inc	bx		; Increment by 1
inc	bx		; Increment by 1
mov	dx, [bp+arg6_EmsHandle]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
			;
			;
			;
mov	ax, [bp+arg2_ES]
mov	es, ax
mov	di, [bp+arg1_DI]
mov	cx, [bp+arg5_ByteCount]
mov	ax, [EMM_PageFrameSegmentAddress]
mov	ds, ax
rep movsb		;
			; Move CX bytes	from DS:[SI] to	ES:[DI].
			;
			; from EMM_PageFrameSegmentAddress:arg3_AX
			; to arg2_ES:arg1_DS
			;


pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp EMS_MapMemory_4



; Attributes: bp-based frame

proc idk_EmsMapMem_s16337 far
			; CODE XREF: sub_179A3+18P
			; sub_179E7+1FP
			; sub_1D40D:loc_1D457P
			; sub_1D40D+6AP
			; LBX_Load_IntroLbx_s21977+112P
			; LBX_Load_IntroLbx_s21977+160P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	es
push	ds
push	si
push	di

loc_16341:		; Compare Two Operands
cmp	[bp+arg_2], 0
jnz	short loc_1634C	; Jump if Not Zero (ZF=0)
mov	ax, ds
mov	[bp+arg_2], ax

loc_1634C:		; CODE XREF: idk_EmsMapMem_s16337+Ej
mov	ax, [bp+arg_4]
mov	dx, [bp+arg_6]
shl	ax, 1		; Shift	Logical	Left

loc_16354:		; Rotate Through Carry Left
rcl	dx, 1

loc_16356:		; Shift	Logical	Left
shl	ax, 1

loc_16358:		; Rotate Through Carry Left
rcl	dx, 1
mov	bx, dx
mov	[cs:nEmsLogicalPageNumber], bx
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
mov	di, ax
mov	ax, 4400h
mov	dx, [bp+arg_A]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status

loc_1636F:
mov	ax, 4401h

loc_16372:
mov	bx, [cs:nEmsLogicalPageNumber]
inc	bx		; Increment by 1

loc_16378:
mov	dx, [bp+arg_A]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4402h
mov	bx, [cs:nEmsLogicalPageNumber]
inc	bx		; Increment by 1
inc	bx		; Increment by 1

loc_16387:
mov	dx, [bp+arg_A]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status

loc_1638C:
mov	ax, 4403h

loc_1638F:
mov	bx, [cs:nEmsLogicalPageNumber]
inc	bx		; Increment by 1
inc	bx		; Increment by 1
inc	bx		; Increment by 1
mov	dx, [bp+arg_A]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, [EMM_PageFrameSegmentAddress]
mov	es, ax
mov	cx, [bp+arg_8]

loc_163A4:
mov	si, [bp+arg_0]
mov	ax, [bp+arg_2]
mov	ds, ax
rep movsb		; Move Byte(s) from String to String
pop	di
pop	si
pop	ds

loc_163B1:
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_EmsMapMem_s16337



;   mov	    ax,	seg dseg
;   mov	    ds,	ax
;   mov	    ax,	adrEMM_PageFrameSegment

proc fncGetEmmPageFrameSegmentAddress far
			; CODE XREF: LBX_LoadFileMemory:loc_1673FP
			; LBX_AllocMem:loc_16995P
			; LBX_s16A80:loc_16C16P
			; sub_17BB8:loc_17C65P
			; LBX_MemAndRead:loc_21BD1P
push	ds

loc_163B7:
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [EMM_PageFrameSegmentAddress]
pop	ds
retf			; Return Far from Procedure
endp fncGetEmmPageFrameSegmentAddress



; DOS -	LIM EMS	- MAP MEMORY
;   argEmsHandle
;   argEmsPageNumber
; Attributes: bp-based frame

proc DOS_MapMemory far	; CODE XREF: LBX_LoadFileMemory+180P
			; LBX_LoadFileMemory+1CDP
			; LBX_AllocMem+172P
			; LBX_AllocMem+1C5P
			; LBX_s16A80+1C5P
			; LBX_s16A80+209P
			; CALL_DOS_MapMemory+AP
			; sub_17BB8:loc_17CF8P
			; LBX_MemAndRead+118P
			; LBX_MemAndRead+157P
			; sub_4F44D+B7P

argEmsHandle= word ptr	6
argEmsPageNumber= word ptr  8

push	bp
mov	bp, sp
push	es
push	ds
mov	ax, 4400h
mov	dx, [bp+argEmsHandle]
mov	bx, [bp+argEmsPageNumber]
int	67h		; DOS -	LIM EMS	- MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4401h
mov	bx, [bp+argEmsPageNumber]
inc	bx		; Increment by 1
mov	dx, [bp+argEmsHandle]
int	67h		; DOS -	LIM EMS	- MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4402h
mov	bx, [bp+argEmsPageNumber]
inc	bx		; Increment by 1
inc	bx		; Increment by 1
mov	dx, [bp+argEmsHandle]
int	67h		; DOS -	LIM EMS	- MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4403h
mov	bx, [bp+argEmsPageNumber]
inc	bx		; Increment by 1
inc	bx		; Increment by 1
inc	bx		; Increment by 1
mov	dx, [bp+argEmsHandle]
int	67h		; DOS -	LIM EMS	- MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp DOS_MapMemory



; Attributes: bp-based frame

proc sub_163FC far	; CODE XREF: sub_1EA9E+29P
			; sub_1EC61+17P
			; sub_226C2:loc_226EBP
			; sub_226C2:loc_22758P
			; sub_229BA+17P
			; sub_22DC6+29P
			; sub_22DC6:loc_22E51P
			; sub_22EFA:loc_22F0BP
			; sub_56220+BP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_163FD:
mov	bp, sp
push	ax
push	bx
push	cx
push	dx
push	si
push	ds
mov	bx, [bp+arg_0]
mov	dx, [bp+arg_2]
mov	ax, seg	dseg
mov	ds, ax
mov	[word_35DFF], bx

loc_16414:		; Increment by 1
inc	bx

loc_16415:
mov	[word_35E03], bx
inc	bx		; Increment by 1

loc_1641A:
mov	[word_35E07], bx

loc_1641E:		; Increment by 1
inc	bx

loc_1641F:
mov	[word_35E0B], bx
inc	bx		; Increment by 1

loc_16424:
mov	cx, 4

loc_16427:
mov	si, 40EFh

loc_1642A:
mov	ax, 5000h

loc_1642D:		;  - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
int	67h		; AL = 00h / 01h, DX = handle, CX = number of entries in array
			; DS:SI	-> mapping array
			; Return: AH = status

loc_1642F:
pop	ds

loc_16430:
pop	si

loc_16431:
pop	dx

loc_16432:
pop	cx

loc_16433:
pop	bx

loc_16434:
pop	ax

loc_16435:
pop	bp

locret_16436:		; Return Far from Procedure
retf
endp sub_163FC

ends seg012


; Segment type:	Pure code
segment	seg013 byte public 'CODE' use16
assume cs:seg013
;org 7
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc idk_Setup_EMM far	; CODE XREF: Load_Fonts_SndDrv+CP
			; idk_Load_FntSty_SndDrv_Mos+CP

varEmmHandleName= word ptr -66h
varUnallocatedPageCount= word ptr -2

push	bp
mov	bp, sp

loc_1643A:		; Integer Subtraction
sub	sp, 66h
push	si		; argSrc

loc_1643E:		; Stores EMM Page Frame	Address	in EMM_PageFrameSegmentAddress
call	EMM_GetPageFrameAddress	; (segment address where the 64K-byte page frame is located)
			; Return:
			;   65535 Success
			;   0 Failure
or	ax, ax		;
			; If (AX == 0) Then Set	(ZF = 1)
jnz	short EMM_GotPageFrameAddress ;	Jump if	Not Zero (ZF=0)

loc_16447:		; Jump
jmp	loc_165CD

EMM_GotPageFrameAddress:
			; CODE XREF: idk_Setup_EMM+Ej
call	EMM_GetUnallocatedPageCount ; returns the number of unallocated	pages (pages available to your program)
			;  and the total number	of pages in expanded memory
			; Return:
			;   Number of EMM Handles
			;   0, Failure
mov	[bp+varUnallocatedPageCount], ax
mov	[idk_EMM_w3C2FE], 0
mov	si, 1
jmp	short CHECK_PAGE_COUNT ; Jump

loc_1645D:		; CODE XREF: idk_Setup_EMM:loc_1648Fj
push	si

loc_1645E:		; Load Effective Address
lea	ax, [bp+varEmmHandleName]
push	ax

loc_16462:		;
call	EMM_GetHandleName ; Return:
			;   65535, Success
			;	   var_66 = HandleNameBuffer (8*8+2)
			;   0, Failure

loc_16467:
pop	cx
pop	cx
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jz	short EMM_FAILURE ; Jump if Zero (ZF=1)

loc_1646D:		; Load Effective Address
lea	ax, [bp+varEmmHandleName]

loc_16470:
push	ax
mov	ax, offset strYOMOMAr1 ; "YO MOMA"

loc_16474:		; str1
push	ax

loc_16475:		; Case-Insensitive String Comparison (i.e. strcasecmp)
call	_stricmp	; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx

loc_1647C:		; Logical Inclusive OR
or	ax, ax

loc_1647E:		; Jump if Not Zero (ZF=0)
jnz	short EMM_FAILURE

loc_16480:
mov	[idk_EMM_w3C2FE], si

EMM_FAILURE:		; CODE XREF: idk_Setup_EMM+34j
			; idk_Setup_EMM:loc_1647Ej
inc	si		; Increment by 1

CHECK_PAGE_COUNT:	; CODE XREF: idk_Setup_EMM+24j
cmp	si, [bp+varUnallocatedPageCount] ; SI -	Available Page Count
			; SI = 1
			; If (SI < Number of EMM Handles) Then Set (SF = 1) AND	(OF = 1)

loc_16488:		; Jump if Greater or Equal (SF=OF)
jge	short GetMoreHandles
cmp	[idk_EMM_w3C2FE], 0 ; Compare Two Operands

loc_1648F:		; Jump if Zero (ZF=1)
jz	short loc_1645D

GetMoreHandles:		; CODE XREF: idk_Setup_EMM:loc_16488j
mov	[hrmEmmPageCount], 0

loc_16497:		; Compare Two Operands
cmp	[idk_EMM_w3C2FE], 0

loc_1649C:		; Jump if Not Zero (ZF=0)
jnz	short loc_164B6
xor	ax, ax		; Logical Exclusive OR

loc_164A0:		; arg4_value
push	ax

loc_164A1:		; "YO MOMA"
mov	ax, offset strYOMOMAr2

loc_164A4:
push	ax
mov	ax, 1		; argValue
push	ax		; arg0_EmmPageCount
nop			; No Operation

loc_164AA:
push	cs
call	near ptr EMM_Allocate ;	Call Procedure

loc_164AE:		; Add
add	sp, 6
mov	[idk_EMM_w3C2FE], ax
jmp	short TEST_HANDLE ; argSrc

loc_164B6:		; CODE XREF: idk_Setup_EMM:loc_1649Cj
mov	ax, offset strYOMOMAr1 ; "YO MOMA"
push	ax
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX:DX	= AX * DX
add	ax, offset Emm_PgCnt_w3C302 ; Add
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX:DX	= AX * DX
mov	bx, ax
mov	[idk_LBX_b3C30B+bx], 0 ;
			; ?EMM Handle?
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX:DX	= AX * DX
mov	dx, [idk_EMM_w3C2FE] ; ?EMM Handle?
mov	bx, ax
mov	[idk_LBX_w3C30C+bx], dx	; ?EMM Handle?
mov	[hrmEmmPageCount], 1

TEST_HANDLE:		; CODE XREF: idk_Setup_EMM+7Dj
cmp	[idk_EMM_w3C2FE], 0 ; Compare Two Operands
jg	short loc_1650F	; Jump if Greater (ZF=0	& SF=OF)

loc_164FB:		; int
lea	ax, [bp+varEmmHandleName]
push	ax		; int
nop			; No Operation
push	cs
call	near ptr fncBldMsgInsuffEMS ; Call Procedure
pop	cx

loc_16505:		; Load Effective Address
lea	ax, [bp+varEmmHandleName]
push	ax		; argSrc
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx

loc_1650F:		; CODE XREF: idk_Setup_EMM+C2j
mov	[word_3C300], 1

loc_16515:
mov	ax, [idk_EMM_w3C2FE]
inc	ax		; Increment by 1
mov	si, ax

loc_1651B:		; Jump
jmp	short LOOP_50

loc_1651D:		; CODE XREF: idk_Setup_EMM+13Fj
push	si

loc_1651E:		; Load Effective Address
lea	ax, [bp+varEmmHandleName]

loc_16521:
push	ax
call	EMM_GetHandleName ;
			; Return:
			;   65535, Success
			;	   var_66 = HandleNameBuffer (8*8+2)
			;   0, Failure

loc_16527:
pop	cx
pop	cx

loc_16529:		; Logical Inclusive OR
or	ax, ax

loc_1652B:		; Jump if Zero (ZF=1)
jz	short loc_1656B

loc_1652D:		; Compare Two Operands
cmp	[byte ptr bp+varEmmHandleName],	0
jz	short loc_1656B	; Jump if Zero (ZF=1)

loc_16533:
mov	ax, [hrmEmmPageCount]

loc_16536:
mov	dx, 12
imul	dx		; AX = AX * DX
mov	bx, ax

loc_1653D:
mov	[idk_LBX_b3C30B+bx], 0
lea	ax, [bp+varEmmHandleName] ; Load Effective Address
push	ax
mov	ax, [hrmEmmPageCount]

loc_16549:
mov	dx, 12
imul	dx		; AX = AX * DX
add	ax, offset Emm_PgCnt_w3C302 ; Add
push	ax		; argDest

loc_16552:		; Source:
call	_strcpy		;   lea	    ax,	[bp+var66_EmmHandleName]
			;   push    ax
			; Destination:
			;   mov	    ax,	hrmEmmPageCount
			;   mov	    dx,	12
			;   imul    dx
			;   add	    ax,	0A5F2h
			;   push    ax
			;
pop	cx

loc_16558:
pop	cx
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX = AX * DX

loc_16561:
mov	bx, ax
mov	[idk_LBX_w3C30C+bx], si	; ?EMM Handle?
inc	[hrmEmmPageCount] ; Increment by 1

loc_1656B:		; CODE XREF: idk_Setup_EMM:loc_1652Bj
			; idk_Setup_EMM+FAj
inc	si		; Increment by 1

LOOP_50:		; CODE XREF: idk_Setup_EMM:loc_1651Bj
cmp	si, 50		; Compare Two Operands

loc_1656F:		; Jump if Greater or Equal (SF=OF)
jge	short loc_16578
cmp	[hrmEmmPageCount], 40 ;	Compare	Two Operands
jl	short loc_1651D	; Jump if Less (SF!=OF)

loc_16578:		; CODE XREF: idk_Setup_EMM:loc_1656Fj
call	DOS_GetNumberOfPages ; DOS - LIM EMS - GET NUMBER OF PAGES
			; Return:
			;   AH = status, 00h function successful
			;   BX = number	of unallocated pages
			;   DX = total number of pages
cmp	ax, [ST_HeapBase] ; Compare Two	Operands
jge	short loc_16597	; Jump if Greater or Equal (SF=OF)
lea	ax, [bp+varEmmHandleName] ; int
push	ax		; int
nop			; No Operation
push	cs
call	near ptr fncBldMsgInsuffEMS ; Call Procedure
pop	cx
lea	ax, [bp+varEmmHandleName] ; Load Effective Address
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure

loc_16596:
pop	cx

loc_16597:		; CODE XREF: idk_Setup_EMM+14Aj
mov	ax, 1
push	ax		; argValue
mov	ax, offset strVGAFILEH ; "VGAFILEH"
push	ax		; argHandleName
mov	ax, 5		; argValue
push	ax		; arg0_EmmPageCount
nop			; No Operation
push	cs
call	near ptr EMM_Allocate ;	Call Procedure
add	sp, 6		; Add
mov	[idk_AddrEmsHandle], ax
mov	ax, 1
push	ax		; argValue
mov	ax, offset strEMMDATAH ; "EMMDATAH"
push	ax		; argHandleName

loc_165B6:		; argValue
mov	ax, 4
push	ax		; arg0_EmmPageCount
nop			; No Operation
push	cs
call	near ptr EMM_Allocate ;	Call Procedure

loc_165BF:		; Add
add	sp, 6
mov	[EmsHndl_w3C2F6], ax
mov	[word_3C2F4], 0
jmp	short loc_165E1	; Jump

loc_165CD:		; CODE XREF: idk_Setup_EMM:loc_16447j
lea	ax, [bp+varEmmHandleName] ; int
push	ax		; int
nop			; No Operation
push	cs
call	near ptr fncBldMsgInsuffEMS ; Call Procedure
pop	cx
lea	ax, [bp+varEmmHandleName] ; Load Effective Address
push	ax		; arg0_PrintString

loc_165DB:		; Call Procedure
call	_f050207_EXIT_CleanUp
pop	cx

loc_165E1:		; CODE XREF: idk_Setup_EMM+194j
pop	si
mov	sp, bp

loc_165E4:
pop	bp
retf			; Return Far from Procedure
endp idk_Setup_EMM ; sp-analysis failed



; Attributes: bp-based frame

proc sub_165E6 far

arg_0= word ptr	 6

push	bp
mov	bp, sp
xor	ax, ax		; argLbxFileName
push	ax
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr LBX_LoadFileMemory ; mov     ax, 1
			; push	  ax
			; push	  [bp+LbxFileName]
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp sub_165E6 ; sp-analysis failed



; Attributes: bp-based frame

; int __cdecl __far LBX_LoadFileIndex1(int argLbxFileName)
proc LBX_LoadFileIndex1	far
			; CODE XREF: _f010409_LoadVortexAnimationImages+8P
			; _f010409_LoadVortexAnimationImages+8FP
			; _f010409_LoadVortexAnimationImages+B7P

argLbxFileName=	word ptr  6

push	bp
mov	bp, sp
mov	ax, 1		; argLbxFileName
push	ax		; int
push	[bp+argLbxFileName] ; argLbxFileName

loc_16602:		; No Operation
nop
push	cs
call	near ptr LBX_LoadFileMemory ; mov     ax, 1
			; push	  ax
			; push	  [bp+LbxFileName]
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_LoadFileIndex1	; sp-analysis failed



; mov	  ax, 1
; push	  ax
; push	  [bp+LbxFileName]
; Attributes: bp-based frame

; int __fastcall __far LBX_LoadFileMemory(char *argLbxFileName,	int argLbxMemberNumber)
proc LBX_LoadFileMemory	far
			; CODE XREF: sub_165E6+Bp
			; LBX_LoadFileIndex1+Cp

varLbxFileName=	byte ptr -3Eh
varDestFileName= byte ptr -2Ah
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
varEmsPageNumber= word ptr -0Eh
varBytesToRead=	word ptr -0Ch
varEmmPageFrameSegmentAddress= word ptr	-0Ah
EmmPageCount= dword ptr	-8
varEmsPageHandle= word ptr -4
varFileHandle= word ptr	-2
argLbxFileName=	word ptr  6
argLbxMemberNumber= word ptr  8

push	bp
mov	bp, sp
sub	sp, 3Eh		; Integer Subtraction
push	si		; argSrc
push	di		; src
push	[bp+argLbxFileName] ; argNameCharArr
call	ST_RemoveExtensionUppercaseName	; Call Procedure
pop	cx
push	[bp+argLbxFileName]
lea	ax, [bp+varLbxFileName]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
xor	si, si		; SI = 0
jmp	short LOOP_TO_EOS ; Jump

NEXT_BYTE:		; CODE XREF: LBX_LoadFileMemory+28j
inc	si		; Increment by 1

LOOP_TO_EOS:		; CODE XREF: LBX_LoadFileMemory+21j
cmp	[bp+si+varLbxFileName],	0 ; varLbxFileName
jnz	short NEXT_BYTE	; Jump if Not Zero (ZF=0)
mov	di, si		; Copy the Count of Bytes (SI) into DI
jmp	short GOT_EOS	; Jump

APPEND_ZERO:		; CODE XREF: LBX_LoadFileMemory+36j
mov	[bp+di+varLbxFileName],	0
inc	di		; Increment by 1

GOT_EOS:		; CODE XREF: LBX_LoadFileMemory+2Cj
cmp	di, 9		; If (DI < 9) Then Set ()
jl	short APPEND_ZERO ; Jump if Less (SF!=OF)

loc_16643:
mov	[word ptr bp+EmmPageCount+2], 0
xor	si, si		; SI = 0
jmp	short loc_1666C	; Jump

loc_1664C:		; CODE XREF: LBX_LoadFileMemory+65j
lea	ax, [bp+varLbxFileName]	; Load Effective Address
push	ax

loc_16650:
mov	ax, si
mov	dx, 12
imul	dx		; AX = AX * DX
add	ax, 0A5F2h	; Add
push	ax		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short STR_MISMATCH ; Jump if Not Zero (ZF=0)
mov	[word ptr bp+EmmPageCount+2], 1

STR_MISMATCH:		; CODE XREF: LBX_LoadFileMemory+59j
inc	si		; Increment by 1

loc_1666C:		; CODE XREF: LBX_LoadFileMemory+3Fj
cmp	si, [hrmEmmPageCount] ;	Compare	Two Operands
jl	short loc_1664C	; Jump if Less (SF!=OF)
cmp	[word ptr bp+EmmPageCount+2], 0	; Compare Two Operands

loc_16676:		; Jump if Zero (ZF=1)
jz	short loc_1668B
xor	ax, ax		; AX = 0
push	ax
mov	ax, e_EMS_RELOAD_WO_RELEASE ; 0xB     EMM loading error. Insufficient EMM.
push	ax
lea	ax, [bp+varLbxFileName]	; arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_1668B:		; CODE XREF: LBX_LoadFileMemory:loc_16676j
cmp	[word_3C300], 0	; Compare Two Operands
jnz	short loc_16695	; Jump if Not Zero (ZF=0)
jmp	loc_16813	; Jump

loc_16695:		; CODE XREF: LBX_LoadFileMemory+85j
cmp	[hrmEmmPageCount], 28h ; Compare Two Operands
jl	short loc_1669F	; Jump if Less (SF!=OF)
jmp	loc_16813	; Jump

loc_1669F:		; CODE XREF: LBX_LoadFileMemory+8Fj
lea	ax, [bp+varLbxFileName]	; Load Effective Address
push	ax
lea	ax, [bp+varDestFileName] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_166AE:		; ".LBX"
mov	ax, offset strDotLBX
push	ax
lea	ax, [bp+varDestFileName] ; Load	Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varDestFileName] ; Load	Effective Address
push	ax		; argFileName
call	DOS_FindFirst	; char *argFileName {AX	= FileSize DX =	FileName}
pop	cx
mov	[bp+var_10], dx
mov	[bp+var_12], ax
mov	ax, [bp+var_12]
or	ax, [bp+var_10]	; Logical Inclusive OR
jnz	short loc_166D8	; Jump if Not Zero (ZF=0)

loc_166D5:		; Jump
jmp	loc_16813

loc_166D8:		; CODE XREF: LBX_LoadFileMemory+C8j
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16384	; 1024 * 16? 256 * 64?
push	ax		; int
push	dx

loc_166DF:
push	[bp+var_10]
push	[bp+var_12]	; int
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[word ptr bp+EmmPageCount], ax

loc_166ED:		; Logical Exclusive OR
xor	ax, ax
mov	dx, 16384
push	ax
push	dx

loc_166F4:
push	[bp+var_10]
push	[bp+var_12]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
or	ax, dx		; Logical Inclusive OR
jz	short loc_16706	; Jump if Zero (ZF=1)
inc	[word ptr bp+EmmPageCount] ; Increment by 1

loc_16706:		; CODE XREF: LBX_LoadFileMemory+F6j
cmp	[bp+argLbxMemberNumber], 0 ; Compare Two Operands
jnz	short loc_16721	; Jump if Not Zero (ZF=0)
call	DOS_GetNumberOfPages ; DOS - LIM EMS - GET NUMBER OF PAGES
			; Return:
			;   AH = status, 00h function successful
			;   BX = number	of unallocated pages
			;   DX = total number of pages
mov	dx, [ST_HeapBase]
add	dx, [word ptr bp+EmmPageCount] ; argEmmHandleName
cmp	ax, dx		; Compare Two Operands
jnb	short loc_16721	; Jump if Not Below (CF=0)
xor	ax, ax		; AX = 0

loc_1671E:		; CODE XREF: LBX_LoadFileMemory:loc_16816j
jmp	loc_16819	; Jump

loc_16721:		; CODE XREF: LBX_LoadFileMemory+FFj
			; LBX_LoadFileMemory+10Fj
push	[bp+argLbxMemberNumber]	; argValue
lea	ax, [bp+varLbxFileName]	; argValue
push	ax		; argHandleName
push	[word ptr bp+EmmPageCount] ; argEmmPageCount
nop			; No Operation
push	cs
call	near ptr EMM_Allocate ;	Call Procedure

loc_16730:		; Add
add	sp, 6
mov	[bp+varEmsPageHandle], ax
cmp	[bp+varEmsPageHandle], 0 ; Compare Two Operands
jnz	short loc_1673F	; Jump if Not Zero (ZF=0)
jmp	loc_167FB	; Jump

loc_1673F:		; CODE XREF: LBX_LoadFileMemory+12Fj
call	fncGetEmmPageFrameSegmentAddress ;   mov     ax, seg dseg
			;   mov	    ds,	ax
			;   mov	    ax,	adrEMM_PageFrameSegment
mov	[bp+varEmmPageFrameSegmentAddress], ax
mov	[bp+varEmsPageNumber], 0

loc_1674C:		; Compare Two Operands
cmp	[bp+varEmmPageFrameSegmentAddress], 0
jnz	short loc_16755	; Jump if Not Zero (ZF=0)
jmp	loc_167F9	; Jump

loc_16755:		; CODE XREF: LBX_LoadFileMemory+145j
lea	ax, [bp+varDestFileName] ; Load	Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	[bp+varFileHandle], ax
cmp	[bp+varFileHandle], 0 ;	Compare	Two Operands
jnz	short loc_1676B	; Jump if Not Zero (ZF=0)
jmp	loc_167F9	; Jump

loc_1676B:		; CODE XREF: LBX_LoadFileMemory+15Bj
mov	[bp+var_14], 0
mov	[bp+var_16], 0
mov	[bp+varBytesToRead], 16384
jmp	short loc_167AF	; Jump

loc_1677C:		; CODE XREF: LBX_LoadFileMemory+1A8j
			; LBX_LoadFileMemory+1B1j
sub	[bp+var_12], 16384 ; Integer Subtraction
sbb	[bp+var_10], 0	; Integer Subtraction with Borrow
push	[bp+varEmsPageNumber]
push	[bp+varEmsPageHandle]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
push	[bp+varFileHandle] ; argFileHandle
push	[bp+varBytesToRead] ; argBytes
push	[bp+varEmmPageFrameSegmentAddress] ; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
inc	[bp+varEmsPageNumber] ;	Increment by 1
add	[bp+var_16], 16384 ; Add
adc	[bp+var_14], 0	; Add with Carry

loc_167AF:		; CODE XREF: LBX_LoadFileMemory+16Fj
cmp	[bp+var_10], 0	; Compare Two Operands
jg	short loc_1677C	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_167BE	; Jump if Less (SF!=OF)
cmp	[bp+var_12], 16384 ; Compare Two Operands
jnb	short loc_1677C	; Jump if Not Below (CF=0)

loc_167BE:		; CODE XREF: LBX_LoadFileMemory+1AAj
cmp	[bp+var_10], 0	; Compare Two Operands
jl	short loc_167F0	; Jump if Less (SF!=OF)
jg	short loc_167CC	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_12], 0	; Compare Two Operands
jbe	short loc_167F0	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_167CC:		; CODE XREF: LBX_LoadFileMemory+1B9j
mov	ax, [bp+var_12]
mov	[bp+varBytesToRead], ax
push	[bp+varEmsPageNumber]
push	[bp+varEmsPageHandle]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx

loc_167DF:		; Buffer
push	[bp+varFileHandle]
push	[bp+varBytesToRead] ; Bytes
push	[bp+varEmmPageFrameSegmentAddress] ; Handle
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

loc_167ED:		; Add
add	sp, 6

loc_167F0:		; CODE XREF: LBX_LoadFileMemory+1B7j
			; LBX_LoadFileMemory+1BFj
push	[bp+varFileHandle]

loc_167F3:		; DOS -	2+ - CLOSE A FILE WITH HANDLE
call	DOS_CloseFileWithHandle	;   argFileHandle = BX = file handle
pop	cx

loc_167F9:		; CODE XREF: LBX_LoadFileMemory+147j
			; LBX_LoadFileMemory+15Dj
jmp	short loc_16813	; Jump

loc_167FB:		; CODE XREF: LBX_LoadFileMemory+131j
cmp	[bp+argLbxMemberNumber], 1 ; Compare Two Operands
jnz	short loc_16813	; Jump if Not Zero (ZF=0)
xor	ax, ax		; AX = 0
push	ax		; argLbxEntryNumber
mov	ax, e_LBX_ErrorType_15 ; arg0_LbxFileName
push	ax		; ErrNo
push	[bp+argLbxFileName] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_16813:		; CODE XREF: LBX_LoadFileMemory+87j
			; LBX_LoadFileMemory+91j
			; LBX_LoadFileMemory:loc_166D5j
			; LBX_LoadFileMemory:loc_167F9j
			; LBX_LoadFileMemory+1F4j
mov	ax, [bp+varEmsPageHandle]

loc_16816:		; Jump
jmp	loc_1671E

loc_16819:		; CODE XREF: LBX_LoadFileMemory:loc_1671Ej
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_LoadFileMemory	; sp-analysis failed



; Attributes: bp-based frame

proc sub_1681F far

argFileName= word ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_16820:
mov	bp, sp
push	[bp+arg_4]	; int

loc_16825:		; int
xor	ax, ax
push	ax		; int

loc_16828:		; int
push	[bp+arg_2]
push	[bp+argFileName] ; argFileName
nop			; No Operation
push	cs
call	near ptr LBX_AllocMem ;	Call Procedure
add	sp, 8		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1681F ; sp-analysis failed



; Attributes: bp-based frame

proc sub_16838 far

argFileName= word ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	[bp+arg_4]	; int

loc_1683E:		; int
mov	ax, 1
push	ax		; int
push	[bp+arg_2]	; int
push	[bp+argFileName] ; argFileName
nop			; No Operation
push	cs
call	near ptr LBX_AllocMem ;	Call Procedure
add	sp, 8		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_16838 ; sp-analysis failed



; Attributes: bp-based frame

; int __fastcall __far LBX_AllocMem(int, int, int, int,	int, int, int argFileName)
proc LBX_AllocMem far	; CODE XREF: sub_1681F+11p
			; sub_16838+12p

var42_value= word ptr -42h
var2E_LbxFileName= word	ptr -2Eh
var1A_offsetDX=	word ptr -1Ah
var18_offsetCX=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
varE_OutputBuffer= word	ptr -0Eh
varC_ByteCount=	word ptr -0Ch
varA_EmmPageCount= dword ptr -0Ah
var_6= word ptr	-6
var_4= word ptr	-4
arg4_FileHandle= word ptr -2
argFileName= word ptr  6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 42h		; Integer Subtraction
push	si
push	di		; argSrc
push	[bp+argFileName] ; argNameCharArr
call	ST_RemoveExtensionUppercaseName	; Call Procedure
pop	cx
push	[bp+argFileName] ; argSrc
lea	ax, [bp+var2E_LbxFileName] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx

loc_16870:
pop	cx
push	[bp+arg_6]	; argSrc
lea	ax, [bp+var42_value] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
xor	si, si		; Logical Exclusive OR
jmp	short loc_16884	; Jump

loc_16883:		; CODE XREF: LBX_AllocMem+36j
inc	si		; Increment by 1

loc_16884:		; CODE XREF: LBX_AllocMem+2Fj
cmp	[byte ptr bp+si+var42_value], 0	; Compare Two Operands
jnz	short loc_16883	; Jump if Not Zero (ZF=0)
mov	di, si
jmp	short LOOP_x9	; Jump

LOOP:			; CODE XREF: LBX_AllocMem+44j
mov	[byte ptr bp+di+var42_value], 0
inc	di		; Increment by 1

LOOP_x9:		; CODE XREF: LBX_AllocMem+3Aj
cmp	di, 9		; Compare Two Operands
jl	short LOOP	; Jump if Less (SF!=OF)

END_LOOP:
mov	[bp+var_6], 0

loc_1689D:		; Logical Exclusive OR
xor	si, si
jmp	short LOOP_PageCount ; Jump

COMPARE_WHAT:		; CODE XREF: LBX_AllocMem+73j
lea	ax, [bp+var42_value] ; Load Effective Address
push	ax		; str2
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
add	ax, offset Emm_PgCnt_w3C302 ; ?word_3C302?

loc_168AF:		; str1
push	ax
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short END_LOOP_PageCount ; Jump	if Not Zero (ZF=0)
mov	[bp+var_6], 1

END_LOOP_PageCount:	; CODE XREF: LBX_AllocMem+67j
inc	si		; Increment by 1

LOOP_PageCount:		; CODE XREF: LBX_AllocMem+4Dj
cmp	si, [hrmEmmPageCount] ;	Compare	Two Operands
jl	short COMPARE_WHAT ; Jump if Less (SF!=OF)
cmp	[bp+var_6], 0	; If (AX != 0) Then Set	(ZF = 1)
jz	short loc_168E0	; Jump if Zero (ZF=1)
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, e_EMS_RELOAD_WO_RELEASE ; no reload	w/o release
push	ax
lea	ax, [bp+var2E_LbxFileName] ; arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_168E0:		; CODE XREF: LBX_AllocMem+79j
cmp	[word_3C300], 0	; Compare Two Operands
jnz	short loc_168EA	; Jump if Not Zero (ZF=0)
jmp	loc_16A2F	; Jump

loc_168EA:		; CODE XREF: LBX_AllocMem+93j
cmp	[hrmEmmPageCount], 40 ;	Compare	Two Operands
jl	short loc_168F4	; Jump if Less (SF!=OF)
jmp	loc_16A2F	; Jump

loc_168F4:		; CODE XREF: LBX_AllocMem+9Dj
push	[bp+arg_4]	; int
lea	ax, [bp+var_16]	; Load Effective Address
push	ax		; int
lea	ax, [bp+var1A_offsetDX]	; Load Effective Address
push	ax		; int
push	[word ptr bp+8]	; int
lea	ax, [bp+var2E_LbxFileName] ; int
push	ax		; int
call	LBX_Load_Entry_4bytes ;	Call Procedure
add	sp, 0Ah		; Add
mov	[bp+arg4_FileHandle], ax
push	[bp+arg4_FileHandle] ; arg4_FileHandle
push	[bp+var18_offsetCX] ; arg2_OffsetHigh
push	[bp+var1A_offsetDX] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add

loc_16922:		; Logical Inclusive OR
or	ax, ax
jnz	short loc_16939	; Jump if Not Zero (ZF=0)
push	[word ptr bp+8]
mov	ax, e_CORRUPTED	; Case 0x1: Corrupted
push	ax
lea	ax, [bp+var2E_LbxFileName] ; arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_16939:		; CODE XREF: LBX_AllocMem+D2j
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16384	; ?16384 / 64 =	256?
push	ax
push	dx
push	[bp+var_14]
push	[bp+var_16]
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[word ptr bp+varA_EmmPageCount], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16384	; ?16384 / 64 =	256?
push	ax
push	dx
push	[bp+var_14]
push	[bp+var_16]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
or	ax, dx		; Logical Inclusive OR
jz	short loc_16967	; Jump if Zero (ZF=1)
inc	[word ptr bp+varA_EmmPageCount]	; Increment by 1

loc_16967:		; CODE XREF: LBX_AllocMem+110j
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg4_value
lea	ax, [bp+var42_value] ; argValue
push	ax

loc_1696E:		; arg0_EmmPageCount
push	[word ptr bp+varA_EmmPageCount]
nop			; No Operation
push	cs
call	near ptr EMM_Allocate ;	Call Procedure
add	sp, 6		; Add
mov	[bp+var_4], ax
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_16995	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, e_INSUFFICIENT_EMM ; Case 0xB: Insufficient	EMM
push	ax
lea	ax, [bp+var2E_LbxFileName] ; arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_16995:		; CODE XREF: LBX_AllocMem+12Ej
call	fncGetEmmPageFrameSegmentAddress ;   mov     ax, seg dseg
			;   mov	    ds,	ax
			;   mov	    ax,	adrEMM_PageFrameSegment
mov	[bp+varC_ByteCount], ax
mov	[word ptr bp+varA_EmmPageCount+2], 0
mov	ax, [bp+var_14]
mov	dx, [bp+var_16]
mov	[bp+var_10], ax
mov	[bp+var_12], dx
mov	[bp+varE_OutputBuffer],	16384
jmp	short loc_169DF	; Jump

loc_169B5:		; CODE XREF: LBX_AllocMem:loc_169E3j
			; LBX_AllocMem+19Aj
sub	[bp+var_12], 16384 ; Integer Subtraction
sbb	[bp+var_10], 0	; Integer Subtraction with Borrow
push	[word ptr bp+varA_EmmPageCount+2]
push	[bp+var_4]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
push	[bp+arg4_FileHandle] ; argFileHandle
push	[bp+varE_OutputBuffer] ; argBytes
push	[bp+varC_ByteCount] ; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
inc	[word ptr bp+varA_EmmPageCount+2] ; Increment by 1

loc_169DF:		; CODE XREF: LBX_AllocMem+161j
cmp	[bp+var_10], 0	; Compare Two Operands

loc_169E3:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_169B5
jl	short loc_169EE	; Jump if Less (SF!=OF)
cmp	[bp+var_12], 16384 ; Compare Two Operands
jnb	short loc_169B5	; Jump if Not Below (CF=0)

loc_169EE:		; CODE XREF: LBX_AllocMem+193j
cmp	[bp+var_10], 0	; Compare Two Operands
jl	short loc_16A2F	; Jump if Less (SF!=OF)
jg	short loc_169FC	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_12], 0	; Compare Two Operands

loc_169FA:		; Jump if Below	or Equal (CF=1 | ZF=1)
jbe	short loc_16A2F

loc_169FC:		; CODE XREF: LBX_AllocMem+1A2j
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16
push	ax
push	dx
push	[bp+var_10]
push	[bp+var_12]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
mov	[bp+varE_OutputBuffer],	ax
push	[word ptr bp+varA_EmmPageCount+2]
push	[bp+var_4]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
push	[bp+arg4_FileHandle] ; argFileHandle
push	[bp+varE_OutputBuffer] ; argBytes
push	[bp+varC_ByteCount] ; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add

loc_16A2F:		; CODE XREF: LBX_AllocMem+95j
			; LBX_AllocMem+9Fj
			; LBX_AllocMem+1A0j
			; LBX_AllocMem:loc_169FAj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_AllocMem ; sp-analysis	failed



; Attributes: bp-based frame

proc sub_16A35 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
push	[bp+arg_C]	; int
push	[bp+arg_A]	; int

loc_16A3E:		; int
push	[bp+arg_8]
push	[bp+arg_6]	; int
push	[bp+arg_4]	; int
xor	ax, ax		; int
push	ax		; int
push	[bp+arg_2]	; int
push	[bp+arg_0]	; int
nop			; No Operation
push	cs

loc_16A52:		; Call Procedure
call	near ptr LBX_s16A80

loc_16A55:		; Add
add	sp, 10h
pop	bp

locret_16A59:		; Return Far from Procedure
retf
endp sub_16A35 ; sp-analysis failed



; Attributes: bp-based frame

proc sub_16A5A far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
push	[bp+arg_C]	; int
push	[bp+arg_A]	; int

loc_16A63:		; int
push	[bp+arg_8]
push	[bp+arg_6]	; int

loc_16A69:		; int
push	[bp+arg_4]

loc_16A6C:		; int
mov	ax, 1
push	ax		; int

loc_16A70:		; int
push	[bp+arg_2]
push	[bp+arg_0]	; int
nop			; No Operation
push	cs
call	near ptr LBX_s16A80 ; Call Procedure
add	sp, 10h		; Add
pop	bp

locret_16A7F:		; Return Far from Procedure
retf
endp sub_16A5A ; sp-analysis failed



; Attributes: bp-based frame

; int __fastcall __far LBX_s16A80(int, int, int, int, int, int,	int, int, int, int, int)
proc LBX_s16A80	far	; CODE XREF: sub_16A35:loc_16A52p
			; sub_16A5A+1Ep

argValue= word ptr -42h
argDest= word ptr -2Eh
arg0_OffsetLow=	word ptr -1Ah
arg2_OffsetHigh= word ptr -18h
arg4_value= word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
argBytes= word ptr -0Eh
argBuffer= word	ptr -0Ch
arg0_EmmPageCount= dword ptr -0Ah
var_6= word ptr	-6
var_4= word ptr	-4
arg4_FileHandle= word ptr -2
argString= word	ptr  6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg2_ErrNo= word ptr  0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp

loc_16A81:
mov	bp, sp

loc_16A83:		; Integer Subtraction
sub	sp, 66
push	si
push	di		; argSrc
push	[bp+argString]	; argNameCharArr
call	ST_RemoveExtensionUppercaseName	; Call Procedure

loc_16A90:
pop	cx
push	[bp+argString]
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest

loc_16A98:		; argDest,argSrc
call	_strcpy
pop	cx
pop	cx
push	[bp+arg_6]
lea	ax, [bp+argValue] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx

loc_16AAC:
pop	cx
xor	si, si		; Logical Exclusive OR
jmp	short loc_16AB2	; Jump

loc_16AB1:		; CODE XREF: LBX_s16A80+36j
inc	si		; Increment by 1

loc_16AB2:		; CODE XREF: LBX_s16A80+2Fj
cmp	[byte ptr bp+si+argValue], 0 ; Compare Two Operands
jnz	short loc_16AB1	; Jump if Not Zero (ZF=0)

loc_16AB8:
mov	di, si
jmp	short loc_16AC1	; Jump

loc_16ABC:		; CODE XREF: LBX_s16A80+44j
mov	[byte ptr bp+di+argValue], 0
inc	di		; Increment by 1

loc_16AC1:		; CODE XREF: LBX_s16A80+3Aj
cmp	di, 9		; Compare Two Operands
jl	short loc_16ABC	; Jump if Less (SF!=OF)
mov	[bp+var_6], 0
xor	si, si		; Logical Exclusive OR
jmp	short loc_16AEF	; Jump

loc_16ACF:		; CODE XREF: LBX_s16A80+73j
lea	ax, [bp+argValue] ; Load Effective Address
push	ax
mov	ax, si
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, 0A5F2h	; Add
push	ax		; str1

loc_16ADE:		; Case-Insensitive String Comparison (i.e. strcasecmp)
call	_stricmp	; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_16AEE	; Jump if Not Zero (ZF=0)
mov	[bp+var_6], 1

loc_16AEE:		; CODE XREF: LBX_s16A80+67j
inc	si		; Increment by 1

loc_16AEF:		; CODE XREF: LBX_s16A80+4Dj
cmp	si, [hrmEmmPageCount] ;	Compare	Two Operands
jl	short loc_16ACF	; Jump if Less (SF!=OF)
cmp	[bp+var_6], 0	; Compare Two Operands
jz	short loc_16B0E	; Jump if Zero (ZF=1)

loc_16AFB:		; Logical Exclusive OR
xor	ax, ax
push	ax		; argLbxEntryNumber
mov	ax, e_EMS_RELOAD_WO_RELEASE
push	ax		; ErrNo

loc_16B02:		; arg0_LbxFileName
lea	ax, [bp+argDest]
push	ax		; arg6_MemShort

loc_16B06:		; Call Procedure
call	LBX_Load_ErrorHandler
add	sp, 6		; Add

loc_16B0E:		; CODE XREF: LBX_s16A80+79j
cmp	[word_3C300], 0	; Compare Two Operands
jnz	short loc_16B18	; Jump if Not Zero (ZF=0)
jmp	loc_16CA1	; Jump

loc_16B18:		; CODE XREF: LBX_s16A80+93j
cmp	[hrmEmmPageCount], 28h ; '(' ; Compare Two Operands
jl	short loc_16B22	; Jump if Less (SF!=OF)
jmp	loc_16CA1	; Jump

loc_16B22:		; CODE XREF: LBX_s16A80+9Dj
push	[bp+arg_4]	; int
lea	ax, [bp+arg4_value] ; Load Effective Address
push	ax		; int
lea	ax, [bp+arg0_OffsetLow]	; Load Effective Address
push	ax		; int
push	[word ptr bp+8]	; int
lea	ax, [bp+argDest] ; int
push	ax		; int
call	LBX_Load_Entry_4bytes ;	Call Procedure
add	sp, 0Ah		; Add
mov	[bp+arg4_FileHandle], ax
mov	ax, [bp+arg_A]
mov	dx, [bp+arg2_ErrNo]
add	[bp+arg0_OffsetLow], dx	; Add
adc	[bp+arg2_OffsetHigh], ax ; Add with Carry
mov	ax, [bp+arg_A]
mov	dx, [bp+arg2_ErrNo] ; arg2_ErrNo
sub	[bp+arg4_value], dx ; Integer Subtraction
sbb	[bp+var_14], ax	; Integer Subtraction with Borrow
cmp	[bp+var_14], 0	; Compare Two Operands
jg	short loc_16B78	; Jump if Greater (ZF=0	& SF=OF)
jnz	short loc_16B65	; Jump if Not Zero (ZF=0)
cmp	[bp+arg4_value], 0 ; Compare Two Operands
ja	short loc_16B78	; Jump if Above	(CF=0 &	ZF=0)

loc_16B65:		; CODE XREF: LBX_s16A80+DDj
push	[word ptr bp+8]	; argLbxEntryNumber
mov	ax, e_CORRUPTED
push	ax		; ErrNo
lea	ax, [bp+argDest] ; arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_16B78:		; CODE XREF: LBX_s16A80+DBj
			; LBX_s16A80+E3j
mov	ax, [bp+arg_E]
mov	dx, [bp+arg_C]

loc_16B7E:		; Compare Two Operands
cmp	ax, [bp+var_14]
jg	short loc_16B96	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_16B8A	; Jump if Less (SF!=OF)
cmp	dx, [bp+arg4_value] ; Compare Two Operands
jnb	short loc_16B96	; Jump if Not Below (CF=0)

loc_16B8A:		; CODE XREF: LBX_s16A80+103j
mov	ax, [bp+arg_E]
mov	dx, [bp+arg_C]	; arg2_ErrNo
mov	[bp+var_14], ax
mov	[bp+arg4_value], dx

loc_16B96:		; CODE XREF: LBX_s16A80+101j
			; LBX_s16A80+108j
push	[bp+arg4_FileHandle] ; arg4_FileHandle
push	[bp+arg2_OffsetHigh] ; arg2_OffsetHigh
push	[bp+arg0_OffsetLow] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_16BBE	; Jump if Not Zero (ZF=0)
push	[word ptr bp+8]	; argLbxEntryNumber
mov	ax, e_CORRUPTED
push	ax		; ErrNo
lea	ax, [bp+argDest] ; arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_16BBE:		; CODE XREF: LBX_s16A80+129j
xor	ax, ax		; Logical Exclusive OR
mov	dx, 4000h	; arg2_ErrNo
push	ax		; int
push	dx
push	[bp+var_14]
push	[bp+arg4_value]	; arg4_value
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[word ptr bp+arg0_EmmPageCount], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 4000h	; arg2_ErrNo
push	ax
push	dx
push	[bp+var_14]
push	[bp+arg4_value]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
or	ax, dx		; Logical Inclusive OR
jz	short loc_16BEC	; Jump if Zero (ZF=1)
inc	[word ptr bp+arg0_EmmPageCount]	; Increment by 1

loc_16BEC:		; CODE XREF: LBX_s16A80+167j
lea	ax, [bp+argValue] ; argValue
push	ax
push	[word ptr bp+arg0_EmmPageCount]	; arg0_EmmPageCount
nop			; No Operation
push	cs
call	near ptr EMM_Allocate ;	Call Procedure
pop	cx
pop	cx

loc_16BFA:
mov	[bp+var_4], ax

loc_16BFD:		; Compare Two Operands
cmp	[bp+var_4], 0
jnz	short loc_16C16	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax		; argLbxEntryNumber
mov	ax, e_INSUFFICIENT_EMM
push	ax		; ErrNo
lea	ax, [bp+argDest] ; arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_16C16:		; CODE XREF: LBX_s16A80+181j
call	fncGetEmmPageFrameSegmentAddress ;   mov     ax, seg dseg
			;   mov	    ds,	ax
			;   mov	    ax,	adrEMM_PageFrameSegment

loc_16C1B:
mov	[bp+argBuffer],	ax
mov	[word ptr bp+arg0_EmmPageCount+2], 0
mov	ax, [bp+var_14]
mov	dx, [bp+arg4_value]
mov	[bp+var_10], ax
mov	[bp+var_12], dx

loc_16C2F:
mov	[bp+argBytes], 4000h
jmp	short loc_16C60	; Jump

loc_16C36:		; CODE XREF: LBX_s16A80+1E4j
			; LBX_s16A80+1EDj
sub	[bp+var_12], 4000h ; Integer Subtraction

loc_16C3B:		; Integer Subtraction with Borrow
sbb	[bp+var_10], 0
push	[word ptr bp+arg0_EmmPageCount+2]
push	[bp+var_4]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
push	[bp+arg4_FileHandle] ; argFileHandle
push	[bp+argBytes]	; argBytes
push	[bp+argBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
inc	[word ptr bp+arg0_EmmPageCount+2] ; Increment by 1

loc_16C60:		; CODE XREF: LBX_s16A80+1B4j
cmp	[bp+var_10], 0	; Compare Two Operands
jg	short loc_16C36	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_16C6F	; Jump if Less (SF!=OF)
cmp	[bp+var_12], 4000h ; Compare Two Operands
jnb	short loc_16C36	; Jump if Not Below (CF=0)

loc_16C6F:		; CODE XREF: LBX_s16A80+1E6j
cmp	[bp+var_10], 0	; Compare Two Operands
jl	short loc_16CA1	; Jump if Less (SF!=OF)
jg	short loc_16C7D	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_12], 0	; Compare Two Operands
jbe	short loc_16CA1	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_16C7D:		; CODE XREF: LBX_s16A80+1F5j
mov	ax, [bp+var_12]
mov	[bp+argBytes], ax
push	[word ptr bp+arg0_EmmPageCount+2]
push	[bp+var_4]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
push	[bp+arg4_FileHandle] ; argFileHandle
push	[bp+argBytes]	; argBytes
push	[bp+argBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add

loc_16CA1:		; CODE XREF: LBX_s16A80+95j
			; LBX_s16A80+9Fj
			; LBX_s16A80+1F3j
			; LBX_s16A80+1FBj
pop	di
pop	si
mov	sp, bp

loc_16CA5:
pop	bp
retf			; Return Far from Procedure
endp LBX_s16A80	; sp-analysis failed



; Only 1 Call -	from LBX_LoadEntry
; Attributes: bp-based frame

; int __fastcall __far LBX_EmsMapMem(int, int, int, int, int, int argPtrBuffer_EMS, int, int)
proc LBX_EmsMapMem far	; CODE XREF: LBX_Load_Entry+65P

var_18=	word ptr -18h
var_16=	word ptr -16h
varPtrSrcBuf= dword ptr	-14h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
varLdivResult= word ptr	-0Ch
var_ES=	word ptr -0Ah
var_ByteCount= word ptr	-8
var_DI=	word ptr -6
varEmsMemMap= word ptr -4
varMemCntOrHandle= word	ptr -2
arg_LbxFileNameBase= word ptr  6
arg_LbxEntryNumber= word ptr  8
argPtrBuffer_EMS= word ptr  0Ah
arg_arg6_DI= word ptr  0Ch
arg_var8_SI= word ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si		; int
push	di		; int
mov	si, [bp+argPtrBuffer_EMS]
xor	di, di		; Logical Exclusive OR
push	[bp+arg_LbxFileNameBase] ; argNameCharArr
nop			; No Operation
push	cs
call	near ptr Emm_PgCnt_s175B1 ; Call Procedure
pop	cx
mov	[bp+varMemCntOrHandle],	ax
cmp	[bp+varMemCntOrHandle],	0 ; Compare Two	Operands
jnz	short GOT_varMemCntOrHandle ; jz EXIT_AX_0_1of

EXIT_AX_0_1of:		; Jump
jmp	loc_16F3A

GOT_varMemCntOrHandle:	; CODE XREF: LBX_EmsMapMem+1Dj
cmp	[idk_LBX_w3C2FC], 1 ; 1	- idk_LBX_w3C2FC
jnz	short loc_16D24	; Jump if Not Zero (ZF=0)
push	[bp+varMemCntOrHandle] ; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount
xor	ax, ax		; Logical Exclusive OR
mov	dx, 6
push	ax		; arg4_6
push	dx		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_DI]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	;
			; EMS_MapMemory_4(var_DI,
			;		  0,
			;		  6,
			;		  0,
			;		  2,
			;		  varMemCntOrHandle)
			;
add	sp, 0Ch		; Add


cmp	[bp+var_DI], 0	; Compare Two Operands
jz	short loc_16D07	; Jump if Zero (ZF=1)
push	[bp+arg_LbxEntryNumber]
mov	ax, e_RESERVED_EMM_PICTURES_ONLY ; Case	0xC:
			; Only pictures	may be loaded into reserved EMM
push	ax
push	[bp+arg_LbxFileNameBase] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add
jmp	short loc_16D21	; Jump

loc_16D07:		; CODE XREF: LBX_EmsMapMem+4Aj
push	[bp+arg_var8_SI]
push	[bp+arg_arg6_DI] ; int
push	si		; int
push	[bp+arg_LbxEntryNumber]	; int
push	[bp+arg_LbxFileNameBase] ; int
push	[bp+varMemCntOrHandle] ; int
nop			; No Operation
push	cs
call	near ptr LBX_s16F45 ; Call Procedure
add	sp, 0Ch		; Add
mov	di, ax

loc_16D21:		; CODE XREF: LBX_EmsMapMem+5Ej
jmp	loc_16F3A	; Jump

loc_16D24:		; CODE XREF: LBX_EmsMapMem+27j
push	[bp+varMemCntOrHandle] ; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg4_6
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+varEmsMemMap] ;	Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [bp+arg_LbxEntryNumber]
cmp	ax, [bp+varEmsMemMap] ;	Compare	Two Operands
jl	short loc_16D4D	; Jump if Less (SF!=OF)

EXIT_AX_ZERO:		; CODE XREF: LBX_EmsMapMem+175j
			; LBX_EmsMapMem+186j
			; LBX_EmsMapMem+19Bj
			; LBX_EmsMapMem+1CDj
			; LBX_EmsMapMem:EXIT_AX_0_4ofj
xor	ax, ax		; Logical Exclusive OR

loc_16D4A:		; CODE XREF: LBX_EmsMapMem+295j
jmp	loc_16F3F	; Jump

loc_16D4D:		; CODE XREF: LBX_EmsMapMem+9Fj
cmp	[bp+arg_var8_SI], 0 ; 0	- arg_var8_SI
jnz	short arg8_SI_NOT_ZERO ; Jump if Not Zero (ZF=0)

arg8_SI_ZERO:
mov	ax, [bp+arg_LbxEntryNumber]
cwd			; AX ->	DX:AX (with sign)
mov	cl, 2
call	LXLSH@		; Long Left-Shift
add	ax, 8		; Add
jmp	short loc_16D71	; Jump

arg8_SI_NOT_ZERO:	; CODE XREF: LBX_EmsMapMem+AAj
mov	ax, [bp+arg_LbxEntryNumber]
cwd			; AX ->	DX:AX (with sign)
mov	cl, 2
call	LXLSH@		; Long Left-Shift
add	ax, 520		; Add

loc_16D71:		; CODE XREF: LBX_EmsMapMem+BAj
adc	dx, 0		; Add with Carry
mov	[bp+var_16], dx
mov	[bp+var_18], ax
push	[bp+varMemCntOrHandle] ; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount
push	[bp+var_16]	; arg4_6
push	[bp+var_18]	; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_10]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add


push	[bp+varMemCntOrHandle] ; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount
mov	ax, [bp+var_16]
mov	dx, [bp+var_18]
add	dx, 4		; Add
adc	ax, 0		; Add with Carry
push	ax		; arg4_6
push	dx		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+varPtrSrcBuf] ;	Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add


mov	ax, [bp+var_E]
mov	dx, [bp+var_10]
sub	[word ptr bp+varPtrSrcBuf], dx ; Integer Subtraction
sbb	[word ptr bp+varPtrSrcBuf+2], ax ; Integer Subtraction with Borrow
cmp	[word ptr bp+varPtrSrcBuf+2], 0	; Compare Two Operands
jge	short loc_16DCF	; Jump if Greater or Equal (SF=OF)

EXIT_AX_0_2of:		; Jump
jmp	loc_16F3A

loc_16DCF:		; CODE XREF: LBX_EmsMapMem+123j
jg	short loc_16DDA	; Jump if Greater (ZF=0	& SF=OF)
cmp	[word ptr bp+varPtrSrcBuf], 0 ;	Compare	Two Operands
ja	short loc_16DDA	; Jump if Above	(CF=0 &	ZF=0)

EXIT_AX_0_3of:		; Jump
jmp	loc_16F3A

loc_16DDA:		; CODE XREF: LBX_EmsMapMem:loc_16DCFj
			; LBX_EmsMapMem+12Ej
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16
push	ax
push	dx
push	[word ptr bp+varPtrSrcBuf+2]
push	[word ptr bp+varPtrSrcBuf] ; argPtrSrcBuf
call	LDIV@		; Long Division
mov	[bp+varLdivResult], ax
test	[bp+varLdivResult], 1111b ; Logical Compare
jz	short TypeCheck_1of3 ; Jump if Zero (ZF=1)
inc	[bp+varLdivResult] ; Increment by 1

TypeCheck_1of3:		; CODE XREF: LBX_EmsMapMem+14Dj
mov	ax, [bp+arg_arg6_DI]
or	ax, ax		; Logical Inclusive OR
jz	short loc_16E0D	; Jump if Zero (ZF=1)

TypeCheck_1of2:		; Compare Two Operands
cmp	ax, 1
jz	short loc_16E22	; Jump if Zero (ZF=1)

TypeCheck_3of3:		; Compare Two Operands
cmp	ax, 2
jz	short loc_16E5E	; Jump if Zero (ZF=1)
jmp	loc_16EAC	; Jump

loc_16E0D:		; CODE XREF: LBX_EmsMapMem+157j
push	[bp+varLdivResult]
call	malloc_s14954	; Call Procedure
pop	cx
mov	di, ax
or	di, di		; Logical Inclusive OR
jnz	short loc_16E1F	; Jump if Not Zero (ZF=0)
jmp	EXIT_AX_ZERO	; Jump

loc_16E1F:		; CODE XREF: LBX_EmsMapMem+173j
jmp	loc_16EAC	; Jump

loc_16E22:		; CODE XREF: LBX_EmsMapMem+15Cj
push	si		; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_16E30	; Jump if Not Zero (ZF=0)
jmp	EXIT_AX_ZERO	; Jump

loc_16E30:		; CODE XREF: LBX_EmsMapMem+184j
mov	ax, 8
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
dec	ax		; Decrement by 1
cmp	ax, [bp+varLdivResult] ; Compare Two Operands
jnb	short loc_16E45	; Jump if Not Below (CF=0)
jmp	EXIT_AX_ZERO	; Jump

loc_16E45:		; CODE XREF: LBX_EmsMapMem+199j
mov	ax, si
inc	ax		; Increment by 1
mov	di, ax
mov	ax, [bp+varLdivResult]
inc	ax		; Increment by 1
push	ax		; argValue

loc_16E4F:		; CODE XREF: LBX_EmsMapMem+203j
mov	ax, 10
push	ax		; argOffset
push	si		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
jmp	short loc_16EAC	; Jump

loc_16E5E:		; CODE XREF: LBX_EmsMapMem+161j
or	si, si		; Logical Inclusive OR
jnz	short loc_16E67	; Jump if Not Zero (ZF=0)
mov	ax, 1
jmp	short loc_16E69	; Jump

loc_16E67:		; CODE XREF: LBX_EmsMapMem+1B9j
xor	ax, ax		; Logical Exclusive OR

loc_16E69:		; CODE XREF: LBX_EmsMapMem+1BEj
push	ax		; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_16E77	; Jump if Zero (ZF=1)
jmp	EXIT_AX_ZERO	; Jump

loc_16E77:		; CODE XREF: LBX_EmsMapMem+1CBj
push	si
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
cmp	ax, [bp+varLdivResult] ; Compare Two Operands
jnb	short loc_16E86	; Jump if Not Below (CF=0)

EXIT_AX_0_4of:		; Jump
jmp	EXIT_AX_ZERO

loc_16E86:		; CODE XREF: LBX_EmsMapMem+1DAj
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, si
add	dx, ax		; Add
mov	di, dx
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varLdivResult]
add	dx, ax		; Add
push	dx
jmp	short loc_16E4F	; Jump

loc_16EAC:		; CODE XREF: LBX_EmsMapMem+163j
			; LBX_EmsMapMem:loc_16E1Fj
			; LBX_EmsMapMem+1B5j
or	di, di		; Logical Inclusive OR
jnz	short loc_16EB3	; Jump if Not Zero (ZF=0)

EXIT_AX_0_5of:		; Jump
jmp	loc_16F3A

loc_16EB3:		; CODE XREF: LBX_EmsMapMem+207j
mov	[bp+var_ES], di
mov	[bp+var_ByteCount], 32768
jmp	short loc_16EEE	; Jump

loc_16EBD:		; CODE XREF: LBX_EmsMapMem+24Bj
			; LBX_EmsMapMem+254j
sub	[word ptr bp+varPtrSrcBuf], 32768 ; Integer Subtraction
sbb	[word ptr bp+varPtrSrcBuf+2], 0	; Integer Subtraction with Borrow
push	[bp+varMemCntOrHandle] ; arg6_EmsHandle
push	[bp+var_ByteCount] ; arg5_ByteCount
push	[bp+var_E]	; arg4_6
push	[bp+var_10]	; arg3_4
push	[bp+var_ES]	; arg2_ES
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
add	[bp+var_10], 32768 ; Add
adc	[bp+var_E], 0	; Add with Carry
add	[bp+var_ES], 2048 ; Add

loc_16EEE:		; CODE XREF: LBX_EmsMapMem+214j
cmp	[word ptr bp+varPtrSrcBuf+2], 0	; Compare Two Operands
jg	short loc_16EBD	; Jump if Greater (ZF=0	& SF=OF)
jnz	short loc_16EFD	; Jump if Not Zero (ZF=0)
cmp	[word ptr bp+varPtrSrcBuf], 32768 ; Compare Two	Operands
ja	short loc_16EBD	; Jump if Above	(CF=0 &	ZF=0)

loc_16EFD:		; CODE XREF: LBX_EmsMapMem+24Dj
cmp	[word ptr bp+varPtrSrcBuf+2], 0	; Compare Two Operands
jl	short loc_16F3A	; Jump if Less (SF!=OF)

loc_16F03:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_16F0B
cmp	[word ptr bp+varPtrSrcBuf], 0 ;	Compare	Two Operands
jbe	short loc_16F3A	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_16F0B:		; CODE XREF: LBX_EmsMapMem:loc_16F03j
xor	ax, ax		; Logical Exclusive OR
mov	dx, 32768
push	ax
push	dx
push	[word ptr bp+varPtrSrcBuf+2]
push	[word ptr bp+varPtrSrcBuf]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
mov	[bp+var_ByteCount], ax
push	[bp+varMemCntOrHandle] ; arg6_EmsHandle
push	[bp+var_ByteCount] ; arg5_ByteCount
push	[bp+var_E]	; arg4_6
push	[bp+var_10]	; arg3_4
push	[bp+var_ES]	; arg2_ES
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add

loc_16F3A:		; CODE XREF: LBX_EmsMapMem:EXIT_AX_0_1ofj
			; LBX_EmsMapMem:loc_16D21j
			; LBX_EmsMapMem:EXIT_AX_0_2ofj
			; LBX_EmsMapMem:EXIT_AX_0_3ofj
			; LBX_EmsMapMem:EXIT_AX_0_5ofj
			; LBX_EmsMapMem+25Aj
			; LBX_EmsMapMem+262j
mov	ax, di
jmp	loc_16D4A	; Jump

loc_16F3F:		; CODE XREF: LBX_EmsMapMem:loc_16D4Aj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_EmsMapMem ; sp-analysis failed



; Attributes: bp-based frame

; int __fastcall __far LBX_s16F45(int, int, int, int, int, int)
proc LBX_s16F45	far	; CODE XREF: LBX_EmsMapMem+72p

var10= word ptr	-10h
varE= word ptr -0Eh
varC= word ptr -0Ch
varA= word ptr -0Ah
var8_Quotient= word ptr	-8
var6_Remainder=	word ptr -6
var4= word ptr -4
var2_DI= word ptr -2
arg6_EmsHandle=	word ptr  6
arg8_MemShort= word ptr	 8
argA_LbxEntryNumber= word ptr  0Ah
argC_DestES= word ptr  0Ch
argE= word ptr	0Eh

push	bp
mov	bp, sp
sub	sp, 10h		; arg2_SI
push	si
push	di		; int
mov	si, [bp+argC_DestES]
xor	di, di		; Logical Exclusive OR
push	[bp+arg6_EmsHandle] ; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg4_6
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var2_DI] ; Load	Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [bp+argA_LbxEntryNumber]
cmp	ax, [bp+var2_DI] ; Compare Two Operands
jl	short loc_16F88	; Jump if Less (SF!=OF)

loc_16F76:
push	[bp+argA_LbxEntryNumber]
mov	ax, 8		; Case 0x7:
			; exceeds number of LBX	entries
push	ax
push	[bp+arg8_MemShort] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_16F88:		; CODE XREF: LBX_s16F45+2Fj
mov	ax, [bp+argA_LbxEntryNumber]
cwd			; AX ->	DX:AX (with sign)
mov	cl, 2
call	LXLSH@		; Call Procedure
add	ax, 8		;
			; ? Add	8 for LBX Header Preamble ?
			;
adc	dx, 0		; arg2_ErrNo
mov	[bp+varE], dx
mov	[bp+var10], ax
push	[bp+arg6_EmsHandle] ; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount
push	[bp+varE]	; arg4_6
push	[bp+var10]	; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+varC]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
mov	[bp+var4], 1
mov	ax, [bp+argE]
or	ax, ax		; Logical Inclusive OR
jz	short argE_Is_0	; Jump if Zero (ZF=1)

argE_Not_0:		; Compare Two Operands
cmp	ax, 1
jz	short argE_Is_1	; Jump if Zero (ZF=1)

argE_Not_1_Not_0:	; Compare Two Operands
cmp	ax, 2
jnz	short argE_Not_2_Not_1_Not_0 ; Jump if Not Zero	(ZF=0)

argE_Is_2:		; Jump
jmp	loc_17059

argE_Not_2_Not_1_Not_0:	; CODE XREF: LBX_s16F45+8Aj
jmp	loc_170C9	; Jump

argE_Is_0:		; CODE XREF: LBX_s16F45+80j
push	[bp+var4]
call	malloc_s14954	; Call Procedure
pop	cx
mov	di, ax
or	di, di		; Logical Inclusive OR
jnz	short loc_16FF8	; Jump if Not Zero (ZF=0)
push	[bp+argA_LbxEntryNumber]
mov	ax, 3		; Case 0x2:
			; Insufficient memory. You need	at least [583]K	free.
push	ax
push	[bp+arg8_MemShort] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_16FF8:		; CODE XREF: LBX_s16F45+9Fj
jmp	loc_170C9	; int

argE_Is_1:		; CODE XREF: LBX_s16F45+85j
push	si		; SI = arg_6
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_17018	; Jump if Not Zero (ZF=0)
push	[bp+argA_LbxEntryNumber]
mov	ax, 4		; Case 0x3:
			; was not properly allocated or	has been corrupted
push	ax
push	[bp+arg8_MemShort] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_17018:		; CODE XREF: LBX_s16F45+BFj
mov	ax, 8
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
dec	ax		; Decrement by 1
cmp	ax, [bp+var4]	; Compare Two Operands
jnb	short loc_17040	; Jump if Not Below (CF=0)
mov	ax, 1
push	ax
push	[bp+argA_LbxEntryNumber]
mov	ax, 5		; Case 0x4:
			; failed to reload. Allocation too small by [x]	pages.
push	ax
push	[bp+arg8_MemShort] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 8		; Add

loc_17040:		; CODE XREF: LBX_s16F45+E3j
mov	ax, si
inc	ax		; Increment by 1
mov	di, ax
mov	ax, [bp+var4]
inc	ax		; Increment by 1
push	ax		; argValue

loc_1704A:		; CODE XREF: LBX_s16F45+182j
mov	ax, 10
push	ax		; argOffset
push	si		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
jmp	short loc_170C9	; int

loc_17059:		; CODE XREF: LBX_s16F45:argE_Is_2j
or	si, si		; Logical Inclusive OR
jnz	short loc_17062	; Jump if Not Zero (ZF=0)
mov	ax, 1
jmp	short loc_17064	; Jump

loc_17062:		; CODE XREF: LBX_s16F45+116j
xor	ax, ax		; Logical Exclusive OR

loc_17064:		; CODE XREF: LBX_s16F45+11Bj
push	ax		; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_17081	; Jump if Zero (ZF=1)

loc_1706F:
push	[bp+argA_LbxEntryNumber]
mov	ax, 4		; Case 0x3:
			; was not properly allocated or	has been corrupted
push	ax
push	[bp+arg8_MemShort] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_17081:		; CODE XREF: LBX_s16F45+128j
push	si
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
cmp	ax, [bp+var4]	; Compare Two Operands
jnb	short loc_170A3	; Jump if Not Below (CF=0)
mov	ax, 1
push	ax		; int
push	[bp+argA_LbxEntryNumber] ; argLbxEntryNumber
mov	ax, 5		; Case 0x4:
			; failed to reload. Allocation too small by [x]	pages.
push	ax		; ErrNo
push	[bp+arg8_MemShort] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 8		; Add

loc_170A3:		; CODE XREF: LBX_s16F45+146j
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, si
add	dx, ax		; Add
mov	di, dx
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+var4]
add	dx, ax		; Add
push	dx
jmp	short loc_1704A	; Jump

loc_170C9:		; CODE XREF: LBX_s16F45:argE_Not_2_Not_1_Not_0j
			; LBX_s16F45:loc_16FF8j
			; LBX_s16F45+112j
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16384
push	ax
push	dx
push	[bp+varA]
push	[bp+varC]
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var8_Quotient], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16384
push	ax
push	dx
push	[bp+varA]
push	[bp+varC]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
mov	[bp+var6_Remainder], ax
push	[bp+arg6_EmsHandle] ; arg6_EmsHandle
mov	ax, 16
push	ax		; arg5_ByteCount
push	[bp+varA]	; arg4_6
push	[bp+varC]	; arg3_4
push	di		; arg2_ES
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
push	[bp+arg6_EmsHandle]
mov	ax, 10
push	ax
push	di
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
push	[bp+var8_Quotient]
mov	ax, 11
push	ax
push	di
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
push	[bp+var6_Remainder] ; argValue
mov	ax, 12
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, di
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_s16F45	; sp-analysis failed



; Attributes: bp-based frame

proc idk_PreEmmPgCnt far
			; CODE XREF: LBX_Load_s15453+53P

arg3_4=	word ptr -1Ah
arg4_6=	word ptr -18h
argPtrSrcBuf= dword ptr	-16h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
arg2_ES= word ptr -8
arg5_ByteCount=	word ptr -6
arg1_DI= word ptr -4
var_2= word ptr	-2
argNameCharArr=	word ptr  6
arg_2= word ptr	 8
arg0_DestES= dword ptr	0Ah
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
sub	sp, 26		; Integer Subtraction
push	si
push	di
mov	si, [word ptr bp+arg0_DestES]
mov	[bp+var_2], 0
push	[bp+argNameCharArr] ; argNameCharArr
nop			; No Operation
push	cs
call	near ptr Emm_PgCnt_s175B1 ; Call Procedure
pop	cx
mov	di, ax
or	di, di		; Logical Inclusive OR
jnz	short loc_17168	; Jump if Not Zero (ZF=0)
jmp	loc_173FC	; Jump

loc_17168:		; CODE XREF: idk_PreEmmPgCnt+1Dj
push	di		; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg4_6
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+arg1_DI] ; Load	Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [bp+arg_2]
cmp	ax, [bp+arg1_DI] ; Compare Two Operands
jl	short loc_1718F	; Jump if Less (SF!=OF)

loc_1718A:		; CODE XREF: idk_PreEmmPgCnt:loc_17258j
			; idk_PreEmmPgCnt+120j
			; idk_PreEmmPgCnt:loc_172DBj
			; idk_PreEmmPgCnt+1A6j
			; idk_PreEmmPgCnt+1BBj
			; idk_PreEmmPgCnt+1EEj
			; idk_PreEmmPgCnt+1FDj
xor	ax, ax		; Logical Exclusive OR

loc_1718C:		; CODE XREF: idk_PreEmmPgCnt+2B9j
jmp	loc_17402	; Jump

loc_1718F:		; CODE XREF: idk_PreEmmPgCnt+42j
mov	ax, [bp+arg_2]
cwd			; AX ->	DX:AX (with sign)
mov	cl, 2
call	LXLSH@		; Call Procedure
add	ax, 8		; Add
adc	dx, 0		; Add with Carry
mov	[bp+arg4_6], dx
mov	[bp+arg3_4], ax
push	di		; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount
push	[bp+arg4_6]	; arg4_6
push	[bp+arg3_4]	; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_12]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
push	di		; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount
mov	ax, [bp+arg4_6]
mov	dx, [bp+arg3_4]
add	dx, 4		; Add
adc	ax, 0		; Add with Carry
push	ax		; arg4_6
push	dx		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+argPtrSrcBuf] ;	Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [bp+var_10]
mov	dx, [bp+var_12]
sub	[word ptr bp+argPtrSrcBuf], dx ; Integer Subtraction
sbb	[word ptr bp+argPtrSrcBuf+2], ax ; Integer Subtraction with Borrow
cmp	[word ptr bp+argPtrSrcBuf+2], 0	; Compare Two Operands
jge	short loc_171F7	; Jump if Greater or Equal (SF=OF)
jmp	loc_173FC	; Jump

loc_171F7:		; CODE XREF: idk_PreEmmPgCnt+ACj
jg	short loc_17202	; Jump if Greater (ZF=0	& SF=OF)
cmp	[word ptr bp+argPtrSrcBuf], 0 ;	Compare	Two Operands
ja	short loc_17202	; Jump if Above	(CF=0 &	ZF=0)

loc_171FF:		; Jump
jmp	loc_173FC

loc_17202:		; CODE XREF: idk_PreEmmPgCnt:loc_171F7j
			; idk_PreEmmPgCnt+B7j
mov	ax, [bp+var_10]
mov	dx, [bp+var_12]
mov	[bp+arg4_6], ax
mov	[bp+arg3_4], dx
push	di		; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount
push	[bp+arg4_6]	; arg4_6
push	[bp+arg3_4]	; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_E]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
push	di		; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount
mov	ax, [bp+arg4_6]
mov	dx, [bp+arg3_4]
add	dx, 2		; Add
adc	ax, 0		; Add with Carry
push	ax		; arg4_6
push	dx		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_C]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
cmp	[bp+var_C], 0	; Compare Two Operands
jz	short loc_17258	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_C]
cmp	ax, [bp+var_C]	; Compare Two Operands
jz	short loc_1725B	; Jump if Zero (ZF=1)

loc_17258:		; CODE XREF: idk_PreEmmPgCnt+108j
jmp	loc_1718A	; Jump

loc_1725B:		; CODE XREF: idk_PreEmmPgCnt+110j
mov	ax, [bp+arg_8]
add	ax, [bp+arg_A]	; Add
cmp	ax, [bp+var_E]	; Compare Two Operands
jbe	short loc_17269	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_1718A	; Jump

loc_17269:		; CODE XREF: idk_PreEmmPgCnt+11Ej
mov	ax, [bp+arg_8]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_C]
push	dx
xor	dx, dx		; Logical Exclusive OR
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
add	ax, 4		; Add
adc	dx, 0		; Add with Carry
add	[bp+var_12], ax	; Add
adc	[bp+var_10], dx	; Add with Carry
mov	ax, [bp+arg_A]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_C]
push	dx
xor	dx, dx		; Logical Exclusive OR
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
mov	[word ptr bp+argPtrSrcBuf+2], dx
mov	[word ptr bp+argPtrSrcBuf], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 10h
push	ax
push	dx
push	[word ptr bp+argPtrSrcBuf+2]
push	[word ptr bp+argPtrSrcBuf] ; argPtrSrcBuf
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
inc	ax		; Increment by 1
mov	[bp+var_A], ax
mov	ax, [word ptr bp+arg0_DestES+2]
or	ax, ax		; Logical Inclusive OR
jz	short loc_172C9	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_172E1	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_1731E	; Jump if Zero (ZF=1)
jmp	loc_1736D	; Jump

loc_172C9:		; CODE XREF: idk_PreEmmPgCnt+174j
push	[bp+var_A]
call	malloc_s14954	; Call Procedure
pop	cx
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_172DE	; Jump if Not Zero (ZF=0)

loc_172DB:		; Jump
jmp	loc_1718A

loc_172DE:		; CODE XREF: idk_PreEmmPgCnt+193j
jmp	loc_1736D	; Jump

loc_172E1:		; CODE XREF: idk_PreEmmPgCnt+179j
push	si		; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_172EF	; Jump if Not Zero (ZF=0)
jmp	loc_1718A	; Jump

loc_172EF:		; CODE XREF: idk_PreEmmPgCnt+1A4j
mov	ax, 8
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
dec	ax		; Decrement by 1
cmp	ax, [bp+var_A]	; Compare Two Operands
jnb	short loc_17304	; Jump if Not Below (CF=0)
jmp	loc_1718A	; Jump

loc_17304:		; CODE XREF: idk_PreEmmPgCnt+1B9j
mov	ax, si
inc	ax		; Increment by 1
mov	[bp+var_2], ax
mov	ax, [bp+var_A]
inc	ax		; Increment by 1
push	ax		; argValue

loc_1730F:		; CODE XREF: idk_PreEmmPgCnt+225j
mov	ax, 10
push	ax		; argOffset
push	si		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
jmp	short loc_1736D	; Jump

loc_1731E:		; CODE XREF: idk_PreEmmPgCnt+17Ej
or	si, si		; Logical Inclusive OR
jnz	short loc_17327	; Jump if Not Zero (ZF=0)
mov	ax, 1
jmp	short loc_17329	; Jump

loc_17327:		; CODE XREF: idk_PreEmmPgCnt+1DAj
xor	ax, ax		; Logical Exclusive OR

loc_17329:		; CODE XREF: idk_PreEmmPgCnt+1DFj
push	ax		; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_17337	; Jump if Zero (ZF=1)
jmp	loc_1718A	; Jump

loc_17337:		; CODE XREF: idk_PreEmmPgCnt+1ECj
push	si
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
cmp	ax, [bp+var_A]	; Compare Two Operands
jnb	short loc_17346	; Jump if Not Below (CF=0)
jmp	loc_1718A	; Jump

loc_17346:		; CODE XREF: idk_PreEmmPgCnt+1FBj
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, si
add	dx, ax		; Add
mov	[bp+var_2], dx
mov	ax, 10
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+var_A]
add	dx, ax		; Add
push	dx
jmp	short loc_1730F	; Jump

loc_1736D:		; CODE XREF: idk_PreEmmPgCnt+180j
			; idk_PreEmmPgCnt:loc_172DEj
			; idk_PreEmmPgCnt+1D6j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_17376	; Jump if Not Zero (ZF=0)
jmp	loc_173FC	; Jump

loc_17376:		; CODE XREF: idk_PreEmmPgCnt+22Bj
mov	ax, [bp+var_2]
mov	[bp+arg2_ES], ax
mov	[bp+arg5_ByteCount], 8000h
jmp	short loc_173B2	; Jump

loc_17383:		; CODE XREF: idk_PreEmmPgCnt+270j
			; idk_PreEmmPgCnt+279j
sub	[word ptr bp+argPtrSrcBuf], 8000h ; Integer Subtraction
sbb	[word ptr bp+argPtrSrcBuf+2], 0	; Integer Subtraction with Borrow
push	di		; arg6_EmsHandle
push	[bp+arg5_ByteCount] ; arg5_ByteCount
push	[bp+var_10]	; arg4_6
push	[bp+var_12]	; arg3_4
push	[bp+arg2_ES]	; arg2_ES
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
add	[bp+var_12], 8000h ; Add
adc	[bp+var_10], 0	; Add with Carry
add	[bp+arg2_ES], 800h ; Add

loc_173B2:		; CODE XREF: idk_PreEmmPgCnt+23Bj
cmp	[word ptr bp+argPtrSrcBuf+2], 0	; Compare Two Operands
jg	short loc_17383	; Jump if Greater (ZF=0	& SF=OF)
jnz	short loc_173C1	; Jump if Not Zero (ZF=0)

loc_173BA:		; Compare Two Operands
cmp	[word ptr bp+argPtrSrcBuf], 8000h
ja	short loc_17383	; Jump if Above	(CF=0 &	ZF=0)

loc_173C1:		; CODE XREF: idk_PreEmmPgCnt+272j
cmp	[word ptr bp+argPtrSrcBuf+2], 0	; Compare Two Operands
jl	short loc_173FC	; Jump if Less (SF!=OF)
jg	short loc_173CF	; Jump if Greater (ZF=0	& SF=OF)

loc_173C9:		; Compare Two Operands
cmp	[word ptr bp+argPtrSrcBuf], 0
jbe	short loc_173FC	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_173CF:		; CODE XREF: idk_PreEmmPgCnt+281j
xor	ax, ax		; Logical Exclusive OR

loc_173D1:
mov	dx, 8000h
push	ax
push	dx
push	[word ptr bp+argPtrSrcBuf+2]
push	[word ptr bp+argPtrSrcBuf]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
mov	[bp+arg5_ByteCount], ax
push	di		; arg6_EmsHandle
push	[bp+arg5_ByteCount] ; arg5_ByteCount
push	[bp+var_10]	; arg4_6
push	[bp+var_12]	; arg3_4
push	[bp+arg2_ES]	; arg2_ES
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add

loc_173FC:		; CODE XREF: idk_PreEmmPgCnt+1Fj
			; idk_PreEmmPgCnt+AEj
			; idk_PreEmmPgCnt:loc_171FFj
			; idk_PreEmmPgCnt+22Dj
			; idk_PreEmmPgCnt+27Fj
			; idk_PreEmmPgCnt+287j
mov	ax, [bp+var_2]
jmp	loc_1718C	; Jump

loc_17402:		; CODE XREF: idk_PreEmmPgCnt:loc_1718Cj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_PreEmmPgCnt ; sp-analysis failed



; Attributes: bp-based frame

proc EMS_s17408	far	; CODE XREF: LBX_Load_HelpNewTerrCity+50P

arg3_4=	word ptr -18h
arg4_6=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
arg5_ByteCount=	word ptr -6
arg1_DI= word ptr -4
var_2= word ptr	-2
argNameCharArr=	word ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_2]
mov	[bp+var_2], 0
push	[bp+argNameCharArr] ; argNameCharArr
nop			; No Operation
push	cs
call	near ptr Emm_PgCnt_s175B1 ; Call Procedure
pop	cx
mov	si, ax
or	si, si		; Logical Inclusive OR
jnz	short loc_1742A	; Jump if Not Zero (ZF=0)
jmp	loc_175A2	; Jump

loc_1742A:		; CODE XREF: EMS_s17408+1Dj
push	si		; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount

loc_1742F:		; Logical Exclusive OR
xor	ax, ax
push	ax		; arg4_6
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+arg1_DI] ; Load	Effective Address
push	ax		; arg1_DI

loc_1743C:		; Call Procedure
call	EMS_MapMemory_4
add	sp, 0Ch		; Add

loc_17444:		; Compare Two Operands
cmp	di, [bp+arg1_DI]
jl	short loc_1744E	; Jump if Less (SF!=OF)

loc_17449:		; CODE XREF: EMS_s17408:loc_17516j
			; EMS_s17408+11Cj
			; EMS_s17408:loc_175A2j
xor	ax, ax		; Logical Exclusive OR

loc_1744B:		; CODE XREF: EMS_s17408+1A0j
jmp	loc_175AB	; Jump

loc_1744E:		; CODE XREF: EMS_s17408+3Fj
mov	ax, di

loc_17450:		; AX ->	DX:AX (with sign)
cwd
mov	cl, 2
call	LXLSH@		; Call Procedure
add	ax, 8		; Add
adc	dx, 0		; Add with Carry

loc_1745E:
mov	[bp+arg4_6], dx
mov	[bp+arg3_4], ax
push	si		; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount

loc_17469:		; arg4_6
push	[bp+arg4_6]
push	[bp+arg3_4]	; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_10]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
push	si		; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount
mov	ax, [bp+arg4_6]
mov	dx, [bp+arg3_4]
add	dx, 4		; Add
adc	ax, 0		; Add with Carry
push	ax		; arg4_6
push	dx		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_14]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [bp+var_E]
mov	dx, [bp+var_10]
sub	[bp+var_14], dx	; Integer Subtraction
sbb	[bp+var_12], ax	; Integer Subtraction with Borrow
cmp	[bp+var_12], 0	; Compare Two Operands
jge	short loc_174B5	; Jump if Greater or Equal (SF=OF)
jmp	loc_175A0	; Jump

loc_174B5:		; CODE XREF: EMS_s17408+A8j
jg	short loc_174C0	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_14], 0	; Compare Two Operands
ja	short loc_174C0	; Jump if Above	(CF=0 &	ZF=0)
jmp	loc_175A0	; Jump

loc_174C0:		; CODE XREF: EMS_s17408:loc_174B5j
			; EMS_s17408+B3j
mov	ax, [bp+var_E]
mov	dx, [bp+var_10]
mov	[bp+arg4_6], ax
mov	[bp+arg3_4], dx
push	si		; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount
push	[bp+arg4_6]	; arg4_6
push	[bp+arg3_4]	; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_C]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
push	si		; arg6_EmsHandle
mov	ax, 2
push	ax		; arg5_ByteCount
mov	ax, [bp+arg4_6]
mov	dx, [bp+arg3_4]
add	dx, 2		; Add
adc	ax, 0		; Add with Carry
push	ax		; arg4_6
push	dx		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_A]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
cmp	[bp+var_A], 0	; Compare Two Operands
jz	short loc_17516	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_A]
cmp	ax, [bp+var_A]	; Compare Two Operands
jz	short loc_17519	; Jump if Zero (ZF=1)

loc_17516:		; CODE XREF: EMS_s17408+104j
jmp	loc_17449	; Jump

loc_17519:		; CODE XREF: EMS_s17408+10Cj
mov	ax, [bp+arg_6]

loc_1751C:		; Add
add	ax, [bp+arg_8]

loc_1751F:		; Compare Two Operands
cmp	ax, [bp+var_C]
jbe	short loc_17527	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_17449	; Jump

loc_17527:		; CODE XREF: EMS_s17408+11Aj
mov	ax, [bp+arg_6]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_A]
push	dx

loc_17530:		; Logical Exclusive OR
xor	dx, dx
pop	cx
pop	bx
call	LXMUL@		; Call Procedure

loc_17539:		; Add
add	ax, 4
adc	dx, 0		; Add with Carry
add	[bp+var_10], ax	; Add
adc	[bp+var_E], dx	; Add with Carry
mov	ax, [bp+arg_8]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_A]
push	dx
xor	dx, dx		; Logical Exclusive OR

loc_17550:
pop	cx
pop	bx
call	LXMUL@		; Call Procedure

loc_17557:
mov	[bp+var_12], dx
mov	[bp+var_14], ax

loc_1755D:		; Logical Exclusive OR
xor	ax, ax

loc_1755F:
mov	dx, 10h
push	ax
push	dx

loc_17564:
push	[bp+var_12]
push	[bp+var_14]
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
inc	ax		; Increment by 1
mov	[bp+var_8], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 8000h
push	ax
push	dx
push	[bp+var_12]
push	[bp+var_14]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]

loc_17585:
mov	[bp+arg5_ByteCount], ax
push	si		; arg6_EmsHandle
push	[bp+arg5_ByteCount] ; arg5_ByteCount
push	[bp+var_E]	; arg4_6
push	[bp+var_10]	; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
push	[bp+arg_4]	; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add

loc_175A0:		; CODE XREF: EMS_s17408+AAj
			; EMS_s17408+B5j
jmp	short loc_175A5	; Jump

loc_175A2:		; CODE XREF: EMS_s17408+1Fj
jmp	loc_17449	; Jump

loc_175A5:		; CODE XREF: EMS_s17408:loc_175A0j
mov	ax, 0FFFFh
jmp	loc_1744B	; Jump

loc_175AB:		; CODE XREF: EMS_s17408:loc_1744Bj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp EMS_s17408	; sp-analysis failed



; Kinda	looks like this	is accessing an	offset in a structure,
;  which is in an array	of structures.
; But, if it is	that simple, it	would also seem	that the offset	is /dynamic/.
; Finally, it returns DI, which	/feels/	like it	must be	returning a string.
; Attributes: bp-based frame

; int __fastcall __far Emm_PgCnt_s175B1(int, int, int, int argNameCharArr)
proc Emm_PgCnt_s175B1 far
			; CODE XREF: LBX_EmsMapMem+12p
			; idk_PreEmmPgCnt+15p
			; EMS_s17408+15p
			; sub_17671+25p

argNameCharArr=	word ptr  6

push	bp
mov	bp, sp
push	si
push	di
xor	di, di		; DI = 0
xor	si, si		; SI = 0
jmp	short LOOP_PageCount ; Jump

COMPARE_WHAT:		; CODE XREF: Emm_PgCnt_s175B1+4Bj
push	[bp+argNameCharArr] ; str2
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
add	ax, offset Emm_PgCnt_w3C302 ; Add
push	ax		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short StringMismatch ; Jump if Not Zero	(ZF=0)
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
mov	bx, ax
mov	di, [idk_LBX_w3C30C+bx]	; ?EMM Handle?
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [idk_LBX_b3C30B+bx]
cbw			; AL ->	AX (with sign)
mov	[idk_LBX_w3C2FC], ax

StringMismatch:		; CODE XREF: Emm_PgCnt_s175B1+22j
inc	si		; Increment by 1

LOOP_PageCount:		; CODE XREF: Emm_PgCnt_s175B1+9j
cmp	si, [hrmEmmPageCount] ;	SI - hrmEmmPageCount
jge	short loc_175FE	; Jump if Greater or Equal (SF=OF)
or	di, di		; If (DI == 0) Then Set	(ZF = 1)
jz	short COMPARE_WHAT ; Jump if Zero (ZF=1)

loc_175FE:		; CODE XREF: Emm_PgCnt_s175B1+47j
mov	ax, di
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp Emm_PgCnt_s175B1



; Attributes: bp-based frame

proc Chk_RelMemHandle far
			; CODE XREF: _f050207_EXIT_CleanUp+12P
			; idk_CleanupPrintExit_s14391+28P
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+17P
push	bp
mov	bp, sp
push	si
xor	si, si		; SI = 0
jmp	short loc_17622	; Jump

loc_1760E:		; CODE XREF: Chk_RelMemHandle+20j
mov	ax, si
mov	dx, 12
imul	dx		; AX = AX * DX
mov	bx, ax

loc_17617:		; Memory Handle?
push	[word ptr bx-5A04h]
call	EMM_ReleaseHandleAndMemory ;
			; DOS -	LIM EMS	- RELEASE HANDLE AND MEMORY
			;   arg0_EmmHandle = DX	= EMM handle
pop	cx
inc	si		; Increment by 1

loc_17622:		; CODE XREF: Chk_RelMemHandle+6j
cmp	si, [hrmEmmPageCount] ;	Compare	Two Operands
jl	short loc_1760E	; Jump if Less (SF!=OF)

loc_17628:		; Compare Two Operands
cmp	[word_3C2F2], 0

loc_1762D:		; Jump if Zero (ZF=1)
jz	short loc_17639

loc_1762F:		;
push	[word_3C2F2]	; Memory Handle?
call	EMM_ReleaseHandleAndMemory ;
			; DOS -	LIM EMS	- RELEASE HANDLE AND MEMORY
			;   arg0_EmmHandle = DX	= EMM handle
pop	cx

loc_17639:		; CODE XREF: Chk_RelMemHandle:loc_1762Dj
pop	si
pop	bp
retf			; Return Far from Procedure
endp Chk_RelMemHandle



; Attributes: bp-based frame

proc EMM_LoopRelease far
			; CODE XREF: ST_execl_WizardsExe:loc_1441EP
push	bp
mov	bp, sp
push	si
xor	si, si		; SI = 0
jmp	short LOOP_RELEASE ; Jump

loc_17644:		; CODE XREF: EMM_LoopRelease+30j
mov	ax, si

loc_17646:
mov	dx, 12

loc_17649:		; Signed Multiply
imul	dx
mov	bx, ax
cmp	[byte ptr bx-5A05h], 1 ; Compare Two Operands
jnz	short loc_17667	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
mov	bx, ax
push	[word ptr bx-5A04h] ; ?EMM Handle?
call	EMM_ReleaseHandleAndMemory ;
			; DOS -	LIM EMS	- RELEASE HANDLE AND MEMORY
			;   arg0_EmmHandle = DX	= EMM handle
pop	cx

loc_17667:		; CODE XREF: EMM_LoopRelease+16j
inc	si		; Increment by 1

LOOP_RELEASE:		; CODE XREF: EMM_LoopRelease+6j
cmp	si, [hrmEmmPageCount] ;	Compare	Two Operands
jl	short loc_17644	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp EMM_LoopRelease



; Attributes: bp-based frame

proc sub_17671 far

argNameCharArr=	byte ptr -32h
argCharPtrFileName= byte ptr -14h
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 32h		; Integer Subtraction
push	si
push	di
push	[bp+arg_0]
lea	ax, [bp+argNameCharArr]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argNameCharArr]	; Load Effective Address
push	ax		; argNameCharArr
call	ST_RemoveExtensionUppercaseName	; Call Procedure
pop	cx
lea	ax, [bp+argNameCharArr]	; int
push	ax		; argNameCharArr
push	cs
call	near ptr Emm_PgCnt_s175B1 ; Call Procedure
pop	cx
mov	di, ax
lea	ax, [bp+argNameCharArr]	; Load Effective Address
push	ax		; argSrc
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strDotLBX ; ".LBX"
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
or	di, di		; Logical Inclusive OR
jnz	short loc_176C1	; Jump if Not Zero (ZF=0)
jmp	loc_17756	; Jump

loc_176C1:		; CODE XREF: sub_17671+4Bj
lea	ax, [bp+argNameCharArr]	; Load Effective Address
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_176D7	; Jump if Not Zero (ZF=0)
db 0E9h,7Fh,0 ;	<BAD>jmp     loc_17756 ; Jump

loc_176D7:		; CODE XREF: sub_17671+61j
cmp	[idk_LBX_w3C2FC], 1 ; 1	- idk_LBX_w3C2FC
jnz	short loc_176E9	; Jump if Not Zero (ZF=0)
push	di		; argEmmHandle
call	EMM_GetPagesOwnedByHandle ;
			; DOS -	LIM EMS	- GET PAGES OWNED BY HANDLE
			; Return:
			;   AX = Pages Owned by	Handle
			;   0, Failure
pop	cx
add	[ST_HeapBase], ax ; Add

loc_176E9:		; CODE XREF: sub_17671+6Bj
push	di		; argEmmHandle
call	EMM_ReleaseHandleAndMemory ;
			; DOS -	LIM EMS	- RELEASE HANDLE AND MEMORY
			;   arg0_EmmHandle = DX	= EMM handle
pop	cx
mov	si, di
jmp	short loc_1774A	; Jump

loc_176F4:		; CODE XREF: sub_17671+DFj
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
add	ax, offset idk_LBX_w3C30E ; Add
push	ax		; argSrc
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
add	ax, offset Emm_PgCnt_w3C302 ; Add
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [idk_LBX_w3C318+bx]
push	ax
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[idk_LBX_w3C30C+bx], ax	; ?EMM Handle?
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [idk_LBX_b3C317+bx]
push	ax
mov	ax, si
mov	dx, 12
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[idk_LBX_b3C30B+bx], al
inc	si		; Increment by 1

loc_1774A:		; CODE XREF: sub_17671+81j
mov	ax, [hrmEmmPageCount]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jg	short loc_176F4	; Jump if Greater (ZF=0	& SF=OF)
dec	[hrmEmmPageCount] ; Decrement by 1

loc_17756:		; CODE XREF: sub_17671+4Dj
			; sub_17671+63j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_17671 ; sp-analysis failed



; Attributes: bp-based frame

proc sub_1775C far
push	bp
mov	bp, sp

loc_1775F:
mov	ax, [word_3C300]
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_1775C



; (0, YO MOMA,	1)
; (1, VGAFILEH,	5)
; (1, EMMDATAH,	4)
; ([bp+argLbxMemberNumber], [bp+varLbxFileName], [bp+EmmPageCount])
; Attributes: bp-based frame

; int __fastcall __far EMM_Allocate(int	argValue, char *argEmmHandleName, int argEmmPageCount)
proc EMM_Allocate far	; CODE XREF: idk_Setup_EMM+74p
			; idk_Setup_EMM+16Ep
			; idk_Setup_EMM+185p
			; LBX_LoadFileMemory+122p
			; LBX_AllocMem+121p
			; LBX_s16A80+175p
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_553C0P
			; idk_EmsPgNm_TileFigureCont_s553B0+27P
			; idk_EmsPgNm_TileFigureCont_s553B0+414P

argPtrWriteString= byte	ptr -0Ah
varItrMax= word	ptr -4
varItrMin= word	ptr -2
argEmmPageCount= word ptr  6
argEmmHandleName= word ptr  8
argValue_0= word ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 10		; Integer Subtraction
push	si
push	di		; argConversionBase
mov	si, [bp+argEmmHandleName] ; Transfer Address to	SI
cmp	[byte ptr si], 0 ; 0 - SI
			; ?Is the char[] empty?
jnz	short ValidParameter ; Jump if Not Zero	(ZF=0)

MissingParameter:	; Logical Exclusive OR
xor	ax, ax

loc_17778:		; CODE XREF: EMM_Allocate+234j
jmp	loc_1799D	; Jump

ValidParameter:		; CODE XREF: EMM_Allocate+Ej
mov	[bp+varItrMax],	0FFFFh
mov	[bp+varItrMin],	0
jmp	short loc_177A8	; Jump

loc_17787:		; CODE XREF: EMM_Allocate+49j
mov	ax, [bp+varItrMin]
mov	dx, 12
imul	dx		; AX:DX	= AX * DX
add	ax, offset Emm_PgCnt_w3C302 ; ?
			; 0*12+42482=42482
			; 1*12+42482=42494
			; 2*12+42482=42506
			; ...
			; ...
			; ...
			; ?
push	ax
push	si		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_177A5	; Jump if Not Zero (ZF=0)

loc_1779F:
mov	ax, [bp+varItrMin]

loc_177A2:
mov	[bp+varItrMax],	ax

loc_177A5:		; CODE XREF: EMM_Allocate+37j
inc	[bp+varItrMin]	; Increment by 1

loc_177A8:		; CODE XREF: EMM_Allocate+1Fj
mov	ax, [bp+varItrMin]
cmp	ax, [hrmEmmPageCount] ;	hrmEmmPageCount	- AX
			; If hrmEmmPageCount < AX Then JUMP
jl	short loc_17787	; Jump if Less (SF!=OF)

GET_MORE_PAGES:		; [bp+varItrMax] - 65535
db 83h,7Eh,0FCh,0FFh ; <BAD>cmp	    [bp+varItrMax], 0FFFFh

loc_177B5:		; Jump if Zero (ZF=1)
jz	short ITR_MAX_65535

loc_177B7:		; Jump
jmp	loc_178C9

ITR_MAX_65535:		; CODE XREF: EMM_Allocate:loc_177B5j
push	si
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX = AX * DX
add	ax, offset Emm_PgCnt_w3C302 ; Add
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
cmp	[bp+argValue_0], 1 ; 1 - [bp+argValue]
jnz	short loc_177F4	; Jump if Not Zero (ZF=0)

argValue_NE_0:		; ?change what gets added in the next chunk?
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX:DX	= AX * DX
mov	bx, ax

loc_177DE:
mov	al, [byte ptr Emm_PgCnt_w3C302+bx]
neg	al		; Two's Complement Negation
push	ax
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX:DX	= AX * DX
mov	bx, ax
pop	ax
mov	[byte ptr Emm_PgCnt_w3C302+bx],	al

loc_177F4:		; CODE XREF: EMM_Allocate+6Cj
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX:DX	= AX * DX

loc_177FC:		; Add
add	ax, offset Emm_PgCnt_w3C302
push	ax		; argHandleName
push	[bp+argEmmPageCount] ; argPagesToAllocate
call	EMS_GetHandleAllocMemSetName ;
			; Return:
			;   AX = Handle
			;   0, Failure
			;
			; argPagesToAllocate =
			; argHandleName	     =
pop	cx
pop	cx
mov	di, ax
or	di, di		; If (AX == 0) Then Set	(ZF = 1)
jnz	short SUCCESS	; Jump if Not Zero (ZF=0)

loc_17810:		; Jump
jmp	LTE_BLOCKS_AVAIL

SUCCESS:		; CODE XREF: EMM_Allocate+A8j
push	si
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX = AX * DX
add	ax, offset Emm_PgCnt_w3C302 ; Add
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, [hrmEmmPageCount]
mov	dx, 12
imul	dx		; AX = AX * DX

loc_1782F:
mov	dl, [byte ptr bp+argValue_0]
mov	bx, ax
mov	[idk_LBX_b3C30B+bx], dl
mov	ax, [hrmEmmPageCount]
mov	dx, 12

loc_1783E:		; AX = AX * DX
imul	dx
mov	bx, ax

loc_17842:		; ?EMM Handle?
mov	[idk_LBX_w3C30C+bx], di
inc	[hrmEmmPageCount] ; Increment by 1
cmp	[bp+argValue_0], 1 ; 1 - [bp+argValue_0]
jnz	short NOT_ZERO	; Jump if Not Zero (ZF=0)

loc_17850:
mov	ax, [bp+argEmmPageCount]
sub	[ST_HeapBase], ax ; Integer Subtraction

NOT_ZERO:		; CODE XREF: EMM_Allocate+E8j
cmp	[ST_HeapBase], 0 ; 0 - idk_EmmPages
jge	short LTE_BLOCKS_AVAIL ; Jump if Greater or Equal (SF=OF)

GT_BLOCKS_AVAIL:
mov	ax, 10
push	ax
lea	ax, [bp+argPtrWriteString] ; Load Effective Address
push	ax		; argPtrCharArr
mov	ax, [ST_HeapBase]
neg	ax		; Two's Complement Negation
push	ax		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, offset aEmmReservedExceededBy ; "EMM reserved exceeded by "
push	ax		; argSrc
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argPtrWriteString] ; Load Effective Address
push	ax		; argSrc
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aBlocks_1 ; " blocks	["
push	ax		; argSrc
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
push	si		; argSrc ?SI = LBX Name?
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset a_lbx ; ".LBX]"
push	ax		; argSrc
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx

LTE_BLOCKS_AVAIL:	; CODE XREF: EMM_Allocate:loc_17810j
			; EMM_Allocate+F6j
jmp	loc_17998	; Jump

loc_178C9:		; CODE XREF: EMM_Allocate:loc_177B7j
mov	ax, [bp+varItrMax]
mov	dx, 12
imul	dx		; Signed Multiply
mov	bx, ax
mov	di, [idk_LBX_w3C30C+bx]	; ?EMM Handle?
push	di		; argEmmHandle
call	EMM_GetPagesOwnedByHandle ;
			; DOS -	LIM EMS	- GET PAGES OWNED BY HANDLE
			; Return:
			;   AX = Pages Owned by	Handle
			;   0, Failure
pop	cx
cmp	ax, [bp+argEmmPageCount] ; Compare Two Operands
jl	short DIFF_SIZE	; Jump if Less (SF!=OF)

GOT_REQUESTED_PAGES:	; Jump
jmp	loc_17998

DIFF_SIZE:		; CODE XREF: EMM_Allocate+17Bj
mov	ax, 10		; base
push	ax		; argConversionBase
mov	ax, offset idk_ItoAbuf_w3B204
push	ax		; argPtrCharArr
mov	ax, [bp+varItrMax]
mov	dx, 12
imul	dx		; AX:DX	= AX * DX
mov	bx, ax
push	[idk_LBX_w3C30C+bx] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, 10
push	ax		; argConversionBase
mov	ax, offset idk_EmsErrStr_w3B218
push	ax		; argPtrCharArr
push	di		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, 10
push	ax
mov	ax, offset idk_EmsErrStr_w3B236
push	ax		; argPtrCharArr
push	[bp+argEmmPageCount] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
push	si
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset aReloadedIntoEmmDiffSi ; " reloaded into EMM, diff size ="
push	ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_17943:
mov	ax, offset idk_ItoAbuf_w3B204
push	ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx

loc_17951:
pop	cx
mov	ax, offset a2spaces ; "	 "
push	ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset idk_EmsErrStr_w3B218
push	ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset a2spaces ; "	 "
push	ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset idk_EmsErrStr_w3B236
push	ax
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset idk_EmmRsrvExcdErrMsg
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx

loc_17998:		; CODE XREF: EMM_Allocate:LTE_BLOCKS_AVAILj
			; EMM_Allocate:GOT_REQUESTED_PAGESj
mov	ax, di
jmp	loc_17778	; Jump

loc_1799D:		; CODE XREF: EMM_Allocate:loc_17778j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp EMM_Allocate



; Attributes: bp-based frame

proc sub_179A3 far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	[idk_AddrEmsHandle]
mov	ax, 4000h
push	ax
mov	ax, 1
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
push	[bp+arg_0]
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_EmsMapMem_s16337 ; Call Procedure
add	sp, 0Ch		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_179A3



; Attributes: bp-based frame

proc sub_179C5 far

arg2_ES= word ptr  6

push	bp
mov	bp, sp
push	[idk_AddrEmsHandle] ; arg6_EmsHandle
mov	ax, 4000h
push	ax		; arg5_ByteCount
mov	ax, 1
xor	dx, dx		; Logical Exclusive OR
push	ax		; arg4_6

loc_179D6:		; arg3_4
push	dx
push	[bp+arg2_ES]	; arg2_ES
xor	ax, ax		; Logical Exclusive OR

loc_179DC:		; arg1_DI
push	ax

loc_179DD:		; Call Procedure
call	EMS_MapMemory_4
add	sp, 0Ch		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_179C5



; Attributes: bp-based frame

proc sub_179E7 far

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
mov	ax, ds
mov	[bp+var_2], ax
push	[idk_AddrEmsHandle]
push	[bp+arg_2]
mov	ax, 1
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx

loc_17A00:
push	[bp+var_2]
push	[bp+arg_0]
call	idk_EmsMapMem_s16337 ; Call Procedure
add	sp, 0Ch		; Add
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_179E7



; Attributes: bp-based frame

proc sub_17A12 far

arg2_ES= word ptr -2
arg1_DI= word ptr  6
arg5_ByteCount=	word ptr  8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
mov	ax, ds
mov	[bp+arg2_ES], ax

loc_17A1D:		; arg6_EmsHandle
push	[idk_AddrEmsHandle]
push	[bp+arg5_ByteCount] ; arg5_ByteCount
mov	ax, 1
xor	dx, dx		; Logical Exclusive OR
push	ax		; arg4_6
push	dx		; arg3_4
push	[bp+arg2_ES]	; arg2_ES
push	[bp+arg1_DI]	; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_17A12



; Attributes: bp-based frame

proc CALL_DOS_MapMemory	far
			; CODE XREF: sub_17A50+1Bp
			; sub_17AFA+Cp
			; sub_17AFA+19p
			; OVR_SaveGame_MagicSet+310P
			; ST_LoadSaveGamByNbr+327P
			; sub_4BF24+7P
			; sub_4C79C+8P
push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax		; EMS Page Number
push	[EmsHndl_w3C2F6] ; EMS Handle
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp CALL_DOS_MapMemory



; Attributes: bp-based frame

proc sub_17A50 far	; CODE XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_5553EP

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	[word_3C2F4], 0
mov	ax, [EMM_PageFrameSegmentAddress]
add	ax, [word_3C2F4] ; Add
mov	di, ax
push	cs
call	near ptr CALL_DOS_MapMemory ; Call Procedure
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax
mov	ax, 0FFAh
sub	ax, [word_3C2F4] ; Integer Subtraction
mov	[bp+var_2], ax
cmp	[bp+var_2], si	; Compare Two Operands
jge	short loc_17A93	; Jump if Greater or Equal (SF=OF)
mov	ax, si
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; argMemAmount
mov	ax, 4		; argMemAmount
push	ax		; argMemErrorCode
call	MemBlocksErrorExit ; Call Procedure
pop	cx
pop	cx

loc_17A93:		; CODE XREF: sub_17A50+30j
mov	ax, 12FAh
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure

loc_17AA1:		; Add
add	sp, 6
mov	ax, 4ECFh
push	ax		; argValue
mov	ax, 6
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, si
dec	ax		; Decrement by 1
push	ax		; argValue
mov	ax, 8
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 1
push	ax		; argValue
mov	ax, 0Ah
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 1
push	ax		; argValue
mov	ax, 0Eh
push	ax		; argOffset
push	di		; argSegment

loc_17AE0:		; Call Procedure
call	fncStoSW
add	sp, 6		; Add
mov	ax, si
inc	ax		; Increment by 1
add	[word_3C2F4], ax ; Add

loc_17AEF:
mov	ax, di
inc	ax		; Increment by 1
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_17A50



; Attributes: bp-based frame

proc sub_17AFA far	; CODE XREF: idk_EmsPgNm_TileFigureCont_s553B0+1A6P
			; idk_EmsPgNm_TileFigureCont_s553B0+1BEP
			; idk_EmsPgNm_TileFigureCont_s553B0+1D6P
			; idk_EmsPgNm_TileFigureCont_s553B0+1EEP

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_17AFD:		; Integer Subtraction
sub	sp, 2

loc_17B00:
push	si
push	di
mov	si, [bp+arg_0]
push	cs
call	near ptr CALL_DOS_MapMemory ; Call Procedure

loc_17B09:
mov	ax, [EMM_PageFrameSegmentAddress]
add	ax, [word_3C2F4] ; Add

loc_17B10:
mov	di, ax
push	cs
call	near ptr CALL_DOS_MapMemory ; Call Procedure
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax
mov	ax, 0FFAh

loc_17B1E:		; Integer Subtraction
sub	ax, [word_3C2F4]
mov	[bp+var_2], ax
cmp	[bp+var_2], si	; Compare Two Operands
jge	short loc_17B3B	; Jump if Greater or Equal (SF=OF)
mov	ax, si
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; argMemAmount
mov	ax, enum_MEM_Error_Type_4 ; argMemAmount
push	ax		; argMemErrorCode
call	MemBlocksErrorExit ; Call Procedure
pop	cx
pop	cx

loc_17B3B:		; CODE XREF: sub_17AFA+2Ej
mov	ax, 12FAh
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 4ECFh
push	ax		; argValue
mov	ax, 6
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, si
dec	ax		; Decrement by 1
push	ax		; argValue
mov	ax, 8
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 1
push	ax		; argValue
mov	ax, 0Ah
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 1
push	ax		; argValue
mov	ax, 0Eh
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add

loc_17B90:
mov	ax, si
inc	ax		; Increment by 1
add	[word_3C2F4], ax ; Add
mov	ax, di
inc	ax		; Increment by 1
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_17AFA



; Attributes: bp-based frame

proc sub_17BA2 far
push	bp
mov	bp, sp
mov	ax, [word_3C2F4]
mov	[word_3C2F0], ax
pop	bp
retf			; Return Far from Procedure
endp sub_17BA2



; Attributes: bp-based frame

proc sub_17BAD far
push	bp
mov	bp, sp
mov	ax, [word_3C2F0]
mov	[word_3C2F4], ax
pop	bp
retf			; Return Far from Procedure
endp sub_17BAD



; Attributes: bp-based frame

proc sub_17BB8 far

argFileName= byte ptr -20h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
argBytes= word ptr -6
argBuffer= word	ptr -4
var_2= word ptr	-2
arg6_MemShort= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 20h		; Integer Subtraction
push	si
push	di
push	[bp+arg6_MemShort]
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
xor	si, si		; Logical Exclusive OR
jmp	short loc_17BDD	; Jump

loc_17BD2:		; CODE XREF: sub_17BB8:loc_17BE0j
cmp	[bp+si+argFileName], 2Eh ; Compare Two Operands
jnz	short loc_17BDC	; Jump if Not Zero (ZF=0)

loc_17BD8:
mov	[bp+si+argFileName], 0

loc_17BDC:		; CODE XREF: sub_17BB8+1Ej
inc	si		; Increment by 1

loc_17BDD:		; CODE XREF: sub_17BB8+18j
cmp	si, 13		; Compare Two Operands

loc_17BE0:		; Jump if Less (SF!=OF)
jl	short loc_17BD2

loc_17BE2:		; ".LBX"
mov	ax, offset strDotLBX
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address

loc_17BE9:		; argDst
push	ax
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx

loc_17BF0:
pop	cx

loc_17BF1:		; Load Effective Address
lea	ax, [bp+argFileName]
push	ax		; argFileName
call	DOS_FindFirst	; char *argFileName {AX	= FileSize DX =	FileName}

loc_17BFA:
pop	cx
mov	[bp+var_A], dx
mov	[bp+var_C], ax
mov	ax, [bp+var_C]

loc_17C04:		; Logical Inclusive OR
or	ax, [bp+var_A]
jnz	short loc_17C1B	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_17C0C:		; arg0_LbxFileName
mov	ax, 0Fh
push	ax
push	[bp+arg6_MemShort] ; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_17C1B:		; CODE XREF: sub_17BB8+4Fj
xor	ax, ax		; Logical Exclusive OR

loc_17C1D:
mov	dx, 4000h

loc_17C20:
push	ax
push	dx

loc_17C22:
push	[bp+var_A]
push	[bp+var_C]
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E

loc_17C2D:
mov	[bp+var_2], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 4000h
push	ax
push	dx
push	[bp+var_A]
push	[bp+var_C]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]

loc_17C42:		; Logical Inclusive OR
or	ax, dx
jz	short loc_17C49	; Jump if Zero (ZF=1)

loc_17C46:		; Increment by 1
inc	[bp+var_2]

loc_17C49:		; CODE XREF: sub_17BB8+8Cj
mov	ah, 4Ch	; 'L'
mov	dx, [bp+arg_2]
int	67h		;  - LIM EMS - GET PAGES OWNED BY HANDLE
			; DX = EMM handle
			; Return: AH = status
mov	[bp+var_12], bx
mov	ax, [bp+var_2]
cmp	ax, [bp+var_12]	; Compare Two Operands
jbe	short loc_17C65	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	ax, offset aEmm2long ; "EMM 2long"
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx

loc_17C65:		; CODE XREF: sub_17BB8+A1j
call	fncGetEmmPageFrameSegmentAddress ;   mov     ax, seg dseg
			;   mov	    ds,	ax
			;   mov	    ax,	adrEMM_PageFrameSegment
mov	[bp+argBuffer],	ax
mov	[bp+var_8], 0
cmp	[bp+argBuffer],	0 ; Compare Two	Operands
jnz	short loc_17C7B	; Jump if Not Zero (ZF=0)
jmp	loc_17D15	; Jump

loc_17C7B:		; CODE XREF: sub_17BB8+BEj
push	[bp+arg6_MemShort]

loc_17C7E:		; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
call	DOS_OpenFile	;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	di, ax
or	di, di		; Logical Inclusive OR
jnz	short loc_17C8D	; Jump if Not Zero (ZF=0)
jmp	loc_17D15	; Jump

loc_17C8D:		; CODE XREF: sub_17BB8+D0j
mov	[bp+var_E], 0
mov	[bp+var_10], 0

loc_17C97:
mov	[bp+argBytes], 4000h
jmp	short loc_17CCF	; Jump

loc_17C9E:		; CODE XREF: sub_17BB8:loc_17CD3j
			; sub_17BB8+124j
sub	[bp+var_C], 4000h ; Integer Subtraction
sbb	[bp+var_A], 0	; Integer Subtraction with Borrow
push	[bp+var_8]
push	[bp+arg_2]
db 9Ah
word_17CAE dw 251h	; DATA XREF: idk_IntVec_s13FF3+3Dr
seg_17CB0 dw seg seg012	; DATA XREF: idk_IntVec_s13FF3+41r
pop	cx
pop	cx

loc_17CB4:		; argFileHandle
push	di
push	[bp+argBytes]	; argBytes

loc_17CB8:		; argBuffer
push	[bp+argBuffer]
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

loc_17CC0:		; Add
add	sp, 6

loc_17CC3:		; Increment by 1
inc	[bp+var_8]
add	[bp+var_10], 4000h ; Add
adc	[bp+var_E], 0	; Add with Carry

loc_17CCF:		; CODE XREF: sub_17BB8+E4j
cmp	[bp+var_A], 0	; Compare Two Operands

loc_17CD3:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_17C9E
jl	short loc_17CDE	; Jump if Less (SF!=OF)
cmp	[bp+var_C], 4000h ; Compare Two	Operands
jnb	short loc_17C9E	; Jump if Not Below (CF=0)

loc_17CDE:		; CODE XREF: sub_17BB8+11Dj
cmp	[bp+var_A], 0	; Compare Two Operands
jl	short loc_17D0E	; Jump if Less (SF!=OF)
jg	short loc_17CEC	; Jump if Greater (ZF=0	& SF=OF)

loc_17CE6:		; Compare Two Operands
cmp	[bp+var_C], 0
jbe	short loc_17D0E	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_17CEC:		; CODE XREF: sub_17BB8+12Cj
mov	ax, [bp+var_C]

loc_17CEF:
mov	[bp+argBytes], ax

loc_17CF2:
push	[bp+var_8]
push	[bp+arg_2]

loc_17CF8:		; DOS -	LIM EMS	- MAP MEMORY
call	DOS_MapMemory	;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx

loc_17CFF:		; argFileHandle
push	di
push	[bp+argBytes]	; argBytes
push	[bp+argBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add

loc_17D0E:		; CODE XREF: sub_17BB8+12Aj
			; sub_17BB8+132j
push	di

loc_17D0F:		; DOS -	2+ - CLOSE A FILE WITH HANDLE
call	DOS_CloseFileWithHandle	;   argFileHandle = BX = file handle
pop	cx

loc_17D15:		; CODE XREF: sub_17BB8+C0j
			; sub_17BB8+D2j
pop	di

loc_17D16:
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_17BB8 ; sp-analysis failed



; Attributes: bp-based frame

; int __cdecl __far setRequiredEMS(int arg_0)
proc setRequiredEMS far	; CODE XREF: _f010109_main+27FP

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	ax, [bp+arg_0]
mov	[nRequiredEMS_2700], ax
pop	bp
retf			; Return Far from Procedure
endp setRequiredEMS



; Attributes: bp-based frame

; int __fastcall __far fncBldMsgInsuffEMS(int, int, int, int)
proc fncBldMsgInsuffEMS	far
			; CODE XREF: idk_Setup_EMM+CAp
			; idk_Setup_EMM+152p
			; idk_Setup_EMM+19Cp

argPtrCharArr= byte ptr	-14h
argDst=	dword ptr  6

push	bp
mov	bp, sp
sub	sp, 14h		; Integer Subtraction
push	si		; argConversionBase

loc_17D2D:
mov	si, [word ptr bp+argDst]
mov	ax, 10
push	ax		; argBaseRadix
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[nRequiredEMS_2700] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add

loc_17D44:		; "You must have at least "
mov	ax, offset strYouMustHaveAtLeast
push	ax

loc_17D48:		; argDest
push	si

loc_17D49:		; argDest,argSrc
call	_strcpy

loc_17D4E:
pop	cx
pop	cx
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax

loc_17D54:		; argDst
push	si

loc_17D55:		; char*	strcat(char* destination, const	char* source)
call	_strcat

loc_17D5A:
pop	cx
pop	cx

loc_17D5C:		; "K of	expanded memory."
mov	ax, offset strKofExpandedMemory_

loc_17D5F:
push	ax

loc_17D60:		; argDst
push	si

loc_17D61:		; char*	strcat(char* destination, const	char* source)
call	_strcat

loc_17D66:
pop	cx

loc_17D67:
pop	cx

loc_17D68:
pop	si

loc_17D69:
mov	sp, bp

loc_17D6B:
pop	bp

locret_17D6C:		; Return Far from Procedure
retf
endp fncBldMsgInsuffEMS

ends seg013


; Segment type:	Pure code
segment	seg014 byte public 'CODE' use16
assume cs:seg014
;org 0Dh
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; mov	  LBX_FONTS_w3A50A, 1 ;	Resource Type 1?
; mov	  LBX_FONTS_w3A508, 2 ;	Resource Type 2?
; push	  [bp+var_12]	  ; int
; push	  [bp+var_10]	  ; int
; push	  [bp+var_E]	  ; int
; push	  [bp+var_C]	  ; int
; push	  di		  ; int
; push	  [bp+var_A]	  ; int
; push	  [bp+var_8]	  ; int
; push	  si		  ; ILSE: "si_sound_driver_nr"
; mov	  ax, offset strFONTSLBXr1 ; "FONTS.LBX"
; push	  ax		  ; argFontsFileName
; push	  LBX_FONTS_w3A508 ; argLbxFonts2
; push	  LBX_FONTS_w3A50A ; argLbxFonts1
; call	  Load_Fonts_SndDrv ;
;
; Load_Fonts_SndDrv(1,
;		    2,
;		    "FONTS.LBX"
;		    si (ILSE: "si_sound_driver_nr")
;		    [bp+var_8],
;		    [bp+var_A],
;		    di,
;		    [bp+var_C]
;		    [bp+var_E]
;		    [bp+var_10]
;		    [bp+var_12])
;
; Attributes: bp-based frame

; int __cdecl __far Load_Fonts_SndDrv(int argLbxFonts1,	int argLbxFonts2, int argFontsFileName,	int, int, int, int, int, int, int, int)
proc Load_Fonts_SndDrv far
			; CODE XREF: _f010109_main+2BBP

argLbxFonts1= word ptr	6
argLbxFonts2= word ptr	8
argFontsFileName= word ptr  0Ah
argMainSI= word	ptr  0Ch
argMainVar8= word ptr  0Eh
argMainVarA= word ptr  10h
argMainDI= word	ptr  12h
argMainVarC= word ptr  14h
argMainVarE= word ptr  16h
argMainVar10= word ptr	18h
argMainVar12= word ptr	1Ah

push	bp
mov	bp, sp
push	si


mov	si, [bp+argLbxFonts1]


call	idk_PushPopEsDsSiDiRetF	; Call Procedure


call	idk_Setup_EMM	; Call Procedure


call	ST_SetVideoMode_VGA ; Call Procedure


db 83h,0FEh,0FFh ; <BAD>cmp	si, 0FFFFh ; Compare Two Operands
jnz	short loc_17DCA	; Jump if Not Zero (ZF=0)

DEFAULT:		; int
mov	ax, offset strFONTSLBXr2
push	ax		; strFontsFileName
nop			; No Operation
push	cs
call	near ptr LBX_Load_FontsStyleData ; ILSe: "load_fonts_lbx"
pop	cx
mov	ax, 0FFFFh
push	ax
mov	ax, 0FFFFh
push	ax
mov	ax, 0FFFFh
push	ax		; int
mov	ax, 0FFFFh
push	ax		; int
mov	ax, 0FFFFh
push	ax		; int
mov	ax, 0FFFFh
push	ax		; int
mov	ax, 0FFFFh
push	ax		; int
mov	ax, 0FFFFh
push	ax		; int
mov	ax, 0FFFFh
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; int
push	ax		; int
call	ST_LoadSoundDrivers ; Call Procedure
add	sp, 16h		; Add
mov	ax, 1		; int
push	ax
jmp	short loc_17DF7	; Jump

loc_17DCA:		; CODE XREF: Load_Fonts_SndDrv+19j
push	[bp+argFontsFileName] ;	strFontsFileName
nop			; No Operation
push	cs
call	near ptr LBX_Load_FontsStyleData ; Call	Procedure
pop	cx


push	[bp+argMainVar12] ; int
push	[bp+argMainVar10] ; int
push	[bp+argMainVarE] ; int
push	[bp+argMainVarC] ; int
push	[bp+argMainDI]	; int
push	[bp+argMainVarA] ; int
push	[bp+argMainVar8] ; int
push	[bp+argLbxFonts2] ; int
push	[bp+argMainSI]	; int
call	ST_LoadSoundDrivers ; Call Procedure
add	sp, 12h		; Add


push	si

loc_17DF7:		; CODE XREF: Load_Fonts_SndDrv+5Bj
call	idk_Mouse_s2B8B1 ; Call	Procedure
pop	cx


call	ILSe_RndCopySeed_s1CC59	; ILSe:	"RNG_copy_seed_from_es_46C"


call	VGA_MathThenSetVarToVgaLoc ; Call Procedure


pop	si
pop	bp
retf			; Return Far from Procedure
endp Load_Fonts_SndDrv ; sp-analysis failed



; Attributes: bp-based frame

proc idk_Load_FntSty_SndDrv_Mos	far

argOptionalFileName= word ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
strFontsFileName= word ptr  0Ch

push	bp
mov	bp, sp
push	si
mov	si, [bp+argOptionalFileName]
call	idk_PushPopEsDsSiDiRetF	; Call Procedure
call	idk_Setup_EMM	; Call Procedure
db 83h,0FEh,0FFh ; <BAD>cmp	si, 0FFFFh ; Compare Two Operands
jnz	short loc_17E3F	; Jump if Not Zero (ZF=0)

loc_17E20:		; "FONTS.LBX"
mov	ax, offset strFONTSLBXr2
push	ax		; strFontsFileName
nop			; No Operation
push	cs
call	near ptr LBX_Load_FontsStyleData ; Call	Procedure
pop	cx
mov	ax, 2
push	ax		; int
mov	ax, 2		; int
push	ax		; int
call	ST_LoadSoundDrivers ; Call Procedure
pop	cx
pop	cx
mov	ax, 1		; int
push	ax
jmp	short loc_17E56	; Jump

loc_17E3F:		; CODE XREF: idk_Load_FntSty_SndDrv_Mos+14j
push	[bp+strFontsFileName] ;	strFontsFileName
nop			; No Operation
push	cs
call	near ptr LBX_Load_FontsStyleData ; Call	Procedure
pop	cx
push	[bp+arg_4]	; int
push	[bp+arg_2]	; int
call	ST_LoadSoundDrivers ; Call Procedure
pop	cx
pop	cx
push	si

loc_17E56:		; CODE XREF: idk_Load_FntSty_SndDrv_Mos+33j
call	idk_Mouse_s2B8B1 ; Call	Procedure

loc_17E5B:
pop	cx

loc_17E5C:		; Call Procedure
call	ILSe_RndCopySeed_s1CC59
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_Load_FntSty_SndDrv_Mos	; sp-analysis failed



; Attributes: bp-based frame

; int __fastcall __far LBX_Load_FontsStyleData(int, int, int, int strFontsFileName)
proc LBX_Load_FontsStyleData far
			; CODE XREF: Load_Fonts_SndDrv+21p
			; Load_Fonts_SndDrv+62p
			; idk_Load_FntSty_SndDrv_Mos+1Cp
			; idk_Load_FntSty_SndDrv_Mos+3Ap

strFontsFileName= word ptr  6

push	bp
mov	bp, sp
push	si
push	di		; argSrc


mov	di, [bp+strFontsFileName]
push	di		; argSrc
mov	ax, offset g_FontsFileName
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx


xor	ax, ax		; Logical Exclusive OR
push	ax		; argLbxEntryNumber
push	di		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ;
			; LBX_Load_Entry_0_0_0("FONTS.LBX", 0)
			;
			; LBX_Load_Entry(0,0,0,"FONTS.LBX",0)
pop	cx
pop	cx
mov	[bufFontsLbxEntry0], ax


mov	ax, 1
push	ax		; argLbxEntryNumber
push	di		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ;
			; LBX_Load_Entry_0_0_0("FONTS.LBX", 1)
			;
			; LBX_Load_Entry(0,0,0,"FONTS.LBX",1)
pop	cx
pop	cx
mov	[bufFontsLbxEntry1], ax


mov	ax, 348		; 16-byte blocks; 5,568	bytes
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[idk_FontsLbx1_5568], ax


mov	ax, 64		; 16-byte blocks; 1,024	bytes
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[idk_FontsLbx1_1024B], ax


mov	ax, [idk_FontsLbx1_1024B]
add	ax, 48		; Add
mov	[idk_FontsLbx1_1024_@48], ax


mov	ax, 48		; 16-byte blocks; 768 bytes
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[idk_FontsLbx1_768B], ax


mov	ax, 384		; 16-byte blocks; 6,144	bytes
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[idk_FontsLbx1_6144B], ax


mov	ax, 2		; 16-byte blocks; 32 bytes
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[idk_FontsLbx1_32B], ax


mov	ax, 96		; 16-byte blocks; 1,536	bytes
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[idk_FontsLbx1_e_96], ax


call	hrmLotsOfFarMallocStoreSW ; Call Procedure
xor	si, si		; Logical Exclusive OR
jmp	short LOOP_x768	; Jump

SI_LT_768:		; CODE XREF: LBX_Load_FontsStyleData+A6j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si
push	[idk_FontsLbx1_1024B]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
inc	si		; Increment by 1

LOOP_x768:		; CODE XREF: LBX_Load_FontsStyleData+8Fj
cmp	si, 768		; Compare Two Operands
jl	short SI_LT_768	; Jump if Less (SF!=OF)

SI_GTE_768:		; Logical Exclusive OR
xor	si, si
jmp	short LOOP_x256	; Jump

SI_LT_256:		; CODE XREF: LBX_Load_FontsStyleData+C2j
mov	ax, 1
push	ax
push	si
push	[idk_FontsLbx1_1024_@48]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
inc	si		; Increment by 1

LOOP_x256:		; CODE XREF: LBX_Load_FontsStyleData+AAj
cmp	si, 256		; Compare Two Operands
jl	short SI_LT_256	; Jump if Less (SF!=OF)

SI_GTE_256:
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_FontsStyleData



; dx = arg_0 ... word_35EC2
; bx = arg_2 ... word_35EC4
; cx = arg_4 ... word_35EC6
; si = arg_6 ... word_35EC8
; Attributes: bp-based frame

proc wtfCompareSwap far	; CODE XREF: sub_19F94+4CP
			; sub_19F94:loc_1A0BBP
			; sub_2BA41:loc_2CF1EP
			; sub_4D7A1+41P
			; sub_4DA02+41P
			; sub_4E031+39P
			; sub_4E031+89P
			; sub_4E031+501P
			; sub_4EC17+A8P
			; sub_4F1AB+78P
			; idk_OVR_LoadLbxHelp+30BP
			; sub_56240:loc_562CFP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_17F2D:
mov	bp, sp
push	si
push	di

loc_17F31:
mov	dx, [bp+arg_0]
mov	bx, [bp+arg_2]
mov	cx, [bp+arg_4]
mov	si, [bp+arg_6]
or	dx, dx		; Logical Inclusive OR

loc_17F3F:		; Jump if Greater or Equal (SF=OF)
jge	short loc_17F43
xor	dx, dx		; Logical Exclusive OR

loc_17F43:		; CODE XREF: wtfCompareSwap:loc_17F3Fj
or	bx, bx		; Logical Inclusive OR
jge	short loc_17F49	; Jump if Greater or Equal (SF=OF)

loc_17F47:		; Logical Exclusive OR
xor	bx, bx

loc_17F49:		; CODE XREF: wtfCompareSwap+19j
cmp	cx, 13Fh	; Compare Two Operands
jle	short loc_17F52	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	cx, 13Fh

loc_17F52:		; CODE XREF: wtfCompareSwap+21j
cmp	si, 0C7h ; ''  ; Compare Two Operands

loc_17F56:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_17F5B
mov	si, 0C7h ; ''

loc_17F5B:		; CODE XREF: wtfCompareSwap:loc_17F56j
cmp	dx, cx		; Compare Two Operands
jle	short loc_17F65	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_17F5F:
mov	di, cx
mov	cx, dx
mov	dx, di

loc_17F65:		; CODE XREF: wtfCompareSwap+31j
cmp	bx, si		; Compare Two Operands

loc_17F67:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_17F6F

loc_17F69:
mov	di, si
mov	si, bx
mov	bx, di

loc_17F6F:		; CODE XREF: wtfCompareSwap:loc_17F67j
mov	[idk_ScrnPosX0_w35EC2],	dx
mov	[idk_ScrnPosX319_w35EC6], cx
mov	[idk_ScrnPosY0_w35EC4],	bx

loc_17F7B:
mov	[idk_ScrnPosY199_w35EC8], si
pop	di

loc_17F80:
pop	si
pop	bp
retf			; Return Far from Procedure
endp wtfCompareSwap



; Attributes: bp-based frame

proc idk_ScrnPos_0_319_0_199 far
			; CODE XREF: sub_2BA41+20P
			; sub_4D5B0+1DCP
			; sub_4D7A1:loc_4D7FEP
			; sub_4D8FA:loc_4D9EEP
			; sub_4DA02+6AP
			; sub_4E031+61FP
			; sub_4E9F4+208P
			; sub_4EC17:loc_4ED08P
			; sub_4EF74+21CP
			; sub_4F1AB+C9P
			; idk_OVR_LoadLbxHelp+324P
			; idk_OVR_LoadLbxHelp:loc_55FE1P
			; sub_56240:loc_56408P
			; sub_56450+119P
			; idk_HoF_s565F2:loc_5664EP
push	bp
mov	bp, sp
mov	[idk_ScrnPosX0_w35EC2],	0

loc_17F8C:
mov	[idk_ScrnPosX319_w35EC6], 319
mov	[idk_ScrnPosY0_w35EC4],	0

loc_17F98:
mov	[idk_ScrnPosY199_w35EC8], 199
pop	bp
retf			; Return Far from Procedure
endp idk_ScrnPos_0_319_0_199



; Attributes: bp-based frame

proc sub_17FA0 far	; CODE XREF: sub_19F94+A9P
			; sub_19F94:loc_1A094P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	si
push	di

loc_17FA5:
mov	si, [bp+arg_0]

loc_17FA8:
mov	di, [bp+arg_2]

loc_17FAB:
mov	ax, [bp+arg_4]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands

loc_17FB2:		; Jump if Greater or Equal (SF=OF)
jge	short loc_17FB8

loc_17FB4:		; CODE XREF: sub_17FA0+1Ej
			; sub_17FA0+29j
			; sub_17FA0+31j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_18018	; Jump

loc_17FB8:		; CODE XREF: sub_17FA0:loc_17FB2j
cmp	si, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands

loc_17FBC:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_17FC0
jmp	short loc_17FB4	; Jump

loc_17FC0:		; CODE XREF: sub_17FA0:loc_17FBCj
mov	ax, [bp+arg_6]

loc_17FC3:		; Compare Two Operands
cmp	ax, [idk_ScrnPosY0_w35EC4]
jge	short loc_17FCB	; Jump if Greater or Equal (SF=OF)
jmp	short loc_17FB4	; Jump

loc_17FCB:		; CODE XREF: sub_17FA0+27j
cmp	di, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands

loc_17FCF:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_17FD3
jmp	short loc_17FB4	; Jump

loc_17FD3:		; CODE XREF: sub_17FA0:loc_17FCFj
cmp	si, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jge	short loc_17FDD	; Jump if Greater or Equal (SF=OF)
mov	si, [idk_ScrnPosX0_w35EC2]

loc_17FDD:		; CODE XREF: sub_17FA0+37j
cmp	di, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands

loc_17FE1:		; Jump if Greater or Equal (SF=OF)
jge	short loc_17FE7

loc_17FE3:
mov	di, [idk_ScrnPosY0_w35EC4]

loc_17FE7:		; CODE XREF: sub_17FA0:loc_17FE1j
mov	ax, [bp+arg_4]

loc_17FEA:		; Compare Two Operands
cmp	ax, [idk_ScrnPosX319_w35EC6]

loc_17FEE:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_17FF6

loc_17FF0:
mov	ax, [idk_ScrnPosX319_w35EC6]
mov	[bp+arg_4], ax

loc_17FF6:		; CODE XREF: sub_17FA0:loc_17FEEj
mov	ax, [bp+arg_6]

loc_17FF9:		; Compare Two Operands
cmp	ax, [idk_ScrnPosY199_w35EC8]
jle	short loc_18005	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_17FFF:
mov	ax, [idk_ScrnPosY199_w35EC8]

loc_18002:
mov	[bp+arg_6], ax

loc_18005:		; CODE XREF: sub_17FA0+5Dj
push	[bp+arg_8]
push	[bp+arg_6]
push	[bp+arg_4]
push	di
push	si
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add

loc_18018:		; CODE XREF: sub_17FA0+16j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_17FA0



; Attributes: bp-based frame

proc sub_1801C far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_1801D:
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]

loc_18024:
mov	di, [bp+arg_2]
cmp	si, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jge	short loc_18031	; Jump if Greater or Equal (SF=OF)

loc_1802D:		; CODE XREF: sub_1801C+1Bj
			; sub_1801C+23j
			; sub_1801C:loc_18047j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_18056	; Jump

loc_18031:		; CODE XREF: sub_1801C+Fj
cmp	si, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jle	short loc_18039	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	short loc_1802D	; Jump

loc_18039:		; CODE XREF: sub_1801C+19j
cmp	di, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands

loc_1803D:		; Jump if Greater or Equal (SF=OF)
jge	short loc_18041
jmp	short loc_1802D	; Jump

loc_18041:		; CODE XREF: sub_1801C:loc_1803Dj
cmp	di, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_18049	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_18047:		; Jump
jmp	short loc_1802D

loc_18049:		; CODE XREF: sub_1801C+29j
push	[bp+arg_4]

loc_1804C:
push	di

loc_1804D:
push	si
call	sub_187C0	; Call Procedure
add	sp, 6		; Add

loc_18056:		; CODE XREF: sub_1801C+13j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1801C



; Attributes: bp-based frame

proc sub_1805A far	; CODE XREF: sub_1844A+2Ap
			; sub_1844A+3Ap
			; sub_1844A+51p
			; sub_1844A+68p
			; sub_2BA41+127CP
			; sub_2BA41+12CAP
			; sub_2BA41+1319P
			; sub_2BA41+1369P
			; sub_2BA41+13EDP
			; sub_2BA41+1431P
			; sub_2BA41+1477P
			; sub_2BA41+14BFP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp

loc_1805D:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_18060:		; Logical Exclusive OR
xor	ax, ax

loc_18062:
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_18066:
push	[bp+arg_8]

loc_18069:		; Logical Exclusive OR
xor	ax, ax
push	ax
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]

loc_18075:
push	[bp+arg_0]

loc_18078:		; No Operation
nop
push	cs

loc_1807A:		; Call Procedure
call	near ptr sub_180AB
add	sp, 12h		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1805A



; Attributes: bp-based frame

proc sub_18082 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp

loc_18085:
push	[bp+arg_C]
push	[bp+arg_A]

loc_1808B:
push	[bp+arg_8]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 1

loc_18094:
push	ax

loc_18095:
push	[bp+arg_6]

loc_18098:
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs

loc_180A3:		; Call Procedure
call	near ptr sub_180AB
add	sp, 12h		; Add

loc_180A9:
pop	bp
retf			; Return Far from Procedure
endp sub_18082



; Attributes: bp-based frame

proc sub_180AB far	; CODE XREF: sub_1805A:loc_1807Ap
			; sub_18082:loc_180A3p

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]

loc_180B9:
mov	[bp+var_2], 0
mov	[bp+var_8], 0
cmp	si, [bp+arg_4]	; Compare Two Operands
jnz	short loc_1812B	; Jump if Not Zero (ZF=0)

loc_180C8:		; Compare Two Operands
cmp	si, [idk_ScrnPosX0_w35EC2]

loc_180CC:		; Jump if Less (SF!=OF)
jl	short loc_180D7

loc_180CE:
mov	ax, [bp+arg_4]

loc_180D1:		; Compare Two Operands
cmp	ax, [idk_ScrnPosX319_w35EC6]

loc_180D5:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_180DE

loc_180D7:		; CODE XREF: sub_180AB:loc_180CCj
mov	[bp+var_2], 1
jmp	short loc_18128	; Jump

loc_180DE:		; CODE XREF: sub_180AB:loc_180D5j
cmp	[bp+arg_6], di	; Compare Two Operands
jge	short loc_180F9	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+arg_6]

loc_180E6:
mov	[bp+var_6], ax
mov	[bp+arg_6], di

loc_180EC:
mov	di, [bp+var_6]

loc_180EF:
mov	ax, [bp+arg_E]
dec	ax		; Decrement by 1

loc_180F3:		; Integer Subtraction
sub	ax, [bp+arg_10]
mov	[bp+arg_10], ax

loc_180F9:		; CODE XREF: sub_180AB+36j
mov	ax, [bp+arg_6]

loc_180FC:		; Compare Two Operands
cmp	ax, [idk_ScrnPosY0_w35EC4]
jl	short loc_18108	; Jump if Less (SF!=OF)
cmp	di, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_1810F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_18108:		; CODE XREF: sub_180AB+55j
mov	[bp+var_2], 1
jmp	short loc_18128	; Jump

loc_1810F:		; CODE XREF: sub_180AB+5Bj
cmp	di, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jge	short loc_18119	; Jump if Greater or Equal (SF=OF)

loc_18115:
mov	di, [idk_ScrnPosY0_w35EC4]

loc_18119:		; CODE XREF: sub_180AB+68j
mov	ax, [bp+arg_6]

loc_1811C:		; Compare Two Operands
cmp	ax, [idk_ScrnPosY199_w35EC8]
jle	short loc_18128	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_18122:
mov	ax, [idk_ScrnPosY199_w35EC8]

loc_18125:
mov	[bp+arg_6], ax

loc_18128:		; CODE XREF: sub_180AB+31j
			; sub_180AB+62j
			; sub_180AB+75j
jmp	loc_18200	; Jump

loc_1812B:		; CODE XREF: sub_180AB+1Bj
cmp	[bp+arg_4], si	; Compare Two Operands

loc_1812E:		; Jump if Greater or Equal (SF=OF)
jge	short loc_18152
mov	ax, [bp+arg_4]
mov	[bp+var_4], ax
mov	[bp+arg_4], si

loc_18139:
mov	si, [bp+var_4]
mov	ax, [bp+arg_6]
mov	[bp+var_6], ax
mov	[bp+arg_6], di

loc_18145:
mov	di, [bp+var_6]

loc_18148:
mov	ax, [bp+arg_E]
dec	ax		; Decrement by 1
sub	ax, [bp+arg_10]	; Integer Subtraction

loc_1814F:
mov	[bp+arg_10], ax

loc_18152:		; CODE XREF: sub_180AB:loc_1812Ej
mov	ax, [bp+arg_6]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, di
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	bx
pop	cx
sub	cx, ax		; Integer Subtraction

loc_1815F:		; Integer Subtraction with Borrow
sbb	bx, dx
mov	[bp+var_E], bx

loc_18164:
mov	[bp+var_10], cx

loc_18167:
mov	ax, [bp+arg_4]

loc_1816A:		; AX ->	DX:AX (with sign)
cwd
push	ax
mov	ax, si
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	bx
pop	cx
sub	cx, ax		; Integer Subtraction

loc_18174:		; Integer Subtraction with Borrow
sbb	bx, dx

loc_18176:
mov	[bp+var_A], bx
mov	[bp+var_C], cx

loc_1817C:		; Compare Two Operands
cmp	si, [idk_ScrnPosX0_w35EC2]

loc_18180:		; Jump if Greater or Equal (SF=OF)
jge	short loc_181B4
mov	ax, [idk_ScrnPosX0_w35EC2]
sub	ax, si		; Integer Subtraction
mov	[bp+var_8], ax

loc_1818A:
push	[bp+var_A]
push	[bp+var_C]
mov	ax, [idk_ScrnPosX0_w35EC2]
sub	ax, si		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
mov	dx, [bp+var_E]
mov	ax, [bp+var_10]
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax

loc_181A7:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
add	ax, di		; Add
mov	di, ax
mov	si, [idk_ScrnPosX0_w35EC2]

loc_181B4:		; CODE XREF: sub_180AB:loc_18180j
cmp	si, [bp+arg_4]	; Compare Two Operands
jle	short loc_181C0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_181B9:
mov	[bp+var_2], 1

loc_181BE:		; Jump
jmp	short loc_18200

loc_181C0:		; CODE XREF: sub_180AB+10Cj
mov	ax, [bp+arg_4]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jle	short loc_181F6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[bp+var_A]

loc_181CC:
push	[bp+var_C]

loc_181CF:
mov	ax, [idk_ScrnPosX319_w35EC6]
sub	ax, si		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
mov	dx, [bp+var_E]

loc_181DA:
mov	ax, [bp+var_10]
pop	cx
pop	bx

loc_181DF:		; Call Procedure
call	LXMUL@
push	dx
push	ax

loc_181E6:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
add	ax, di		; Add
mov	[bp+arg_6], ax
mov	ax, [idk_ScrnPosX319_w35EC6]
mov	[bp+arg_4], ax

loc_181F6:		; CODE XREF: sub_180AB+11Cj
cmp	[bp+arg_4], si	; Compare Two Operands
jge	short loc_18200	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_2], 1

loc_18200:		; CODE XREF: sub_180AB:loc_18128j
			; sub_180AB:loc_181BEj
			; sub_180AB+14Ej
cmp	di, [bp+arg_6]	; Compare Two Operands
jnz	short loc_18266	; Jump if Not Zero (ZF=0)
cmp	di, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jl	short loc_18214	; Jump if Less (SF!=OF)

loc_1820B:
mov	ax, [bp+arg_6]
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_1821B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_18214:		; CODE XREF: sub_180AB+15Ej
mov	[bp+var_2], 1
jmp	short loc_18263	; Jump

loc_1821B:		; CODE XREF: sub_180AB+167j
cmp	[bp+arg_4], si	; Compare Two Operands

loc_1821E:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1822C

loc_18220:
mov	ax, [bp+arg_4]

loc_18223:
mov	[bp+var_4], ax

loc_18226:
mov	[bp+arg_4], si
mov	si, [bp+var_4]

loc_1822C:		; CODE XREF: sub_180AB:loc_1821Ej
mov	ax, [bp+arg_4]

loc_1822F:		; Compare Two Operands
cmp	ax, [idk_ScrnPosX0_w35EC2]
jl	short loc_1823B	; Jump if Less (SF!=OF)

loc_18235:		; Compare Two Operands
cmp	si, [idk_ScrnPosX319_w35EC6]
jle	short loc_18242	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1823B:		; CODE XREF: sub_180AB+188j
mov	[bp+var_2], 1
jmp	short loc_18263	; Jump

loc_18242:		; CODE XREF: sub_180AB+18Ej
cmp	si, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jge	short loc_18254	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_ScrnPosX0_w35EC2]

loc_1824B:		; Integer Subtraction
sub	ax, si
mov	[bp+var_8], ax
mov	si, [idk_ScrnPosX0_w35EC2]

loc_18254:		; CODE XREF: sub_180AB+19Bj
mov	ax, [bp+arg_4]

loc_18257:		; Compare Two Operands
cmp	ax, [idk_ScrnPosX319_w35EC6]

loc_1825B:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_18263

loc_1825D:
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_18260:
mov	[bp+arg_4], ax

loc_18263:		; CODE XREF: sub_180AB+16Ej
			; sub_180AB+195j
			; sub_180AB:loc_1825Bj
jmp	loc_18329	; Jump

loc_18266:		; CODE XREF: sub_180AB+158j
cmp	[bp+arg_6], di	; Compare Two Operands
jge	short loc_18283	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+arg_6]

loc_1826E:
mov	[bp+var_6], ax
mov	[bp+arg_6], di
mov	di, [bp+var_6]

loc_18277:
mov	ax, [bp+arg_4]

loc_1827A:
mov	[bp+var_4], ax

loc_1827D:
mov	[bp+arg_4], si

loc_18280:
mov	si, [bp+var_4]

loc_18283:		; CODE XREF: sub_180AB+1BEj
mov	ax, [bp+arg_4]

loc_18286:		; AX ->	DX:AX (with sign)
cwd
push	ax
mov	ax, si

loc_1828A:
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	bx
pop	cx
sub	cx, ax		; Integer Subtraction
sbb	bx, dx		; Integer Subtraction with Borrow

loc_18292:
mov	[bp+var_A], bx
mov	[bp+var_C], cx

loc_18298:
mov	ax, [bp+arg_6]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, di
push	dx
cwd			; AX ->	DX:AX (with sign)

loc_182A1:
pop	bx
pop	cx
sub	cx, ax		; Integer Subtraction

loc_182A5:		; Integer Subtraction with Borrow
sbb	bx, dx

loc_182A7:
mov	[bp+var_E], bx

loc_182AA:
mov	[bp+var_10], cx

loc_182AD:		; Compare Two Operands
cmp	di, [idk_ScrnPosY0_w35EC4]
jge	short loc_182DD	; Jump if Greater or Equal (SF=OF)
push	[bp+var_E]
push	[bp+var_10]
mov	ax, [idk_ScrnPosY0_w35EC4]

loc_182BC:		; Integer Subtraction
sub	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
mov	dx, [bp+var_A]

loc_182C4:
mov	ax, [bp+var_C]
pop	cx
pop	bx

loc_182C9:		; Call Procedure
call	LXMUL@
push	dx
push	ax

loc_182D0:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
add	ax, si		; Add

loc_182D7:
mov	si, ax
mov	di, [idk_ScrnPosY0_w35EC4]

loc_182DD:		; CODE XREF: sub_180AB+206j
cmp	di, [bp+arg_6]	; Compare Two Operands

loc_182E0:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_182E9
mov	[bp+var_2], 1
jmp	short loc_18329	; Jump

loc_182E9:		; CODE XREF: sub_180AB:loc_182E0j
mov	ax, [bp+arg_6]
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_1831F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_182F2:
push	[bp+var_E]

loc_182F5:
push	[bp+var_10]

loc_182F8:
mov	ax, [idk_ScrnPosY199_w35EC8]

loc_182FB:		; Integer Subtraction
sub	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax

loc_182FF:
push	dx

loc_18300:
mov	dx, [bp+var_A]

loc_18303:
mov	ax, [bp+var_C]

loc_18306:
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
add	ax, si		; Add
mov	[bp+arg_4], ax
mov	ax, [idk_ScrnPosY199_w35EC8]

loc_1831C:
mov	[bp+arg_6], ax

loc_1831F:		; CODE XREF: sub_180AB+245j
cmp	[bp+arg_6], di	; Compare Two Operands
jge	short loc_18329	; Jump if Greater or Equal (SF=OF)

loc_18324:
mov	[bp+var_2], 1

loc_18329:		; CODE XREF: sub_180AB:loc_18263j
			; sub_180AB+23Cj
			; sub_180AB+277j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_1836B	; Jump if Not Zero (ZF=0)

loc_1832F:		; Compare Two Operands
cmp	[bp+arg_8], 0
jnz	short loc_1834A	; Jump if Not Zero (ZF=0)
push	[bp+arg_A]

loc_18338:
push	[bp+arg_6]

loc_1833B:
push	[bp+arg_4]
push	di
push	si

loc_18340:		; Call Procedure
call	sub_187FA
add	sp, 0Ah		; Add

loc_18348:		; Jump
jmp	short loc_1836B

loc_1834A:		; CODE XREF: sub_180AB+288j
mov	ax, [bp+arg_10]

loc_1834D:		; Add
add	ax, [bp+var_8]
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+arg_E]	; Signed Divide
push	dx

loc_18355:
push	[bp+arg_E]

loc_18358:
push	[bp+arg_C]

loc_1835B:
push	[bp+arg_6]

loc_1835E:
push	[bp+arg_4]
push	di

loc_18362:
push	si

loc_18363:		; Call Procedure
call	sub_18903
add	sp, 0Eh		; Add

loc_1836B:		; CODE XREF: sub_180AB+282j
			; sub_180AB:loc_18348j
pop	di
pop	si
mov	sp, bp

loc_1836F:
pop	bp
retf			; Return Far from Procedure
endp sub_180AB



; Attributes: bp-based frame

proc sub_18371 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp

loc_18372:
mov	bp, sp

loc_18374:
push	si
push	di

loc_18376:
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
push	[bp+arg_8]
push	di

loc_18380:
push	[bp+arg_4]

loc_18383:
push	di
push	si
call	sub_187FA	; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_8]

loc_18390:
push	[bp+arg_6]
push	si
push	di
push	si

loc_18396:		; Call Procedure
call	sub_187FA

loc_1839B:		; Add
add	sp, 0Ah
push	[bp+arg_A]

loc_183A1:
push	[bp+arg_6]

loc_183A4:
push	[bp+arg_4]
push	[bp+arg_6]
mov	ax, si
inc	ax		; Increment by 1
push	ax

loc_183AE:		; Call Procedure
call	sub_187FA
add	sp, 0Ah		; Add
push	[bp+arg_A]
push	[bp+arg_6]

loc_183BC:
push	[bp+arg_4]

loc_183BF:
mov	ax, di
inc	ax		; Increment by 1
push	ax

loc_183C3:
push	[bp+arg_4]

loc_183C6:		; Call Procedure
call	sub_187FA

loc_183CB:		; Add
add	sp, 0Ah
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_18371



; Attributes: bp-based frame

proc sub_183D2 far

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction

loc_183D8:
push	si
push	di

loc_183DA:
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]

loc_183E0:
mov	ax, si
add	ax, [bp+arg_4]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_2], ax

loc_183E9:
mov	ax, di

loc_183EB:		; Add
add	ax, [bp+arg_6]
dec	ax		; Decrement by 1

loc_183EF:
mov	[bp+var_4], ax
push	[bp+arg_8]
push	di
push	[bp+var_2]
push	di
push	si
call	sub_187FA	; Call Procedure

loc_18400:		; Add
add	sp, 0Ah

loc_18403:
push	[bp+arg_8]
push	[bp+var_4]
push	si
push	di
push	si

loc_1840C:		; Call Procedure
call	sub_187FA
add	sp, 0Ah		; Add
push	[bp+arg_8]
push	[bp+var_4]
push	[bp+var_2]
push	[bp+var_4]

loc_18420:
mov	ax, si
inc	ax		; Increment by 1
push	ax
call	sub_187FA	; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_8]
push	[bp+var_4]
push	[bp+var_2]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	[bp+var_2]

loc_1843C:		; Call Procedure
call	sub_187FA
add	sp, 0Ah		; Add

loc_18444:
pop	di
pop	si
mov	sp, bp
pop	bp

locret_18449:		; Return Far from Procedure
retf
endp sub_183D2



; Attributes: bp-based frame

proc sub_1844A far

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction

loc_18450:
push	si

loc_18451:
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
mov	ax, si

loc_1845A:		; Add
add	ax, [bp+arg_4]
dec	ax		; Decrement by 1

loc_1845E:
mov	[bp+var_2], ax
mov	ax, di
add	ax, [bp+arg_6]	; Add

loc_18466:		; Decrement by 1
dec	ax
mov	[bp+var_4], ax
push	[bp+arg_8]
push	di
push	[bp+var_2]
push	di
push	si
push	cs
call	near ptr sub_1805A ; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_8]

loc_1847D:
push	[bp+var_4]

loc_18480:
push	si
push	di

loc_18482:
push	si
push	cs
call	near ptr sub_1805A ; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_8]

loc_1848D:
push	[bp+var_4]
push	[bp+var_2]

loc_18493:
push	[bp+var_4]
mov	ax, si
inc	ax		; Increment by 1
push	ax
push	cs
call	near ptr sub_1805A ; Call Procedure
add	sp, 0Ah		; Add

loc_184A1:
push	[bp+arg_8]

loc_184A4:
push	[bp+var_4]

loc_184A7:
push	[bp+var_2]
mov	ax, di

loc_184AC:		; Increment by 1
inc	ax

loc_184AD:
push	ax
push	[bp+var_2]
push	cs
call	near ptr sub_1805A ; Call Procedure
add	sp, 0Ah		; Add
pop	di
pop	si

loc_184BA:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1844A



; Attributes: bp-based frame

proc sub_184BE far	; CODE XREF: sub_1D1B5:loc_1D254P
			; sub_1D1B5:loc_1D27CP
			; sub_1D1B5:loc_1D2D0P
			; sub_1D1B5+17FP
			; sub_1D1B5:loc_1D39AP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]

loc_184C6:
mov	di, [bp+arg_2]
push	[bp+arg_8]

loc_184CC:
push	di
push	[bp+arg_4]

loc_184D0:
push	di
push	si

loc_184D2:		; Call Procedure
call	sub_187FA

loc_184D7:		; Add
add	sp, 0Ah
push	[bp+arg_8]

loc_184DD:
push	[bp+arg_6]

loc_184E0:
push	si
push	di
push	si

loc_184E3:		; Call Procedure
call	sub_187FA
add	sp, 0Ah		; Add
push	[bp+arg_C]
push	[bp+arg_6]
push	[bp+arg_4]

loc_184F4:
push	[bp+arg_6]
mov	ax, si
inc	ax		; Increment by 1

loc_184FA:
push	ax

loc_184FB:		; Call Procedure
call	sub_187FA

loc_18500:		; Add
add	sp, 0Ah
push	[bp+arg_C]

loc_18506:
push	[bp+arg_6]
push	[bp+arg_4]

loc_1850C:
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	[bp+arg_4]
call	sub_187FA	; Call Procedure
add	sp, 0Ah		; Add
inc	si		; Increment by 1
inc	di		; Increment by 1
dec	[bp+arg_4]	; Decrement by 1
dec	[bp+arg_6]	; Decrement by 1

loc_18523:
push	[bp+arg_A]
push	di

loc_18527:
push	[bp+arg_4]
push	di
push	si

loc_1852C:		; Call Procedure
call	sub_187FA

loc_18531:		; Add
add	sp, 0Ah
push	[bp+arg_A]
push	[bp+arg_6]
push	si
push	di
push	si

loc_1853D:		; Call Procedure
call	sub_187FA
add	sp, 0Ah		; Add
push	[bp+arg_E]
push	[bp+arg_6]

loc_1854B:
push	[bp+arg_4]
push	[bp+arg_6]
mov	ax, si
inc	ax		; Increment by 1
push	ax
call	sub_187FA	; Call Procedure

loc_1855A:		; Add
add	sp, 0Ah
push	[bp+arg_E]

loc_18560:
push	[bp+arg_6]

loc_18563:
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	[bp+arg_4]

loc_1856D:		; Call Procedure
call	sub_187FA
add	sp, 0Ah		; Add
pop	di
pop	si
pop	bp

locret_18578:		; Return Far from Procedure
retf
endp sub_184BE



; Attributes: bp-based frame

proc sub_18579 far	; CODE XREF: sub_2BA41+BD2P
			; sub_2CF44+E01P
			; sub_4E9F4+E6P
			; sub_4EF74+EBP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h

push	bp
mov	bp, sp

loc_1857C:
push	si

loc_1857D:
push	di

loc_1857E:
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]

loc_18584:
mov	bx, [bp+arg_8]
cmp	bx, 10h		; switch 17 cases
jbe	short loc_1858F	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_1862C	; default

loc_1858F:		; CODE XREF: sub_18579+11j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_18631+bx] ; switch jump

loc_18596:		; DATA XREF: seg014:off_18631o
jmp	loc_1862C	; case 0x0

loc_18599:		; CODE XREF: sub_18579+18j
			; DATA XREF: seg014:off_18631o
push	[bp+arg_A]	; case 0x1
push	[bp+arg_6]
push	[bp+arg_4]
push	di
push	si

loc_185A4:		; Call Procedure
call	idk_VGA_ScData_s186BC

loc_185A9:		; CODE XREF: sub_18579+4Aj
			; sub_18579+B0j
add	sp, 0Ah		; Add
jmp	short loc_1862C	; default

loc_185AE:		; CODE XREF: sub_18579+18j
			; DATA XREF: seg014:off_18631o
xor	ax, ax		; case 0x3
push	ax
jmp	short loc_185B6	; Jump

loc_185B3:		; CODE XREF: sub_18579+18j
			; DATA XREF: seg014:off_18631o
push	[bp+arg_A]	; case 0xF

loc_185B6:		; CODE XREF: sub_18579+38j
push	[bp+arg_6]
push	[bp+arg_4]
push	di
push	si
call	sub_18BA2	; Call Procedure
jmp	short loc_185A9	; Jump

loc_185C5:		; CODE XREF: sub_18579+18j
			; DATA XREF: seg014:off_18631o
push	[bp+arg_10]	; case 0x5
push	[bp+arg_E]
push	[bp+arg_C]

loc_185CE:
push	[bp+arg_A]

loc_185D1:
push	[bp+arg_6]

loc_185D4:
push	[bp+arg_4]
push	di
push	si
call	sub_18FCC	; Call Procedure
jmp	short loc_18614	; Jump

loc_185E0:		; CODE XREF: sub_18579+18j
			; DATA XREF: seg014:off_18631o
push	[bp+arg_10]	; case 0x7
push	[bp+arg_E]

loc_185E6:
push	[bp+arg_C]
push	[bp+arg_A]

loc_185EC:
push	[bp+arg_6]
push	[bp+arg_4]
push	di
push	si
call	sub_18A5C	; Call Procedure

loc_185F9:		; Jump
jmp	short loc_18614

loc_185FB:		; CODE XREF: sub_18579+18j
			; DATA XREF: seg014:off_18631o
push	[bp+arg_10]	; case 0xD

loc_185FE:
push	[bp+arg_E]
push	[bp+arg_C]

loc_18604:
push	[bp+arg_A]
push	[bp+arg_6]

loc_1860A:
push	[bp+arg_4]
push	di
push	si
call	sub_190B6	; Call Procedure

loc_18614:		; CODE XREF: sub_18579+65j
			; sub_18579:loc_185F9j
add	sp, 10h		; Add
jmp	short loc_1862C	; default

loc_18619:		; CODE XREF: sub_18579+18j
			; DATA XREF: seg014:off_18631o
push	[bp+arg_A]	; case 0x10
push	[bp+arg_6]

loc_1861F:
push	[bp+arg_4]

loc_18622:
push	di
push	si
call	idk_VidPalFnt_s18D9F ; Call Procedure
jmp	loc_185A9	; Jump

loc_1862C:		; CODE XREF: sub_18579+13j
			; sub_18579+18j
			; sub_18579:loc_18596j
			; sub_18579+33j
			; sub_18579+9Ej
			; DATA XREF: seg014:off_18631o
pop	di		; default
pop	si

loc_1862E:
pop	bp
retf			; Return Far from Procedure
endp sub_18579

db 0
off_18631 dw offset loc_18596
			; DATA XREF: sub_18579+18r
dw offset loc_18599	; jump table for switch	statement
dw offset loc_1862C
dw offset loc_185AE
dw offset loc_1862C
dw offset loc_185C5
dw offset loc_1862C
dw offset loc_185E0
dw offset loc_1862C
dw offset loc_1862C
dw offset loc_1862C
dw offset loc_1862C
dw offset loc_1862C
dw offset loc_185FB
dw offset loc_1862C
dw offset loc_185B3
dw offset loc_18619


; Attributes: bp-based frame

proc DOS_PrintString far
			; CODE XREF: _f010109_main+DEP

argString= word	ptr  6

push	bp

loc_18654:
mov	bp, sp

loc_18656:
push	si

loc_18657:
mov	si, [bp+argString]

loc_1865A:
mov	dx, [bp+argString]

loc_1865D:
mov	ah, 9

loc_1865F:		; DOS -	PRINT STRING
int	21h		; DS:DX	-> string terminated by	"$"
pop	si
pop	bp
retf			; Return Far from Procedure
endp DOS_PrintString

ends seg014


; Segment type:	Pure code
segment	seg015 byte public 'CODE' use16
assume cs:seg015
;org 4
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing



proc ST_SetVideoMode_VGA far
			; CODE XREF: Load_Fonts_SndDrv+11P
push	si
push	di

loc_18666:
push	es
push	ds

loc_18668:
mov	ax, VGA_256_COLOR_MODE

loc_1866B:		; DOS -	VIDEO -	SET VIDEO MODE
int	10h		; AL = mode

loc_1866D:
mov	dx, SC_INDEX
mov	al, MEMORY_MODE
out	dx, al		; EGA: sequencer address reg
			; memory mode. Data bits:
			; 0: 1=text char generator; 0=graphics
			; 1: 1=EGA ram > 64K; 0=64K
			; 2: 1=sequential; 0=odd/even
inc	dx		; Increment by 1
in	al, dx		; EGA port: sequencer data register
and	al, 11110111b	; Logical AND
or	al, 100b	; Logical Inclusive OR
out	dx, al		; EGA port: sequencer data register
			;
			;
			;
			;
mov	ax, VIDEO_RAM	; Clear	all the	memory...
mov	es, ax
assume es:nothing
sub	di, di		; Integer Subtraction
mov	ax, di
mov	cx, 8000h	; 0x10000 / 2 =	0x8000
			; 65536	/ 2 = 32768
cld			; Clear	Direction Flag
rep stosw		;
			;
			;
mov	dx, CRTC_INDEX
mov	al, 14h
out	dx, al		; Video: CRT cntrlr addr
			; underline location.  Bits 0-5	are scan line number.
inc	dx		; Increment by 1
in	al, dx		; Video: CRT controller	internal registers
and	al, 10111111b	; Logical AND
out	dx, al		; Video: CRT controller	internal registers

loc_18694:		; Decrement by 1
dec	dx

loc_18695:
mov	al, CRTC_MODE_CONTROL
out	dx, al		; Video: CRT cntrlr addr
			; mode control.Data bits:
			; 0:0=CGA compatible
			; 1:select row scan counter
			; 2:hor	retrace:1=double vert res
			; 3:1=use char clock/2 for word	refresh
			; 4:1=high impedance on	output
			; 5:addr wrapping mode
			; 6:1=byte,0=word mode
			; 7:0=hardware reset

loc_18698:		; Increment by 1
inc	dx
in	al, dx		; Video: CRT controller	internal registers

loc_1869A:		; Logical Inclusive OR
or	al, 1000000b

loc_1869C:		; Video: CRT controller	internal registers
out	dx, al

loc_1869D:
mov	dx, SC_INDEX

loc_186A0:
mov	al, MAP_MASK
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
pop	ds
pop	es
assume es:nothing
pop	di

loc_186A6:
pop	si
retf			; Return Far from Procedure
endp ST_SetVideoMode_VGA

ends seg015


; Segment type:	Pure code
segment	seg016 byte public 'CODE' use16
assume cs:seg016
;org 8
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
word_186A8 dw 0		; DATA XREF: sub_18BA2+B5w
			; sub_18BA2+F2r
			; sub_18BA2+140r
			; sub_18BA2+18Ar
			; sub_18BA2+1D4r
			; idk_VidPalFnt_s18D9F+F1w
			; idk_VidPalFnt_s18D9F+122r
			; idk_VidPalFnt_s18D9F+170r
			; idk_VidPalFnt_s18D9F+1BAr
			; idk_VidPalFnt_s18D9F+204r
word_186AA dw 0		; DATA XREF: sub_18BA2+31w
			; sub_18BA2:loc_18C09w
			; sub_18BA2+DFr
			; idk_VidPalFnt_s18D9F+6Dw
			; idk_VidPalFnt_s18D9F:loc_18E42w
			; idk_VidPalFnt_s18D9F+10Fr
word_186AC dw 0		; DATA XREF: sub_18BA2+18w
			; sub_18BA2:loc_18C0Ew
			; sub_18BA2+E6r
			; idk_VidPalFnt_s18D9F+54w
			; idk_VidPalFnt_s18D9F+A8w
			; idk_VidPalFnt_s18D9F+116r
word_186AE dw 0		; DATA XREF: sub_18BA2+35w
			; sub_18BA2:loc_18BFFw
			; sub_18BA2:loc_18CCFr
			; idk_VidPalFnt_s18D9F+71w
			; idk_VidPalFnt_s18D9F:loc_18E38w
			; idk_VidPalFnt_s18D9F+15Dr
word_186B0 dw 0		; DATA XREF: sub_18BA2+1Cw
			; sub_18BA2:loc_18C04w
			; sub_18BA2:loc_18C28w
			; sub_18BA2:loc_18CB7r
			; sub_18BA2:loc_18CD6r
			; idk_VidPalFnt_s18D9F+58w
			; idk_VidPalFnt_s18D9F+9Ew
			; idk_VidPalFnt_s18D9F+C2w
			; idk_VidPalFnt_s18D9F:loc_18EE4r
			; idk_VidPalFnt_s18D9F+164r
word_186B2 dw 0		; DATA XREF: sub_18BA2+39w
			; sub_18BA2+53w
			; sub_18BA2:loc_18D19r
			; idk_VidPalFnt_s18D9F+75w
			; idk_VidPalFnt_s18D9F:loc_18E2Ew
			; idk_VidPalFnt_s18D9F+1A7r
word_186B4 dw 0		; DATA XREF: sub_18BA2+20w
			; sub_18BA2+58w
			; sub_18BA2:loc_18C2Dw
			; sub_18BA2:loc_18D20r
			; idk_VidPalFnt_s18D9F+5Cw
			; idk_VidPalFnt_s18D9F+94w
			; idk_VidPalFnt_s18D9F:loc_18E66w
			; idk_VidPalFnt_s18D9F+1AEr
word_186B6 dw 0		; DATA XREF: sub_18BA2+3Dw
			; sub_18BA2:loc_18D63r
			; idk_VidPalFnt_s18D9F+79w
			; idk_VidPalFnt_s18D9F+1F1r
word_186B8 dw 0		; DATA XREF: sub_18BA2+24w
			; sub_18BA2:loc_18C32w
			; sub_18BA2+1C8r
			; idk_VidPalFnt_s18D9F+60w
			; idk_VidPalFnt_s18D9F:loc_18E6Bw
			; idk_VidPalFnt_s18D9F+1F8r
word_186BA dw 0		; DATA XREF: sub_18BA2:loc_18C98w
			; sub_18BA2+10Ew
			; sub_18BA2+144w
			; sub_18BA2:loc_18CFEw
			; sub_18BA2+18Ew
			; sub_18BA2+1A6w
			; sub_18BA2+1D8w
			; sub_18BA2+1F0w
			; idk_VidPalFnt_s18D9F+126w
			; idk_VidPalFnt_s18D9F+13Ew
			; idk_VidPalFnt_s18D9F+174w
			; idk_VidPalFnt_s18D9F+18Cw
			; idk_VidPalFnt_s18D9F+1BEw
			; idk_VidPalFnt_s18D9F+1D6w
			; idk_VidPalFnt_s18D9F+208w
			; idk_VidPalFnt_s18D9F+220w


; Attributes: bp-based frame

proc idk_VGA_ScData_s186BC far
			; CODE XREF: _f010109_main+351P
			; _f010109_main+36FP
			; _f010509_MainMenuScreen+69P
			; _f010509_MainMenuScreen+87P
			; _f010609_DrawMainMenuScreen+2CP
			; sub_17FA0+70P
			; sub_18579:loc_185A4P
			; sub_1CBE3:loc_1CBFCP
			; sub_1CBE3:loc_1CC1AP
			; sub_1D1B5:loc_1D22CP
			; sub_28963+122P
			; sub_2BA41+CC7P
			; sub_2BA41+F45P
			; sub_2BA41+10D6P
			; sub_3D378+42P
			; sub_3DBA6+106P
			; sub_3DBA6+124P
			; sub_3DF8C+50P
			; sub_3DF8C:loc_3E009P
			; sub_3DF8C+98P
			; sub_3E1DE+2BP
			; sub_3E1DE+49P
			; sub_3E1DE+1EFP
			; sub_3E1DE:loc_3E3EBP
			; sub_3E60E+8FP
			; sub_3E60E+AAP
			; sub_3E60E+C5P
			; sub_3E60E+E0P
			; sub_3E60E+FBP
			; sub_3E60E+116P
			; sub_3EDD1+B3P
			; sub_3EDD1+CEP
			; sub_3EDD1+E9P
			; sub_3EDD1+104P
			; sub_3EDD1+11FP
			; sub_3EDD1+13AP
			; sub_3EDD1+155P
			; sub_3EDD1+170P
			; sub_3EDD1:loc_3EF5CP
			; sub_3EDD1+1A6P
			; sub_3EDD1:loc_3EF92P
			; sub_3EDD1+1DCP
			; sub_3EDD1+1F7P
			; sub_3EDD1+212P
			; sub_3EDD1+23BP
			; sub_40EC0+BBP
			; sub_424BB+81P
			; sub_4CAF3+50P
			; sub_4EC17+11AP
			; sub_4F1AB+E8P
			; ST_LoadMusicSoundfxIntro+11FP
			; sub_56450+3BP
			; sub_56450+17CP

var_4= word ptr	-4
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= byte ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	ds
push	di
push	si
push	es
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	ax, [bp+arg_4]
mov	bx, [bp+arg_0]
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
cmp	ax, bx		; Compare Two Operands
jnz	short loc_1872A	; Jump if Not Zero (ZF=0)

loc_186DE:
mov	di, ax
mov	si, 41C8h
mov	ax, [bp+arg_0]
and	ax, 3		; Logical AND
add	si, ax		; Add
lodsb			; Load String
mov	bl, al
mov	si, 41CCh
mov	ax, [bp+arg_4]
and	ax, 3		; Logical AND
add	si, ax		; Add
lodsb			; Load String
and	bl, al		; Logical AND
mov	dx, SC_DATA
mov	al, bl
out	dx, al		; EGA port: sequencer data register


mov	ax, [bp+arg_2]
mov	dx, ax
mov	cx, [bp+arg_6]
inc	cx		; Increment by 1
sub	cx, ax		; Integer Subtraction
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	al, [bp+arg_8]

loc_1871C:		; CODE XREF: idk_VGA_ScData_s186BC+64j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1871C	; Loop while CX	!= 0
pop	es
pop	si
pop	di
pop	ds
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_1872A:		; CODE XREF: idk_VGA_ScData_s186BC+20j
mov	dx, [bp+arg_6]
mov	bx, [bp+arg_2]
sub	dx, bx		; Integer Subtraction
inc	dx		; Increment by 1
mov	[bp+var_4], dx
mov	ax, bx
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	di, [bp+arg_0]
mov	bx, di
shr	di, 1		; Shift	Logical	Right
shr	di, 1		; Shift	Logical	Right
and	bx, 3		; Logical AND
add	bx, 41C8h	; Add
mov	al, [bx]
mov	dx, SC_DATA
out	dx, al		; EGA port: sequencer data register


mov	cx, [bp+var_4]
mov	al, [bp+arg_8]

loc_18760:		; CODE XREF: idk_VGA_ScData_s186BC+A8j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_18760	; Loop while CX	!= 0

loc_18766:
mov	di, [bp+arg_4]
mov	bx, di
shr	di, 1		; Shift	Logical	Right
shr	di, 1		; Shift	Logical	Right
and	bx, 3		; Logical AND
add	bx, 41CCh	; Add
mov	al, [bx]
mov	dx, SC_DATA
out	dx, al		; EGA port: sequencer data register
mov	cx, [bp+var_4]
mov	al, [bp+arg_8]

loc_18782:		; CODE XREF: idk_VGA_ScData_s186BC+CAj
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_18782	; Loop while CX	!= 0

loc_18788:
mov	al, 0Fh
mov	dx, SC_DATA
out	dx, al		; EGA port: sequencer data register
mov	bx, [bp+arg_4]
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
mov	ax, [bp+arg_0]
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
sub	bx, ax		; Integer Subtraction
dec	bx		; Decrement by 1
jz	short loc_187B8	; Jump if Zero (ZF=1)

loc_187A1:
mov	di, ax
inc	di		; Increment by 1
mov	dx, 50h	; 'P'
sub	dx, bx		; Integer Subtraction
mov	si, [bp+var_4]
mov	al, [bp+arg_8]

loc_187AF:		; CODE XREF: idk_VGA_ScData_s186BC+FAj
mov	cx, bx
rep stosb		; Store	String
add	di, dx		; Add
dec	si		; Decrement by 1
jnz	short loc_187AF	; Jump if Not Zero (ZF=0)

loc_187B8:		; CODE XREF: idk_VGA_ScData_s186BC+E3j
pop	es
pop	si
pop	di
pop	ds
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_VGA_ScData_s186BC



; Attributes: bp-based frame

proc sub_187C0 far	; CODE XREF: sub_1801C+32P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= byte ptr	 0Ah

push	bp
mov	bp, sp
push	di
push	es

loc_187C5:
mov	bx, [bp+arg_0]

loc_187C8:
mov	di, bx
shr	di, 1		; Shift	Logical	Right

loc_187CC:		; Shift	Logical	Right
shr	di, 1

loc_187CE:		; Logical AND
and	bx, 3

loc_187D1:		; Add
add	bx, 41D0h
mov	ah, [bx]

loc_187D7:
mov	dx, SC_INDEX

loc_187DA:
mov	al, 2

loc_187DC:		; EGA: sequencer address reg
out	dx, al		; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1

loc_187DE:
mov	al, ah

loc_187E0:		; EGA port: sequencer data register
out	dx, al
mov	ax, [bp+arg_2]

loc_187E4:
mov	dx, ax

loc_187E6:		; Shift	Logical	Left
shl	dx, 1
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add

loc_187EC:		; Add
add	ax, [g_ptrVideoRamBuffer]
mov	es, ax
mov	al, [bp+arg_4]
stosb			; Store	String
pop	es
pop	di
pop	bp
retf			; Return Far from Procedure
endp sub_187C0



; Attributes: bp-based frame

proc sub_187FA far	; CODE XREF: sub_180AB:loc_18340P
			; sub_18371+14P
			; sub_18371:loc_18396P
			; sub_18371:loc_183AEP
			; sub_18371:loc_183C6P
			; sub_183D2+29P
			; sub_183D2:loc_1840CP
			; sub_183D2+52P
			; sub_183D2:loc_1843CP
			; sub_184BE:loc_184D2P
			; sub_184BE:loc_184E3P
			; sub_184BE:loc_184FBP
			; sub_184BE+55P
			; sub_184BE:loc_1852CP
			; sub_184BE:loc_1853DP
			; sub_184BE+97P
			; sub_184BE:loc_1856DP
			; sub_28963+205P
			; sub_28963+277P
			; sub_28963+352P

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= byte ptr	 0Eh

push	bp

loc_187FB:
mov	bp, sp

loc_187FD:		; Integer Subtraction
sub	sp, 0Ah

loc_18800:
push	es
push	ds
push	si
push	di

loc_18804:
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_1880A:
mov	ax, [bp+arg_4]
cmp	ax, [bp+arg_0]	; Compare Two Operands

loc_18810:		; Jump if Not Sign (SF=0)
jns	short loc_18829
mov	si, ax

loc_18814:
mov	ax, [bp+arg_0]
mov	[bp+arg_4], ax

loc_1881A:
mov	[bp+arg_0], si
mov	si, [bp+arg_6]

loc_18820:
mov	ax, [bp+arg_2]

loc_18823:
mov	[bp+arg_6], ax

loc_18826:
mov	[bp+arg_2], si

loc_18829:		; CODE XREF: sub_187FA:loc_18810j
mov	ax, [bp+arg_0]

loc_1882C:
mov	bx, [bp+arg_2]
mov	cx, [bp+arg_4]

loc_18832:
mov	dx, [bp+arg_6]
sub	cx, ax		; Integer Subtraction
sub	dx, bx		; Integer Subtraction
mov	[bp+var_8], 5
jns	short loc_18847	; Jump if Not Sign (SF=0)
neg	dx		; Two's Complement Negation

loc_18842:
mov	[bp+var_8], 0FFFBh

loc_18847:		; CODE XREF: sub_187FA+44j
cmp	cx, dx		; Compare Two Operands
jns	short loc_1886B	; Jump if Not Sign (SF=0)
inc	dx		; Increment by 1
mov	[bp+var_4], dx

loc_1884F:
mov	[bp+var_2], 100h
dec	dx		; Decrement by 1
jz	short loc_18884	; Jump if Zero (ZF=1)
mov	bx, dx

loc_18859:
mov	ah, cl

loc_1885B:		; Logical Exclusive OR
xor	al, al
mov	dl, ch

loc_1885F:		; Logical Exclusive OR
xor	dh, dh

loc_18861:
mov	cx, bx
div	cx		; Unsigned Divide

loc_18865:
mov	[bp+var_6], ax
jmp	short loc_18884	; Jump
db 90h

loc_1886B:		; CODE XREF: sub_187FA+4Fj
inc	cx		; Increment by 1
mov	[bp+var_4], cx

loc_1886F:		; Decrement by 1
dec	cx
jz	short loc_18884	; Jump if Zero (ZF=1)

loc_18872:
mov	[bp+var_6], 100h
mov	ah, dl

loc_18879:		; Logical Exclusive OR
xor	al, al
mov	dl, dh
xor	dh, dh		; Logical Exclusive OR

loc_1887F:		; Unsigned Divide
div	cx
mov	[bp+var_2], ax

loc_18884:		; CODE XREF: sub_187FA+5Bj
			; sub_187FA+6Ej
			; sub_187FA+76j
mov	bx, [bp+arg_2]
mov	ax, bx
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	cx, [bp+arg_0]
mov	ax, cx
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
mov	di, ax

loc_188A0:		; Logical AND
and	cx, 3
mov	ax, 1

loc_188A6:		; Shift	Logical	Left
shl	ax, cl

loc_188A8:
mov	ah, al
mov	al, [bp+arg_8]

loc_188AD:
mov	bx, 80h	; ''
mov	cx, 80h	; ''
mov	si, ax

loc_188B5:
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, ah
out	dx, al		; EGA port: sequencer data register

loc_188BF:
mov	ax, si
jmp	short loc_188F3	; Jump
align 2

loc_188C4:		; CODE XREF: sub_187FA:loc_188F9j
add	bx, [bp+var_6]	; Add
cmp	bh, 0		; Compare Two Operands
jz	short loc_188E2	; Jump if Zero (ZF=1)
xor	bh, bh		; Logical Exclusive OR
shl	ah, 1		; Shift	Logical	Left

loc_188D0:		; Compare Two Operands
cmp	ah, 9

loc_188D3:		; Jump if Sign (SF=1)
js	short loc_188D8
mov	ah, 1

loc_188D7:		; Increment by 1
inc	di

loc_188D8:		; CODE XREF: sub_187FA:loc_188D3j
mov	si, ax
mov	dx, SC_DATA

loc_188DD:
mov	al, ah
out	dx, al		; EGA port: sequencer data register

loc_188E0:
mov	ax, si

loc_188E2:		; CODE XREF: sub_187FA+D0j
add	cx, [bp+var_2]	; Add

loc_188E5:		; Compare Two Operands
cmp	ch, 0
jz	short loc_188F3	; Jump if Zero (ZF=1)

loc_188EA:		; Logical Exclusive OR
xor	ch, ch
mov	dx, es

loc_188EE:		; Add
add	dx, [bp+var_8]
mov	es, dx

loc_188F3:		; CODE XREF: sub_187FA+C7j
			; sub_187FA+EEj
mov	[es:di], al

loc_188F6:		; Decrement by 1
dec	[bp+var_4]

loc_188F9:		; Jump if Not Zero (ZF=0)
jnz	short loc_188C4
pop	di
pop	si
pop	ds
pop	es

loc_188FF:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_187FA



; Attributes: bp-based frame

proc sub_18903 far	; CODE XREF: sub_180AB:loc_18363P
			; sub_4F808+1D0P
			; sub_4F808+1FEP
			; sub_4F808+22BP
			; sub_4F808+25AP
			; sub_4F808+300P
			; sub_4F808+32EP
			; sub_4F808+35FP
			; sub_4F808+38CP
			; sub_4F808+428P
			; sub_4F808+458P
			; sub_4F808+489P
			; sub_4F808+531P
			; sub_4F808+55FP
			; sub_4F808+58CP
			; sub_4F808+5BBP
			; sub_4F808+65DP
			; sub_4F808:loc_4FE93P
			; sub_4F808+6B8P
			; sub_4F808+6E5P
			; sub_4F808+784P
			; sub_4F808+7B4P
			; sub_4F808+7E5P
			; sub_4F808+880P
			; sub_4F808+8AEP
			; sub_4F808+8DBP
			; sub_4F808+976P
			; sub_4F808+9A4P
			; sub_4F808+9D5P

var_C= word ptr	-0Ch
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp

loc_18904:
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	es

loc_1890A:
push	ds
push	si
push	di
mov	dx, SC_INDEX

loc_18910:
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	ax, [bp+arg_4]
cmp	ax, [bp+arg_0]	; Compare Two Operands
jns	short loc_18932	; Jump if Not Sign (SF=0)

loc_1891B:
mov	si, ax

loc_1891D:
mov	ax, [bp+arg_0]

loc_18920:
mov	[bp+arg_4], ax
mov	[bp+arg_0], si

loc_18926:
mov	si, [bp+arg_6]
mov	ax, [bp+arg_2]

loc_1892C:
mov	[bp+arg_6], ax

loc_1892F:
mov	[bp+arg_2], si

loc_18932:		; CODE XREF: sub_18903+16j
mov	ax, [bp+arg_0]

loc_18935:
mov	bx, [bp+arg_2]

loc_18938:
mov	cx, [bp+arg_4]
mov	dx, [bp+arg_6]
sub	cx, ax		; Integer Subtraction
sub	dx, bx		; Integer Subtraction

loc_18942:
mov	[bp+var_8], 5
jns	short loc_18950	; Jump if Not Sign (SF=0)
neg	dx		; Two's Complement Negation

loc_1894B:
mov	[bp+var_8], 0FFFBh

loc_18950:		; CODE XREF: sub_18903+44j
cmp	cx, dx		; Compare Two Operands
jns	short loc_18974	; Jump if Not Sign (SF=0)

loc_18954:		; Increment by 1
inc	dx

loc_18955:
mov	[bp+var_4], dx

loc_18958:
mov	[bp+var_2], 100h
dec	dx		; Decrement by 1

loc_1895E:		; Jump if Zero (ZF=1)
jz	short loc_1898D

loc_18960:
mov	bx, dx

loc_18962:
mov	ah, cl
xor	al, al		; Logical Exclusive OR
mov	dl, ch
xor	dh, dh		; Logical Exclusive OR

loc_1896A:
mov	cx, bx
div	cx		; Unsigned Divide

loc_1896E:
mov	[bp+var_6], ax
jmp	short loc_1898D	; Jump
align 2

loc_18974:		; CODE XREF: sub_18903+4Fj
inc	cx		; Increment by 1
mov	[bp+var_4], cx
dec	cx		; Decrement by 1

loc_18979:		; Jump if Zero (ZF=1)
jz	short loc_1898D

loc_1897B:
mov	[bp+var_6], 100h
mov	ah, dl

loc_18982:		; Logical Exclusive OR
xor	al, al
mov	dl, dh
xor	dh, dh		; Logical Exclusive OR
div	cx		; Unsigned Divide
mov	[bp+var_2], ax

loc_1898D:		; CODE XREF: sub_18903:loc_1895Ej
			; sub_18903+6Ej
			; sub_18903:loc_18979j
mov	ax, [bp+arg_8]
mov	si, ax
add	si, [bp+arg_C]	; Add

loc_18995:		; Add
add	ax, [bp+arg_A]

loc_18998:
mov	[bp+var_C], ax
mov	bx, [bp+arg_2]
mov	ax, bx

loc_189A0:		; Shift	Logical	Left
shl	ax, 1

loc_189A2:		; Shift	Logical	Left
shl	ax, 1
add	ax, bx		; Add

loc_189A6:		; Add
add	ax, [g_ptrVideoRamBuffer]

loc_189AA:
mov	es, ax
mov	cx, [bp+arg_0]

loc_189AF:
mov	ax, cx
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
mov	di, ax

loc_189B7:		; Logical AND
and	cx, 3
mov	ax, 1

loc_189BD:		; Shift	Logical	Left
shl	ax, cl

loc_189BF:
mov	ah, al
mov	bx, 80h	; ''

loc_189C4:
mov	cx, 80h	; ''
mov	dx, SC_DATA
mov	al, ah
out	dx, al		; EGA port: sequencer data register
jmp	short loc_189FB	; Jump
align 2

loc_189D0:		; CODE XREF: sub_18903+108j
			; sub_18903+118j
add	bx, [bp+var_6]	; Add

loc_189D3:		; Compare Two Operands
cmp	bh, 0
jz	short loc_189EA	; Jump if Zero (ZF=1)
xor	bh, bh		; Logical Exclusive OR
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands

loc_189DF:		; Jump if Sign (SF=1)
js	short loc_189E4
mov	ah, 1
inc	di		; Increment by 1

loc_189E4:		; CODE XREF: sub_18903:loc_189DFj
mov	dx, SC_DATA
mov	al, ah
out	dx, al		; EGA port: sequencer data register

loc_189EA:		; CODE XREF: sub_18903+D3j
add	cx, [bp+var_2]	; Add
cmp	ch, 0		; Compare Two Operands
jz	short loc_189FB	; Jump if Zero (ZF=1)
xor	ch, ch		; Logical Exclusive OR
mov	dx, es
add	dx, [bp+var_8]	; Add
mov	es, dx

loc_189FB:		; CODE XREF: sub_18903+CAj
			; sub_18903+EDj
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jz	short loc_18A03	; Jump if Zero (ZF=1)

loc_18A00:
mov	[es:di], al

loc_18A03:		; CODE XREF: sub_18903+FBj
cmp	si, [bp+var_C]	; Compare Two Operands
jz	short loc_18A15	; Jump if Zero (ZF=1)
dec	[bp+var_4]	; Decrement by 1
jnz	short loc_189D0	; Jump if Not Zero (ZF=0)
pop	di
pop	si
pop	ds

loc_18A10:
pop	es

loc_18A11:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_18A15:		; CODE XREF: sub_18903+103j
mov	si, [bp+arg_8]
dec	[bp+var_4]	; Decrement by 1
jnz	short loc_189D0	; Jump if Not Zero (ZF=0)
pop	di
pop	si
pop	ds

loc_18A20:
pop	es
mov	sp, bp
pop	bp

locret_18A24:		; Return Far from Procedure
retf
endp sub_18903




proc sub_18A25 far	; CODE XREF: sub_18A5C+21p
			; sub_18FCC+21p
push	es
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, 41D4h

loc_18A2D:		; Compare Two Operands
cmp	dx, 100h
jb	short loc_18A44	; Jump if Below	(CF=1)
mov	si, dx
mov	cx, bx
rep movsb		; Move Byte(s) from String to String
dec	si		; Decrement by 1

loc_18A3A:
mov	cx, bx

loc_18A3C:		; CODE XREF: sub_18A25+1Bj
movsb			; Move Byte(s) from String to String
sub	si, 2		; Integer Subtraction
loop	loc_18A3C	; Loop while CX	!= 0

loc_18A42:
pop	es
assume es:nothing
retf			; Return Far from Procedure

loc_18A44:		; CODE XREF: sub_18A25+Cj
mov	al, dl
mov	cx, bx

loc_18A48:		; CODE XREF: sub_18A25+26j
stosb			; Store	String
inc	al		; Increment by 1
loop	loc_18A48	; Loop while CX	!= 0
dec	al		; Decrement by 1
dec	si		; Decrement by 1

loc_18A50:
mov	cx, bx

loc_18A52:		; CODE XREF: sub_18A25:loc_18A58j
stosb			; Store	String

loc_18A53:		; Integer Subtraction
sub	si, 2
dec	al		; Decrement by 1

loc_18A58:		; Loop while CX	!= 0
loop	loc_18A52
pop	es
retf			; Return Far from Procedure
endp sub_18A25



; Attributes: bp-based frame

proc sub_18A5C far	; CODE XREF: sub_18579+7BP

var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp

loc_18A5D:
mov	bp, sp

loc_18A5F:		; Integer Subtraction
sub	sp, 14h
push	es
push	ds

loc_18A64:
push	si

loc_18A65:
push	di
mov	ax, [bp+arg_A]
shl	ax, 1		; Shift	Logical	Left
mov	[bp+var_14], ax

loc_18A6E:
mov	ax, [bp+arg_E]
xor	ah, ah		; Logical Exclusive OR
mov	[bp+var_12], ax
mov	bx, [bp+arg_A]

loc_18A79:
mov	dx, [bp+arg_8]
push	cs
call	near ptr sub_18A25 ; Call Procedure
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_18A86:
mov	bx, [bp+arg_4]
sub	bx, [bp+arg_0]	; Integer Subtraction
inc	bx		; Increment by 1
mov	cx, 80h	; ''

loc_18A90:
mov	ax, [bp+arg_A]
mul	cx		; Unsigned Multiplication of AL	or AX
mov	cx, [bp+arg_C]
mul	cx		; Unsigned Multiplication of AL	or AX
div	bx		; Unsigned Divide
mov	[bp+var_2], ax
mov	bx, [bp+arg_6]

loc_18AA2:		; Integer Subtraction
sub	bx, [bp+arg_2]
inc	bx		; Increment by 1
mov	cx, 80h	; ''
mov	ax, [bp+arg_A]
mul	cx		; Unsigned Multiplication of AL	or AX
mov	cx, [bp+arg_C]
mul	cx		; Unsigned Multiplication of AL	or AX
div	bx		; Unsigned Divide
mov	[bp+var_4], ax

loc_18AB8:
mov	[bp+var_6], 0
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_C], ax
mov	ax, [bp+arg_6]

loc_18ACA:		; Integer Subtraction
sub	ax, [bp+arg_2]
inc	ax		; Increment by 1

loc_18ACE:
mov	[bp+var_A], ax
mov	ax, [bp+arg_2]

loc_18AD4:
mov	bx, ax
shl	ax, 1		; Shift	Logical	Left

loc_18AD8:		; Shift	Logical	Left
shl	ax, 1
add	ax, bx		; Add

loc_18ADC:		; Add
add	ax, [g_ptrVideoRamBuffer]

loc_18AE0:
mov	es, ax
mov	cx, [bp+arg_0]

loc_18AE5:
mov	bx, cx
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
mov	[bp+var_10], bx
mov	al, 1
and	cx, 3		; Logical AND
jz	short loc_18AF7	; Jump if Zero (ZF=1)
shl	al, cl		; Shift	Logical	Left

loc_18AF7:		; CODE XREF: sub_18A5C+97j
xor	ah, ah		; Logical Exclusive OR
mov	[bp+var_E], ax
mov	bx, 41D4h

loc_18AFF:		; Jump
jmp	short loc_18B10
align 2

loc_18B02:		; CODE XREF: sub_18A5C:loc_18B5Fj
mov	al, [byte ptr bp+var_E]

loc_18B05:		; Shift	Logical	Left
shl	al, 1
cmp	al, 9		; Compare Two Operands
js	short loc_18B10	; Jump if Sign (SF=1)

loc_18B0B:
mov	al, 1

loc_18B0D:		; Increment by 1
inc	[bp+var_10]

loc_18B10:		; CODE XREF: sub_18A5C:loc_18AFFj
			; sub_18A5C+ADj
mov	[byte ptr bp+var_E], al
mov	di, [bp+var_10]
mov	dx, SC_DATA
out	dx, al		; EGA port: sequencer data register
mov	ax, [bp+var_6]

loc_18B1D:		; Add
add	ax, [bp+var_2]

loc_18B20:
mov	[bp+var_6], ax
mov	[bp+var_8], ax

loc_18B26:
mov	cx, [bp+var_A]

loc_18B29:		; CODE XREF: sub_18A5C+FEj
mov	dx, [bp+var_8]

loc_18B2C:		; Add
add	dx, [bp+var_4]
mov	[bp+var_8], dx

loc_18B32:
mov	si, [bp+var_12]

loc_18B35:		; Increment by 1
inc	[byte ptr bp+var_12]
add	si, 4214h	; Add
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
add	dx, ax		; Add
mov	al, dh
and	ax, 3Fh		; Logical AND

loc_18B48:		; CODE XREF: sub_18A5C+F4j
cmp	ax, [bp+var_14]	; Compare Two Operands
js	short loc_18B52	; Jump if Sign (SF=1)
sub	ax, [bp+var_14]	; Integer Subtraction
jmp	short loc_18B48	; Jump

loc_18B52:		; CODE XREF: sub_18A5C+EFj
add	ax, bx		; Add
mov	si, ax
movsb			; Move Byte(s) from String to String
add	di, 4Fh	; 'O'   ; Add
loop	loc_18B29	; Loop while CX	!= 0
dec	[bp+var_C]	; Decrement by 1

loc_18B5F:		; Jump if Not Zero (ZF=0)
jnz	short loc_18B02
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp

locret_18B68:		; Return Far from Procedure
retf
endp sub_18A5C




proc sub_18B69 far	; CODE XREF: sub_190B6+Ep
			; sub_190B6+CDp
			; sub_190B6:loc_191C4p
			; sub_190B6:loc_19217p
			; sub_234B7+32P
push	bx
push	cx
push	dx
cmp	ax, 0		; Compare Two Operands
jz	short loc_18B9C	; Jump if Zero (ZF=1)

loc_18B71:		; CODE XREF: sub_18B69+36j
mov	cx, 8

loc_18B74:		; CODE XREF: sub_18B69+2Dj
mov	dx, ax
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right
xor	ax, bx		; Logical Exclusive OR
shr	bx, 1		; Shift	Logical	Right
xor	ax, bx		; Logical Exclusive OR

loc_18B80:		; Shift	Logical	Right
shr	bx, 1
shr	bx, 1		; Shift	Logical	Right
xor	ax, bx		; Logical Exclusive OR
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right

loc_18B8A:		; Logical Exclusive OR
xor	ax, bx
shr	bx, 1		; Shift	Logical	Right
xor	al, bh		; Logical Exclusive OR
shr	ax, 1		; Shift	Logical	Right
rcr	dx, 1		; Rotate Through Carry Right
mov	ax, dx
loop	loc_18B74	; Loop while CX	!= 0
pop	dx
pop	cx
pop	bx
retf			; Return Far from Procedure

loc_18B9C:		; CODE XREF: sub_18B69+6j
mov	ax, 35C8h
jmp	short loc_18B71	; Jump
retf			; Return Far from Procedure
endp sub_18B69



; Attributes: bp-based frame

proc sub_18BA2 far	; CODE XREF: sub_18579+45P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	ds
push	di
push	si
push	es
mov	ax, [bp+arg_4]
mov	bx, [bp+arg_0]
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right

loc_18BB3:		; Shift	Logical	Right
shr	bx, 1
shr	bx, 1		; Shift	Logical	Right
sub	ax, bx		; Integer Subtraction
inc	ax		; Increment by 1
mov	[cs:word_186AC], ax
mov	[cs:word_186B0], ax
mov	[cs:word_186B4], ax
mov	[cs:word_186B8], ax
mov	bx, [bp+arg_0]
mov	ax, bx

loc_18BCF:		; Shift	Logical	Right
shr	ax, 1
shr	ax, 1		; Shift	Logical	Right
mov	[cs:word_186AA], ax
mov	[cs:word_186AE], ax
mov	[cs:word_186B2], ax
mov	[cs:word_186B6], ax

loc_18BE3:		; Logical AND
and	bx, 3
cmp	bx, 0		; Compare Two Operands

loc_18BE9:		; Jump if Zero (ZF=1)
jz	short loc_18C13
cmp	bx, 1		; Compare Two Operands
jz	short loc_18C09	; Jump if Zero (ZF=1)

loc_18BF0:		; Compare Two Operands
cmp	bx, 2
jz	short loc_18BFF	; Jump if Zero (ZF=1)
inc	[cs:word_186B2]	; Increment by 1
dec	[cs:word_186B4]	; Decrement by 1

loc_18BFF:		; CODE XREF: sub_18BA2+51j
inc	[cs:word_186AE]	; Increment by 1

loc_18C04:		; Decrement by 1
dec	[cs:word_186B0]

loc_18C09:		; CODE XREF: sub_18BA2+4Cj
inc	[cs:word_186AA]	; Increment by 1

loc_18C0E:		; Decrement by 1
dec	[cs:word_186AC]

loc_18C13:		; CODE XREF: sub_18BA2:loc_18BE9j
mov	bx, [bp+arg_4]
and	bx, 3		; Logical AND
cmp	bx, 3		; Compare Two Operands

loc_18C1C:		; Jump if Zero (ZF=1)
jz	short loc_18C37

loc_18C1E:		; Compare Two Operands
cmp	bx, 2

loc_18C21:		; Jump if Zero (ZF=1)
jz	short loc_18C32
cmp	bx, 1		; Compare Two Operands

loc_18C26:		; Jump if Zero (ZF=1)
jz	short loc_18C2D

loc_18C28:		; Decrement by 1
dec	[cs:word_186B0]

loc_18C2D:		; CODE XREF: sub_18BA2:loc_18C26j
dec	[cs:word_186B4]	; Decrement by 1

loc_18C32:		; CODE XREF: sub_18BA2:loc_18C21j
dec	[cs:word_186B8]	; Decrement by 1

loc_18C37:		; CODE XREF: sub_18BA2:loc_18C1Cj
mov	ax, [bp+arg_2]

loc_18C3A:
mov	dx, ax

loc_18C3C:
mov	cx, [bp+arg_6]
inc	cx		; Increment by 1
sub	cx, ax		; Integer Subtraction

loc_18C42:		; Shift	Logical	Left
shl	dx, 1
shl	dx, 1		; Shift	Logical	Left

loc_18C46:		; Add
add	ax, dx
add	ax, [g_ptrVideoRamBuffer] ; Add

loc_18C4C:
mov	es, ax

loc_18C4E:
mov	dx, [bp+arg_6]
mov	bx, [bp+arg_2]
sub	dx, bx		; Integer Subtraction
inc	dx		; Increment by 1
mov	[cs:word_186A8], dx
mov	ax, [bp+arg_8]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left

loc_18C65:		; Shift	Logical	Left
shl	ax, 1

loc_18C67:		; Add
add	ax, [idk_FontsLbx1_6144B]
mov	ds, ax
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 1
out	dx, al		; EGA port: sequencer data register
mov	dx, GC_INDEX
mov	al, 4

loc_18C7C:		; EGA: graph 1 and 2 addr reg:
out	dx, al		; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, 0
out	dx, al		; EGA port: graphics controller	data register
mov	di, [cs:word_186AA]
mov	si, di
mov	dx, [cs:word_186AC]
cmp	dx, 0		; Compare Two Operands
jbe	short loc_18CB7	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_18C92:		; Logical Exclusive OR
xor	bh, bh
mov	ax, [cs:word_186A8]

loc_18C98:
mov	[cs:word_186BA], ax

loc_18C9C:		; CODE XREF: sub_18BA2+113j
mov	cx, dx

loc_18C9E:		; CODE XREF: sub_18BA2+103j
mov	bl, [es:si]
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_18C9E	; Loop while CX	!= 0
mov	ax, 50h	; 'P'

loc_18CAA:		; Integer Subtraction
sub	ax, dx
add	si, ax		; Add
add	di, ax		; Add
dec	[cs:word_186BA]	; Decrement by 1
jnz	short loc_18C9C	; Jump if Not Zero (ZF=0)

loc_18CB7:		; CODE XREF: sub_18BA2+EEj
mov	ax, [cs:word_186B0]
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1

loc_18CC2:
mov	al, 2
out	dx, al		; EGA port: sequencer data register
mov	dx, GC_INDEX

loc_18CC8:
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, 1
out	dx, al		; EGA port: graphics controller	data register

loc_18CCF:
mov	di, [cs:word_186AE]
mov	si, di

loc_18CD6:
mov	dx, [cs:word_186B0]

loc_18CDB:		; Compare Two Operands
cmp	dx, 0
jbe	short loc_18D05	; Jump if Below	or Equal (CF=1 | ZF=1)
xor	bh, bh		; Logical Exclusive OR
mov	ax, [cs:word_186A8]
mov	[cs:word_186BA], ax

loc_18CEA:		; CODE XREF: sub_18BA2+161j
mov	cx, dx

loc_18CEC:		; CODE XREF: sub_18BA2+151j
mov	bl, [es:si]

loc_18CEF:
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_18CEC	; Loop while CX	!= 0
mov	ax, 50h	; 'P'
sub	ax, dx		; Integer Subtraction
add	si, ax		; Add
add	di, ax		; Add

loc_18CFE:		; Decrement by 1
dec	[cs:word_186BA]
jnz	short loc_18CEA	; Jump if Not Zero (ZF=0)

loc_18D05:		; CODE XREF: sub_18BA2+13Cj
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 4
out	dx, al		; EGA port: sequencer data register
mov	dx, GC_INDEX
mov	al, 4

loc_18D14:		; EGA: graph 1 and 2 addr reg:
out	dx, al		; read map select.
			; Data bits 0-2	select map # for read mode 00.

loc_18D15:		; Increment by 1
inc	dx
mov	al, 2
out	dx, al		; EGA port: graphics controller	data register

loc_18D19:
mov	di, [cs:word_186B2]

loc_18D1E:
mov	si, di

loc_18D20:
mov	dx, [cs:word_186B4]
cmp	dx, 0		; Compare Two Operands

loc_18D28:		; Jump if Below	or Equal (CF=1 | ZF=1)
jbe	short loc_18D4F
xor	bh, bh		; Logical Exclusive OR
mov	ax, [cs:word_186A8]
mov	[cs:word_186BA], ax

loc_18D34:		; CODE XREF: sub_18BA2+1ABj
mov	cx, dx

loc_18D36:		; CODE XREF: sub_18BA2+19Bj
mov	bl, [es:si]
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_18D36	; Loop while CX	!= 0
mov	ax, 50h	; 'P'
sub	ax, dx		; Integer Subtraction
add	si, ax		; Add
add	di, ax		; Add
dec	[cs:word_186BA]	; Decrement by 1
jnz	short loc_18D34	; Jump if Not Zero (ZF=0)

loc_18D4F:		; CODE XREF: sub_18BA2:loc_18D28j
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 8
out	dx, al		; EGA port: sequencer data register
mov	dx, GC_INDEX
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_18D60:
mov	al, 3

loc_18D62:		; EGA port: graphics controller	data register
out	dx, al

loc_18D63:
mov	di, [cs:word_186B6]

loc_18D68:
mov	si, di
mov	dx, [cs:word_186B8]
cmp	dx, 0		; Compare Two Operands
jbe	short loc_18D99	; Jump if Below	or Equal (CF=1 | ZF=1)
xor	bh, bh		; Logical Exclusive OR
mov	ax, [cs:word_186A8]
mov	[cs:word_186BA], ax

loc_18D7E:		; CODE XREF: sub_18BA2:loc_18D97j
mov	cx, dx

loc_18D80:		; CODE XREF: sub_18BA2+1E5j
mov	bl, [es:si]
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_18D80	; Loop while CX	!= 0
mov	ax, 50h	; 'P'

loc_18D8C:		; Integer Subtraction
sub	ax, dx
add	si, ax		; Add

loc_18D90:		; Add
add	di, ax
dec	[cs:word_186BA]	; Decrement by 1

loc_18D97:		; Jump if Not Zero (ZF=0)
jnz	short loc_18D7E

loc_18D99:		; CODE XREF: sub_18BA2+1D0j
pop	es
pop	si
pop	di
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_18BA2



; Attributes: bp-based frame

proc idk_VidPalFnt_s18D9F far
			; CODE XREF: sub_18579+ABP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	ds
push	di
push	si
push	es
push	ds


mov	dx, [bp+arg_8]
mov	si, 0
mov	ax, [idk_FontsLbx1_e_96]
mov	es, ax
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	di, 0
mov	cx, 256
xor	ah, ah		; Logical Exclusive OR

loc_18DBF:		; CODE XREF: idk_VidPalFnt_s18D9F+40j
xor	bx, bx		; Logical Exclusive OR
lodsb			; Load String


add	bx, ax		; Add
shr	al, 1		; Shift	Logical	Right
add	bx, ax		; Add
lodsb			; Load String


add	bx, ax		; Add
shr	al, 1		; Shift	Logical	Right
add	bx, ax		; Add
lodsb			; Load String


add	bx, ax		; Add
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
add	bx, dx		; Add
mov	al, bl
stosb			; Store	String


loop	loc_18DBF	; Loop while CX	!= 0
pop	ds
mov	ax, [bp+arg_4]
mov	bx, [bp+arg_0]
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
sub	ax, bx		; Integer Subtraction
inc	ax		; Increment by 1
mov	[cs:word_186AC], ax
mov	[cs:word_186B0], ax
mov	[cs:word_186B4], ax
mov	[cs:word_186B8], ax
mov	bx, [bp+arg_0]
mov	ax, bx
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
mov	[cs:word_186AA], ax
mov	[cs:word_186AE], ax
mov	[cs:word_186B2], ax
mov	[cs:word_186B6], ax
and	bx, 11b		; Logical AND
cmp	bx, 0		; Compare Two Operands
jz	short loc_18E4C	; Jump if Zero (ZF=1)

loc_18E24:		; Compare Two Operands
cmp	bx, 1
jz	short loc_18E42	; Jump if Zero (ZF=1)
cmp	bx, 2		; Compare Two Operands
jz	short loc_18E38	; Jump if Zero (ZF=1)

loc_18E2E:		; Increment by 1
inc	[cs:word_186B2]
dec	[cs:word_186B4]	; Decrement by 1

loc_18E38:		; CODE XREF: idk_VidPalFnt_s18D9F+8Dj
inc	[cs:word_186AE]	; Increment by 1
dec	[cs:word_186B0]	; Decrement by 1

loc_18E42:		; CODE XREF: idk_VidPalFnt_s18D9F+88j
inc	[cs:word_186AA]	; Increment by 1
dec	[cs:word_186AC]	; Decrement by 1

loc_18E4C:		; CODE XREF: idk_VidPalFnt_s18D9F+83j
mov	bx, [bp+arg_4]
and	bx, 3		; Logical AND
cmp	bx, 3		; Compare Two Operands
jz	short loc_18E70	; Jump if Zero (ZF=1)
cmp	bx, 2		; Compare Two Operands
jz	short loc_18E6B	; Jump if Zero (ZF=1)
cmp	bx, 1		; Compare Two Operands
jz	short loc_18E66	; Jump if Zero (ZF=1)
dec	[cs:word_186B0]	; Decrement by 1

loc_18E66:		; CODE XREF: idk_VidPalFnt_s18D9F+C0j
dec	[cs:word_186B4]	; Decrement by 1

loc_18E6B:		; CODE XREF: idk_VidPalFnt_s18D9F+BBj
dec	[cs:word_186B8]	; Decrement by 1

loc_18E70:		; CODE XREF: idk_VidPalFnt_s18D9F+B6j
mov	ax, [bp+arg_2]
mov	dx, ax
mov	cx, [bp+arg_6]
inc	cx		; Increment by 1
sub	cx, ax		; Integer Subtraction
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	dx, [bp+arg_6]
mov	bx, [bp+arg_2]
sub	dx, bx		; Integer Subtraction
inc	dx		; Increment by 1
mov	[cs:word_186A8], dx
mov	ax, [idk_FontsLbx1_e_96]
mov	ds, ax
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3


inc	dx		; Increment by 1
mov	al, 1
out	dx, al		; EGA port: sequencer data register


mov	dx, GC_INDEX
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.


inc	dx		; Increment by 1
mov	al, 0
out	dx, al		; EGA port: graphics controller	data register


mov	di, [cs:word_186AA]
mov	si, di
mov	dx, [cs:word_186AC]
cmp	dx, 0		; Compare Two Operands
jbe	short loc_18EE4	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_18EBF:		; Logical Exclusive OR
xor	bh, bh
mov	ax, [cs:word_186A8]
mov	[cs:word_186BA], ax

loc_18EC9:		; CODE XREF: idk_VidPalFnt_s18D9F+143j
mov	cx, dx

loc_18ECB:		; CODE XREF: idk_VidPalFnt_s18D9F+133j
mov	bl, [es:si]
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_18ECB	; Loop while CX	!= 0
mov	ax, 50h	; 'P'
sub	ax, dx		; Integer Subtraction
add	si, ax		; Add
add	di, ax		; Add
dec	[cs:word_186BA]	; Decrement by 1
jnz	short loc_18EC9	; Jump if Not Zero (ZF=0)

loc_18EE4:		; CODE XREF: idk_VidPalFnt_s18D9F+11Ej
mov	ax, [cs:word_186B0]
mov	dx, SC_INDEX

loc_18EEB:
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 2
out	dx, al		; EGA port: sequencer data register
mov	dx, GC_INDEX
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, 1
out	dx, al		; EGA port: graphics controller	data register
mov	di, [cs:word_186AE]
mov	si, di
mov	dx, [cs:word_186B0]
cmp	dx, 0		; Compare Two Operands
jbe	short loc_18F32	; Jump if Below	or Equal (CF=1 | ZF=1)
xor	bh, bh		; Logical Exclusive OR
mov	ax, [cs:word_186A8]
mov	[cs:word_186BA], ax

loc_18F17:		; CODE XREF: idk_VidPalFnt_s18D9F+191j
mov	cx, dx

loc_18F19:		; CODE XREF: idk_VidPalFnt_s18D9F+181j
mov	bl, [es:si]
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_18F19	; Loop while CX	!= 0
mov	ax, 50h	; 'P'
sub	ax, dx		; Integer Subtraction
add	si, ax		; Add
add	di, ax		; Add
dec	[cs:word_186BA]	; Decrement by 1
jnz	short loc_18F17	; Jump if Not Zero (ZF=0)

loc_18F32:		; CODE XREF: idk_VidPalFnt_s18D9F+16Cj
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 4
out	dx, al		; EGA port: sequencer data register
mov	dx, GC_INDEX
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, 2
out	dx, al		; EGA port: graphics controller	data register
mov	di, [cs:word_186B2]
mov	si, di
mov	dx, [cs:word_186B4]
cmp	dx, 0		; Compare Two Operands
jbe	short loc_18F7C	; Jump if Below	or Equal (CF=1 | ZF=1)
xor	bh, bh		; Logical Exclusive OR
mov	ax, [cs:word_186A8]
mov	[cs:word_186BA], ax

loc_18F61:		; CODE XREF: idk_VidPalFnt_s18D9F+1DBj
mov	cx, dx

loc_18F63:		; CODE XREF: idk_VidPalFnt_s18D9F+1CBj
mov	bl, [es:si]
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_18F63	; Loop while CX	!= 0
mov	ax, 50h	; 'P'
sub	ax, dx		; Integer Subtraction
add	si, ax		; Add
add	di, ax		; Add
dec	[cs:word_186BA]	; Decrement by 1
jnz	short loc_18F61	; Jump if Not Zero (ZF=0)

loc_18F7C:		; CODE XREF: idk_VidPalFnt_s18D9F+1B6j
mov	dx, SC_INDEX
mov	al, MAP_MASK
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3


inc	dx		; dx is	now 0x3C5 SC_DATA
mov	al, 1000b
out	dx, al		; EGA port: sequencer data register


mov	dx, GC_INDEX
mov	al, 4		; #define VGA_GFX_PLANE_READ	  0x04
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.


inc	dx		; dx is	now 0x3CF GC_DATA
mov	al, 11b
out	dx, al		; EGA port: graphics controller	data register


mov	di, [cs:word_186B6]
mov	si, di
mov	dx, [cs:word_186B8]
cmp	dx, 0		; Compare Two Operands
jbe	short loc_18FC6	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_18FA1:		; Logical Exclusive OR
xor	bh, bh
mov	ax, [cs:word_186A8]
mov	[cs:word_186BA], ax

loc_18FAB:		; CODE XREF: idk_VidPalFnt_s18D9F+225j
mov	cx, dx

loc_18FAD:		; CODE XREF: idk_VidPalFnt_s18D9F+215j
mov	bl, [es:si]
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_18FAD	; Loop while CX	!= 0
mov	ax, 50h	; 'P'
sub	ax, dx		; Integer Subtraction
add	si, ax		; Add
add	di, ax		; Add
dec	[cs:word_186BA]	; Decrement by 1
jnz	short loc_18FAB	; Jump if Not Zero (ZF=0)

loc_18FC6:		; CODE XREF: idk_VidPalFnt_s18D9F+200j
pop	es
pop	si
pop	di
pop	ds
pop	bp
retf			; Return Far from Procedure
endp idk_VidPalFnt_s18D9F



; Attributes: bp-based frame

proc sub_18FCC far	; CODE XREF: sub_18579+60P

var_16=	word ptr -16h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_6= word ptr	-6
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp

loc_18FCF:		; Integer Subtraction
sub	sp, 16h

loc_18FD2:
push	es

loc_18FD3:
push	ds
push	si
push	di

loc_18FD6:
mov	ax, [bp+arg_A]
shl	ax, 1		; Shift	Logical	Left

loc_18FDB:
mov	[bp+var_16], ax
mov	ax, [bp+arg_E]
xor	ah, ah		; Logical Exclusive OR
mov	[bp+var_12], ax
mov	bx, [bp+arg_A]
mov	dx, [bp+arg_8]
push	cs
call	near ptr sub_18A25 ; Call Procedure
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	bx, [bp+arg_4]

loc_18FF9:		; Integer Subtraction
sub	bx, [bp+arg_0]

loc_18FFC:		; Increment by 1
inc	bx

loc_18FFD:
mov	cx, 100h

loc_19000:
mov	ax, [bp+arg_A]
mul	cx		; Unsigned Multiplication of AL	or AX

loc_19005:
mov	cx, [bp+arg_C]
mul	cx		; Unsigned Multiplication of AL	or AX
div	bx		; Unsigned Divide
mov	[bp+var_2], ax
mov	[bp+var_6], 0
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_C], ax

loc_1901E:
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_2]	; Integer Subtraction

loc_19024:		; Increment by 1
inc	ax
mov	[bp+var_A], ax
mov	ax, [bp+arg_2]
mov	bx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	cx, [bp+arg_0]
mov	bx, cx
shr	bx, 1		; Shift	Logical	Right

loc_19040:		; Shift	Logical	Right
shr	bx, 1
mov	[bp+var_10], bx
mov	al, 1

loc_19047:		; Logical AND
and	cx, 3
jz	short loc_1904E	; Jump if Zero (ZF=1)

loc_1904C:		; Shift	Logical	Left
shl	al, cl

loc_1904E:		; CODE XREF: sub_18FCC+7Ej
xor	ah, ah		; Logical Exclusive OR

loc_19050:
mov	[bp+var_E], ax
mov	bx, 41D4h

loc_19056:		; Jump
jmp	short loc_19067
db 90h

loc_19059:		; CODE XREF: sub_18FCC+E0j
mov	al, [byte ptr bp+var_E]
shl	al, 1		; Shift	Logical	Left
cmp	al, 9		; Compare Two Operands

loc_19060:		; Jump if Sign (SF=1)
js	short loc_19067
mov	al, 1
inc	[bp+var_10]	; Increment by 1

loc_19067:		; CODE XREF: sub_18FCC:loc_19056j
			; sub_18FCC:loc_19060j
mov	[byte ptr bp+var_E], al
mov	di, [bp+var_10]

loc_1906D:
mov	dx, SC_DATA
out	dx, al		; EGA port: sequencer data register
mov	ax, [bp+var_6]

loc_19074:		; Add
add	ax, [bp+var_2]

loc_19077:
mov	[bp+var_6], ax

loc_1907A:
mov	dx, ax
mov	cx, [bp+var_A]

loc_1907F:		; CODE XREF: sub_18FCC+DBj
mov	si, [bp+var_12]
inc	[byte ptr bp+var_12] ; Increment by 1
add	si, 4214h	; Add
lodsb			; Load String

loc_1908A:		; Logical Exclusive OR
xor	ah, ah
shl	ax, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	al, ah
and	ax, 3Fh		; Logical AND

loc_19095:		; CODE XREF: sub_18FCC+D1j
cmp	ax, [bp+var_16]	; Compare Two Operands
js	short loc_1909F	; Jump if Sign (SF=1)

loc_1909A:		; Integer Subtraction
sub	ax, [bp+var_16]
jmp	short loc_19095	; Jump

loc_1909F:		; CODE XREF: sub_18FCC+CCj
add	ax, bx		; Add
mov	si, ax
movsb			; Move Byte(s) from String to String

loc_190A4:		; Add
add	di, 4Fh	; 'O'
loop	loc_1907F	; Loop while CX	!= 0
dec	[bp+var_C]	; Decrement by 1
jnz	short loc_19059	; Jump if Not Zero (ZF=0)
pop	di

loc_190AF:
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_18FCC



; Attributes: bp-based frame

proc sub_190B6 far	; CODE XREF: sub_18579+96P

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_6= word ptr	-6
var_4= word ptr	-4
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= byte ptr	 0Eh
arg_A= byte ptr	 10h
arg_E= word ptr	 14h

push	bp
mov	bp, sp

loc_190B9:		; Integer Subtraction
sub	sp, 0Ch

loc_190BC:
push	ds
push	di
push	si
push	es
mov	ax, [bp+arg_E]
push	cs
call	near ptr sub_18B69 ; Call Procedure

loc_190C7:
mov	[bp+var_6], ax

loc_190CA:
mov	dx, SC_INDEX

loc_190CD:
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_190D0:
mov	ax, [bp+arg_4]
mov	bx, [bp+arg_0]
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right

loc_190DA:		; Shift	Logical	Right
shr	bx, 1
shr	bx, 1		; Shift	Logical	Right
cmp	ax, bx		; Compare Two Operands
jnz	short loc_1912E	; Jump if Not Zero (ZF=0)
mov	di, ax
mov	si, 41C8h
mov	ax, [bp+arg_0]

loc_190EA:		; Logical AND
and	ax, 3
add	si, ax		; Add

loc_190EF:		; Load String
lodsb
mov	bl, al
mov	si, 41CCh
mov	ax, [bp+arg_4]
and	ax, 3		; Logical AND
add	si, ax		; Add
lodsb			; Load String
and	bl, al		; Logical AND

loc_19100:
mov	dx, SC_DATA
mov	al, bl
out	dx, al		; EGA port: sequencer data register
mov	ax, [bp+arg_2]
mov	dx, ax
mov	cx, [bp+arg_6]
inc	cx		; Increment by 1
sub	cx, ax		; Integer Subtraction
shl	dx, 1		; Shift	Logical	Left

loc_19113:		; Shift	Logical	Left
shl	dx, 1
add	ax, dx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add

loc_1911B:
mov	es, ax
mov	al, [bp+arg_8]

loc_19120:		; CODE XREF: sub_190B6+6Ej
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_19120	; Loop while CX	!= 0
pop	es
pop	si
pop	di
pop	ds
mov	sp, bp

loc_1912C:
pop	bp
retf			; Return Far from Procedure

loc_1912E:		; CODE XREF: sub_190B6+2Aj
mov	dx, [bp+arg_6]
mov	bx, [bp+arg_2]
sub	dx, bx		; Integer Subtraction
inc	dx		; Increment by 1
mov	[bp+var_4], dx
mov	ax, bx
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax

loc_19148:
mov	di, [bp+arg_0]
mov	bx, di
shr	di, 1		; Shift	Logical	Right
shr	di, 1		; Shift	Logical	Right
and	bx, 3		; Logical AND
add	bx, 41C8h	; Add
mov	ah, [bx]
mov	bl, [byte ptr bp+var_6]
xor	bh, bh		; Logical Exclusive OR

loc_1915F:
mov	cx, [bp+var_4]
mov	dx, SC_DATA

loc_19165:		; CODE XREF: sub_190B6+C7j
mov	al, ah
out	dx, al		; EGA port: sequencer data register

loc_19168:
mov	al, [bp+arg_8]
stosb			; Store	String
dec	di		; Decrement by 1

loc_1916D:
mov	al, [bx+4214h]
and	al, ah		; Logical AND
out	dx, al		; EGA port: sequencer data register

loc_19174:
mov	al, [bp+arg_A]
stosb			; Store	String

loc_19178:		; Add
add	di, 4Fh	; 'O'
inc	bl		; Increment by 1
loop	loc_19165	; Loop while CX	!= 0

loc_1917F:
mov	ax, [bp+var_6]
push	cs
call	near ptr sub_18B69 ; Call Procedure
mov	[bp+var_6], ax
mov	di, [bp+arg_4]
mov	bx, di
shr	di, 1		; Shift	Logical	Right
shr	di, 1		; Shift	Logical	Right

loc_19192:		; Logical AND
and	bx, 3

loc_19195:		; Add
add	bx, 41CCh
mov	ah, [bx]
mov	bl, [byte ptr bp+var_6]
xor	bh, bh		; Logical Exclusive OR
mov	cx, [bp+var_4]
mov	dx, SC_DATA

loc_191A6:		; CODE XREF: sub_190B6+108j
mov	al, ah

loc_191A8:		; EGA port: sequencer data register
out	dx, al
mov	al, [bp+arg_8]
stosb			; Store	String
dec	di		; Decrement by 1

loc_191AE:
mov	al, [bx+4214h]
and	al, ah		; Logical AND

loc_191B4:		; EGA port: sequencer data register
out	dx, al
mov	al, [bp+arg_A]
stosb			; Store	String

loc_191B9:		; Add
add	di, 4Fh	; 'O'

loc_191BC:		; Increment by 1
inc	bl
loop	loc_191A6	; Loop while CX	!= 0

loc_191C0:
mov	ax, [bp+var_6]
push	cs

loc_191C4:		; Call Procedure
call	near ptr sub_18B69

loc_191C7:
mov	[bp+var_6], ax

loc_191CA:
mov	bx, [bp+arg_4]

loc_191CD:		; Shift	Logical	Right
shr	bx, 1

loc_191CF:		; Shift	Logical	Right
shr	bx, 1

loc_191D1:
mov	ax, [bp+arg_0]
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
sub	bx, ax		; Integer Subtraction
dec	bx		; Decrement by 1
jz	short loc_19222	; Jump if Zero (ZF=1)
mov	di, ax
inc	di		; Increment by 1

loc_191E0:
mov	dx, 50h	; 'P'
sub	dx, bx		; Integer Subtraction

loc_191E5:
mov	[bp+var_A], dx
mov	[bp+var_C], bx

loc_191EB:
mov	bl, [byte ptr bp+var_6]

loc_191EE:		; Logical Exclusive OR
xor	bh, bh
mov	si, [bp+var_4]
mov	dx, SC_DATA

loc_191F6:		; CODE XREF: sub_190B6:loc_19220j
mov	cx, [bp+var_C]

loc_191F9:		; CODE XREF: sub_190B6:loc_1920Ej
mov	al, 0Fh
out	dx, al		; EGA port: sequencer data register
mov	al, [bp+arg_8]
stosb			; Store	String

loc_19200:		; Decrement by 1
dec	di

loc_19201:
mov	al, [bx+4214h]

loc_19205:		; Logical AND
and	al, 0Fh
out	dx, al		; EGA port: sequencer data register

loc_19208:
mov	al, [bp+arg_A]
stosb			; Store	String

loc_1920C:		; Increment by 1
inc	bl

loc_1920E:		; Loop while CX	!= 0
loop	loc_191F9

loc_19210:		; Add
add	di, [bp+var_A]

loc_19213:
mov	ax, [bp+var_6]

loc_19216:
push	cs

loc_19217:		; Call Procedure
call	near ptr sub_18B69

loc_1921A:
mov	[bp+var_6], ax

loc_1921D:
mov	bl, al

loc_1921F:		; Decrement by 1
dec	si

loc_19220:		; Jump if Not Zero (ZF=0)
jnz	short loc_191F6

loc_19222:		; CODE XREF: sub_190B6+125j
pop	es

loc_19223:
pop	si

loc_19224:
pop	di

loc_19225:
pop	ds

loc_19226:
mov	sp, bp

loc_19228:
pop	bp

locret_19229:		; Return Far from Procedure
retf
endp sub_190B6

ends seg016


; Segment type:	Pure code
segment	seg017 byte public 'CODE' use16
assume cs:seg017
;org 0Ah
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_1922A far	; CODE XREF: sub_2BA41+ED1P
			; sub_2BA41+105DP
			; sub_3D378+56P
			; sub_3D378+411P
			; sub_3EDD1+79P
			; sub_3F6BF+58P
			; sub_3FA0C+59P
			; sub_40037+BCP
			; sub_40037:loc_4029DP
			; sub_40037+330P
			; sub_4276F+12FP
			; sub_4276F+27BP
			; sub_4276F+504P
			; sub_4276F+78FP
			; sub_4E031+62CP
			; idk_HoF_s565F2+83P
			; idk_HoF_s565F2+123P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_1922B:
mov	bp, sp

loc_1922D:		; int
push	[bp+arg_6]
push	[bp+arg_4]	; int
push	[bp+arg_2]	; int
push	[bp+arg_0]	; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 8		; Add
mov	ax, 1
push	ax
mov	ax, 12h
push	ax
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1922A



; Attributes: bp-based frame

proc sub_19257 far	; CODE XREF: sub_2BA41+E97P
			; sub_2BA41+1023P
			; sub_3DF8C+E8P
			; sub_3DF8C+126P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp

loc_1925A:		; int
push	[bp+arg_6]

loc_1925D:		; int
push	[bp+arg_4]

loc_19260:		; int
push	[bp+arg_2]

loc_19263:		; int
push	[bp+arg_0]

loc_19266:		; Call Procedure
call	idk_PalFnt_s1AB64

loc_1926B:		; Add
add	sp, 8

loc_1926E:
mov	ax, 2
push	ax

loc_19272:
mov	ax, 12h
push	ax

loc_19276:
push	[bufFontsLbxEntry0]

loc_1927A:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_1927F:		; Add
add	sp, 6
pop	bp
retf			; Return Far from Procedure
endp sub_19257



; Attributes: bp-based frame

proc sub_19284 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_19285:
mov	bp, sp

loc_19287:		; int
push	[bp+arg_6]

loc_1928A:		; int
push	[bp+arg_4]
push	[bp+arg_2]	; int

loc_19290:		; int
push	[bp+arg_0]
call	idk_PalFnt_s1AB64 ; Call Procedure

loc_19298:		; Add
add	sp, 8

loc_1929B:
mov	ax, 3
push	ax

loc_1929F:
mov	ax, 12h
push	ax

loc_192A3:
push	[bufFontsLbxEntry0]

loc_192A7:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_192AC:		; Add
add	sp, 6

loc_192AF:
pop	bp
retf			; Return Far from Procedure
endp sub_19284



; Attributes: bp-based frame

proc sub_192B1 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_192B2:
mov	bp, sp

loc_192B4:		; int
push	[bp+arg_6]

loc_192B7:		; int
push	[bp+arg_4]

loc_192BA:		; int
push	[bp+arg_2]

loc_192BD:		; int
push	[bp+arg_0]
call	idk_PalFnt_s1AB64 ; Call Procedure

loc_192C5:		; Add
add	sp, 8

loc_192C8:
mov	ax, 4

loc_192CB:
push	ax

loc_192CC:
mov	ax, 12h
push	ax

loc_192D0:
push	[bufFontsLbxEntry0]

loc_192D4:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_192D9:		; Add
add	sp, 6
pop	bp
retf			; Return Far from Procedure
endp sub_192B1



; Attributes: bp-based frame

proc sub_192DE far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_192DF:
mov	bp, sp
push	[bp+arg_6]	; int
push	[bp+arg_4]	; int

loc_192E7:		; int
push	[bp+arg_2]
push	[bp+arg_0]	; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 8		; Add

loc_192F5:
mov	ax, 5
push	ax

loc_192F9:
mov	ax, 12h
push	ax

loc_192FD:
push	[bufFontsLbxEntry0]

loc_19301:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_19306:		; Add
add	sp, 6
pop	bp
retf			; Return Far from Procedure
endp sub_192DE



; Attributes: bp-based frame

proc idk_SetConfigMomFlagValue_s1930B far
			; CODE XREF: _f010309_RUN+6AP
			; sub_4E031+642P
			; sub_4E031+651P
			; idk_HoF_s565F2+8FP
			; idk_HoF_s565F2+12FP

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	ax, [bp+arg_0]
mov	[word_36024], ax
pop	bp
retf			; Return Far from Procedure
endp idk_SetConfigMomFlagValue_s1930B



; Attributes: bp-based frame

proc sub_19316 far	; CODE XREF: sub_4043A+EEP
			; sub_4043A+123P

arg_0= word ptr	 6

push	bp		; arg2_SI

loc_19317:
mov	bp, sp

loc_19319:
mov	ax, 10h
push	ax

loc_1931D:		; argOffset
push	[bufFontsLbxEntry0]

loc_19321:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx
add	ax, [bp+arg_0]	; Add
push	ax		; argValue
mov	ax, 44h	; 'D'
push	ax		; argOffset
push	[bufFontsLbxEntry0] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_19316



; Attributes: bp-based frame

proc sub_1933E far

arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_19341:
push	[bp+arg_0]

loc_19344:
mov	ax, 4Ah	; 'J'
push	ax

loc_19348:
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1933E



; Attributes: bp-based frame

proc sub_19356 far

argValue= word ptr  6

push	bp
mov	bp, sp
push	[bp+argValue]	; argValue
mov	ax, 48h	; 'H'

loc_1935F:		; argOffset
push	ax

loc_19360:		; argSegment
push	[bufFontsLbxEntry0]
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_19356



; Attributes: bp-based frame

proc sub_1936E far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
xor	si, si		; Logical Exclusive OR
jmp	short loc_19391	; Jump

loc_19376:		; CODE XREF: sub_1936E+26j
mov	bx, [bp+arg_0]

loc_19379:		; Add
add	bx, si

loc_1937B:
mov	al, [bx]
cbw			; AL ->	AX (with sign)

loc_1937E:		; argValue
push	ax

loc_1937F:
mov	ax, si

loc_19381:		; Add
add	ax, si

loc_19383:		; argOffset
push	ax

loc_19384:		; argSegment
push	[bufFontsLbxEntry0]
call	fncStoSW	; Call Procedure

loc_1938D:		; Add
add	sp, 6
inc	si		; Increment by 1

loc_19391:		; CODE XREF: sub_1936E+6j
cmp	si, 8		; Compare Two Operands
jl	short loc_19376	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1936E



; Attributes: bp-based frame

proc sub_19399 far	; CODE XREF: sub_3D378+3FEP
			; sub_3DF8C+D9P
			; sub_3DF8C+117P
			; sub_3DF8C+231P
			; sub_3E60E+16DP
			; sub_3E60E+19AP
			; sub_3E60E+1D4P
			; sub_3E60E+201P
			; sub_3E60E+24BP
			; sub_3E60E+278P
			; sub_3E60E+2B2P
			; sub_3E60E+2DFP
			; sub_3E60E:loc_3E937P
			; sub_3E60E+356P
			; sub_3E60E+390P
			; sub_3E60E+3BDP
			; sub_3E60E+407P
			; sub_3E60E+434P
			; sub_3E60E+46EP
			; sub_3E60E+49BP
			; sub_3EDD1+2A9P
			; sub_3EDD1+2DAP
			; sub_3EDD1+323P
			; sub_3EDD1+354P
			; sub_3EDD1+3CEP
			; sub_3EDD1+3FFP
			; sub_3EDD1:loc_3F219P
			; sub_3EDD1+479P
			; sub_3EDD1+4E8P
			; sub_3EDD1+538P
			; sub_3EDD1+585P
			; sub_3EDD1+5CCP
			; sub_3F6BF+A6P
			; sub_3F6BF+DDP
			; sub_3FA0C+A7P
			; sub_3FA0C:loc_3FAEAP
			; sub_3FBE0+2D8P
			; sub_3FBE0+322P
			; sub_3FBE0+384P
			; sub_3FBE0+3D1P
			; sub_40037+10AP
			; sub_40037+141P
			; sub_40037+257P
			; sub_40037+28EP
			; sub_40037:loc_40313P
			; sub_40037+321P
			; sub_40037+358P
			; sub_40037+3AFP
			; sub_40037+3C0P
			; sub_4043A+E3P
			; sub_4043A+118P
			; sub_40EC0+69BP
			; sub_40EC0+6DEP
			; sub_40EC0:loc_4168BP
			; sub_40EC0:loc_416FBP
			; sub_40EC0:loc_4173EP
			; sub_40EC0:loc_417C0P
			; sub_40EC0+93CP
			; sub_40EC0:loc_41899P
			; sub_40EC0+A24P
			; sub_40EC0:loc_41920P
			; sub_40EC0+AE4P
			; sub_40EC0+B07P
			; sub_40EC0:loc_419F9P
			; sub_40EC0:loc_41A30P
			; sub_424BB+A0P
			; sub_424BB+D7P
			; sub_424BB+267P
			; sub_424BB+28AP
			; sub_4276F+120P
			; sub_4276F+26CP
			; sub_4276F+2F3P
			; sub_4276F+38CP
			; sub_4276F+3C6P
			; sub_4276F+4F5P
			; sub_4276F+57EP
			; sub_4276F+617P
			; sub_4276F+651P
			; sub_4276F+780P
			; sub_4276F+809P
			; sub_4276F+8A2P
			; sub_4276F+8DCP
			; sub_4D5B0:loc_4D5C4P
			; sub_4D7A1+83P
			; sub_4D7A1+F2P
			; sub_4D8FA+7CP
			; sub_4DA02+83P
			; sub_4E031+5B4P
			; sub_4E031+5EEP
			; sub_4EC17+1DAP
			; sub_4EC17+26CP
			; sub_4EC17+2DDP
			; sub_4F1AB+194P
			; sub_4F1AB+210P
			; ST_LoadMusicSoundfxIntro+13DP
			; idk_OVR_LoadLbxHelp+24CP
			; idk_OVR_LoadLbxHelp+453P
			; idk_OVR_LoadLbxHelp+47EP
			; sub_56240+F2P
			; idk_HoF_s565F2+6EP
			; idk_HoF_s565F2+10EP

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
mov	[bp+var_2], 0F0h ; ''
xor	si, si		; Logical Exclusive OR
jmp	short loc_193C5	; Jump

loc_193A9:		; CODE XREF: sub_19399+2Fj
mov	bx, [bp+arg_2]
add	bx, si		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_2]
add	ax, si		; Add
push	ax
push	[ptrFontsLbx2_@48]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
inc	si		; Increment by 1

loc_193C5:		; CODE XREF: sub_19399+Ej
cmp	si, 16		; Compare Two Operands
jl	short loc_193A9	; Jump if Less (SF!=OF)
mov	ax, 15
push	ax		; int
push	[bp+arg_0]	; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19399



; Attributes: bp-based frame

proc sub_193DD far	; CODE XREF: sub_4D7A1+E4P
			; sub_4DA02+E6P
			; sub_4E031+5BFP
			; sub_4E031:loc_4E62AP
			; sub_4E031+65BP
			; sub_4EC17+253P

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_193E0:		; Integer Subtraction
sub	sp, 2
push	si
push	di
mov	si, [bp+arg_0]

loc_193E8:
mov	[bp+var_2], 0F0h ; ''
xor	di, di		; Logical Exclusive OR
jmp	short loc_19406	; Jump

loc_193F1:		; CODE XREF: sub_193DD+2Cj
push	si

loc_193F2:
mov	ax, di
mov	cl, 4
shl	ax, cl		; Shift	Logical	Left
push	ax

loc_193F9:
push	[ptrFontsLbx2_@48]

loc_193FD:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add

loc_19405:		; Increment by 1
inc	di

loc_19406:		; CODE XREF: sub_193DD+12j
cmp	di, 10h		; Compare Two Operands
jl	short loc_193F1	; Jump if Less (SF!=OF)
push	si
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1940F:
push	[bufFontsLbxEntry0]

loc_19413:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_19418:		; Add
add	sp, 6

loc_1941B:
push	si

loc_1941C:
mov	ax, 14h
push	ax

loc_19420:
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add

loc_1942C:
push	si
mov	ax, 24h	; '$'
push	ax
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
push	si

loc_1943E:
mov	ax, 34h	; '4'
push	ax
push	[bufFontsLbxEntry0]

loc_19446:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_193DD



; Attributes: bp-based frame

proc sub_19454 far	; CODE XREF: sub_4D5B0:loc_4D5B8P
			; sub_4D8FA+70P
			; sub_4DB4D+8P
			; sub_4E9F4+B8P
			; sub_4EF74+BDP
push	bp
mov	bp, sp
push	si
xor	si, si		; Logical Exclusive OR
jmp	short loc_19473	; Jump

loc_1945C:		; CODE XREF: sub_19454+22j
mov	ax, si
mov	cl, 4

loc_19460:		; Shift	Logical	Left
shl	ax, cl
push	ax
push	[ptrFontsLbx2_@48]

loc_19467:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx
mov	[si-580Ah], al
inc	si		; Increment by 1

loc_19473:		; CODE XREF: sub_19454+6j
cmp	si, 10h		; Compare Two Operands
jl	short loc_1945C	; Jump if Less (SF!=OF)

loc_19478:		; Logical Exclusive OR
xor	ax, ax

loc_1947A:
push	ax
push	[bufFontsLbxEntry0]

loc_1947F:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx
mov	[byte_3C516], al

loc_19489:
mov	ax, 14h
push	ax

loc_1948D:
push	[bufFontsLbxEntry0]

loc_19491:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx
mov	[byte_3C517], al
mov	ax, 24h	; '$'

loc_1949E:
push	ax

loc_1949F:
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure

loc_194A8:
pop	cx
pop	cx
mov	[byte_3C518], al

loc_194AD:
mov	ax, 34h	; '4'
push	ax

loc_194B1:
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[byte_3C519], al
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_19454



; Attributes: bp-based frame

proc sub_194C2 far	; CODE XREF: sub_4D5B0:loc_4D787P
			; sub_4D8FA+EFP
			; sub_4DB4D+4CFP
			; sub_4E9F4+203P
			; sub_4EF74+217P
push	bp

loc_194C3:
mov	bp, sp
push	si
xor	si, si		; Logical Exclusive OR
jmp	short loc_194E4	; Jump

loc_194CA:		; CODE XREF: sub_194C2+25j
mov	al, [si-580Ah]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	cl, 4
shl	ax, cl		; Shift	Logical	Left
push	ax
push	[ptrFontsLbx2_@48]

loc_194DB:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
inc	si		; Increment by 1

loc_194E4:		; CODE XREF: sub_194C2+6j
cmp	si, 10h		; Compare Two Operands
jl	short loc_194CA	; Jump if Less (SF!=OF)
mov	al, [byte_3C516]
cbw			; AL ->	AX (with sign)
push	ax

loc_194EE:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_194F1:
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
mov	al, [byte_3C517]

loc_19500:		; AL ->	AX (with sign)
cbw
push	ax
mov	ax, 14h
push	ax

loc_19506:
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
mov	al, [byte_3C518]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, 24h	; '$'
push	ax
push	[bufFontsLbxEntry0]

loc_1951F:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_19524:		; Add
add	sp, 6

loc_19527:
mov	al, [byte_3C519]

loc_1952A:		; AL ->	AX (with sign)
cbw
push	ax
mov	ax, 34h	; '4'

loc_1952F:
push	ax

loc_19530:
push	[bufFontsLbxEntry0]

loc_19534:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_19539:		; Add
add	sp, 6
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_194C2



; Attributes: bp-based frame

proc sub_1953F far	; CODE XREF: sub_4276F+327P
			; sub_4276F+3F9P
			; sub_4276F+5B2P
			; sub_4276F+684P
			; sub_4276F+83DP
			; sub_4276F:loc_4307EP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure

loc_19554:		; Add
add	sp, 8
mov	ax, 9490h
push	ax
push	[bp+arg_2]

loc_1955E:
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_1993F ; Call Procedure
add	sp, 6		; Add

loc_19569:
pop	bp
retf			; Return Far from Procedure
endp sub_1953F



; Attributes: bp-based frame

proc sub_1956B far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp

loc_1956E:
push	[bp+arg_6]
push	[bp+arg_4]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
mov	ax, 9490h

loc_19586:		; int
push	ax

loc_19587:		; int
push	[bp+arg_2]
push	[bp+arg_0]	; int
nop			; No Operation
push	cs
call	near ptr sub_196ED ; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1956B



; Attributes: bp-based frame

proc sub_19597 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]

loc_195A0:		; Logical Exclusive OR
xor	ax, ax
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add

loc_195AF:
mov	ax, 9490h
push	ax
push	[bp+arg_2]
push	[bp+arg_0]

loc_195B9:		; No Operation
nop
push	cs
call	near ptr sub_196B8 ; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_19597



; Attributes: bp-based frame

proc sub_195C3 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
mov	ax, 9490h
push	ax

loc_195DF:
push	[bp+arg_2]

loc_195E2:
push	[bp+arg_0]

loc_195E5:		; No Operation
nop
push	cs
call	near ptr sub_1A0DC ; Call Procedure
add	sp, 6		; Add
pop	bp

locret_195EE:		; Return Far from Procedure
retf
endp sub_195C3



; Attributes: bp-based frame

proc sub_195EF far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_195F0:
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]
xor	ax, ax		; Logical Exclusive OR

loc_195FA:
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure

loc_19604:		; Add
add	sp, 8

loc_19607:
mov	ax, 9490h
push	ax
push	[bp+arg_2]

loc_1960E:
push	[bp+arg_0]

loc_19611:		; No Operation
nop
push	cs
call	near ptr sub_19873 ; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_195EF



; Attributes: bp-based frame

proc sub_1961B far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
mov	ax, 9490h
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs

loc_1963F:		; Call Procedure
call	near ptr sub_1983E
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1961B



; Attributes: bp-based frame

proc sub_19647 far

var_C= word ptr	-0Ch
argPtrCharArr= byte ptr	-0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
argNumber= word	ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction

loc_1964D:
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add

loc_19660:		; Load Effective Address
lea	ax, [bp+argPtrCharArr]
push	ax
push	[bp+arg_2]
push	[bp+arg_0]

loc_1966A:		; No Operation
nop
push	cs
call	near ptr sub_1993F ; Call Procedure
add	sp, 6		; Add

loc_19672:
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
jmp	short $+2	; Jump
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19647



; Attributes: bp-based frame

proc sub_1967E far

var_C= word ptr	-0Ch
string=	byte ptr -0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
value= dword ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
mov	ax, 0Ah
push	ax
lea	ax, [bp+string]	; Load Effective Address
push	ax		; string

loc_1968C:
push	[word ptr bp+value+2]

loc_1968F:		; value
push	[word ptr bp+value]
call	_ltoa		; char *LtoA(long value, char ^string, int radix)
			;   converts value to a	null-terminated	string and stores the result in	string
			; Parameters:
			;   value   long integer to be converted
			;   string  pointer to character array
			;   radix   the	base to	be used	in converting
			; Return:
			;   LtoA returns a pointer to string.
			;
add	sp, 8		; Add
lea	ax, [bp+string]	; Load Effective Address
push	ax

loc_1969E:
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_1993F ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax

loc_196AF:
mov	ax, [bp+var_C]
jmp	short $+2	; Jump
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1967E



; Attributes: bp-based frame

proc sub_196B8 far	; CODE XREF: sub_19597+24p
			; sub_19728:loc_1974Cp
			; sub_19794+27p
			; sub_1B0AD:loc_1B140P
			; sub_2BA41+D4FP
			; idk_HoF_s565F2+194P
			; idk_HoF_s565F2+27AP

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
mov	si, [bp+arg_4]
push	si
call	sub_1AF46	; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_2], ax
push	si

loc_196CE:
push	[bp+arg_2]
mov	ax, [bp+arg_0]
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1993F ; Call Procedure
add	sp, 6		; Add

loc_196E0:
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
jmp	short $+2	; Jump

loc_196E8:
pop	si

loc_196E9:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_196B8



; Attributes: bp-based frame

; int __cdecl __far sub_196ED(int, int,	int)
proc sub_196ED far	; CODE XREF: sub_1956B+24p
			; sub_1975E+24p
			; sub_1B0AD:loc_1B187P
			; sub_1D1B5+E9P
			; sub_1D1B5:loc_1D2E1P
			; sub_1D1B5:loc_1D347P
			; sub_1D1B5:loc_1D3ADP
			; sub_2BA41+1A8P
			; sub_2BA41+478P
			; sub_2BA41+748P
			; sub_2BA41+A27P
			; sub_2CF44+2E3P
			; sub_2CF44+5BCP
			; sub_2CF44+898P
			; sub_2CF44+BBCP
			; sub_3DF8C+244P
			; sub_3E60E+18AP
			; sub_3E60E+1F1P
			; sub_3E60E+21EP
			; sub_3E60E+268P
			; sub_3E60E+2CFP
			; sub_3E60E+2FCP
			; sub_3E60E+346P
			; sub_3E60E+3ADP
			; sub_3E60E+3DAP
			; sub_3E60E+424P
			; sub_3E60E+48BP
			; sub_3E60E+4B8P
			; sub_3EDD1+98P
			; sub_3EDD1:loc_3F09BP
			; sub_3EDD1+344P
			; sub_3EDD1+375P
			; sub_3EDD1+3EFP
			; sub_3EDD1+469P
			; sub_3EDD1+49AP
			; sub_3EDD1+5A0P
			; sub_3EDD1+5BCP
			; sub_3EDD1+5E7P
			; sub_3F6BF+6BP
			; sub_3F6BF+B9P
			; sub_3F6BF+CDP
			; sub_3F6BF+F0P
			; sub_3FA0C:loc_3FA78P
			; sub_3FA0C+BAP
			; sub_3FA0C+CEP
			; sub_3FA0C+F1P
			; sub_40037+CFP
			; sub_40037+11DP
			; sub_40037+131P
			; sub_40037+154P
			; sub_40EC0:loc_419B7P
			; sub_40EC0:loc_419DAP
			; sub_40EC0:loc_41A0CP
			; sub_40EC0+B60P
			; sub_40EC0:loc_41A43P
			; sub_424BB+B3P
			; sub_424BB+C7P
			; sub_424BB+EAP
			; sub_424BB+27AP
			; sub_424BB+29DP
			; sub_4276F+143P
			; sub_4E031+5DEP
			; sub_4E031+617P
			; ST_LoadMusicSoundfxIntro+150P
			; idk_HoF_s565F2+ECP

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
mov	si, [bp+arg_4]
push	si
call	sub_1AF46	; Call Procedure
pop	cx
mov	[bp+var_2], ax
push	si
push	[bp+arg_2]
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+arg_0]
sub	dx, ax		; Integer Subtraction
push	dx
nop			; No Operation
push	cs
call	near ptr sub_1993F ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
jmp	short $+2	; Jump
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_196ED



; Attributes: bp-based frame

; int __cdecl __far sub_19728(int, int,	int value)
proc sub_19728 far	; CODE XREF: idk_HoF_s565F2+1FEP

var_C= word ptr	-0Ch
argPtrCharArr= byte ptr	-0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
argNumber= word	ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 0Ch		; argConversionBase
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase

loc_1973E:		; Add
add	sp, 6
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
push	cs

loc_1974C:		; Call Procedure
call	near ptr sub_196B8
add	sp, 6		; Add
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
jmp	short $+2	; Jump
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19728



; Attributes: bp-based frame

proc sub_1975E far

var_C= word ptr	-0Ch
argPtrCharArr= byte ptr	-0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
argNumber= word	ptr  0Ah

push	bp

loc_1975F:
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; int
push	[bp+arg_2]	; int
push	[bp+arg_0]	; int
push	cs
call	near ptr sub_196ED ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax
mov	ax, [bp+var_C]

loc_1978E:		; Jump
jmp	short $+2
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1975E



; Attributes: bp-based frame

proc sub_19794 far

var_C= word ptr	-0Ch
string=	byte ptr -0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
value= dword ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction

loc_1979A:
mov	ax, 0Ah
push	ax
lea	ax, [bp+string]	; Load Effective Address
push	ax		; string
push	[word ptr bp+value+2]
push	[word ptr bp+value] ; value
call	_ltoa		; char *LtoA(long value, char ^string, int radix)
			;   converts value to a	null-terminated	string and stores the result in	string
			; Parameters:
			;   value   long integer to be converted
			;   string  pointer to character array
			;   radix   the	base to	be used	in converting
			; Return:
			;   LtoA returns a pointer to string.
			;
add	sp, 8		; Add

loc_197B0:		; Load Effective Address
lea	ax, [bp+string]
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_196B8 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
jmp	short $+2	; Jump
mov	sp, bp
pop	bp

locret_197CC:		; Return Far from Procedure
retf
endp sub_19794



; Attributes: bp-based frame

proc sub_197CD far

var_C= word ptr	-0Ch
argPtrCharArr= byte ptr	-0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
argNumber= word	ptr  0Ah

push	bp

loc_197CE:
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
push	[bp+arg_2]
push	[bp+arg_0]

loc_197F0:		; No Operation
nop
push	cs
call	near ptr sub_1A0DC ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax

loc_197FB:
mov	ax, [bp+var_C]
jmp	short $+2	; Jump

loc_19800:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_197CD



; Attributes: bp-based frame

proc sub_19804 far

var_C= word ptr	-0Ch
string=	byte ptr -0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
value= dword ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction

loc_1980A:
mov	ax, 0Ah
push	ax
lea	ax, [bp+string]	; Load Effective Address
push	ax		; string
push	[word ptr bp+value+2]
push	[word ptr bp+value] ; value
call	_ltoa		; char *LtoA(long value, char ^string, int radix)
			;   converts value to a	null-terminated	string and stores the result in	string
			; Parameters:
			;   value   long integer to be converted
			;   string  pointer to character array
			;   radix   the	base to	be used	in converting
			; Return:
			;   LtoA returns a pointer to string.
			;
add	sp, 8		; Add
lea	ax, [bp+string]	; Load Effective Address
push	ax
push	[bp+arg_2]
push	[bp+arg_0]

loc_1982A:		; No Operation
nop
push	cs

loc_1982C:		; Call Procedure
call	near ptr sub_1A0DC

loc_1982F:		; Add
add	sp, 6
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
jmp	short $+2	; Jump
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19804



; Attributes: bp-based frame

proc sub_1983E far	; CODE XREF: sub_1961B:loc_1963Fp
			; sub_198AE+24p
			; sub_198E4:loc_1990Bp
			; sub_1B241+94P

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_1983F:
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
mov	si, [bp+arg_4]
push	si
call	sub_1AF46	; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_2], ax
push	si
push	[bp+arg_2]
mov	ax, [bp+arg_0]

loc_1985A:		; Integer Subtraction
sub	ax, [bp+var_2]
push	ax
nop			; No Operation
push	cs

loc_19860:		; Call Procedure
call	near ptr sub_1A0DC

loc_19863:		; Add
add	sp, 6
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
jmp	short $+2	; Jump
pop	si

loc_1986F:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1983E



; Attributes: bp-based frame

proc sub_19873 far	; CODE XREF: sub_195EF+24p
			; sub_1B241:loc_1B31CP

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si

loc_1987A:
mov	si, [bp+arg_4]
push	si
call	sub_1AF46	; Call Procedure
pop	cx
mov	[bp+var_2], ax
push	si
push	[bp+arg_2]
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+arg_0]

loc_19896:		; Integer Subtraction
sub	dx, ax
push	dx
nop			; No Operation
push	cs
call	near ptr sub_1A0DC ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
jmp	short $+2	; Jump

loc_198A9:
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19873



; Attributes: bp-based frame

proc sub_198AE far

var_C= word ptr	-0Ch
argPtrCharArr= byte ptr	-0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
argNumber= word	ptr  0Ah

push	bp

loc_198AF:
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
mov	ax, 0Ah
push	ax

loc_198B8:		; Load Effective Address
lea	ax, [bp+argPtrCharArr]
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase

loc_198C4:		; Add
add	sp, 6
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
push	[bp+arg_2]

loc_198CE:
push	[bp+arg_0]
push	cs
call	near ptr sub_1983E ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
jmp	short $+2	; Jump
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_198AE



; Attributes: bp-based frame

proc sub_198E4 far

var_C= word ptr	-0Ch
string=	byte ptr -0Ah
arg_0= word ptr	 6
arg_2= word ptr	 8
value= dword ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
mov	ax, 0Ah
push	ax
lea	ax, [bp+string]	; Load Effective Address

loc_198F1:		; string
push	ax

loc_198F2:
push	[word ptr bp+value+2]
push	[word ptr bp+value] ; value
call	_ltoa		; char *LtoA(long value, char ^string, int radix)
			;   converts value to a	null-terminated	string and stores the result in	string
			; Parameters:
			;   value   long integer to be converted
			;   string  pointer to character array
			;   radix   the	base to	be used	in converting
			; Return:
			;   LtoA returns a pointer to string.
			;
add	sp, 8		; Add

loc_19900:		; Load Effective Address
lea	ax, [bp+string]
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
push	cs

loc_1990B:		; Call Procedure
call	near ptr sub_1983E

loc_1990E:		; Add
add	sp, 6
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
jmp	short $+2	; Jump
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_198E4



; Attributes: bp-based frame

proc sub_1991D far	; CODE XREF: sub_1B0AD:loc_1B1DFP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp

loc_19920:
push	si
mov	si, [bp+arg_6]

loc_19924:		; Logical Inclusive OR
or	si, si

loc_19926:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1992A
xor	si, si		; Logical Exclusive OR

loc_1992A:		; CODE XREF: sub_1991D:loc_19926j
push	si
push	[bp+arg_4]

loc_1992E:
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_19958 ; Call Procedure
add	sp, 8		; Add
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1991D



; Attributes: bp-based frame

proc sub_1993F far	; CODE XREF: sub_1953F+24p
			; sub_19647+25p
			; sub_1967E+28p
			; sub_196B8+22p
			; sub_196ED+28p
			; sub_1B0AD:loc_1B108P
			; sub_1B0AD+166P
			; sub_28963+3C5P
			; sub_2BA41+B23P
			; sub_2BA41+C0EP
			; sub_2BA41+D15P
			; sub_2BA41+F83P
			; sub_2BA41:loc_2CC44P
			; sub_2CF44+CE1P
			; sub_2CF44+D4DP
			; sub_2CF44+E3DP
			; sub_3D378+286P
			; sub_3D378+29AP
			; sub_3D378+2AEP
			; sub_3D378+2C2P
			; sub_3D378+2D6P
			; sub_3D378+2EAP
			; sub_3D378+2FEP
			; sub_3D378+312P
			; sub_3D378+326P
			; sub_3D378+33AP
			; sub_3D378+34EP
			; sub_3D378+362P
			; sub_3D378+376P
			; sub_3D378+38AP
			; sub_3D378+39EP
			; sub_3D378+3B2P
			; sub_3D378+3C6P
			; sub_3D378+3DAP
			; sub_3D378+3EEP
			; sub_3D378+425P
			; sub_3D378+439P
			; sub_3D378+44DP
			; sub_3D378+461P
			; sub_3DF8C+155P
			; sub_3EDD1+529P
			; sub_3EDD1+54BP
			; sub_3FBE0+304P
			; sub_3FBE0+34EP
			; sub_3FBE0+3B3P
			; sub_3FBE0:loc_3FFE0P
			; sub_40037+279P
			; sub_40037+2BAP
			; sub_40037+308P
			; sub_40037+343P
			; sub_40037+384P
			; sub_40037:loc_40423P
			; sub_40EC0:loc_4158FP
			; sub_40EC0+712P
			; sub_40EC0+7FFP
			; sub_40EC0:loc_4172FP
			; sub_40EC0+8B2P
			; sub_40EC0+92DP
			; sub_40EC0+960P
			; sub_40EC0:loc_418C6P
			; sub_40EC0:loc_41911P
			; sub_40EC0+A84P
			; sub_4276F+297P
			; sub_4276F:loc_42C8FP
			; sub_4276F+7ABP
			; idk_BuildingWorlds+75P
			; sub_4E031+704P
			; idk_OVR_LoadLbxHelp:loc_5610EP
			; idk_HoF_s565F2+1E6P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_19958 ; Call Procedure
add	sp, 8		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1993F



; Attributes: bp-based frame

proc sub_19958 far	; CODE XREF: sub_1991D+19p
			; sub_1993F+11p

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
mov	ax, 18
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_19981	; Jump if Not Zero (ZF=0)
jmp	loc_19B29	; Jump

loc_19981:		; CODE XREF: sub_19958+24j
mov	[bp+var_4], 0
jmp	short loc_1999E	; Jump

loc_19988:		; CODE XREF: sub_19958+4Aj
push	[word_36024]
push	[bp+var_4]
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
inc	[bp+var_4]	; Increment by 1

loc_1999E:		; CODE XREF: sub_19958+2Ej
cmp	[bp+var_4], 10h	; Compare Two Operands
jl	short loc_19988	; Jump if Less (SF!=OF)
mov	[idk_Flag_w36026], 1
cmp	[bp+var_2], 2	; Compare Two Operands
jz	short loc_199F5	; Jump if Zero (ZF=1)

loc_199B0:
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure

loc_199C6:		; Add
add	sp, 0Ah
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	si
nop			; No Operation
push	cs

loc_199D9:		; Call Procedure
call	near ptr ILSe_display_text
add	sp, 0Ah		; Add

loc_199DF:
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	di
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs

loc_199EF:		; Call Procedure
call	near ptr ILSe_display_text

loc_199F2:		; Add
add	sp, 0Ah

loc_199F5:		; CODE XREF: sub_19958+56j
cmp	[bp+var_2], 1	; Compare Two Operands
jz	short loc_19A46	; Jump if Zero (ZF=1)

loc_199FB:		; Compare Two Operands
cmp	[bp+var_2], 3
jz	short loc_19A46	; Jump if Zero (ZF=1)
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	di

loc_19A0B:
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure

loc_19A14:		; Add
add	sp, 0Ah
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]

loc_19A20:
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs

loc_19A2A:		; Call Procedure
call	near ptr ILSe_display_text
add	sp, 0Ah		; Add
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
dec	ax		; Decrement by 1
push	ax

loc_19A3D:
push	si
nop			; No Operation
push	cs

loc_19A40:		; Call Procedure
call	near ptr ILSe_display_text
add	sp, 0Ah		; Add

loc_19A46:		; CODE XREF: sub_19958+A1j
			; sub_19958+A7j
cmp	[bp+var_2], 3	; Compare Two Operands
jz	short loc_19A52	; Jump if Zero (ZF=1)

loc_19A4C:		; Compare Two Operands
cmp	[bp+var_2], 5

loc_19A50:		; Jump if Not Zero (ZF=0)
jnz	short loc_19AA5

loc_19A52:		; CODE XREF: sub_19958+F2j
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
add	ax, 2		; Add

loc_19A60:
push	ax
mov	ax, si
add	ax, 2		; Add
push	ax
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
add	ax, 2		; Add
push	ax
mov	ax, si

loc_19A80:		; Increment by 1
inc	ax
push	ax
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
add	ax, 2		; Add
push	ax
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure
add	sp, 0Ah		; Add

loc_19AA5:		; CODE XREF: sub_19958:loc_19A50j
cmp	[bp+var_2], 3	; Compare Two Operands
jle	short loc_19ADD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure
add	sp, 0Ah		; Add

loc_19ADD:		; CODE XREF: sub_19958+151j
cmp	[bp+var_2], 5	; Compare Two Operands
jnz	short loc_19B13	; Jump if Not Zero (ZF=0)
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	di
mov	ax, si
add	ax, 2		; Add
push	ax
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR

loc_19B00:
push	ax
push	[bp+arg_4]
mov	ax, di
add	ax, 2		; Add
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr ILSe_display_text ; Call Procedure
add	sp, 0Ah		; Add

loc_19B13:		; CODE XREF: sub_19958+189j
mov	ax, 19
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx

loc_19B22:
push	ax
nop			; No Operation
push	cs
call	near ptr sub_19D78 ; Call Procedure
pop	cx

loc_19B29:		; CODE XREF: sub_19958+26j
mov	[idk_Flag_w36026], 0
push	[bp+arg_6]
mov	ax, 1
push	ax
push	[bp+arg_4]
push	di
push	si
nop			; No Operation
push	cs

loc_19B3D:		; Call Procedure
call	near ptr ILSe_display_text
add	sp, 0Ah		; Add
pop	di
pop	si
mov	sp, bp
pop	bp

locret_19B48:		; Return Far from Procedure
retf
endp sub_19958



; Attributes: bp-based frame

proc ILSe_display_text far
			; CODE XREF: sub_19958+6Bp
			; sub_19958:loc_199D9p
			; sub_19958:loc_199EFp
			; sub_19958+B9p
			; sub_19958:loc_19A2Ap
			; sub_19958:loc_19A40p
			; sub_19958+111p
			; sub_19958+12Cp
			; sub_19958+147p
			; sub_19958+166p
			; sub_19958+17Fp
			; sub_19958+19Dp
			; sub_19958+1B5p
			; sub_19958:loc_19B3Dp

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
push	si
push	di		; arg2_SI
mov	si, [bp+arg_4]
mov	di, [bp+arg_8]

loc_19B57:
mov	[bp+var_2], 0
mov	ax, [bp+arg_0]

loc_19B5F:
mov	[word_3C524], ax
mov	ax, [bp+arg_2]
mov	[word_3C522], ax
or	di, di		; Logical Inclusive OR
jnz	short loc_19B6F	; Jump if Not Zero (ZF=0)
db 0E9h,7Fh,0 ;	<BAD>jmp     loc_19BEE ; Jump

loc_19B6F:		; CODE XREF: ILSe_display_text+21j
mov	[bp+var_8], 0
mov	[bp+var_A], 0
mov	[bp+var_E], 0

loc_19B7E:
mov	[bp+var_6], 0

loc_19B83:		; Jump
jmp	short loc_19B93

loc_19B85:		; CODE XREF: ILSe_display_text:loc_19BC1j
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 20h ;	' ' ; Compare Two Operands
jnz	short loc_19B90	; Jump if Not Zero (ZF=0)

loc_19B8D:		; Increment by 1
inc	[bp+var_6]

loc_19B90:		; CODE XREF: ILSe_display_text+42j
inc	[bp+var_E]	; Increment by 1

loc_19B93:		; CODE XREF: ILSe_display_text:loc_19B83j
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 0 ; Compare Two Operands
jz	short loc_19BC3	; Jump if Zero (ZF=1)
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 0Dh ;	Compare	Two Operands
jz	short loc_19BC3	; Jump if Zero (ZF=1)
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 14h ;	Compare	Two Operands
jz	short loc_19BC3	; Jump if Zero (ZF=1)
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 19h ;	Compare	Two Operands
jz	short loc_19BC3	; Jump if Zero (ZF=1)
mov	bx, [bp+var_E]

loc_19BB6:		; Compare Two Operands
cmp	[byte ptr bx+si], 15h
jz	short loc_19BC3	; Jump if Zero (ZF=1)
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 1Dh ;	Compare	Two Operands

loc_19BC1:		; Jump if Not Zero (ZF=0)
jnz	short loc_19B85

loc_19BC3:		; CODE XREF: ILSe_display_text+50j
			; ILSe_display_text+58j
			; ILSe_display_text+60j
			; ILSe_display_text+68j
			; ILSe_display_text+70j
cmp	[bp+var_6], 0	; Compare Two Operands

loc_19BC7:		; Jump if Not Zero (ZF=0)
jnz	short loc_19BCB
xor	di, di		; Logical Exclusive OR

loc_19BCB:		; CODE XREF: ILSe_display_text:loc_19BC7j
push	si

loc_19BCC:		; Call Procedure
call	sub_1AF46
pop	cx
sub	di, ax		; Integer Subtraction
or	di, di		; Logical Inclusive OR
jg	short loc_19BDC	; Jump if Greater (ZF=0	& SF=OF)
xor	di, di		; Logical Exclusive OR
jmp	short loc_19BEE	; Jump

loc_19BDC:		; CODE XREF: ILSe_display_text+8Dj
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_6]	; Signed Divide
mov	[bp+var_A], dx
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_6]	; Signed Divide
mov	[bp+var_C], ax

loc_19BEE:		; CODE XREF: ILSe_display_text+23j
			; ILSe_display_text+91j
jmp	loc_19CD4	; Jump

loc_19BF1:		; CODE XREF: ILSe_display_text+198j
mov	ax, [bp+var_4]
mov	[bp+var_10], ax
mov	cx, 9		; switch 9 cases
mov	bx, offset word_19CED

loc_19BFD:		; CODE XREF: ILSe_display_text+BFj
mov	ax, [cs:bx]
cmp	ax, [bp+var_10]	; Compare Two Operands
jz	short loc_19C0C	; Jump if Zero (ZF=1)
add	bx, 2		; Add
loop	loc_19BFD	; Loop while CX	!= 0
jmp	short loc_19C80	; default

loc_19C0C:		; CODE XREF: ILSe_display_text+BAj
jmp	[word ptr cs:bx+12h] ; switch jump

loc_19C10:		; DATA XREF: seg017:off_19CFFo
cmp	[bp+arg_6], 0	; case 0x1
jz	short loc_19C1B	; Jump if Zero (ZF=1)
nop			; No Operation
push	cs
call	near ptr sub_19D1C ; Call Procedure

loc_19C1B:		; CODE XREF: ILSe_display_text+CBj
jmp	loc_19CD1	; Jump

loc_19C1E:		; CODE XREF: ILSe_display_text:loc_19C0Cj
			; DATA XREF: seg017:off_19CFFo
cmp	[bp+arg_6], 0	; case 0x2
jz	short loc_19C29	; Jump if Zero (ZF=1)

loc_19C24:		; No Operation
nop
push	cs
call	near ptr sub_19D2A ; Call Procedure

loc_19C29:		; CODE XREF: ILSe_display_text+D9j
jmp	loc_19CD1	; Jump

loc_19C2C:		; CODE XREF: ILSe_display_text:loc_19C0Cj
			; DATA XREF: seg017:off_19CFFo
cmp	[bp+arg_6], 0	; case 0x3
jz	short loc_19C37	; Jump if Zero (ZF=1)
nop			; No Operation
push	cs
call	near ptr sub_19D51 ; Call Procedure

loc_19C37:		; CODE XREF: ILSe_display_text+E7j
jmp	loc_19CD1	; Jump

loc_19C3A:		; CODE XREF: ILSe_display_text:loc_19C0Cj
			; DATA XREF: seg017:off_19CFFo
cmp	[bp+arg_6], 0	; case 0x4
jz	short loc_19C45	; Jump if Zero (ZF=1)
nop			; No Operation
push	cs
call	near ptr sub_19D2A ; Call Procedure

loc_19C45:		; CODE XREF: ILSe_display_text+F5j
jmp	loc_19CD1	; Jump

loc_19C48:		; CODE XREF: ILSe_display_text:loc_19C0Cj
			; DATA XREF: seg017:off_19CFFo
mov	ax, 68		; case 0xD
push	ax
push	[bufFontsLbxEntry0] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
add	[word_3C522], ax ; Add
mov	ax, [bp+arg_0]
mov	[word_3C524], ax
jmp	short loc_19CD1	; Jump

loc_19C63:		; CODE XREF: ILSe_display_text:loc_19C0Cj
			; DATA XREF: seg017:off_19CFFo
mov	bx, [bp+var_2]	; case 0x19
add	bx, si		; Add
mov	al, [bx+1]
mov	ah, 0
mov	dx, [bp+arg_0]
add	dx, ax		; Add
mov	[word_3C524], dx
inc	[bp+var_2]	; Increment by 1
jmp	short loc_19CD1	; Jump

loc_19C7B:		; CODE XREF: ILSe_display_text:loc_19C0Cj
			; ILSe_display_text:loc_19CE4j
			; DATA XREF: seg017:off_19CFFo
mov	ax, [word_3C524] ; case	0x15
jmp	short loc_19CE6	; Jump

loc_19C80:		; CODE XREF: ILSe_display_text+C1j
cmp	[idk_Flag_w36026], 0 ; default
jnz	short loc_19C99	; Jump if Not Zero (ZF=0)
push	[bp+var_4]
push	[word_3C522]
push	[word_3C524]
call	sub_1ACAA	; Call Procedure
jmp	short loc_19CA9	; Jump

loc_19C99:		; CODE XREF: ILSe_display_text+13Cj
push	[bp+var_4]
push	[word_3C522]
push	[word_3C524]
call	sub_1AD1E	; Call Procedure

loc_19CA9:		; CODE XREF: ILSe_display_text+14Ej
add	sp, 6		; Add
mov	[word_3C524], ax
or	di, di		; Logical Inclusive OR
jz	short loc_19CCF	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 32	; Compare Two Operands
jnz	short loc_19CCF	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_C]
add	[word_3C524], ax ; Add
mov	ax, [bp+var_8]
cmp	ax, [bp+var_A]	; Compare Two Operands
jge	short loc_19CCC	; Jump if Greater or Equal (SF=OF)

loc_19CC8:		; Increment by 1
inc	[word_3C524]

loc_19CCC:		; CODE XREF: ILSe_display_text+17Dj
inc	[bp+var_8]	; Increment by 1

loc_19CCF:		; CODE XREF: ILSe_display_text+168j
			; ILSe_display_text+16Ej
jmp	short $+2	; Jump

loc_19CD1:		; CODE XREF: ILSe_display_text:loc_19C1Bj
			; ILSe_display_text:loc_19C29j
			; ILSe_display_text:loc_19C37j
			; ILSe_display_text:loc_19C45j
			; ILSe_display_text+118j
			; ILSe_display_text+130j
inc	[bp+var_2]	; Increment by 1

loc_19CD4:		; CODE XREF: ILSe_display_text:loc_19BEEj
mov	bx, [bp+var_2]

loc_19CD7:
mov	al, [bx+si]
cbw			; AL ->	AX (with sign)

loc_19CDA:
mov	[bp+var_4], ax
or	ax, ax		; Logical Inclusive OR

loc_19CDF:		; Jump if Zero (ZF=1)
jz	short loc_19CE4
jmp	loc_19BF1	; Jump

loc_19CE4:		; CODE XREF: ILSe_display_text:loc_19CDFj
jmp	short loc_19C7B	; case 0x15

loc_19CE6:		; CODE XREF: ILSe_display_text+135j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ILSe_display_text

db 0
word_19CED dw	   1,	  2,	 3,	4
			; DATA XREF: ILSe_display_text+B1o
dw    0Dh,   14h,   15h,   19h ; value table for switch	statement
dw    1Dh
off_19CFF dw offset loc_19C10 ;	jump table for switch statement
dw offset loc_19C1E
dw offset loc_19C2C
dw offset loc_19C3A
dw offset loc_19C48
dw offset loc_19C48
dw offset loc_19C7B
dw offset loc_19C63
dw offset loc_19C63


; Attributes: bp-based frame

proc sub_19D11 far
push	bp
mov	bp, sp
mov	[idk_Flag_w36026], 1
pop	bp
retf			; Return Far from Procedure
endp sub_19D11



; Attributes: bp-based frame

proc sub_19D1C far	; CODE XREF: ILSe_display_text+CFp
			; sub_1A296+99p
			; sub_1A7FF+CEp
			; sub_2BA41+120BP
			; sub_2CF44+D55P
push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_19D78 ; Call Procedure
pop	cx
pop	bp
retf			; Return Far from Procedure
endp sub_19D1C



; Attributes: bp-based frame

proc sub_19D2A far	; CODE XREF: ILSe_display_text+DDp
			; ILSe_display_text+F9p
			; sub_1A296+A3p
			; sub_1A296+B7p
			; sub_1A7FF+DBp
			; sub_1A7FF+F5p
			; sub_28963:loc_28CFCP
			; sub_2BA41:loc_2CAA8P
push	bp
mov	bp, sp
mov	ax, 19
push	ax

loc_19D31:
push	[bufFontsLbxEntry0]

loc_19D35:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_19D45	; Jump if Not Zero (ZF=0)

loc_19D41:		; Logical Exclusive OR
xor	ax, ax
jmp	short loc_19D48	; Jump

loc_19D45:		; CODE XREF: sub_19D2A+15j
mov	ax, 1

loc_19D48:		; CODE XREF: sub_19D2A+19j
push	ax
nop			; No Operation
push	cs
call	near ptr sub_19D78 ; Call Procedure
pop	cx
pop	bp

locret_19D50:		; Return Far from Procedure
retf
endp sub_19D2A



; Attributes: bp-based frame

proc sub_19D51 far	; CODE XREF: ILSe_display_text+EBp
			; sub_1A296+ADp
			; sub_1A7FF+E8p
push	bp
mov	bp, sp
mov	ax, 19
push	ax

loc_19D58:
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
cmp	ax, 2		; Compare Two Operands
jnz	short loc_19D6C	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_19D6F	; Jump

loc_19D6C:		; CODE XREF: sub_19D51+15j
mov	ax, 2

loc_19D6F:		; CODE XREF: sub_19D51+19j
push	ax

loc_19D70:		; No Operation
nop
push	cs

loc_19D72:		; Call Procedure
call	near ptr sub_19D78
pop	cx
pop	bp
retf			; Return Far from Procedure
endp sub_19D51



; Attributes: bp-based frame

proc sub_19D78 far	; CODE XREF: sub_19958+1CDp
			; sub_19D1C+8p
			; sub_19D2A+21p
			; sub_19D51:loc_19D72p
			; sub_1A0DC+19Fp
			; sub_1A5F1:loc_1A7DEp

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si

loc_19D7F:		; arg2_SI
push	di
mov	di, [bp+arg_0]
mov	ax, di
mov	cl, 4
shl	ax, cl		; Shift	Logical	Left
add	ax, 14h		; Add
mov	[bp+var_2], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_19DB5	; Jump

loc_19D93:		; CODE XREF: sub_19D78+40j
mov	ax, si

loc_19D95:		; Add
add	ax, [bp+var_2]
push	ax
push	[bufFontsLbxEntry0] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
push	ax		; argValue
push	si		; argOffset

loc_19DA6:		; argSegment
push	[bufFontsLbxEntry0]
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
add	si, 2		; Add

loc_19DB5:		; CODE XREF: sub_19D78+19j
cmp	si, 16		; Compare Two Operands
jl	short loc_19D93	; Jump if Less (SF!=OF)
push	di
mov	ax, 19
push	ax
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
pop	di
pop	si
mov	sp, bp

loc_19DCF:
pop	bp
retf			; Return Far from Procedure
endp sub_19D78



; Attributes: bp-based frame

proc sub_19DD1 far

argPtrCharArr= byte ptr	-16h
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
argNumber= word	ptr  0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 16h		; Integer Subtraction

loc_19DD7:
push	si
push	di
mov	si, [bp+arg_6]
call	fncCheckDebugMode ; Call Procedure
cmp	ax, 1		; Compare Two Operands
jnz	short loc_19DEA	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_19E68	; Jump

loc_19DEA:		; CODE XREF: sub_19DD1+13j
xor	di, di		; Logical Exclusive OR
jmp	short loc_19DEF	; Jump

loc_19DEE:		; CODE XREF: sub_19DD1+23j
inc	di		; Increment by 1

loc_19DEF:		; CODE XREF: sub_19DD1+1Bj
mov	bx, di
cmp	[byte ptr bx+si], 0 ; Compare Two Operands
jnz	short loc_19DEE	; Jump if Not Zero (ZF=0)
mov	ax, [idk_w3C520]
mov	[bp+var_6], ax
mov	ax, [idk_w3C51E]
mov	[bp+var_4], ax
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
push	si
push	[bp+arg_2]

loc_19E13:
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_19F94 ; Call Procedure
add	sp, 6		; Add
push	si
call	sub_1AF46	; Call Procedure
pop	cx
add	ax, 2		; Add
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_2], ax
mov	ax, 0Ah

loc_19E34:
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr

loc_19E39:		; argNumber
push	[bp+argNumber]
call	_itoa		; argNumber,argPtrCharArr,argConversionBase

loc_19E41:		; Add
add	sp, 6
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax

loc_19E48:
push	[bp+arg_2]
mov	ax, [bp+arg_0]
add	ax, [bp+var_2]	; Add
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs

loc_19E55:		; Call Procedure
call	near ptr sub_19F94
add	sp, 6		; Add
push	[bp+var_4]	; int
push	[bp+var_6]	; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx

loc_19E68:		; CODE XREF: sub_19DD1+17j
pop	di
pop	si
mov	sp, bp
pop	bp

locret_19E6D:		; Return Far from Procedure
retf
endp sub_19DD1



; Attributes: bp-based frame

proc sub_19E6E far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_19E6F:
mov	bp, sp
call	fncCheckDebugMode ; Call Procedure
cmp	ax, 1		; Compare Two Operands
jnz	short loc_19E7F	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_19E90	; Jump

loc_19E7F:		; CODE XREF: sub_19E6E+Bj
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_19F94 ; Call Procedure
add	sp, 6		; Add

loc_19E90:		; CODE XREF: sub_19E6E+Fj
pop	bp
retf			; Return Far from Procedure
endp sub_19E6E



; Attributes: bp-based frame

proc sub_19E92 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_19E93:
mov	bp, sp
call	fncCheckDebugMode ; Call Procedure

loc_19E9A:		; Compare Two Operands
cmp	ax, 1
jnz	short loc_19EA3	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_19ECA	; Jump

loc_19EA3:		; CODE XREF: sub_19E92+Bj
push	[bp+arg_6]
push	[bp+arg_4]

loc_19EA9:		; Logical Exclusive OR
xor	ax, ax
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
mov	ax, 9490h
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_19F94 ; Call Procedure
add	sp, 6		; Add

loc_19ECA:		; CODE XREF: sub_19E92+Fj
pop	bp
retf			; Return Far from Procedure
endp sub_19E92



; Attributes: bp-based frame

proc sub_19ECC far

argPtrCharArr= byte ptr	-10h
arg_0= word ptr	 6
arg_2= word ptr	 8
argNumber= word	ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
call	fncCheckDebugMode ; Call Procedure
cmp	ax, 1		; Compare Two Operands
jnz	short loc_19EE0	; Jump if Not Zero (ZF=0)

loc_19EDC:		; Logical Exclusive OR
xor	ax, ax
jmp	short loc_19F05	; Jump

loc_19EE0:		; CODE XREF: sub_19ECC+Ej
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber

loc_19EEB:		; argNumber,argPtrCharArr,argConversionBase
call	_itoa

loc_19EF0:		; Add
add	sp, 6
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs

loc_19EFF:		; Call Procedure
call	near ptr sub_19F94
add	sp, 6		; Add

loc_19F05:		; CODE XREF: sub_19ECC+12j
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19ECC



; Attributes: bp-based frame

proc sub_19F09 far

string=	byte ptr -10h
arg_0= word ptr	 6
arg_2= word ptr	 8
value= dword ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
call	fncCheckDebugMode ; Call Procedure
cmp	ax, 1		; Compare Two Operands
jnz	short loc_19F1D	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_19F45	; Jump

loc_19F1D:		; CODE XREF: sub_19F09+Ej
mov	ax, 0Ah
push	ax
lea	ax, [bp+string]	; Load Effective Address
push	ax		; string
push	[word ptr bp+value+2]
push	[word ptr bp+value] ; value
call	_ltoa		; char *LtoA(long value, char ^string, int radix)
			;   converts value to a	null-terminated	string and stores the result in	string
			; Parameters:
			;   value   long integer to be converted
			;   string  pointer to character array
			;   radix   the	base to	be used	in converting
			; Return:
			;   LtoA returns a pointer to string.
			;

loc_19F30:		; Add
add	sp, 8
lea	ax, [bp+string]	; Load Effective Address
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_19F94 ; Call Procedure
add	sp, 6		; Add

loc_19F45:		; CODE XREF: sub_19F09+12j
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19F09



; Attributes: bp-based frame

proc sub_19F49 far

string=	byte ptr -14h
value= dword ptr -4
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp

loc_19F4C:		; Integer Subtraction
sub	sp, 14h
call	fncCheckDebugMode ; Call Procedure
cmp	ax, 1		; Compare Two Operands
jnz	short loc_19F5D	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_19F90	; Jump

loc_19F5D:		; CODE XREF: sub_19F49+Ej
mov	ax, [bp+arg_4]
mov	[word ptr bp+value+2], 0
mov	[word ptr bp+value], ax
mov	ax, 0Ah
push	ax
lea	ax, [bp+string]	; Load Effective Address
push	ax		; string
push	[word ptr bp+value+2]

loc_19F73:		; value
push	[word ptr bp+value]
call	_ultoa		; Call Procedure

loc_19F7B:		; Add
add	sp, 8
lea	ax, [bp+string]	; Load Effective Address
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_19F94 ; Call Procedure
add	sp, 6		; Add

loc_19F90:		; CODE XREF: sub_19F49+12j
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19F49



; Attributes: bp-based frame

proc sub_19F94 far	; CODE XREF: sub_19DD1+47p
			; sub_19DD1:loc_19E55p
			; sub_19E6E+1Cp
			; sub_19E92+32p
			; sub_19ECC:loc_19EFFp
			; sub_19F09+36p
			; sub_19F49+41p

varVideoMemory=	word ptr -0Eh
var__idk_ScrnPosY199_w35EC8= word ptr -0Ch
var__idk_ScrnPosX319_w35EC6= word ptr -0Ah
var__idk_ScrnPosY0_w35EC4= word	ptr -8
var__idk_ScrnPosX0_w35EC2= word	ptr -6
var__idk_w3C520= word ptr -4
var__idk_w3C51E= word ptr -2
arg_SI=	word ptr  6
arg_DI=	word ptr  8
arg_4= word ptr	 0Ah

push	bp

loc_19F95:
mov	bp, sp
sub	sp, 0Eh		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_SI]
mov	di, [bp+arg_DI]
mov	ax, [g_ptrVideoRamBuffer]
mov	[bp+varVideoMemory], ax
mov	ax, si

loc_19FAA:
mov	dx, 10
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, di
mov	dx, 10
imul	dx		; Signed Multiply
mov	di, ax

loc_19FBA:
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	[bp+var__idk_ScrnPosX0_w35EC2],	ax
mov	ax, [idk_ScrnPosY0_w35EC4]
mov	[bp+var__idk_ScrnPosY0_w35EC4],	ax

loc_19FC6:
mov	ax, [idk_ScrnPosX319_w35EC6]
mov	[bp+var__idk_ScrnPosX319_w35EC6], ax
mov	ax, [idk_ScrnPosY199_w35EC8]
mov	[bp+var__idk_ScrnPosY199_w35EC8], ax

loc_19FD2:
mov	ax, 0C7h ; ''

loc_19FD5:
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR

loc_19FDC:
push	ax

loc_19FDD:		; Logical Exclusive OR
xor	ax, ax
push	ax
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
mov	ax, [idk_w3C520]
mov	[bp+var__idk_w3C520], ax

loc_19FEE:
mov	ax, [idk_w3C51E]
mov	[bp+var__idk_w3C51E], ax
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx


call	idk_VGA_s1E4BA	; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 16

loc_1A00C:
push	ax

loc_1A00D:
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	dx, di

loc_1A01A:		; Add
add	dx, ax

loc_1A01C:		; Add
add	dx, 5
push	dx
push	[bp+arg_4]
call	sub_1AF46	; Call Procedure

loc_1A028:
pop	cx
mov	dx, si
add	dx, ax		; Add
add	dx, 4		; Add

loc_1A030:
push	dx
mov	ax, di
add	ax, 0FFFDh	; Add
push	ax
mov	ax, si
add	ax, 0FFFDh	; Add
push	ax
call	sub_17FA0	; Call Procedure
add	sp, 0Ah		; Add
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax

loc_1A04C:
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A0DC ; Call Procedure
add	sp, 6		; Add
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 10h
push	ax

loc_1A064:
push	[bufFontsLbxEntry0]

loc_1A068:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx

loc_1A06E:
pop	cx

loc_1A06F:
mov	dx, di
add	dx, ax		; Add

loc_1A073:		; Add
add	dx, 5
push	dx
push	[bp+arg_4]
call	sub_1AF46	; Call Procedure
pop	cx
mov	dx, si
add	dx, ax		; Add
add	dx, 4		; Add
push	dx
mov	ax, di
add	ax, 0FFFDh	; Add
push	ax
mov	ax, si
add	ax, 0FFFDh	; Add
push	ax

loc_1A094:		; Call Procedure
call	sub_17FA0

loc_1A099:		; Add
add	sp, 0Ah
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax

loc_1A0A3:
mov	ax, si
inc	ax		; Increment by 1

loc_1A0A6:
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A0DC ; Call Procedure

loc_1A0AC:		; Add
add	sp, 6
push	[bp+var__idk_ScrnPosY199_w35EC8]
push	[bp+var__idk_ScrnPosX319_w35EC6]
push	[bp+var__idk_ScrnPosY0_w35EC4]
push	[bp+var__idk_ScrnPosX0_w35EC2]

loc_1A0BB:		; dx = arg_0 ... word_35EC2
call	wtfCompareSwap	; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
push	[bp+var__idk_w3C51E] ; int

loc_1A0C6:		; int
push	[bp+var__idk_w3C520]

loc_1A0C9:		; Call Procedure
call	idk_PalFnt_s1AB64
pop	cx
pop	cx
mov	ax, [bp+varVideoMemory]
mov	[g_ptrVideoRamBuffer], ax

loc_1A0D6:
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_19F94



; Attributes: bp-based frame

proc sub_1A0DC far	; CODE XREF: sub_195C3+24p
			; sub_197CD+25p
			; sub_19804:loc_1982Cp
			; sub_1983E:loc_19860p
			; sub_19873+28p
			; sub_19F94+BEp
			; sub_19F94+115p
			; sub_1B241+5DP

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]

loc_1A0EA:
mov	ax, 12h
push	ax

loc_1A0EE:
push	[bufFontsLbxEntry0]

loc_1A0F2:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx

loc_1A0F9:
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands

loc_1A100:		; Jump if Not Zero (ZF=0)
jnz	short loc_1A105
jmp	loc_1A27F	; Jump

loc_1A105:		; CODE XREF: sub_1A0DC:loc_1A100j
mov	[bp+var_4], 0
jmp	short loc_1A122	; Jump

loc_1A10C:		; CODE XREF: sub_1A0DC+4Aj
push	[word_36024]
push	[bp+var_4]
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
inc	[bp+var_4]	; Increment by 1

loc_1A122:		; CODE XREF: sub_1A0DC+2Ej
cmp	[bp+var_4], 10h	; Compare Two Operands
jl	short loc_1A10C	; Jump if Less (SF!=OF)

loc_1A128:		; Compare Two Operands
cmp	[bp+var_2], 2

loc_1A12C:		; Jump if Zero (ZF=1)
jz	short loc_1A16A
xor	ax, ax		; Logical Exclusive OR

loc_1A130:
push	ax

loc_1A131:
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs

loc_1A13E:		; Call Procedure
call	near ptr sub_1A296
add	sp, 8		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]

loc_1A14A:
mov	ax, di

loc_1A14C:		; Increment by 1
inc	ax
push	ax
push	si

loc_1A14F:		; No Operation
nop
push	cs

loc_1A151:		; Call Procedure
call	near ptr sub_1A296

loc_1A154:		; Add
add	sp, 8
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	di
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A296 ; Call Procedure
add	sp, 8		; Add

loc_1A16A:		; CODE XREF: sub_1A0DC:loc_1A12Cj
cmp	[bp+var_2], 1	; Compare Two Operands

loc_1A16E:		; Jump if Zero (ZF=1)
jz	short loc_1A1B2

loc_1A170:		; Compare Two Operands
cmp	[bp+var_2], 3

loc_1A174:		; Jump if Zero (ZF=1)
jz	short loc_1A1B2
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1A179:
push	[bp+arg_4]
push	di
mov	ax, si
dec	ax		; Decrement by 1

loc_1A180:
push	ax
nop			; No Operation
push	cs

loc_1A183:		; Call Procedure
call	near ptr sub_1A296
add	sp, 8		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1A18C:
push	[bp+arg_4]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation

loc_1A198:
push	cs
call	near ptr sub_1A296 ; Call Procedure

loc_1A19C:		; Add
add	sp, 8
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]

loc_1A1A5:
mov	ax, di
dec	ax		; Decrement by 1
push	ax
push	si
nop			; No Operation

loc_1A1AB:
push	cs
call	near ptr sub_1A296 ; Call Procedure
add	sp, 8		; Add

loc_1A1B2:		; CODE XREF: sub_1A0DC:loc_1A16Ej
			; sub_1A0DC:loc_1A174j
cmp	[bp+var_2], 3	; Compare Two Operands
jz	short loc_1A1BE	; Jump if Zero (ZF=1)
cmp	[bp+var_2], 5	; Compare Two Operands
jnz	short loc_1A208	; Jump if Not Zero (ZF=0)

loc_1A1BE:		; CODE XREF: sub_1A0DC+DAj
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di

loc_1A1C6:		; Add
add	ax, 2
push	ax
mov	ax, si

loc_1A1CC:		; Add
add	ax, 2
push	ax
nop			; No Operation
push	cs

loc_1A1D2:		; Call Procedure
call	near ptr sub_1A296
add	sp, 8		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
add	ax, 2		; Add
push	ax
mov	ax, si

loc_1A1E6:		; Increment by 1
inc	ax

loc_1A1E7:
push	ax
nop			; No Operation
push	cs

loc_1A1EA:		; Call Procedure
call	near ptr sub_1A296
add	sp, 8		; Add

loc_1A1F0:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_1A1F3:
push	[bp+arg_4]
mov	ax, di

loc_1A1F8:		; Increment by 1
inc	ax
push	ax

loc_1A1FA:
mov	ax, si
add	ax, 2		; Add
push	ax

loc_1A200:		; No Operation
nop
push	cs
call	near ptr sub_1A296 ; Call Procedure
add	sp, 8		; Add

loc_1A208:		; CODE XREF: sub_1A0DC+E0j
cmp	[bp+var_2], 3	; Compare Two Operands

loc_1A20C:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_1A23A
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]

loc_1A214:
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs

loc_1A21E:		; Call Procedure
call	near ptr sub_1A296
add	sp, 8		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]

loc_1A22A:
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A296 ; Call Procedure
add	sp, 8		; Add

loc_1A23A:		; CODE XREF: sub_1A0DC:loc_1A20Cj
cmp	[bp+var_2], 5	; Compare Two Operands
jnz	short loc_1A26A	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	di
mov	ax, si

loc_1A249:		; Add
add	ax, 2

loc_1A24C:
push	ax
nop			; No Operation
push	cs

loc_1A24F:		; Call Procedure
call	near ptr sub_1A296
add	sp, 8		; Add

loc_1A255:		; Logical Exclusive OR
xor	ax, ax
push	ax
push	[bp+arg_4]
mov	ax, di
add	ax, 2		; Add
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_1A296 ; Call Procedure
add	sp, 8		; Add

loc_1A26A:		; CODE XREF: sub_1A0DC+162j
mov	ax, 13h

loc_1A26D:
push	ax
push	[bufFontsLbxEntry0]

loc_1A272:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx
push	ax
push	cs
call	near ptr sub_19D78 ; Call Procedure
pop	cx

loc_1A27F:		; CODE XREF: sub_1A0DC+26j
mov	ax, 1
push	ax
push	[bp+arg_4]
push	di
push	si

loc_1A288:		; No Operation
nop
push	cs
call	near ptr sub_1A296 ; Call Procedure
add	sp, 8		; Add
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A0DC



; Attributes: bp-based frame

proc sub_1A296 far	; CODE XREF: sub_1A0DC:loc_1A13Ep
			; sub_1A0DC:loc_1A151p
			; sub_1A0DC+88p
			; sub_1A0DC:loc_1A183p
			; sub_1A0DC+BDp
			; sub_1A0DC+D0p
			; sub_1A0DC:loc_1A1D2p
			; sub_1A0DC:loc_1A1EAp
			; sub_1A0DC+126p
			; sub_1A0DC:loc_1A21Ep
			; sub_1A0DC+158p
			; sub_1A0DC:loc_1A24Fp
			; sub_1A0DC+188p
			; sub_1A0DC+1AEp

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_1A297:
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction

loc_1A29C:
push	si

loc_1A29D:		; arg2_SI
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_6]
mov	[bp+var_2], 0
mov	[word_3C524], si

loc_1A2AD:
mov	ax, [bp+arg_2]

loc_1A2B0:
mov	[word_3C522], ax
mov	ax, 10h

loc_1A2B6:
push	ax
push	[bufFontsLbxEntry0] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax

loc_1A2C5:
mov	ax, [bp+arg_2]
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_1A2D3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1A2CE:		; CODE XREF: sub_1A296+49j
xor	ax, ax		; Logical Exclusive OR

loc_1A2D0:		; CODE XREF: sub_1A296:loc_1A2E9j
			; sub_1A296+71j
			; sub_1A296+ECj
jmp	loc_1A385	; Jump

loc_1A2D3:		; CODE XREF: sub_1A296+36j
mov	ax, [bp+arg_2]
add	ax, [bp+var_4]	; Add
cmp	ax, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jg	short loc_1A2E1	; Jump if Greater (ZF=0	& SF=OF)
jmp	short loc_1A2CE	; Jump

loc_1A2E1:		; CODE XREF: sub_1A296+47j
cmp	si, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jle	short loc_1A2EB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1A2E7:
mov	ax, si

loc_1A2E9:		; Jump
jmp	short loc_1A2D0

loc_1A2EB:		; CODE XREF: sub_1A296+4Fj
push	[bp+arg_4]
call	sub_1AF46	; Call Procedure
pop	cx

loc_1A2F4:
mov	[bp+var_6], ax
mov	ax, si

loc_1A2F9:		; Add
add	ax, [bp+var_6]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands

loc_1A300:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1A309
mov	ax, si
add	ax, [bp+var_6]	; Add
jmp	short loc_1A2D0	; Jump

loc_1A309:		; CODE XREF: sub_1A296:loc_1A300j
jmp	short loc_1A36F	; Jump

loc_1A30B:		; CODE XREF: sub_1A296+E7j
mov	ax, [bp+var_8]

loc_1A30E:
mov	[bp+var_A], ax
mov	cx, 9		; switch 9 cases
mov	bx, offset word_1A38B

loc_1A317:		; CODE XREF: sub_1A296+8Cj
mov	ax, [cs:bx]
cmp	ax, [bp+var_A]	; Compare Two Operands
jz	short loc_1A326	; Jump if Zero (ZF=1)
add	bx, 2		; Add
loop	loc_1A317	; Loop while CX	!= 0
jmp	short loc_1A354	; default

loc_1A326:		; CODE XREF: sub_1A296+87j
jmp	[word ptr cs:bx+12h] ; switch jump

loc_1A32A:		; DATA XREF: seg017:off_1A39Do
or	di, di		; case 0x1
jz	short loc_1A332	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_19D1C ; Call Procedure

loc_1A332:		; CODE XREF: sub_1A296+96j
jmp	short loc_1A36C	; Jump

loc_1A334:		; CODE XREF: sub_1A296:loc_1A326j
			; DATA XREF: seg017:off_1A39Do
or	di, di		; case 0x2
jz	short loc_1A33C	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_19D2A ; Call Procedure

loc_1A33C:		; CODE XREF: sub_1A296+A0j
jmp	short loc_1A36C	; Jump

loc_1A33E:		; CODE XREF: sub_1A296:loc_1A326j
			; DATA XREF: seg017:off_1A39Do
or	di, di		; case 0x3
jz	short loc_1A346	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_19D51 ; Call Procedure

loc_1A346:		; CODE XREF: sub_1A296+AAj
jmp	short loc_1A36C	; Jump

loc_1A348:		; CODE XREF: sub_1A296:loc_1A326j
			; DATA XREF: seg017:off_1A39Do
or	di, di		; case 0x4
jz	short loc_1A350	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_19D2A ; Call Procedure

loc_1A350:		; CODE XREF: sub_1A296+B4j
jmp	short loc_1A36C	; Jump

loc_1A352:		; CODE XREF: sub_1A296:loc_1A326j
			; DATA XREF: seg017:off_1A39Do
jmp	short loc_1A37F	; case 0xD

loc_1A354:		; CODE XREF: sub_1A296+8Ej
push	[bp+var_8]	; default
push	[word_3C522]
push	[word_3C524]
nop			; No Operation
push	cs
call	near ptr sub_1A3AF ; Call Procedure
add	sp, 6		; Add
mov	[word_3C524], ax
jmp	short $+2	; Jump

loc_1A36C:		; CODE XREF: sub_1A296:loc_1A332j
			; sub_1A296:loc_1A33Cj
			; sub_1A296:loc_1A346j
			; sub_1A296:loc_1A350j
inc	[bp+var_2]	; Increment by 1

loc_1A36F:		; CODE XREF: sub_1A296:loc_1A309j
mov	bx, [bp+arg_4]
add	bx, [bp+var_2]	; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_8], ax
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1A30B	; Jump if Not Zero (ZF=0)

loc_1A37F:		; CODE XREF: sub_1A296:loc_1A352j
mov	ax, [word_3C524]
jmp	loc_1A2D0	; Jump

loc_1A385:		; CODE XREF: sub_1A296:loc_1A2D0j
pop	di
pop	si

loc_1A387:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A296

word_1A38B dw	   1,	  2,	 3,	4
			; DATA XREF: sub_1A296+7Eo
dw    0Dh,   14h,   15h,   19h ; value table for switch	statement
dw    1Dh
off_1A39D dw offset loc_1A32A ;	jump table for switch statement
dw offset loc_1A334
dw offset loc_1A33E
dw offset loc_1A348
dw offset loc_1A352
dw offset loc_1A352
dw offset loc_1A352
dw offset loc_1A352
dw offset loc_1A352


; Attributes: bp-based frame

proc sub_1A3AF far	; CODE XREF: sub_1A296+CBp

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_1A3B0:
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
push	si

loc_1A3B6:
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
mov	ax, [bp+arg_4]

loc_1A3C0:		; Add
add	ax, 0FFE0h
mov	[bp+var_C], ax

loc_1A3C6:		; Compare Two Operands
cmp	[bp+var_C], 0
jl	short loc_1A3D2	; Jump if Less (SF!=OF)

loc_1A3CC:		; Compare Two Operands
cmp	[bp+var_C], 5Eh	; '^'
jle	short loc_1A3D7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1A3D2:		; CODE XREF: sub_1A3AF+1Bj
mov	ax, si

loc_1A3D4:		; CODE XREF: sub_1A3AF:loc_1A4C8j
jmp	loc_1A4CB	; Jump

loc_1A3D7:		; CODE XREF: sub_1A3AF+21j
push	ds
mov	ax, [bufFontsLbxEntry0]

loc_1A3DB:
mov	ds, ax
mov	ax, [word_31D20]
mov	[bp+var_6], ax
mov	ax, [word ptr ZeroDivMSG] ; "Divide error\r\n"
mov	[bp+var_A], ax
mov	bx, [bp+var_C]
mov	al, [bx+4Ah]
xor	ah, ah		; Logical Exclusive OR
mov	[bp+var_8], ax
pop	ds

loc_1A3F5:		; Compare Two Operands
cmp	si, [idk_ScrnPosX0_w35EC2]
jl	short loc_1A42A	; Jump if Less (SF!=OF)
mov	ax, si
add	ax, [bp+var_8]	; Add
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jg	short loc_1A42A	; Jump if Greater (ZF=0	& SF=OF)
cmp	di, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jl	short loc_1A42A	; Jump if Less (SF!=OF)
mov	ax, di
add	ax, [bp+var_6]	; Add
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jg	short loc_1A42A	; Jump if Greater (ZF=0	& SF=OF)
push	[bp+arg_4]
push	di
push	si
call	sub_1ACAA	; Call Procedure

loc_1A421:		; Add
add	sp, 6
mov	[bp+var_2], ax
jmp	loc_1A4C5	; Jump

loc_1A42A:		; CODE XREF: sub_1A3AF+4Aj
			; sub_1A3AF+55j
			; sub_1A3AF+5Bj
			; sub_1A3AF+66j
mov	ax, si
add	ax, [bp+var_8]	; Add

loc_1A42F:		; Add
add	ax, [bp+var_A]
mov	[bp+var_2], ax
cmp	si, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jge	short loc_1A459	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_ScrnPosX0_w35EC2]
sub	ax, si		; Integer Subtraction
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
cmp	ax, [bp+var_8]	; Compare Two Operands
jl	short loc_1A44D	; Jump if Less (SF!=OF)
jmp	short loc_1A4C5	; Jump

loc_1A44D:		; CODE XREF: sub_1A3AF+9Aj
mov	si, [idk_ScrnPosX0_w35EC2]
mov	ax, [bp+var_4]
sub	[bp+var_8], ax	; Integer Subtraction
jmp	short loc_1A45E	; Jump

loc_1A459:		; CODE XREF: sub_1A3AF+8Aj
mov	[bp+var_4], 0

loc_1A45E:		; CODE XREF: sub_1A3AF+A8j
mov	ax, si
add	ax, [bp+var_8]	; Add

loc_1A463:		; Compare Two Operands
cmp	ax, [idk_ScrnPosX319_w35EC6]
jle	short loc_1A47A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_ScrnPosX319_w35EC6]
inc	ax		; Increment by 1
sub	ax, si		; Integer Subtraction

loc_1A46F:
mov	[bp+var_8], ax
cmp	[bp+var_8], 1	; Compare Two Operands
jge	short loc_1A47A	; Jump if Greater or Equal (SF=OF)
jmp	short loc_1A4C5	; Jump

loc_1A47A:		; CODE XREF: sub_1A3AF+B8j
			; sub_1A3AF+C7j
cmp	di, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jge	short loc_1A48E	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_ScrnPosY0_w35EC4]
sub	ax, di		; Integer Subtraction
mov	[bp+var_E], ax
mov	di, [idk_ScrnPosY0_w35EC4]

loc_1A48C:		; Jump
jmp	short loc_1A493

loc_1A48E:		; CODE XREF: sub_1A3AF+CFj
mov	[bp+var_E], 0

loc_1A493:		; CODE XREF: sub_1A3AF:loc_1A48Cj
mov	ax, di
add	ax, [bp+var_6]	; Add
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_1A4A6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_ScrnPosY199_w35EC8]
inc	ax		; Increment by 1
sub	ax, di		; Integer Subtraction
jmp	short loc_1A4A9	; Jump

loc_1A4A6:		; CODE XREF: sub_1A3AF+EDj
mov	ax, [bp+var_6]

loc_1A4A9:		; CODE XREF: sub_1A3AF+F5j
mov	[bp+var_10], ax
push	[bp+var_10]
push	[bp+var_E]
push	[bp+var_8]
push	[bp+var_4]
push	[bp+var_C]

loc_1A4BB:
push	di
push	si

loc_1A4BD:		; Call Procedure
call	sub_1AF9B
add	sp, 0Eh		; Add

loc_1A4C5:		; CODE XREF: sub_1A3AF+78j
			; sub_1A3AF+9Cj
			; sub_1A3AF+C9j
mov	ax, [bp+var_2]

loc_1A4C8:		; Jump
jmp	loc_1A3D4

loc_1A4CB:		; CODE XREF: sub_1A3AF:loc_1A3D4j
pop	di

loc_1A4CC:
pop	si

loc_1A4CD:
mov	sp, bp

loc_1A4CF:
pop	bp
retf			; Return Far from Procedure
endp sub_1A3AF



; Attributes: bp-based frame

proc sub_1A4D1 far	; CODE XREF: sub_28D4A:loc_28D78P
			; sub_28F19+2EP
			; sub_290A9:loc_290D8P
			; sub_29731+A9P
			; sub_2A755+1ABP
			; sub_2A755+2E4P
			; sub_2A755+3DCP
			; sub_2A755+4A8P
			; sub_2A755+5BBP
			; sub_2A755+6ABP
			; sub_2A755+7E0P
			; sub_2A755+8A8P
			; sub_2A755+97CP
			; sub_2B1F9+117P

var_2= word ptr	-2

push	bp
mov	bp, sp

loc_1A4D4:		; Integer Subtraction
sub	sp, 2
mov	ax, [idk_w3C520]
mov	[bp+var_2], ax
mov	ax, [bp+var_2]

loc_1A4E0:		; Jump
jmp	short $+2
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A4D1



; Attributes: bp-based frame

proc sub_1A4E6 far	; CODE XREF: sub_28D4A:loc_28D91P
			; sub_28F19+47P
			; sub_290A9+48P
			; sub_29731+C2P
			; sub_2A755+1A5P
			; sub_2A755:loc_2AA33P
			; sub_2A755+3D6P
			; sub_2A755+4A2P
			; sub_2A755+5B5P
			; sub_2A755+6A5P
			; sub_2A755+7DAP
			; sub_2A755+8A2P
			; sub_2A755+976P
			; sub_2B1F9+111P

var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
mov	ax, [idk_w3C51E]
mov	[bp+var_2], ax
mov	ax, [bp+var_2]

loc_1A4F5:		; Jump
jmp	short $+2
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A4E6



; Attributes: bp-based frame

proc sub_1A4FB far	; CODE XREF: sub_28D4A:loc_28DAAP
			; sub_28F19+60P
			; sub_290A9+61P
			; sub_2A755+25P

var_2= word ptr	-2

push	bp
mov	bp, sp

loc_1A4FE:		; Integer Subtraction
sub	sp, 2
mov	ax, [word_3C51C]
mov	[bp+var_2], ax
mov	ax, [bp+var_2]

loc_1A50A:		; Jump
jmp	short $+2

loc_1A50C:
mov	sp, bp
pop	bp

locret_1A50F:		; Return Far from Procedure
retf
endp sub_1A4FB



; Attributes: bp-based frame

proc sub_1A510 far	; CODE XREF: sub_2A755+1DP
			; sub_2B1F9+10BP

var_2= word ptr	-2

push	bp

loc_1A511:
mov	bp, sp
sub	sp, 2		; Integer Subtraction

loc_1A516:
mov	ax, [word_3C51A]

loc_1A519:
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
jmp	short $+2	; Jump

loc_1A521:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A510



; Attributes: bp-based frame

proc sub_1A525 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	[bp+arg_4]
push	[bp+arg_2]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, [bp+arg_0]

loc_1A534:		; Add
add	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1A525



; Attributes: bp-based frame

proc sub_1A542 far	; CODE XREF: sub_2A755:loc_2A7A1P
			; sub_2B1F9+30P
			; sub_2BA41+A60P
			; sub_2CF44+C4EP

var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
mov	ax, 44h	; 'D'
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
push	ax		; argPtrSrcBuf

loc_1A558:
mov	ax, 10h
push	ax

loc_1A55C:		; argOffset
push	[bufFontsLbxEntry0]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
pop	dx
sub	dx, ax		; Integer Subtraction

loc_1A56A:
mov	[bp+var_2], dx

loc_1A56D:
mov	ax, [bp+var_2]

loc_1A570:		; Jump
jmp	short $+2
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A542



; Attributes: bp-based frame

; int __fastcall __far sub_1A576(int, int, int,	char *dest)
proc sub_1A576 far	; CODE XREF: idk_Load_NEWGAME_LBX+C2P

var_4= word ptr	-4
var_2= word ptr	-2
argDest= dword ptr  6

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di		; argSrc
mov	si, [word ptr bp+argDest]
mov	[bp+var_2], 0

loc_1A586:		; Jump
jmp	short loc_1A58B

loc_1A588:		; CODE XREF: sub_1A576+1Bj
inc	[bp+var_2]	; Increment by 1

loc_1A58B:		; CODE XREF: sub_1A576:loc_1A586j
mov	bx, [bp+var_2]
cmp	[byte ptr bx+si], 20h ;	' ' ; Compare Two Operands
jz	short loc_1A588	; Jump if Zero (ZF=1)
mov	ax, si

loc_1A595:		; Add
add	ax, [bp+var_2]
push	ax

loc_1A599:		; argDest
push	si
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
xor	di, di		; Logical Exclusive OR

loc_1A5A3:
mov	[bp+var_4], 0FFFFh
jmp	short loc_1A5BC	; Jump

loc_1A5AA:		; CODE XREF: sub_1A576+4Bj
mov	bx, di
cmp	[byte ptr bx+si], 20h ;	' ' ; Compare Two Operands
jnz	short loc_1A5B6	; Jump if Not Zero (ZF=0)
mov	[bp+var_4], di

loc_1A5B4:		; Jump
jmp	short loc_1A5BB

loc_1A5B6:		; CODE XREF: sub_1A576+39j
mov	[bp+var_4], 0FFFFh

loc_1A5BB:		; CODE XREF: sub_1A576:loc_1A5B4j
inc	di		; Increment by 1

loc_1A5BC:		; CODE XREF: sub_1A576+32j
mov	bx, di

loc_1A5BE:		; Compare Two Operands
cmp	[byte ptr bx+si], 0
jnz	short loc_1A5AA	; Jump if Not Zero (ZF=0)

loc_1A5C3:		; Compare Two Operands
db 83h,7Eh,0FCh,0FFh ; <BAD>cmp	    [bp+var_4],	0FFFFh
jz	short loc_1A5CF	; Jump if Zero (ZF=1)
mov	bx, [bp+var_4]

loc_1A5CC:
mov	[byte ptr bx+si], 0

loc_1A5CF:		; CODE XREF: sub_1A576+51j
pop	di

loc_1A5D0:
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A576



; Attributes: bp-based frame

proc sub_1A5D5 far	; CODE XREF: sub_1A9A8+24p
			; sub_1A9DF+2Ap
			; sub_1AA40+26p
			; sub_1BC65+5DP
			; sub_1BC65+174P
			; sub_56240+110P
			; sub_56240+148P
			; sub_56240+170P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_1A5F1 ; Call Procedure
add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1A5D5



; Attributes: bp-based frame

proc sub_1A5F1 far	; CODE XREF: sub_1A5D5+14p
			; sub_1AA1C:loc_1AA37p

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp

loc_1A5F2:
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]

loc_1A5FC:
mov	di, [bp+arg_2]

loc_1A5FF:
mov	ax, 12h
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx

loc_1A60E:
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_1A61A	; Jump if Not Zero (ZF=0)
jmp	loc_1A7E2	; Jump

loc_1A61A:		; CODE XREF: sub_1A5F1+24j
mov	[bp+var_4], 0

loc_1A61F:		; Jump
jmp	short loc_1A637

loc_1A621:		; CODE XREF: sub_1A5F1+4Aj
push	[word_36024]
push	[bp+var_4]
push	[bufFontsLbxEntry0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_1A631:		; Add
add	sp, 6
inc	[bp+var_4]	; Increment by 1

loc_1A637:		; CODE XREF: sub_1A5F1:loc_1A61Fj
cmp	[bp+var_4], 10h	; Compare Two Operands
jl	short loc_1A621	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 2	; Compare Two Operands
jz	short loc_1A691	; Jump if Zero (ZF=1)

loc_1A643:
push	[bp+arg_8]
push	[bp+arg_6]

loc_1A649:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_1A64C:
push	[bp+arg_4]
mov	ax, di

loc_1A651:		; Increment by 1
inc	ax
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	si

loc_1A670:		; No Operation
nop
push	cs
call	near ptr sub_1A7FF ; Call Procedure

loc_1A675:		; Add
add	sp, 0Ch

loc_1A678:
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	di
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add

loc_1A691:		; CODE XREF: sub_1A5F1+50j
cmp	[bp+var_2], 1	; Compare Two Operands
jz	short loc_1A6EB	; Jump if Zero (ZF=1)
cmp	[bp+var_2], 3	; Compare Two Operands
jz	short loc_1A6EB	; Jump if Zero (ZF=1)
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	di
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add
push	[bp+arg_8]

loc_1A6D5:
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add

loc_1A6EB:		; CODE XREF: sub_1A5F1+A4j
			; sub_1A5F1+AAj
cmp	[bp+var_2], 3	; Compare Two Operands
jz	short loc_1A6F7	; Jump if Zero (ZF=1)
cmp	[bp+var_2], 5	; Compare Two Operands
jnz	short loc_1A753	; Jump if Not Zero (ZF=0)

loc_1A6F7:		; CODE XREF: sub_1A5F1+FEj
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
add	ax, 2		; Add
push	ax
mov	ax, si
add	ax, 2		; Add
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add

loc_1A717:
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
add	ax, 2		; Add
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs

loc_1A72F:		; Call Procedure
call	near ptr sub_1A7FF
add	sp, 0Ch		; Add
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si

loc_1A747:		; Add
add	ax, 2

loc_1A74A:
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add

loc_1A753:		; CODE XREF: sub_1A5F1+104j
cmp	[bp+var_2], 3	; Compare Two Operands
jle	short loc_1A791	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
dec	ax		; Decrement by 1
push	ax

loc_1A769:
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1A77E:
push	[bp+arg_4]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1

loc_1A788:
push	ax
nop			; No Operation
push	cs

loc_1A78B:		; Call Procedure
call	near ptr sub_1A7FF

loc_1A78E:		; Add
add	sp, 0Ch

loc_1A791:		; CODE XREF: sub_1A5F1+166j
cmp	[bp+var_2], 5	; Compare Two Operands

loc_1A795:		; Jump if Not Zero (ZF=0)
jnz	short loc_1A7CD
push	[bp+arg_8]
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
push	di
mov	ax, si
add	ax, 2		; Add
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add
push	[bp+arg_8]

loc_1A7B5:
push	[bp+arg_6]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_4]
mov	ax, di
add	ax, 2		; Add
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add

loc_1A7CD:		; CODE XREF: sub_1A5F1:loc_1A795j
mov	ax, 13h
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure

loc_1A7DA:
pop	cx
pop	cx
push	ax
push	cs

loc_1A7DE:		; Call Procedure
call	near ptr sub_19D78
pop	cx

loc_1A7E2:		; CODE XREF: sub_1A5F1+26j
push	[bp+arg_8]
push	[bp+arg_6]
mov	ax, 1
push	ax

loc_1A7EC:
push	[bp+arg_4]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_1A7FF ; Call Procedure
add	sp, 0Ch		; Add
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A5F1



; Attributes: bp-based frame

proc sub_1A7FF far	; CODE XREF: sub_1A5F1+68p
			; sub_1A5F1+81p
			; sub_1A5F1+9Ap
			; sub_1A5F1+BFp
			; sub_1A5F1+DBp
			; sub_1A5F1+F4p
			; sub_1A5F1+120p
			; sub_1A5F1:loc_1A72Fp
			; sub_1A5F1+15Cp
			; sub_1A5F1+17Ep
			; sub_1A5F1:loc_1A78Bp
			; sub_1A5F1+1BBp
			; sub_1A5F1+1D6p
			; sub_1A5F1+202p

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
push	si
push	di		; arg2_SI
mov	si, [bp+arg_4]
mov	di, [bp+arg_8]

loc_1A80D:
mov	[bp+var_2], 0

loc_1A812:
mov	ax, [bp+arg_0]

loc_1A815:
mov	[word_3C524], ax
mov	ax, [bp+arg_2]

loc_1A81B:
mov	[word_3C522], ax

loc_1A81E:		; Logical Inclusive OR
or	di, di

loc_1A820:		; Jump if Not Zero (ZF=0)
jnz	short loc_1A825
db 0E9h,7Fh,0 ;	<BAD>jmp     loc_1A8A4 ; Jump

loc_1A825:		; CODE XREF: sub_1A7FF:loc_1A820j
mov	[bp+var_8], 0
mov	[bp+var_A], 0

loc_1A82F:
mov	[bp+var_E], 0
mov	[bp+var_6], 0
jmp	short loc_1A849	; Jump

loc_1A83B:		; CODE XREF: sub_1A7FF+78j
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 20h ;	' ' ; Compare Two Operands
jnz	short loc_1A846	; Jump if Not Zero (ZF=0)
inc	[bp+var_6]	; Increment by 1

loc_1A846:		; CODE XREF: sub_1A7FF+42j
inc	[bp+var_E]	; Increment by 1

loc_1A849:		; CODE XREF: sub_1A7FF+3Aj
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 0 ; Compare Two Operands

loc_1A84F:		; Jump if Zero (ZF=1)
jz	short loc_1A879
mov	bx, [bp+var_E]

loc_1A854:		; Compare Two Operands
cmp	[byte ptr bx+si], 0Dh
jz	short loc_1A879	; Jump if Zero (ZF=1)
mov	bx, [bp+var_E]

loc_1A85C:		; Compare Two Operands
cmp	[byte ptr bx+si], 14h
jz	short loc_1A879	; Jump if Zero (ZF=1)
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 19h ;	Compare	Two Operands
jz	short loc_1A879	; Jump if Zero (ZF=1)
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 15h ;	Compare	Two Operands

loc_1A86F:		; Jump if Zero (ZF=1)
jz	short loc_1A879
mov	bx, [bp+var_E]
cmp	[byte ptr bx+si], 1Dh ;	Compare	Two Operands
jnz	short loc_1A83B	; Jump if Not Zero (ZF=0)

loc_1A879:		; CODE XREF: sub_1A7FF:loc_1A84Fj
			; sub_1A7FF+58j
			; sub_1A7FF+60j
			; sub_1A7FF+68j
			; sub_1A7FF:loc_1A86Fj
cmp	[bp+var_6], 0	; Compare Two Operands
jnz	short loc_1A881	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR

loc_1A881:		; CODE XREF: sub_1A7FF+7Ej
push	si

loc_1A882:		; Call Procedure
call	sub_1AF46
pop	cx
sub	di, ax		; Integer Subtraction
or	di, di		; Logical Inclusive OR
jg	short loc_1A892	; Jump if Greater (ZF=0	& SF=OF)
xor	di, di		; Logical Exclusive OR
jmp	short loc_1A8A4	; Jump

loc_1A892:		; CODE XREF: sub_1A7FF+8Dj
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_6]	; Signed Divide
mov	[bp+var_A], dx
mov	ax, di
cwd			; AX ->	DX:AX (with sign)

loc_1A89E:		; Signed Divide
idiv	[bp+var_6]
mov	[bp+var_C], ax

loc_1A8A4:		; CODE XREF: sub_1A7FF+23j
			; sub_1A7FF+91j
jmp	loc_1A96F	; Jump

loc_1A8A7:		; CODE XREF: sub_1A7FF+17Dj
mov	ax, [bp+var_4]
mov	[bp+var_10], ax
mov	cx, 8		; switch 8 cases
mov	bx, offset word_1A988

loc_1A8B3:		; CODE XREF: sub_1A7FF+BFj
mov	ax, [cs:bx]
cmp	ax, [bp+var_10]	; Compare Two Operands
jz	short loc_1A8C2	; Jump if Zero (ZF=1)
add	bx, 2		; Add
loop	loc_1A8B3	; Loop while CX	!= 0
jmp	short loc_1A931	; default

loc_1A8C2:		; CODE XREF: sub_1A7FF+BAj
jmp	[word ptr cs:bx+10h] ; switch jump

loc_1A8C6:		; DATA XREF: seg017:off_1A998o
cmp	[bp+arg_6], 0	; case 0x1
jz	short loc_1A8D0	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_19D1C ; Call Procedure

loc_1A8D0:		; CODE XREF: sub_1A7FF+CBj
jmp	loc_1A96C	; Jump

loc_1A8D3:		; CODE XREF: sub_1A7FF:loc_1A8C2j
			; DATA XREF: seg017:off_1A998o
cmp	[bp+arg_6], 0	; case 0x2

loc_1A8D7:		; Jump if Zero (ZF=1)
jz	short loc_1A8DD
push	cs
call	near ptr sub_19D2A ; Call Procedure

loc_1A8DD:		; CODE XREF: sub_1A7FF:loc_1A8D7j
jmp	loc_1A96C	; Jump

loc_1A8E0:		; CODE XREF: sub_1A7FF:loc_1A8C2j
			; DATA XREF: seg017:off_1A998o
cmp	[bp+arg_6], 0	; case 0x3
jz	short loc_1A8EA	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_19D51 ; Call Procedure

loc_1A8EA:		; CODE XREF: sub_1A7FF+E5j
db 0E9h,7Fh,0 ;	<BAD>jmp     loc_1A96C ; Jump

loc_1A8ED:		; CODE XREF: sub_1A7FF:loc_1A8C2j
			; DATA XREF: seg017:off_1A998o
cmp	[bp+arg_6], 0	; case 0x4
jz	short loc_1A8F7	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_19D2A ; Call Procedure

loc_1A8F7:		; CODE XREF: sub_1A7FF+F2j
jmp	short loc_1A96C	; Jump

loc_1A8F9:		; CODE XREF: sub_1A7FF:loc_1A8C2j
			; DATA XREF: seg017:off_1A998o
mov	ax, 68		; case 0xD
push	ax
push	[bufFontsLbxEntry0] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
add	[word_3C522], ax ; Add
mov	ax, [bp+arg_0]
mov	[word_3C524], ax
jmp	short loc_1A96C	; Jump

loc_1A914:		; CODE XREF: sub_1A7FF:loc_1A8C2j
			; DATA XREF: seg017:off_1A998o
mov	bx, [bp+var_2]	; case 0x1D
add	bx, si		; Add
mov	al, [bx+1]
mov	ah, 0
mov	dx, [bp+arg_0]
add	dx, ax		; Add

loc_1A923:
mov	[word_3C524], dx
inc	[bp+var_2]	; Increment by 1
jmp	short loc_1A96C	; Jump

loc_1A92C:		; CODE XREF: sub_1A7FF:loc_1A8C2j
			; sub_1A7FF:loc_1A97Fj
			; DATA XREF: seg017:off_1A998o
mov	ax, [word_3C524] ; case	0x15
jmp	short loc_1A981	; Jump

loc_1A931:		; CODE XREF: sub_1A7FF+C1j
push	[bp+arg_A]	; default
push	[bp+var_4]
push	[word_3C522]
push	[word_3C524]
call	sub_1AD92	; Call Procedure
add	sp, 8		; Add
mov	[word_3C524], ax
or	di, di		; Logical Inclusive OR
jz	short loc_1A96A	; Jump if Zero (ZF=1)

loc_1A94E:		; Compare Two Operands
cmp	[bp+var_4], 20h	; ' '
jnz	short loc_1A96A	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_C]
add	[word_3C524], ax ; Add
mov	ax, [bp+var_8]
cmp	ax, [bp+var_A]	; Compare Two Operands
jge	short loc_1A967	; Jump if Greater or Equal (SF=OF)
inc	[word_3C524]	; Increment by 1

loc_1A967:		; CODE XREF: sub_1A7FF+162j
inc	[bp+var_8]	; Increment by 1

loc_1A96A:		; CODE XREF: sub_1A7FF+14Dj
			; sub_1A7FF+153j
jmp	short $+2	; Jump

loc_1A96C:		; CODE XREF: sub_1A7FF:loc_1A8D0j
			; sub_1A7FF:loc_1A8DDj
			; sub_1A7FF:loc_1A8EAj
			; sub_1A7FF:loc_1A8F7j
			; sub_1A7FF+113j
			; sub_1A7FF+12Bj
inc	[bp+var_2]	; Increment by 1

loc_1A96F:		; CODE XREF: sub_1A7FF:loc_1A8A4j
mov	bx, [bp+var_2]
mov	al, [bx+si]
cbw			; AL ->	AX (with sign)
mov	[bp+var_4], ax

loc_1A978:		; Logical Inclusive OR
or	ax, ax
jz	short loc_1A97F	; Jump if Zero (ZF=1)
jmp	loc_1A8A7	; Jump

loc_1A97F:		; CODE XREF: sub_1A7FF+17Bj
jmp	short loc_1A92C	; case 0x15

loc_1A981:		; CODE XREF: sub_1A7FF+130j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A7FF

align 2
word_1A988 dw	   1,	  2,	 3,	4
			; DATA XREF: sub_1A7FF+B1o
dw    0Dh,   14h,   15h,   1Dh ; value table for switch	statement
off_1A998 dw offset loc_1A8C6 ;	jump table for switch statement
dw offset loc_1A8D3
dw offset loc_1A8E0
dw offset loc_1A8ED
dw offset loc_1A8F9
dw offset loc_1A8F9
dw offset loc_1A92C
dw offset loc_1A914


; Attributes: bp-based frame

proc sub_1A9A8 far	; CODE XREF: sub_1AA6E+26p
			; sub_1BC65:loc_1BCFDP

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction

loc_1A9AE:
push	si
mov	si, [bp+arg_4]
push	si
call	sub_1AF46	; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_2], ax
push	[bp+arg_6]
push	si
push	[bp+arg_2]
mov	ax, [bp+arg_0]
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
push	cs
call	near ptr sub_1A5D5 ; Call Procedure
add	sp, 8		; Add
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
jmp	short $+2	; Jump
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A9A8



; Attributes: bp-based frame

proc sub_1A9DF far	; CODE XREF: sub_1AA9C+26p
			; sub_1BC65+E2P

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
mov	si, [bp+arg_4]
push	si
call	sub_1AF46	; Call Procedure
pop	cx

loc_1A9F0:
mov	[bp+var_2], ax

loc_1A9F3:
push	[bp+arg_6]
push	si
push	[bp+arg_2]

loc_1A9FA:
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)

loc_1A9FE:		; Integer Subtraction
sub	ax, dx
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+arg_0]
sub	dx, ax		; Integer Subtraction
push	dx
push	cs
call	near ptr sub_1A5D5 ; Call Procedure
add	sp, 8		; Add
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
jmp	short $+2	; Jump
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1A9DF



; Attributes: bp-based frame

proc sub_1AA1C far	; CODE XREF: sub_1AACA:loc_1AAF3p
			; sub_1BC65+13DP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	si
mov	si, [bp+arg_6]
or	si, si		; Logical Inclusive OR
jge	short loc_1AA29	; Jump if Greater or Equal (SF=OF)
xor	si, si		; Logical Exclusive OR

loc_1AA29:		; CODE XREF: sub_1AA1C+9j
push	[bp+arg_8]
push	si
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs

loc_1AA37:		; Call Procedure
call	near ptr sub_1A5F1
add	sp, 0Ah		; Add
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1AA1C



; Attributes: bp-based frame

proc sub_1AA40 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]

loc_1AA49:		; Logical Exclusive OR
xor	ax, ax
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
push	[bp+arg_8]
mov	ax, 9490h
push	ax
push	[bp+arg_2]

loc_1AA62:
push	[bp+arg_0]
push	cs
call	near ptr sub_1A5D5 ; Call Procedure
add	sp, 8		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1AA40



; Attributes: bp-based frame

proc sub_1AA6E far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]

loc_1AA77:		; Logical Exclusive OR
xor	ax, ax
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
push	[bp+arg_8]

loc_1AA89:
mov	ax, 9490h
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_1A9A8 ; Call Procedure
add	sp, 8		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1AA6E



; Attributes: bp-based frame

proc sub_1AA9C far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 9490h
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure

loc_1AAB1:		; Add
add	sp, 8
push	[bp+arg_8]
mov	ax, 9490h
push	ax
push	[bp+arg_2]

loc_1AABE:
push	[bp+arg_0]
push	cs
call	near ptr sub_1A9DF ; Call Procedure
add	sp, 8		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1AA9C



; Attributes: bp-based frame

proc sub_1AACA far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	[bp+arg_6]
push	[bp+arg_4]

loc_1AAD3:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_1AAD6:
mov	ax, 9490h
push	ax

loc_1AADA:		; Call Procedure
call	idk_Get_FAT_FileExtension_s14EED
add	sp, 8		; Add

loc_1AAE2:
push	[bp+arg_A]

loc_1AAE5:
push	[bp+arg_8]

loc_1AAE8:
mov	ax, 9490h
push	ax

loc_1AAEC:
push	[bp+arg_2]

loc_1AAEF:
push	[bp+arg_0]

loc_1AAF2:
push	cs

loc_1AAF3:		; Call Procedure
call	near ptr sub_1AA1C

loc_1AAF6:		; Add
add	sp, 0Ah

loc_1AAF9:
pop	bp

locret_1AAFA:		; Return Far from Procedure
retf
endp sub_1AACA

ends seg017


; Segment type:	Pure code
segment	seg018 byte public 'CODE' use16
assume cs:seg018
;org 0Ch
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
word_1AAFC dw 0		; DATA XREF: idk_PalFnt_s1AB64+3Dw
			; idk_PalFnt_s1AB64+8Fr
word_1AAFE dw 0		; DATA XREF: idk_PalFnt_s1AB64+41w
			; idk_PalFnt_s1AB64+A4r
word_1AB00 dw 0		; DATA XREF: idk_PalFnt_s1AB64+46w
			; idk_PalFnt_s1AB64+C0r
			; idk_PalFnt_s1AB64+CFr
			; idk_PalFnt_s1AB64+E7r
			; idk_PalFnt_s1AB64+FDr
			; idk_PalFnt_s1AB64+11Er
word_1AB02 dw 0		; DATA XREF: sub_1ACAA+Dw
			; sub_1ACAA:loc_1ACEDr
			; sub_1ACAA+52r
			; sub_1ACAA:loc_1AD12r
			; sub_1AD1E+Dw
			; sub_1AD1E+43r
			; sub_1AD1E+52r
			; sub_1AD1E:loc_1AD86r
			; sub_1AD92+45w
			; sub_1AD92:loc_1ADEDr
word_1AB04 dw 0		; DATA XREF: sub_1AD92:loc_1ADACw
			; sub_1AD92:loc_1ADC2r
			; sub_1AD92+9Br
word_1AB06 dw 0		; DATA XREF: sub_1ACAA+48w
			; sub_1ACAA+5Cr
			; sub_1AD1E+48w
			; sub_1AD1E+5Cr
			; sub_1AD92+Dw
			; sub_1AD92:loc_1ADF2w
			; sub_1AD92:loc_1AE35r
word_1AB08 dw 0		; DATA XREF: sub_1AD92:loc_1ADFCw
			; sub_1AD92:loc_1AE28r
word_1AB0A dw 0		; DATA XREF: sub_1AE41w
			; sub_1AE41:loc_1AEB7w
			; sub_1AEBFw
			; sub_1AEBF:loc_1AF3Ew
			; sub_1AFEF+10w
			; sub_1AFEF:loc_1B099w
word_1AB0C dw 0		; DATA XREF: sub_1AFEFw
			; sub_1AFEF:loc_1B06Cr
word_1AB0E dw 0		; DATA XREF: sub_1AFEF+4w
			; sub_1AFEF+43r
word_1AB10 dw 0		; DATA XREF: sub_1AFEF+Bw
			; sub_1AFEF+82r
word_1AB12 dw 0		; DATA XREF: sub_1AFEF+17w
			; sub_1AFEF+6Dr
byte_1AB14 db 50h dup(0)


; Attributes: bp-based frame

; int __cdecl __far idk_PalFnt_s1AB64(int, int,	int, int)
proc idk_PalFnt_s1AB64 far ; CODE XREF:	sub_1922A+FP
			; sub_19257:loc_19266P
			; sub_19284+FP
			; sub_192B1+FP
			; sub_192DE+FP
			; sub_19399+38P
			; sub_19DD1+37P
			; sub_19DD1+90P
			; sub_19F94+66P
			; sub_19F94:loc_1A0C9P
			; ILSe_prepare_palette+B9P
			; sub_1D1B5+D7P
			; sub_28141+B3P
			; sub_28963+A7P
			; sub_28963:loc_28CF4P
			; sub_2A755+1B1P
			; sub_2A755+2EAP
			; sub_2A755+3E2P
			; sub_2A755+4AEP
			; sub_2A755+5C1P
			; sub_2A755+6B1P
			; sub_2A755:loc_2AF3BP
			; sub_2A755+8AEP
			; sub_2A755+982P
			; sub_2B1F9+11DP
			; sub_2BA41+103P
			; sub_2BA41+242P
			; sub_2BA41+3CBP
			; sub_2BA41+512P
			; sub_2BA41+69BP
			; sub_2BA41:loc_2C232P
			; sub_2BA41+97AP
			; sub_2BA41+A58P
			; sub_2BA41+AE7P
			; sub_2BA41+C55P
			; sub_2BA41+E5AP
			; sub_2BA41+FE6P
			; sub_2CF44+AAP
			; sub_2CF44+236P
			; sub_2CF44+383P
			; sub_2CF44+50FP
			; sub_2CF44:loc_2D5A3P
			; sub_2CF44:loc_2D72FP
			; sub_2CF44+986P
			; sub_2CF44+B0FP
			; sub_2CF44+C46P
			; sub_2CF44+D11P
			; sub_3E60E+141P
			; sub_3EDD1+26CP
			; sub_3EDD1+4DAP
			; sub_3EDD1+576P
			; idk_Load_NEWGAME_LBX+76P
			; sub_3F6BF+97P
			; sub_3FA0C:loc_3FAA4P
			; sub_40037+FBP
			; sub_4043A+D5P
			; sub_40EC0+643P
			; sub_40EC0+AD5P
			; sub_40EC0+B2AP
			; sub_424BB+91P
			; sub_424BB+258P
			; idk_BuildingWorlds+62P
			; sub_4D5B0:loc_4D642P
			; sub_4D7A1+10P
			; sub_4D7A1+96P
			; sub_4D7A1+105P
			; sub_4D8FA+98P
			; sub_4DA02:loc_4DA12P
			; sub_4DA02+96P
			; sub_4DA02+F8P
			; sub_4E751+2CP
			; sub_4E9F4+132P
			; sub_4EC17+71P
			; sub_4EC17+1EDP
			; sub_4EC17+247P
			; sub_4EC17+27FP
			; sub_4EF74+137P
			; sub_4F1AB+3AP
			; sub_4F1AB+1A7P

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	es
push	ds
push	si
push	di
mov	ax, [bp+arg_2]
cmp	ax, 16		; 16 - AX
jb	short loc_1AB79	; Jump if Below	(CF=1)
mov	ax, 0

loc_1AB79:		; CODE XREF: idk_PalFnt_s1AB64+10j
mov	[bp+var_6], ax


mov	ax, [bp+arg_4]
cmp	ax, 16		; 16 - AX
jb	short loc_1AB87	; Jump if Below	(CF=1)

loc_1AB84:
mov	ax, 0

loc_1AB87:		; CODE XREF: idk_PalFnt_s1AB64+1Ej
mov	[bp+var_8], ax


mov	ax, [bp+arg_6]
cmp	ax, 16		; 16 - AX
jb	short loc_1AB95	; Jump if Below	(CF=1)
mov	ax, 0

loc_1AB95:		; CODE XREF: idk_PalFnt_s1AB64+2Cj
mov	[bp+var_A], ax


mov	ax, [bp+var_8]
mov	bx, [bp+var_A]
mov	cx, [bp+arg_0]
mov	[cs:word_1AAFC], ax
mov	[cs:word_1AAFE], bx
mov	[cs:word_1AB00], cx


mov	ax, [bp+arg_0]
mov	[idk_w3C520], ax
mov	ax, [bp+var_6]
mov	[idk_w3C51E], ax
mov	ax, [bp+var_8]
mov	[word_3C51C], ax
mov	ax, [bp+var_A]
mov	[word_3C51A], ax

Copy 8 words/16	bytes
 from ptrFontsLbx2_@48
 to   bufFontsLbxEntry0:0
mov	ax, [bufFontsLbxEntry0]
mov	es, ax
mov	di, 0
mov	si, [bp+var_6]	; ? arg_2 or 0 ?
mov	ax, [ptrFontsLbx2_@48]
mov	ds, ax
and	si, 1111b	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
mov	dx, si
mov	cx, 8
rep movsw		; Move CX words	from DS:[SI] to	ES:[DI].


mov	di, 20
mov	si, dx
mov	cx, 8
rep movsw		; Move CX words	from DS:[SI] to	ES:[DI].


mov	si, [cs:word_1AAFC]
and	si, 1111b	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
mov	cx, 8
rep movsw		; Move CX words	from DS:[SI] to	ES:[DI].


mov	si, [cs:word_1AAFE]
and	si, 1111b	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
mov	cx, 8
rep movsw		; Move CX words	from DS:[SI] to	ES:[DI].


mov	ax, es
mov	ds, ax
mov	di, 16
mov	si, [cs:word_1AB00]
shl	si, 1		; Shift	Logical	Left
add	si, 16Ah	; Add
movsw			; Move Byte(s) from String to String


mov	di, 46h	; 'F'
mov	si, [cs:word_1AB00]
shl	si, 1		; Shift	Logical	Left
add	si, 18Ah	; Add
lodsw			; Load String
stosw			; Store	String


mov	di, 44h	; 'D'
add	ax, [word_31D20] ; Add
stosw			; Store	String


mov	di, 48h	; 'H'
mov	si, [cs:word_1AB00]
shl	si, 1		; Shift	Logical	Left
add	si, 17Ah	; Add
movsw			; Move Byte(s) from String to String


mov	di, 18
mov	ax, 0
stosw			; Store	String


mov	di, 4Ah	; 'J'
mov	si, [cs:word_1AB00]
mov	ax, si
shl	si, 1		; Shift	Logical	Left
add	si, ax		; Add
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
add	si, 19Ah	; Add
mov	cx, 48
rep movsw		; Move CX words	from DS:[SI] to	ES:[DI].


mov	di, 0AAh ; ''
mov	si, [cs:word_1AB00]
mov	ax, si
shl	si, 1		; Shift	Logical	Left
add	si, ax		; Add
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
add	si, 49Ah	; Add
mov	cx, 96
rep movsw		; Move CX words	from DS:[SI] to	ES:[DI].


pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_PalFnt_s1AB64



; Attributes: bp-based frame

proc sub_1ACAA far	; CODE XREF: ILSe_display_text+149P
			; sub_1A3AF+6DP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	es
push	ds
push	si
push	di
mov	ax, [bp+arg_0]
mov	[cs:word_1AB02], ax
mov	bx, [bp+arg_4]
xor	bh, bh		; Logical Exclusive OR

loc_1ACC0:		; Compare Two Operands
cmp	bx, 20h	; ' '
js	short loc_1AD12	; Jump if Sign (SF=1)
cmp	bx, 7Eh	; '~'   ; Compare Two Operands
jns	short loc_1AD12	; Jump if Not Sign (SF=0)
mov	ax, [bp+arg_2]
mov	cx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, cx		; Add

loc_1ACD5:		; Add
add	ax, [g_ptrVideoRamBuffer]
mov	es, ax
mov	ax, [bufFontsLbxEntry0]
mov	ds, ax
sub	bx, 20h	; ' '   ; Integer Subtraction
mov	dl, [bx+4Ah]
xor	dh, dh		; Logical Exclusive OR
mov	ax, [word ptr ZeroDivMSG] ; "Divide error\r\n"
add	ax, dx		; Add

loc_1ACED:		; Add
add	ax, [cs:word_1AB02]
mov	[cs:word_1AB06], ax
shl	bx, 1		; Shift	Logical	Left
mov	si, [bx+0AAh]
mov	bx, [cs:word_1AB02]
push	cs
call	near ptr sub_1AE41 ; Call Procedure
nop			; No Operation
mov	ax, [cs:word_1AB06]
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp

loc_1AD10:
pop	bp
retf			; Return Far from Procedure

loc_1AD12:		; CODE XREF: sub_1ACAA+19j
			; sub_1ACAA+1Ej
mov	ax, [cs:word_1AB02]
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1ACAA



; Attributes: bp-based frame

proc sub_1AD1E far	; CODE XREF: ILSe_display_text+15BP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	es
push	ds
push	si
push	di

loc_1AD28:
mov	ax, [bp+arg_0]
mov	[cs:word_1AB02], ax
mov	bx, [bp+arg_4]
xor	bh, bh		; Logical Exclusive OR
cmp	bx, 20h	; ' '   ; Compare Two Operands

loc_1AD37:		; Jump if Sign (SF=1)
js	short loc_1AD86
cmp	bx, 7Eh	; '~'   ; Compare Two Operands
jns	short loc_1AD86	; Jump if Not Sign (SF=0)
mov	ax, [bp+arg_2]
mov	cx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, cx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax

loc_1AD4F:
mov	ax, [bufFontsLbxEntry0]
mov	ds, ax
sub	bx, 20h	; ' '   ; Integer Subtraction
mov	dl, [bx+4Ah]
xor	dh, dh		; Logical Exclusive OR
mov	ax, [word ptr ZeroDivMSG] ; "Divide error\r\n"
add	ax, dx		; Add
add	ax, [cs:word_1AB02] ; Add
mov	[cs:word_1AB06], ax
shl	bx, 1		; Shift	Logical	Left

loc_1AD6C:
mov	si, [bx+0AAh]
mov	bx, [cs:word_1AB02]
push	cs
call	near ptr sub_1AEBF ; Call Procedure
nop			; No Operation
mov	ax, [cs:word_1AB06]
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_1AD86:		; CODE XREF: sub_1AD1E:loc_1AD37j
			; sub_1AD1E+1Ej
mov	ax, [cs:word_1AB02]
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1AD1E



; Attributes: bp-based frame

proc sub_1AD92 far	; CODE XREF: sub_1A7FF+140P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	es
push	ds
push	si
push	di

loc_1AD9C:
mov	ax, [bp+arg_0]
mov	[cs:word_1AB06], ax
mov	ax, [bp+arg_6]
mov	es, ax

loc_1ADA8:
mov	ax, [es:2]

loc_1ADAC:
mov	[cs:word_1AB04], ax
mov	bx, [bp+arg_4]
xor	bh, bh		; Logical Exclusive OR
cmp	bx, 20h	; ' '   ; Compare Two Operands

loc_1ADB8:		; Jump if Sign (SF=1)
js	short loc_1AE35

loc_1ADBA:		; Compare Two Operands
cmp	bx, 7Eh	; '~'

loc_1ADBD:		; Jump if Not Sign (SF=0)
jns	short loc_1AE35

loc_1ADBF:
mov	ax, [bp+arg_0]

loc_1ADC2:
mov	cx, [cs:word_1AB04]
mul	cx		; Unsigned Multiplication of AL	or AX
add	ax, [bp+arg_2]	; Add
mov	di, ax
mov	ax, [bp+arg_6]
inc	ax		; Increment by 1
mov	es, ax
mov	ax, [bp+arg_0]
mov	[cs:word_1AB02], ax
mov	ax, [bufFontsLbxEntry0]
mov	ds, ax
sub	bx, 20h	; ' '   ; Integer Subtraction
mov	dl, [bx+4Ah]
xor	dh, dh		; Logical Exclusive OR
mov	ax, [word ptr ZeroDivMSG] ; "Divide error\r\n"
add	ax, dx		; Add

loc_1ADED:		; Add
add	ax, [cs:word_1AB02]

loc_1ADF2:
mov	[cs:word_1AB06], ax
shl	bx, 1		; Shift	Logical	Left

loc_1ADF8:
mov	si, [bx+0AAh]

loc_1ADFC:		; CODE XREF: sub_1AD92+A1j
mov	[cs:word_1AB08], di

loc_1AE01:		; CODE XREF: sub_1AD92+7Dj
			; sub_1AD92+94j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jns	short loc_1AE11	; Jump if Not Sign (SF=0)
cmp	al, 80h	; ''   ; Compare Two Operands
jz	short loc_1AE28	; Jump if Zero (ZF=1)
and	ax, 1111111b	; Logical AND
add	di, ax		; Add
jmp	short loc_1AE01	; Jump

loc_1AE11:		; CODE XREF: sub_1AD92+72j
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
mov	bl, al
and	bx, 0Fh		; Logical AND
mov	al, [bx]
rep stosb		; Store	String
jmp	short loc_1AE01	; Jump

loc_1AE28:		; CODE XREF: sub_1AD92+76j
mov	di, [cs:word_1AB08]
add	di, [cs:word_1AB04] ; Add
dec	dx		; Decrement by 1
jnz	short loc_1ADFC	; Jump if Not Zero (ZF=0)

loc_1AE35:		; CODE XREF: sub_1AD92:loc_1ADB8j
			; sub_1AD92:loc_1ADBDj
mov	ax, [cs:word_1AB06]
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1AD92




proc sub_1AE41 far	; CODE XREF: sub_1ACAA+58p
mov	[cs:word_1AB0A], dx
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	di, bx
shr	di, 1		; Shift	Logical	Right

loc_1AE50:		; Shift	Logical	Right
shr	di, 1
mov	ah, 1
and	bx, 3		; Logical AND
jz	short loc_1AE5F	; Jump if Zero (ZF=1)
mov	cx, bx

loc_1AE5B:		; CODE XREF: sub_1AE41+1Cj
shl	ah, 1		; Shift	Logical	Left
loop	loc_1AE5B	; Loop while CX	!= 0

loc_1AE5F:		; CODE XREF: sub_1AE41+16j
mov	dx, SC_DATA
mov	al, ah
out	dx, al		; EGA port: sequencer data register
mov	dx, di

loc_1AE67:		; CODE XREF: sub_1AE41+44j
			; sub_1AE41+60j
			; sub_1AE41+7Bj
lodsb			; Load String
cmp	al, 0		; Compare Two Operands

loc_1AE6A:		; Jump if Sign (SF=1)
js	short loc_1AE87
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
mov	bl, al
and	bx, 0Fh		; Logical AND
mov	al, [bx]

loc_1AE7F:		; CODE XREF: sub_1AE41+42j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1AE7F	; Loop while CX	!= 0
jmp	short loc_1AE67	; Jump

loc_1AE87:		; CODE XREF: sub_1AE41:loc_1AE6Aj
and	al, 7Fh		; Logical AND
jz	short loc_1AEA3	; Jump if Zero (ZF=1)
mov	bl, al
xor	bh, bh		; Logical Exclusive OR
mov	cx, bx
shl	bx, 1		; Shift	Logical	Left
shl	bx, 1		; Shift	Logical	Left

loc_1AE95:		; Add
add	bx, cx
shl	bx, 1		; Shift	Logical	Left

loc_1AE99:		; Shift	Logical	Left
shl	bx, 1
shl	bx, 1		; Shift	Logical	Left

loc_1AE9D:		; Shift	Logical	Left
shl	bx, 1

loc_1AE9F:		; Add
add	di, bx
jmp	short loc_1AE67	; Jump

loc_1AEA3:		; CODE XREF: sub_1AE41+48j
mov	di, dx
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands

loc_1AEAA:		; Jump if Sign (SF=1)
js	short loc_1AEAF
mov	ah, 1
inc	di		; Increment by 1

loc_1AEAF:		; CODE XREF: sub_1AE41:loc_1AEAAj
mov	dx, SC_DATA
mov	al, ah

loc_1AEB4:		; EGA port: sequencer data register
out	dx, al

loc_1AEB5:
mov	dx, di

loc_1AEB7:		; Decrement by 1
dec	[cs:word_1AB0A]
jnz	short loc_1AE67	; Jump if Not Zero (ZF=0)

locret_1AEBE:		; Return Far from Procedure
retf
endp sub_1AE41




proc sub_1AEBF far	; CODE XREF: sub_1AD1E+58p
mov	[cs:word_1AB0A], dx
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_1AECA:
mov	di, bx
shr	di, 1		; Shift	Logical	Right
shr	di, 1		; Shift	Logical	Right

loc_1AED0:
mov	ah, 1
and	bx, 3		; Logical AND

loc_1AED5:		; Jump if Zero (ZF=1)
jz	short loc_1AEDD

loc_1AED7:
mov	cx, bx

loc_1AED9:		; CODE XREF: sub_1AEBF+1Cj
shl	ah, 1		; Shift	Logical	Left
loop	loc_1AED9	; Loop while CX	!= 0

loc_1AEDD:		; CODE XREF: sub_1AEBF:loc_1AED5j
mov	dx, SC_DATA

loc_1AEE0:
mov	al, ah
out	dx, al		; EGA port: sequencer data register
mov	dx, di

loc_1AEE5:		; CODE XREF: sub_1AEBF+46j
			; sub_1AEBF+4Dj
			; sub_1AEBF:loc_1AF28j
			; sub_1AEBF:loc_1AF43j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands

loc_1AEE8:		; Jump if Sign (SF=1)
js	short loc_1AF0E
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
mov	bl, al
and	bx, 0Fh		; Logical AND
jz	short loc_1AF07	; Jump if Zero (ZF=1)
mov	al, [bx]

loc_1AEFF:		; CODE XREF: sub_1AEBF:loc_1AF03j
			; sub_1AEBF+4Bj
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add

loc_1AF03:		; Loop while CX	!= 0
loop	loc_1AEFF
jmp	short loc_1AEE5	; Jump

loc_1AF07:		; CODE XREF: sub_1AEBF+3Cj
add	di, 50h	; 'P'   ; Add
loop	loc_1AEFF	; Loop while CX	!= 0
jmp	short loc_1AEE5	; Jump

loc_1AF0E:		; CODE XREF: sub_1AEBF:loc_1AEE8j
and	al, 7Fh		; Logical AND

loc_1AF10:		; Jump if Zero (ZF=1)
jz	short loc_1AF2A
mov	bl, al
xor	bh, bh		; Logical Exclusive OR
mov	cx, bx

loc_1AF18:		; Shift	Logical	Left
shl	bx, 1

loc_1AF1A:		; Shift	Logical	Left
shl	bx, 1
add	bx, cx		; Add

loc_1AF1E:		; Shift	Logical	Left
shl	bx, 1
shl	bx, 1		; Shift	Logical	Left

loc_1AF22:		; Shift	Logical	Left
shl	bx, 1
shl	bx, 1		; Shift	Logical	Left
add	di, bx		; Add

loc_1AF28:		; Jump
jmp	short loc_1AEE5

loc_1AF2A:		; CODE XREF: sub_1AEBF:loc_1AF10j
mov	di, dx
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands

loc_1AF31:		; Jump if Sign (SF=1)
js	short loc_1AF36

loc_1AF33:
mov	ah, 1
inc	di		; Increment by 1

loc_1AF36:		; CODE XREF: sub_1AEBF:loc_1AF31j
mov	dx, SC_DATA

loc_1AF39:
mov	al, ah
out	dx, al		; EGA port: sequencer data register
mov	dx, di

loc_1AF3E:		; Decrement by 1
dec	[cs:word_1AB0A]

loc_1AF43:		; Jump if Not Zero (ZF=0)
jnz	short loc_1AEE5
retf			; Return Far from Procedure
endp sub_1AEBF



; Attributes: bp-based frame

proc sub_1AF46 far	; CODE XREF: sub_196B8+BP
			; sub_196ED+BP
			; sub_1983E+BP
			; sub_19873+BP
			; ILSe_display_text:loc_19BCCP
			; sub_19DD1+4EP
			; sub_19F94+8FP
			; sub_19F94+E6P
			; sub_1A296+58P
			; sub_1A7FF:loc_1A882P
			; sub_1A9A8+BP
			; sub_1A9DF+BP
			; sub_1B341+7EP
			; sub_1B9E2:loc_1BA1DP
			; sub_28141:loc_2822EP
			; sub_28141+2BCP
			; sub_28141+33FP
			; sub_28141+396P
			; sub_28583:loc_28636P
			; sub_28583:loc_287D8P
			; sub_28583+2D8P
			; sub_28583+32FP
			; sub_28963+16CP
			; sub_28963+1A5P
			; sub_28963+2A8P
			; sub_28963+2E1P
			; sub_4E751+44P
			; sub_4E751+59P
			; sub_4E751+7EP
			; sub_56240:loc_56367P

arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_1AF49:
push	es
push	ds
push	si
push	di

loc_1AF4D:
mov	si, [bp+arg_0]

loc_1AF50:
mov	ax, [bufFontsLbxEntry0]
mov	es, ax
mov	bx, 48h	; 'H'
mov	cx, [es:bx]

loc_1AF5B:
mov	dx, 0

loc_1AF5E:
mov	bh, 0

loc_1AF60:
mov	ah, 0

loc_1AF62:		; CODE XREF: sub_1AF46+23j
			; sub_1AF46+2Fj
			; sub_1AF46+49j
lodsb			; Load String

loc_1AF63:		; Integer Subtraction
sub	al, 20h	; ' '
js	short loc_1AF77	; Jump if Sign (SF=1)
cmp	al, 5Eh	; '^'   ; Compare Two Operands
jns	short loc_1AF62	; Jump if Not Sign (SF=0)
mov	bl, al
mov	al, [es:bx+4Ah]

loc_1AF71:		; Add
add	dx, ax
add	dx, cx		; Add
jmp	short loc_1AF62	; Jump

loc_1AF77:		; CODE XREF: sub_1AF46+1Fj
add	al, 20h	; ' '   ; Add
jz	short loc_1AF91	; Jump if Zero (ZF=1)
cmp	al, 0Dh		; Compare Two Operands
jz	short loc_1AF91	; Jump if Zero (ZF=1)
cmp	al, 14h		; Compare Two Operands
jz	short loc_1AF91	; Jump if Zero (ZF=1)

loc_1AF83:		; Compare Two Operands
cmp	al, 15h
jz	short loc_1AF91	; Jump if Zero (ZF=1)
cmp	al, 19h		; Compare Two Operands

loc_1AF89:		; Jump if Zero (ZF=1)
jz	short loc_1AF91
cmp	al, 1Dh		; Compare Two Operands

loc_1AF8D:		; Jump if Zero (ZF=1)
jz	short loc_1AF91
jmp	short loc_1AF62	; Jump

loc_1AF91:		; CODE XREF: sub_1AF46+33j
			; sub_1AF46+37j
			; sub_1AF46+3Bj
			; sub_1AF46+3Fj
			; sub_1AF46:loc_1AF89j
			; sub_1AF46:loc_1AF8Dj
mov	ax, dx

loc_1AF93:		; Integer Subtraction
sub	ax, cx
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp sub_1AF46



; Attributes: bp-based frame

proc sub_1AF9B far	; CODE XREF: sub_1A3AF:loc_1A4BDP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
push	es
push	ds
push	si
push	di
push	ds
mov	ax, [bp+arg_2]
mov	cx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, cx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	bx, [bp+arg_4]

loc_1AFB7:
mov	cx, [bp+arg_6]

loc_1AFBA:
mov	ax, [bufFontsLbxEntry0]
mov	ds, ax
shl	bx, 1		; Shift	Logical	Left
mov	si, [bx+0AAh]
cmp	cx, 0		; Compare Two Operands
jz	short loc_1AFD1	; Jump if Zero (ZF=1)

loc_1AFCA:		; CODE XREF: sub_1AF9B+32j
			; sub_1AF9B+34j
lodsb			; Load String
cmp	al, 80h	; ''   ; Compare Two Operands
jnz	short loc_1AFCA	; Jump if Not Zero (ZF=0)
loop	loc_1AFCA	; Loop while CX	!= 0

loc_1AFD1:		; CODE XREF: sub_1AF9B+2Dj
pop	ds

loc_1AFD2:
mov	dx, [bp+arg_8]
mov	bx, [bp+arg_0]
mov	ax, [bp+arg_A]
mov	cx, [bp+arg_C]
mov	di, [bufFontsLbxEntry0]
mov	ds, di
push	cs
call	near ptr sub_1AFEF ; Call Procedure
nop			; No Operation
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp sub_1AF9B




proc sub_1AFEF far	; CODE XREF: sub_1AF9B+4Ap
mov	[cs:word_1AB0C], ax
mov	[cs:word_1AB0E], cx
sub	cx, ax		; Integer Subtraction
mov	[cs:word_1AB10], cx
mov	[cs:word_1AB0A], dx
mov	ax, es
mov	[cs:word_1AB12], ax
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_1B010:
mov	di, bx
shr	di, 1		; Shift	Logical	Right

loc_1B014:		; Shift	Logical	Right
shr	di, 1
mov	ah, 1
and	bx, 3		; Logical AND
jz	short loc_1B023	; Jump if Zero (ZF=1)
mov	cx, bx

loc_1B01F:		; CODE XREF: sub_1AFEF+32j
shl	ah, 1		; Shift	Logical	Left
loop	loc_1B01F	; Loop while CX	!= 0

loc_1B023:		; CODE XREF: sub_1AFEF+2Cj
mov	dx, 3C5h
mov	al, ah

loc_1B028:		; EGA port: sequencer data register
out	dx, al
mov	dx, di

loc_1B02B:		; CODE XREF: sub_1AFEF:loc_1B09Ej
mov	bx, cs
mov	es, bx
assume es:seg018
mov	di, 24h	; '$'
mov	cx, [cs:word_1AB0E]
mov	al, 0FFh

loc_1B039:		; Store	String
rep stosb
mov	di, 24h	; '$'

loc_1B03E:		; CODE XREF: sub_1AFEF+69j
			; sub_1AFEF:loc_1B0ABj
lodsb			; Load String

loc_1B03F:		; Compare Two Operands
cmp	al, 0
js	short loc_1B0A1	; Jump if Sign (SF=1)
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right
shr	cx, 1		; Shift	Logical	Right

loc_1B04F:
mov	bl, al
and	bx, 0Fh		; Logical AND
mov	al, [bx]
rep stosb		; Store	String
jmp	short loc_1B03E	; Jump

loc_1B05A:		; CODE XREF: sub_1AFEF:loc_1B0A3j
push	ds
push	si
mov	bx, [cs:word_1AB12]

loc_1B061:
mov	es, bx
assume es:nothing

loc_1B063:
mov	di, dx
mov	bx, cs
mov	ds, bx
assume ds:seg018
mov	si, 24h	; '$'

loc_1B06C:		; Add
add	si, [cs:word_1AB0C]
mov	cx, [cs:word_1AB10]

loc_1B076:		; CODE XREF: sub_1AFEF+92j
lodsb			; Load String
inc	di		; Increment by 1
cmp	al, 0FFh	; Compare Two Operands
jz	short loc_1B07E	; Jump if Zero (ZF=1)
dec	di		; Decrement by 1
stosb			; Store	String

loc_1B07E:		; CODE XREF: sub_1AFEF+8Bj
add	di, 4Fh	; 'O'   ; Add
loop	loc_1B076	; Loop while CX	!= 0

loc_1B083:
mov	di, dx

loc_1B085:		; Shift	Logical	Left
shl	ah, 1

loc_1B087:		; Compare Two Operands
cmp	ah, 9

loc_1B08A:		; Jump if Sign (SF=1)
js	short loc_1B08F

loc_1B08C:
mov	ah, 1

loc_1B08E:		; Increment by 1
inc	di

loc_1B08F:		; CODE XREF: sub_1AFEF:loc_1B08Aj
mov	dx, 3C5h

loc_1B092:
mov	al, ah

loc_1B094:		; EGA port: sequencer data register
out	dx, al

loc_1B095:
mov	dx, di
pop	si

loc_1B098:
pop	ds
assume ds:dseg

loc_1B099:		; Decrement by 1
dec	[cs:word_1AB0A]

loc_1B09E:		; Jump if Not Zero (ZF=0)
jnz	short loc_1B02B

locret_1B0A0:		; Return Far from Procedure
retf

loc_1B0A1:		; CODE XREF: sub_1AFEF+52j
and	al, 7Fh		; Logical AND

loc_1B0A3:		; Jump if Zero (ZF=1)
jz	short loc_1B05A

loc_1B0A5:
mov	cx, ax

loc_1B0A7:		; Logical Exclusive OR
xor	ch, ch

loc_1B0A9:		; Add
add	di, cx

loc_1B0AB:		; Jump
jmp	short loc_1B03E
endp sub_1AFEF

ends seg018


; Segment type:	Pure code
segment	seg019 byte public 'CODE' use16
assume cs:seg019
;org 0Dh
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_1B0AD far	; CODE XREF: sub_4043A+109P
			; sub_4043A+13CP
			; sub_4D7A1+B7P
			; sub_4D7A1+D8P
			; sub_4D7A1:loc_4D8C7P
			; sub_4DA02+B8P
			; sub_4DA02+DAP
			; sub_4DA02:loc_4DB1CP
			; sub_4EC17+210P
			; sub_4EC17+233P
			; sub_4EC17+2A2P
			; sub_4EC17+2C5P
			; sub_4EC17+2FFP
			; sub_4F1AB+1D0P
			; sub_4F1AB+1F8P
			; sub_4F1AB+237P
			; idk_OVR_LoadLbxHelp:loc_5613EP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp

loc_1B0AE:
mov	bp, sp

loc_1B0B0:
push	si
push	di

loc_1B0B2:
mov	di, [bp+arg_6]
push	di

loc_1B0B6:
push	[bp+arg_4]

loc_1B0B9:
push	[bp+arg_2]

loc_1B0BC:
push	[bp+arg_0]

loc_1B0BF:		; No Operation
nop

loc_1B0C0:
push	cs

loc_1B0C1:		; Call Procedure
call	near ptr sub_1B654

loc_1B0C4:		; Add
add	sp, 8

loc_1B0C7:		; Logical Exclusive OR
xor	si, si

loc_1B0C9:		; Jump
jmp	loc_1B21E

loc_1B0CC:		; CODE XREF: sub_1B0AD:loc_1B224j
mov	bx, [bp+arg_8]

loc_1B0CF:		; switch 4 cases
cmp	bx, 3

loc_1B0D2:		; Jump if Below	or Equal (CF=1 | ZF=1)
jbe	short loc_1B0D7
jmp	loc_1B21D	; default

loc_1B0D7:		; CODE XREF: sub_1B0AD:loc_1B0D2j
shl	bx, 1		; Shift	Logical	Left

loc_1B0D9:		; switch jump
jmp	[cs:off_1B239+bx]

loc_1B0DE:		; DATA XREF: seg019:off_1B239o
mov	ax, si		; case 0x0

loc_1B0E0:		; Shift	Logical	Left
shl	ax, 1

loc_1B0E2:		; Load Full Pointer to ES:xx
les	bx, [dword_3C530]

loc_1B0E6:		; Add
add	bx, ax

loc_1B0E8:
mov	ax, di

loc_1B0EA:		; Add
add	ax, [es:bx]
push	ax

loc_1B0EE:
mov	ax, si

loc_1B0F0:		; Shift	Logical	Left
shl	ax, 1

loc_1B0F2:		; Load Full Pointer to ES:xx
les	bx, [dword_3C534]

loc_1B0F6:		; Add
add	bx, ax

loc_1B0F8:
push	[word ptr es:bx]

loc_1B0FB:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_1B0FF:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]

loc_1B103:		; Add
add	bx, ax

loc_1B105:
push	[word ptr es:bx]

loc_1B108:		; Call Procedure
call	sub_1993F
add	sp, 6		; Add

loc_1B110:		; default
jmp	loc_1B21D

loc_1B113:		; CODE XREF: sub_1B0AD:loc_1B0D9j
			; DATA XREF: seg019:off_1B239o
push	[bp+arg_4]	; case 0x1
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_1B11A:		; Load Full Pointer to ES:xx
les	bx, [dword_3C530]

loc_1B11E:		; Add
add	bx, ax

loc_1B120:
mov	ax, di
add	ax, [es:bx]	; Add
push	ax
mov	ax, si

loc_1B128:		; Shift	Logical	Left
shl	ax, 1

loc_1B12A:		; Load Full Pointer to ES:xx
les	bx, [dword_3C534]

loc_1B12E:		; Add
add	bx, ax

loc_1B130:
push	[word ptr es:bx]
mov	ax, si

loc_1B135:		; Shift	Logical	Left
shl	ax, 1

loc_1B137:		; Load Full Pointer to ES:xx
les	bx, [dword_3C538]
add	bx, ax		; Add

loc_1B13D:
push	[word ptr es:bx]

loc_1B140:		; Call Procedure
call	sub_196B8
jmp	short loc_1B18C	; Jump

loc_1B147:		; CODE XREF: sub_1B0AD:loc_1B0D9j
			; DATA XREF: seg019:off_1B239o
push	[bp+arg_4]	; case 0x2

loc_1B14A:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_1B14E:		; Load Full Pointer to ES:xx
les	bx, [dword_3C530]
add	bx, ax		; Add

loc_1B154:
mov	ax, di
add	ax, [es:bx]	; Add

loc_1B159:		; int
push	ax

loc_1B15A:
mov	ax, si

loc_1B15C:		; Shift	Logical	Left
shl	ax, 1

loc_1B15E:		; Load Full Pointer to ES:xx
les	bx, [dword_3C534]
add	bx, ax		; Add
push	[word ptr es:bx] ; int

loc_1B167:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_1B16B:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]
add	bx, ax		; Add
mov	ax, [es:bx]
mov	dx, si

loc_1B176:		; Shift	Logical	Left
shl	dx, 1
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, dx		; Add

loc_1B17E:		; Add
add	ax, [es:bx]
cwd			; AX ->	DX:AX (with sign)

loc_1B182:		; Integer Subtraction
sub	ax, dx

loc_1B184:		; Shift	Arithmetic Right
sar	ax, 1
push	ax		; int

loc_1B187:		; Call Procedure
call	sub_196ED

loc_1B18C:		; CODE XREF: sub_1B0AD+98j
add	sp, 8		; Add

loc_1B18F:		; default
jmp	loc_1B21D

loc_1B192:		; CODE XREF: sub_1B0AD:loc_1B0D9j
			; DATA XREF: seg019:off_1B239o
mov	ax, [word_3C540] ; case	0x3
dec	ax		; Decrement by 1

loc_1B196:		; Compare Two Operands
cmp	ax, si

loc_1B198:		; Jump if Zero (ZF=1)
jz	short loc_1B1E9

loc_1B19A:
mov	ax, si

loc_1B19C:		; Shift	Logical	Left
shl	ax, 1

loc_1B19E:		; Load Full Pointer to ES:xx
les	bx, [dword_3C538]
add	bx, ax		; Add
mov	ax, [es:bx]
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, dx		; Add
sub	ax, [es:bx]	; Integer Subtraction
push	ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [es:bx]	; Add
push	ax

loc_1B1C5:
mov	ax, si

loc_1B1C7:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_1B1D6:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]
add	bx, ax		; Add
push	[word ptr es:bx]

loc_1B1DF:		; Call Procedure
call	sub_1991D
add	sp, 8		; Add

loc_1B1E7:		; Jump
jmp	short loc_1B21B

loc_1B1E9:		; CODE XREF: sub_1B0AD:loc_1B198j
mov	ax, si

loc_1B1EB:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [es:bx]	; Add
push	ax

loc_1B1F9:
mov	ax, si

loc_1B1FB:		; Shift	Logical	Left
shl	ax, 1

loc_1B1FD:		; Load Full Pointer to ES:xx
les	bx, [dword_3C534]
add	bx, ax		; Add

loc_1B203:
push	[word ptr es:bx]

loc_1B206:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_1B20A:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]
add	bx, ax		; Add

loc_1B210:
push	[word ptr es:bx]
call	sub_1993F	; Call Procedure
add	sp, 6		; Add

loc_1B21B:		; CODE XREF: sub_1B0AD:loc_1B1E7j
jmp	short $+2	; Jump

loc_1B21D:		; CODE XREF: sub_1B0AD+27j
			; sub_1B0AD:loc_1B110j
			; sub_1B0AD:loc_1B18Fj
inc	si		; default

loc_1B21E:		; CODE XREF: sub_1B0AD:loc_1B0C9j
cmp	si, [word_3C540] ; Compare Two Operands
jge	short loc_1B227	; Jump if Greater or Equal (SF=OF)

loc_1B224:		; Jump
jmp	loc_1B0CC

loc_1B227:		; CODE XREF: sub_1B0AD+175j
push	di
nop			; No Operation
push	cs
call	near ptr sub_1BBD3 ; Call Procedure
pop	cx
mov	[word_3602A], 0
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1B0AD

db 0
off_1B239 dw offset loc_1B0DE
			; DATA XREF: sub_1B0AD:loc_1B0D9r
dw offset loc_1B113	; jump table for switch	statement
dw offset loc_1B147
dw offset loc_1B192


; Attributes: bp-based frame

proc sub_1B241 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	si
push	di
mov	di, [bp+arg_6]
push	di
push	[bp+arg_4]
push	[bp+arg_2]

loc_1B250:
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_1B654 ; Call Procedure
add	sp, 8		; Add
xor	si, si		; Logical Exclusive OR
jmp	loc_1B327	; Jump

loc_1B260:		; CODE XREF: sub_1B241+ECj
mov	ax, [bp+arg_8]
or	ax, ax		; Logical Inclusive OR
jz	short loc_1B274	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_1B2A8	; Jump if Zero (ZF=1)

loc_1B26C:		; Compare Two Operands
cmp	ax, 2
jz	short loc_1B2DC	; Jump if Zero (ZF=1)

loc_1B271:		; Jump
jmp	loc_1B326

loc_1B274:		; CODE XREF: sub_1B241+24j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [es:bx]	; Add
push	ax

loc_1B284:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_1B28E:
push	[word ptr es:bx]
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_1B295:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1A0DC	; Call Procedure
add	sp, 6		; Add
jmp	short loc_1B326	; Jump

loc_1B2A8:		; CODE XREF: sub_1B241+29j
push	[bp+arg_4]
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [es:bx]	; Add
push	ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_1B2BF:		; Load Full Pointer to ES:xx
les	bx, [dword_3C534]
add	bx, ax		; Add
push	[word ptr es:bx]
mov	ax, si

loc_1B2CA:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx

loc_1B2D0:		; Add
add	bx, ax
push	[word ptr es:bx]
call	sub_1983E	; Call Procedure
jmp	short loc_1B321	; Jump

loc_1B2DC:		; CODE XREF: sub_1B241+2Ej
push	[bp+arg_4]
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx

loc_1B2E7:		; Add
add	bx, ax
mov	ax, di
add	ax, [es:bx]	; Add
push	ax

loc_1B2EF:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
mov	ax, si

loc_1B2FE:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx

loc_1B304:		; Add
add	bx, ax
mov	ax, [es:bx]
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, dx		; Add
add	ax, [es:bx]	; Add
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax

loc_1B31C:		; Call Procedure
call	sub_19873

loc_1B321:		; CODE XREF: sub_1B241+99j
add	sp, 8		; Add

loc_1B324:		; Jump
jmp	short $+2

loc_1B326:		; CODE XREF: sub_1B241:loc_1B271j
			; sub_1B241+65j
inc	si		; Increment by 1

loc_1B327:		; CODE XREF: sub_1B241+1Cj
cmp	si, [word_3C540] ; Compare Two Operands
jge	short loc_1B330	; Jump if Greater or Equal (SF=OF)
jmp	loc_1B260	; Jump

loc_1B330:		; CODE XREF: sub_1B241+EAj
push	di
nop			; No Operation
push	cs
call	near ptr sub_1BBD3 ; Call Procedure

loc_1B336:
pop	cx

loc_1B337:
mov	[word_3602A], 0
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1B241



; Attributes: bp-based frame

proc sub_1B341 far

var_4A=	byte ptr -4Ah
var_36=	byte ptr -36h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp
sub	sp, 4Ah		; Integer Subtraction
push	si
push	di
push	[bufFontsLbxEntry0]
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
add	ax, 4Ah	; 'J'   ; Add
adc	dx, 0		; Add with Carry
mov	[bp+var_20], dx

loc_1B35C:
mov	[bp+var_22], ax
mov	ax, 10h
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure

loc_1B36C:
pop	cx
pop	cx

loc_1B36E:
mov	[bp+var_2], ax
mov	ax, 48h	; 'H'
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
call	sub_2B8A7	; Call Procedure
mov	[bp+var_E], ax
mov	[bp+var_10], 1
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs

loc_1B39E:		; Call Procedure
call	near ptr sub_1B654

loc_1B3A1:		; Add
add	sp, 8
mov	[bp+var_A], 0

loc_1B3A9:		; Logical Exclusive OR
xor	di, di
jmp	loc_1B634	; Jump

loc_1B3AE:		; CODE XREF: sub_1B341+2F9j
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
add	ax, [es:bx]	; Add
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
mov	[bp+var_1E], ax

loc_1B3C8:
mov	ax, [word_3C540]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jnz	short loc_1B3DB	; Jump if Not Zero (ZF=0)

loc_1B3D0:		; Compare Two Operands
cmp	[bp+arg_8], 3
jnz	short loc_1B3DB	; Jump if Not Zero (ZF=0)
mov	[bp+arg_8], 0

loc_1B3DB:		; CODE XREF: sub_1B341+8Dj
			; sub_1B341+93j
mov	bx, [bp+arg_8]
cmp	bx, 3		; switch 4 cases
jbe	short loc_1B3E6	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_1B511	; default

loc_1B3E6:		; CODE XREF: sub_1B341+A0j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_1B64C+bx] ; switch jump

loc_1B3ED:		; DATA XREF: seg019:off_1B64Co
mov	ax, di		; case 0x0
shl	ax, 1		; Shift	Logical	Left

loc_1B3F1:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]
add	bx, ax		; Add
mov	ax, [es:bx]

loc_1B3FA:		; CODE XREF: sub_1B341:loc_1B410j
mov	[bp+var_6], ax
jmp	loc_1B511	; default

loc_1B400:		; CODE XREF: sub_1B341+A7j
			; DATA XREF: seg019:off_1B64Co
mov	ax, di		; case 0x1
shl	ax, 1		; Shift	Logical	Left

loc_1B404:		; Load Full Pointer to ES:xx
les	bx, [dword_3C538]
add	bx, ax		; Add
mov	ax, [es:bx]
sub	ax, [bp+var_1E]	; Integer Subtraction

loc_1B410:		; Jump
jmp	short loc_1B3FA

loc_1B412:		; CODE XREF: sub_1B341+A7j
			; DATA XREF: seg019:off_1B64Co
mov	ax, di		; case 0x2
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_1B41C:
mov	ax, [es:bx]
mov	dx, di
shl	dx, 1		; Shift	Logical	Left
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, dx		; Add
add	ax, [es:bx]	; Add
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, [bp+var_1E]
cwd			; AX ->	DX:AX (with sign)

loc_1B436:		; Integer Subtraction
sub	ax, dx
sar	ax, 1		; Shift	Arithmetic Right
pop	dx
sub	dx, ax		; Integer Subtraction
mov	[bp+var_6], dx
jmp	loc_1B511	; default

loc_1B443:		; CODE XREF: sub_1B341+A7j
			; DATA XREF: seg019:off_1B64Co
mov	ax, di		; case 0x3
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]

loc_1B450:
mov	[bp+var_6], ax
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
sub	ax, [bp+var_6]	; Integer Subtraction

loc_1B463:
mov	[bp+var_A], ax
cmp	[bp+var_A], 0	; Compare Two Operands
jge	short loc_1B471	; Jump if Greater or Equal (SF=OF)

loc_1B46C:
mov	[bp+var_A], 0

loc_1B471:		; CODE XREF: sub_1B341+129j
cmp	[bp+var_A], 0	; Compare Two Operands
jnz	short loc_1B47A	; Jump if Not Zero (ZF=0)
jmp	loc_1B50F	; Jump

loc_1B47A:		; CODE XREF: sub_1B341+134j
mov	[bp+var_16], 0
mov	[bp+var_18], 0
mov	ax, di
shl	ax, 1		; Shift	Logical	Left

loc_1B488:		; Load Full Pointer to ES:xx
les	bx, [dword_3C530]
add	bx, ax		; Add
mov	si, [es:bx]

loc_1B491:
mov	[bp+var_1A], 0
jmp	short loc_1B4A6	; Jump

loc_1B498:		; CODE XREF: sub_1B341+19Aj
mov	bx, [bp+arg_6]
add	bx, si		; Add
cmp	[byte ptr bx], 20h ; ' ' ; Compare Two Operands
jnz	short loc_1B4A5	; Jump if Not Zero (ZF=0)
inc	[bp+var_1A]	; Increment by 1

loc_1B4A5:		; CODE XREF: sub_1B341+15Fj
inc	si		; Increment by 1

loc_1B4A6:		; CODE XREF: sub_1B341+155j
mov	bx, [bp+arg_6]
add	bx, si		; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jz	short loc_1B4DD	; Jump if Zero (ZF=1)
mov	bx, [bp+arg_6]
add	bx, si		; Add
cmp	[byte ptr bx], 0Dh ; Compare Two Operands
jz	short loc_1B4DD	; Jump if Zero (ZF=1)

loc_1B4BA:
mov	bx, [bp+arg_6]
add	bx, si		; Add
cmp	[byte ptr bx], 14h ; Compare Two Operands
jz	short loc_1B4DD	; Jump if Zero (ZF=1)
mov	bx, [bp+arg_6]
add	bx, si		; Add

loc_1B4C9:		; Compare Two Operands
cmp	[byte ptr bx], 19h
jz	short loc_1B4DD	; Jump if Zero (ZF=1)
mov	bx, [bp+arg_6]
add	bx, si		; Add
cmp	[byte ptr bx], 15h ; Compare Two Operands
jz	short loc_1B4DD	; Jump if Zero (ZF=1)
cmp	si, 1Dh		; Compare Two Operands
jnz	short loc_1B498	; Jump if Not Zero (ZF=0)

loc_1B4DD:		; CODE XREF: sub_1B341+16Dj
			; sub_1B341+177j
			; sub_1B341+181j
			; sub_1B341+18Bj
			; sub_1B341+195j
cmp	[bp+var_1A], 0	; Compare Two Operands
jnz	short loc_1B4E8	; Jump if Not Zero (ZF=0)
mov	[bp+var_A], 0

loc_1B4E8:		; CODE XREF: sub_1B341+1A0j
mov	ax, [bp+var_1E]
sub	[bp+var_A], ax	; Integer Subtraction
cmp	[bp+var_A], 0	; Compare Two Operands
jg	short loc_1B4FB	; Jump if Greater (ZF=0	& SF=OF)
mov	[bp+var_A], 0
jmp	short loc_1B50F	; Jump

loc_1B4FB:		; CODE XREF: sub_1B341+1B1j
mov	ax, [bp+var_A]
cwd			; AX ->	DX:AX (with sign)

loc_1B4FF:		; Signed Divide
idiv	[bp+var_1A]
mov	[bp+var_18], dx
mov	ax, [bp+var_A]
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_1A]	; Signed Divide

loc_1B50C:
mov	[bp+var_1C], ax

loc_1B50F:		; CODE XREF: sub_1B341+136j
			; sub_1B341+1B8j
jmp	short $+2	; Jump

loc_1B511:		; CODE XREF: sub_1B341+A2j
			; sub_1B341+BCj
			; sub_1B341+FFj
mov	ax, di		; default
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]

loc_1B51E:
mov	[bp+var_8], ax
mov	[bp+var_12], 0
mov	[bp+var_14], 0
jmp	short loc_1B5A4	; Jump

loc_1B52D:		; CODE XREF: sub_1B341+293j
cmp	[bp+var_C], 4	; Compare Two Operands
jnz	short loc_1B566	; Jump if Not Zero (ZF=0)
cmp	[bp+var_14], 0	; Compare Two Operands
jnz	short loc_1B54F	; Jump if Not Zero (ZF=0)
mov	[bp+var_14], 1
mov	bx, [bp+var_12]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_36]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bp+var_6]

loc_1B54B:
mov	[bx], ax
jmp	short loc_1B566	; Jump

loc_1B54F:		; CODE XREF: sub_1B341+1F6j
mov	[bp+var_14], 0
mov	bx, [bp+var_12]

loc_1B557:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bp+var_6]
mov	[bx], ax

loc_1B563:		; Increment by 1
inc	[bp+var_12]

loc_1B566:		; CODE XREF: sub_1B341+1F0j
			; sub_1B341+20Cj
cmp	[bp+var_C], 20h	; ' ' ; Compare Two Operands
jl	short loc_1B5A1	; Jump if Less (SF!=OF)
mov	bx, [bp+var_C]
mov	es, [bp+var_20]

loc_1B572:		; Add
add	bx, [bp+var_22]
mov	al, [es:bx-20h]
mov	ah, 0

loc_1B57B:		; Add
add	ax, [bp+var_4]
add	[bp+var_6], ax	; Add
cmp	[bp+var_A], 0	; Compare Two Operands
jz	short loc_1B5A1	; Jump if Zero (ZF=1)
cmp	[bp+var_C], 20h	; ' ' ; Compare Two Operands
jnz	short loc_1B5A1	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_1C]
add	[bp+var_6], ax	; Add
mov	ax, [bp+var_16]
cmp	ax, [bp+var_18]	; Compare Two Operands
jge	short loc_1B59E	; Jump if Greater or Equal (SF=OF)

loc_1B59B:		; Increment by 1
inc	[bp+var_6]

loc_1B59E:		; CODE XREF: sub_1B341+258j
inc	[bp+var_16]	; Increment by 1

loc_1B5A1:		; CODE XREF: sub_1B341+229j
			; sub_1B341+244j
			; sub_1B341+24Aj
inc	[bp+var_8]	; Increment by 1

loc_1B5A4:		; CODE XREF: sub_1B341+1EAj
mov	bx, [bp+arg_6]
add	bx, [bp+var_8]	; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_C], ax

loc_1B5B0:		; Compare Two Operands
cmp	[bp+var_C], 0
jz	short loc_1B5D7	; Jump if Zero (ZF=1)

loc_1B5B6:		; Compare Two Operands
cmp	[bp+var_C], 15h
jz	short loc_1B5D7	; Jump if Zero (ZF=1)
cmp	[bp+var_C], 0Dh	; Compare Two Operands
jz	short loc_1B5D7	; Jump if Zero (ZF=1)

loc_1B5C2:		; Compare Two Operands
cmp	[bp+var_C], 14h
jz	short loc_1B5D7	; Jump if Zero (ZF=1)
cmp	[bp+var_C], 19h	; Compare Two Operands
jz	short loc_1B5D7	; Jump if Zero (ZF=1)
cmp	[bp+var_C], 1Dh	; Compare Two Operands
jz	short loc_1B5D7	; Jump if Zero (ZF=1)
jmp	loc_1B52D	; Jump

loc_1B5D7:		; CODE XREF: sub_1B341+273j
			; sub_1B341+279j
			; sub_1B341+27Fj
			; sub_1B341+285j
			; sub_1B341+28Bj
			; sub_1B341+291j
xor	si, si		; Logical Exclusive OR
jmp	short loc_1B62E	; Jump

loc_1B5DB:		; CODE XREF: sub_1B341+2F0j
push	[bp+arg_E]

loc_1B5DE:
push	[bp+arg_C]

loc_1B5E1:
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_1B5EB:
mov	ax, [es:bx]
add	ax, [bp+var_2]	; Add
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add

loc_1B5FB:
push	[word ptr bx]
mov	ax, di

loc_1B5FF:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
dec	ax		; Decrement by 1
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_1B610:		; Load Effective Address
lea	ax, [bp+var_36]
add	bx, ax		; Add
mov	ax, [bx]
dec	ax		; Decrement by 1
push	ax
push	[bp+var_10]
push	[bp+arg_A]

loc_1B61F:
push	[bp+var_E]
call	sub_29D8F	; Call Procedure
add	sp, 12h		; Add

loc_1B62A:		; Increment by 1
inc	[bp+var_10]
inc	si		; Increment by 1

loc_1B62E:		; CODE XREF: sub_1B341+298j
cmp	si, [bp+var_12]	; Compare Two Operands
jl	short loc_1B5DB	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_1B634:		; CODE XREF: sub_1B341+6Aj
cmp	di, [word_3C540] ; Compare Two Operands
jge	short loc_1B63D	; Jump if Greater or Equal (SF=OF)
jmp	loc_1B3AE	; Jump

loc_1B63D:		; CODE XREF: sub_1B341+2F7j
push	[bp+arg_6]

loc_1B640:		; No Operation
nop
push	cs
call	near ptr sub_1BBD3 ; Call Procedure
pop	cx
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1B341

off_1B64C dw offset loc_1B3ED
			; DATA XREF: sub_1B341+A7r
dw offset loc_1B400	; jump table for switch	statement
dw offset loc_1B412
dw offset loc_1B443


; Attributes: bp-based frame

proc sub_1B654 far	; CODE XREF: sub_1B0AD:loc_1B0C1p
			; sub_1B241+14p
			; sub_1B341:loc_1B39Ep
			; sub_1B984+27p
			; sub_1B9E2:loc_1B9F7p
			; sub_1BC65+13p

var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 20h		; Integer Subtraction
push	si
push	di
mov	[bp+var_2], 0
mov	[word_3C540], 0
mov	[bp+var_1C], 0FFFFh
push	[bufFontsLbxEntry0]
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
add	ax, 4Ah	; 'J'   ; Add
adc	dx, 0		; Add with Carry
mov	[bp+var_1E], dx
mov	[bp+var_20], ax
mov	ax, 16
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, 48h	; 'H'
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_6], ax
mov	ax, 44h	; 'D'
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_8], ax
mov	ax, [bp+arg_2]
mov	[bp+var_E], ax
jmp	loc_1B970	; Jump

loc_1B6C1:		; CODE XREF: sub_1B654:loc_1B97Bj
mov	[bp+var_12], 0
db 83h,7Eh,0E4h,0FFh ; <BAD>cmp	    [bp+var_1C], 0FFFFh	; Compare Two Operands
jnz	short loc_1B6DE	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	[bp+var_C], ax
mov	ax, [bp+arg_0]
add	ax, [bp+arg_4]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_10], ax

loc_1B6DC:		; Jump
jmp	short loc_1B6F3

loc_1B6DE:		; CODE XREF: sub_1B654+76j
mov	ax, [bp+var_1C]
mov	[bp+var_C], ax
mov	ax, [bp+arg_0]

loc_1B6E7:		; Add
add	ax, [bp+arg_4]

loc_1B6EA:		; Decrement by 1
dec	ax
mov	[bp+var_10], ax
mov	[bp+var_1C], 0FFFFh

loc_1B6F3:		; CODE XREF: sub_1B654:loc_1B6DCj
xor	di, di		; Logical Exclusive OR

loc_1B6F5:		; Jump
jmp	loc_1B781

loc_1B6F8:		; CODE XREF: sub_1B654+139j
mov	bx, di

loc_1B6FA:		; Shift	Logical	Left
shl	bx, 1

loc_1B6FC:
mov	ax, [word_3C552+bx]

loc_1B700:		; Compare Two Operands
cmp	ax, [bp+var_E]
jg	short loc_1B712	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_3C542+bx]
cmp	ax, [bp+var_E]	; Compare Two Operands

loc_1B710:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1B732

loc_1B712:		; CODE XREF: sub_1B654+AFj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_E]
add	ax, [bp+var_8]	; Add

loc_1B71C:		; Compare Two Operands
cmp	[word_3C552+bx], ax
jg	short loc_1B780	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, di

loc_1B724:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bp+var_E]

loc_1B729:		; Add
add	ax, [bp+var_4]
cmp	[word_3C542+bx], ax ; Compare Two Operands

loc_1B730:		; Jump if Less (SF!=OF)
jl	short loc_1B780

loc_1B732:		; CODE XREF: sub_1B654:loc_1B710j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_3C54A+bx]
cmp	ax, [bp+var_C]	; Compare Two Operands
jle	short loc_1B773	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_3C55A+bx]
cmp	ax, [bp+var_10]	; Compare Two Operands
jge	short loc_1B773	; Jump if Greater or Equal (SF=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left

loc_1B750:
mov	ax, [word_3C55A+bx]
cmp	ax, [bp+var_C]	; Compare Two Operands
jle	short loc_1B767	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left

loc_1B75D:
mov	ax, [word_3C55A+bx]
dec	ax		; Decrement by 1
mov	[bp+var_10], ax
jmp	short loc_1B773	; Jump

loc_1B767:		; CODE XREF: sub_1B654+103j
mov	bx, di

loc_1B769:		; Shift	Logical	Left
shl	bx, 1

loc_1B76B:
mov	ax, [word_3C54A+bx]
inc	ax		; Increment by 1
mov	[bp+var_C], ax

loc_1B773:		; CODE XREF: sub_1B654+E9j
			; sub_1B654+F6j
			; sub_1B654+111j
mov	ax, [bp+var_C]
cmp	ax, [bp+var_10]	; Compare Two Operands
jl	short loc_1B780	; Jump if Less (SF!=OF)
mov	[bp+var_12], 1

loc_1B780:		; CODE XREF: sub_1B654+CCj
			; sub_1B654:loc_1B730j
			; sub_1B654+125j
inc	di		; Increment by 1

loc_1B781:		; CODE XREF: sub_1B654:loc_1B6F5j
cmp	di, [word_3602A] ; Compare Two Operands
jge	short loc_1B790	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_12], 0	; Compare Two Operands
jnz	short loc_1B790	; Jump if Not Zero (ZF=0)
jmp	loc_1B6F8	; Jump

loc_1B790:		; CODE XREF: sub_1B654+131j
			; sub_1B654+137j
cmp	[bp+var_12], 0	; Compare Two Operands
jz	short loc_1B799	; Jump if Zero (ZF=1)
jmp	loc_1B955	; Jump

loc_1B799:		; CODE XREF: sub_1B654+140j
mov	ax, [bp+var_E]
add	ax, [bp+var_4]	; Add
cmp	ax, 0C8h ; ''  ; Compare Two Operands
jl	short loc_1B7AF	; Jump if Less (SF!=OF)
mov	[word_3C540], 0
xor	ax, ax		; Logical Exclusive OR
jmp	loc_1B97E	; Jump

loc_1B7AF:		; CODE XREF: sub_1B654+14Ej
mov	ax, [bp+var_10]
sub	ax, [bp+var_C]	; Integer Subtraction
inc	ax		; Increment by 1

loc_1B7B6:
mov	[bp+var_1A], ax
mov	[bp+var_14], 0FFFFh

loc_1B7BE:
mov	[bp+var_A], 0FFFFh
mov	si, [bp+var_2]
jmp	short loc_1B827	; Jump

loc_1B7C8:		; CODE XREF: sub_1B654+1DBj
mov	bx, [bp+arg_6]
add	bx, si		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_16], ax
cmp	[bp+var_16], 20h ; ' ' ; Compare Two Operands
jl	short loc_1B7F9	; Jump if Less (SF!=OF)
mov	bx, [bp+var_16]
mov	es, [bp+var_1E]
add	bx, [bp+var_20]	; Add
mov	al, [es:bx-20h]
mov	ah, 0

loc_1B7E8:		; Add
add	ax, [bp+var_6]

loc_1B7EB:		; Integer Subtraction
sub	[bp+var_1A], ax

loc_1B7EE:		; Compare Two Operands
cmp	[bp+var_16], 20h ; ' '
jnz	short loc_1B7F7	; Jump if Not Zero (ZF=0)

loc_1B7F4:
mov	[bp+var_14], si

loc_1B7F7:		; CODE XREF: sub_1B654+19Ej
jmp	short loc_1B826	; Jump

loc_1B7F9:		; CODE XREF: sub_1B654+183j
cmp	[bp+var_16], 14h ; Compare Two Operands
jz	short loc_1B817	; Jump if Zero (ZF=1)

loc_1B7FF:		; Compare Two Operands
cmp	[bp+var_16], 0Dh
jz	short loc_1B817	; Jump if Zero (ZF=1)
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_1B817	; Jump if Zero (ZF=1)

loc_1B80B:		; Compare Two Operands
cmp	[bp+var_16], 19h

loc_1B80F:		; Jump if Zero (ZF=1)
jz	short loc_1B817

loc_1B811:		; Compare Two Operands
cmp	[bp+var_16], 1Dh
jnz	short loc_1B826	; Jump if Not Zero (ZF=0)

loc_1B817:		; CODE XREF: sub_1B654+1A9j
			; sub_1B654+1AFj
			; sub_1B654+1B5j
			; sub_1B654:loc_1B80Fj
mov	ax, [bp+var_6]
neg	ax		; Two's Complement Negation
dec	ax		; Decrement by 1
mov	[bp+var_1A], ax

loc_1B820:
mov	ax, [bp+var_16]
mov	[bp+var_A], ax

loc_1B826:		; CODE XREF: sub_1B654:loc_1B7F7j
			; sub_1B654+1C1j
inc	si		; Increment by 1

loc_1B827:		; CODE XREF: sub_1B654+172j
mov	ax, [bp+var_6]
neg	ax		; Two's Complement Negation
cmp	ax, [bp+var_1A]	; Compare Two Operands
jle	short loc_1B7C8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1B831:		; Compare Two Operands
cmp	[bp+var_A], 0
jnz	short loc_1B838	; Jump if Not Zero (ZF=0)
dec	si		; Decrement by 1

loc_1B838:		; CODE XREF: sub_1B654+1E1j
db 83h,7Eh,0F6h,0FFh ; <BAD>cmp	    [bp+var_A],	0FFFFh ; Compare Two Operands
jnz	short loc_1B841	; Jump if Not Zero (ZF=0)
jmp	loc_1B8F7	; Jump

loc_1B841:		; CODE XREF: sub_1B654+1E8j
mov	ax, [word_3C540]
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_1B84C:
mov	ax, [bp+var_C]

loc_1B84F:
mov	[es:bx], ax
mov	ax, [word_3C540]
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_10]

loc_1B860:
mov	[es:bx], ax
mov	ax, [word_3C540]
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_1B86E:
mov	ax, [bp+var_E]

loc_1B871:
mov	[es:bx], ax

loc_1B874:
mov	ax, [word_3C540]
shl	ax, 1		; Shift	Logical	Left

loc_1B879:		; Load Full Pointer to ES:xx
les	bx, [dword_3C530]
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	[es:bx], ax
inc	[word_3C540]	; Increment by 1

loc_1B889:		; Compare Two Operands
cmp	[bp+var_A], 19h
jnz	short loc_1B8BC	; Jump if Not Zero (ZF=0)
mov	bx, [bp+arg_6]
add	bx, si		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
add	ax, 0FFD0h	; Add
mov	dx, 0Ah
imul	dx		; Signed Multiply

loc_1B89F:
mov	[bp+var_18], ax

loc_1B8A2:
mov	bx, [bp+arg_6]
add	bx, si		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
add	ax, 0FFD0h	; Add
add	[bp+var_18], ax	; Add
mov	ax, [bp+var_18]
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_E], ax
add	si, 2		; Add

loc_1B8BC:		; CODE XREF: sub_1B654+239j
cmp	[bp+var_A], 1Dh	; Compare Two Operands
jnz	short loc_1B8F2	; Jump if Not Zero (ZF=0)
mov	bx, [bp+arg_6]
add	bx, si		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
add	ax, 0FFD0h	; Add
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	[bp+var_18], ax
mov	bx, [bp+arg_6]
add	bx, si		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
add	ax, 0FFD0h	; Add
add	[bp+var_18], ax	; Add
mov	ax, [bp+var_8]
sub	[bp+var_E], ax	; Integer Subtraction
mov	ax, [bp+var_18]
mov	[bp+var_1C], ax
add	si, 2		; Add

loc_1B8F2:		; CODE XREF: sub_1B654+26Cj
mov	[bp+var_2], si
jmp	short loc_1B955	; Jump

loc_1B8F7:		; CODE XREF: sub_1B654+1EAj
mov	ax, [word_3C540]
shl	ax, 1		; Shift	Logical	Left

loc_1B8FC:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]
add	bx, ax		; Add
mov	ax, [bp+var_C]
mov	[es:bx], ax
mov	ax, [word_3C540]
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_10]
mov	[es:bx], ax
mov	ax, [word_3C540]
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	[es:bx], ax
mov	ax, [word_3C540]
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	[es:bx], ax
inc	[word_3C540]	; Increment by 1
db 83h,7Eh,0ECh,0FFh ; <BAD>cmp	    [bp+var_14], 0FFFFh	; Compare Two Operands
jz	short loc_1B955	; Jump if Zero (ZF=1)
mov	bx, [bp+arg_6]
add	bx, [bp+var_14]	; Add

loc_1B94B:
mov	[byte ptr bx], 15h
mov	ax, [bp+var_14]
inc	ax		; Increment by 1
mov	[bp+var_2], ax

loc_1B955:		; CODE XREF: sub_1B654+142j
			; sub_1B654+2A1j
			; sub_1B654+2EFj
mov	ax, [bp+arg_0]
add	ax, [bp+arg_4]	; Add
dec	ax		; Decrement by 1
cmp	ax, [bp+var_10]	; Compare Two Operands

loc_1B95F:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_1B96A
mov	ax, [bp+var_10]
inc	ax		; Increment by 1
mov	[bp+var_1C], ax
jmp	short loc_1B970	; Jump

loc_1B96A:		; CODE XREF: sub_1B654:loc_1B95Fj
mov	ax, [bp+var_8]
add	[bp+var_E], ax	; Add

loc_1B970:		; CODE XREF: sub_1B654+6Aj
			; sub_1B654+314j
mov	bx, [bp+arg_6]
add	bx, [bp+var_2]	; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jz	short loc_1B97E	; Jump if Zero (ZF=1)

loc_1B97B:		; Jump
jmp	loc_1B6C1

loc_1B97E:		; CODE XREF: sub_1B654+158j
			; sub_1B654+325j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1B654



; Attributes: bp-based frame

proc sub_1B984 far	; CODE XREF: sub_4D5B0+A1P
			; sub_4D7A1+20P
			; sub_4D8FA:loc_4D99FP
			; sub_4DA02:loc_4DA22P
			; idk_OVR_LoadLbxHelp+28FP
			; idk_OVR_LoadLbxHelp+4C0P

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
mov	si, [bp+arg_2]
mov	ax, 10h
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
push	si

loc_1B9A1:
push	[bp+arg_0]

loc_1B9A4:		; Logical Exclusive OR
xor	ax, ax
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	cs
call	near ptr sub_1B654 ; Call Procedure
add	sp, 8		; Add
cmp	[word_3C540], 1	; Compare Two Operands
jge	short loc_1B9BC	; Jump if Greater or Equal (SF=OF)
xor	ax, ax		; Logical Exclusive OR

loc_1B9BA:		; CODE XREF: sub_1B984+57j
jmp	short loc_1B9DD	; Jump

loc_1B9BC:		; CODE XREF: sub_1B984+32j
mov	ax, [word_3C540]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]

loc_1B9CB:		; Add
add	ax, [bp+var_2]
mov	[bp+var_4], ax
push	si
nop			; No Operation
push	cs

loc_1B9D4:		; Call Procedure
call	near ptr sub_1BBD3
pop	cx
mov	ax, [bp+var_4]
jmp	short loc_1B9BA	; Jump

loc_1B9DD:		; CODE XREF: sub_1B984:loc_1B9BAj
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1B984



; Attributes: bp-based frame

proc sub_1B9E2 far	; CODE XREF: sub_4E9F4+143P
			; sub_4EC17+83P
			; sub_4EF74+148P
			; sub_4F1AB+4CP

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
push	[bp+arg_2]
push	[bp+arg_0]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	cs

loc_1B9F7:		; Call Procedure
call	near ptr sub_1B654
add	sp, 8		; Add

loc_1B9FD:
mov	[bp+var_A], 3E8h
mov	[bp+var_C], 0
xor	si, si		; Logical Exclusive OR
jmp	loc_1BAE0	; Jump

loc_1BA0C:		; CODE XREF: sub_1B9E2+104j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
add	ax, [es:bx]	; Add

loc_1BA1C:
push	ax

loc_1BA1D:		; Call Procedure
call	sub_1AF46
pop	cx
dec	ax		; Decrement by 1

loc_1BA24:
mov	[bp+var_8], ax

loc_1BA27:
mov	bx, [bp+arg_4]

loc_1BA2A:		; switch 4 cases
cmp	bx, 3
jbe	short loc_1BA32	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_1BA2F:		; default
jmp	loc_1BAC9

loc_1BA32:		; CODE XREF: sub_1B9E2+4Bj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_1BB08+bx] ; switch jump

loc_1BA39:		; DATA XREF: seg019:off_1BB08o
mov	ax, si		; case 0x0
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	di, [es:bx]
mov	ax, di
add	ax, [bp+var_8]	; Add

loc_1BA4B:		; CODE XREF: sub_1B9E2+E5j
mov	[bp+var_4], ax
jmp	short loc_1BAC9	; default

loc_1BA50:		; CODE XREF: sub_1B9E2+52j
			; DATA XREF: seg019:off_1BB08o
mov	ax, si		; case 0x1
shl	ax, 1		; Shift	Logical	Left

loc_1BA54:		; Load Full Pointer to ES:xx
les	bx, [dword_3C538]

loc_1BA58:		; Add
add	bx, ax
mov	ax, [es:bx]

loc_1BA5D:
mov	[bp+var_4], ax

loc_1BA60:
mov	ax, [bp+var_4]
sub	ax, [bp+var_8]	; Integer Subtraction
mov	di, ax
jmp	short loc_1BAC9	; default

loc_1BA6A:		; CODE XREF: sub_1B9E2+52j
			; DATA XREF: seg019:off_1BB08o
mov	ax, si		; case 0x2
shl	ax, 1		; Shift	Logical	Left

loc_1BA6E:		; Load Full Pointer to ES:xx
les	bx, [dword_3C538]
add	bx, ax		; Add

loc_1BA74:
mov	ax, [es:bx]
mov	dx, si
shl	dx, 1		; Shift	Logical	Left

loc_1BA7B:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]

loc_1BA7F:		; Add
add	bx, dx

loc_1BA81:		; Add
add	ax, [es:bx]
cwd			; AX ->	DX:AX (with sign)

loc_1BA85:		; Integer Subtraction
sub	ax, dx
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_6], ax
mov	ax, [bp+var_8]
cwd			; AX ->	DX:AX (with sign)

loc_1BA90:		; Integer Subtraction
sub	ax, dx
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+var_6]
sub	dx, ax		; Integer Subtraction

loc_1BA99:
mov	di, dx
mov	ax, [bp+var_8]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+var_6]
add	dx, ax		; Add
mov	[bp+var_4], dx
jmp	short loc_1BAC9	; default

loc_1BAAD:		; CODE XREF: sub_1B9E2+52j
			; DATA XREF: seg019:off_1BB08o
mov	ax, si		; case 0x3

loc_1BAAF:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx

loc_1BAB5:		; Add
add	bx, ax
mov	di, [es:bx]
mov	ax, si

loc_1BABC:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
jmp	short loc_1BA4B	; Jump

loc_1BAC9:		; CODE XREF: sub_1B9E2:loc_1BA2Fj
			; sub_1B9E2+6Cj
			; sub_1B9E2+86j
			; sub_1B9E2+C9j
cmp	di, [bp+var_A]	; default
jge	short loc_1BAD1	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_A], di

loc_1BAD1:		; CODE XREF: sub_1B9E2+EAj
mov	ax, [bp+var_4]
cmp	ax, [bp+var_C]	; Compare Two Operands
jle	short loc_1BADF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1BAD9:
mov	ax, [bp+var_4]
mov	[bp+var_C], ax

loc_1BADF:		; CODE XREF: sub_1B9E2+F5j
inc	si		; Increment by 1

loc_1BAE0:		; CODE XREF: sub_1B9E2+27j
cmp	si, [word_3C540] ; Compare Two Operands
jge	short loc_1BAE9	; Jump if Greater or Equal (SF=OF)
jmp	loc_1BA0C	; Jump

loc_1BAE9:		; CODE XREF: sub_1B9E2+102j
push	[bp+arg_2]
nop			; No Operation
push	cs

loc_1BAEE:		; Call Procedure
call	near ptr sub_1BBD3
pop	cx

loc_1BAF2:
mov	ax, [bp+var_C]
sub	ax, [bp+var_A]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_2], ax
mov	ax, [bp+var_2]

loc_1BAFF:		; Jump
jmp	short $+2
pop	di
pop	si

loc_1BB03:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1B9E2

align 2
off_1BB08 dw offset loc_1BA39
			; DATA XREF: sub_1B9E2+52r
dw offset loc_1BA50	; jump table for switch	statement
dw offset loc_1BA6A
dw offset loc_1BAAD


; Attributes: bp-based frame

proc sub_1BB10 far
push	bp

loc_1BB11:
mov	bp, sp
mov	[word_3602A], 0
pop	bp
retf			; Return Far from Procedure
endp sub_1BB10



; Attributes: bp-based frame

proc sub_1BB1B far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp

loc_1BB1E:		; Compare Two Operands
cmp	[word_3602A], 4
jge	short loc_1BB5D	; Jump if Greater or Equal (SF=OF)
mov	bx, [word_3602A]
shl	bx, 1		; Shift	Logical	Left

loc_1BB2B:
mov	ax, [bp+arg_0]
mov	[bx-57B6h], ax
mov	bx, [word_3602A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+arg_2]
mov	[bx-57BEh], ax
mov	bx, [word_3602A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+arg_4]
mov	[bx-57C6h], ax
mov	bx, [word_3602A]
shl	bx, 1		; Shift	Logical	Left

loc_1BB52:
mov	ax, [bp+arg_6]
mov	[bx-57CEh], ax
inc	[word_3602A]	; Increment by 1

loc_1BB5D:		; CODE XREF: sub_1BB1B+8j
pop	bp
retf			; Return Far from Procedure
endp sub_1BB1B



; Attributes: bp-based frame

proc sub_1BB5F far

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
argOffset= dword ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax

loc_1BB7D:
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax

loc_1BB8E:		; Compare Two Operands
cmp	[word_3602A], 4
jge	short loc_1BBCD	; Jump if Greater or Equal (SF=OF)
mov	bx, [word_3602A]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-57B6h], si
mov	bx, [word_3602A]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-57BEh], di
mov	bx, [word_3602A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, si
add	ax, [bp+var_2]	; Add
dec	ax		; Decrement by 1
mov	[bx-57C6h], ax
mov	bx, [word_3602A]

loc_1BBBD:		; Shift	Logical	Left
shl	bx, 1
mov	ax, di
add	ax, [bp+var_4]	; Add
dec	ax		; Decrement by 1
mov	[bx-57CEh], ax

loc_1BBC9:		; Increment by 1
inc	[word_3602A]

loc_1BBCD:		; CODE XREF: sub_1BB5F+34j
pop	di
pop	si

loc_1BBCF:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1BB5F



; Attributes: bp-based frame

proc sub_1BBD3 far	; CODE XREF: sub_1B0AD+17Dp
			; sub_1B241+F2p
			; sub_1B341+301p
			; sub_1B984:loc_1B9D4p
			; sub_1B9E2:loc_1BAEEp
			; sub_1BC65+18Ap

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	dx, [bp+arg_0]
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1BBEE	; Jump

loc_1BBDD:		; CODE XREF: sub_1BBD3+22j
mov	bx, dx
add	bx, ax		; Add
cmp	[byte ptr bx], 15h ; Compare Two Operands
jnz	short loc_1BBED	; Jump if Not Zero (ZF=0)
mov	bx, dx
add	bx, ax		; Add
mov	[byte ptr bx], 20h ; ' '

loc_1BBED:		; CODE XREF: sub_1BBD3+11j
inc	ax		; Increment by 1

loc_1BBEE:		; CODE XREF: sub_1BBD3+8j
mov	bx, dx
add	bx, ax		; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jnz	short loc_1BBDD	; Jump if Not Zero (ZF=0)
pop	bp
retf			; Return Far from Procedure
endp sub_1BBD3



; Attributes: bp-based frame

proc sub_1BBF9 far	; CODE XREF: sub_28141+12BP
			; sub_28583:loc_2860BP
			; sub_28963+12P
			; sub_28963+AFP
			; sub_28D4A+90P
			; sub_28F19+90P
			; sub_290A9:loc_2913AP
			; sub_2A755+44P
			; sub_2B1F9+28P
			; sub_2BA41+10AP
			; sub_2BA41+249P
			; sub_2BA41+3D2P
			; sub_2BA41+519P
			; sub_2BA41+6A2P
			; sub_2BA41+7F8P
			; sub_2BA41+981P
			; sub_2BA41:loc_2C4B9P
			; sub_2CF44+B1P
			; sub_2CF44+23DP
			; sub_2CF44+38AP
			; sub_2CF44+516P
			; sub_2CF44+666P
			; sub_2CF44+7F2P
			; sub_2CF44+98DP
			; sub_2CF44+B16P
			; sub_2CF44:loc_2DBAAP

var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 2		; arg2_SI
mov	ax, 10h
push	ax
push	[bufFontsLbxEntry0] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
jmp	short $+2	; Jump
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1BBF9



; Attributes: bp-based frame

proc sub_1BC1A far

var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction

loc_1BC20:
push	si
push	di
xor	si, si		; Logical Exclusive OR
xor	di, di		; Logical Exclusive OR
jmp	short loc_1BC45	; Jump

loc_1BC28:		; CODE XREF: sub_1BC1A+2Ej
mov	ax, di
add	ax, 4Ah	; 'J'   ; Add
push	ax
push	[bufFontsLbxEntry0]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax

loc_1BC3C:		; Compare Two Operands
cmp	[bp+var_2], si
jle	short loc_1BC44	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	si, [bp+var_2]

loc_1BC44:		; CODE XREF: sub_1BC1A+25j
inc	di		; Increment by 1

loc_1BC45:		; CODE XREF: sub_1BC1A+Cj
cmp	di, 60h	; '`'   ; Compare Two Operands
jl	short loc_1BC28	; Jump if Less (SF!=OF)
mov	ax, 48h	; 'H'
push	ax

loc_1BC4E:
push	[bufFontsLbxEntry0]

loc_1BC52:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx
add	si, ax		; Add
mov	ax, si
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1BC1A



; Attributes: bp-based frame

proc sub_1BC65 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	si
push	di
mov	di, [bp+arg_6]
push	di
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_1B654 ; Call Procedure
add	sp, 8		; Add
xor	si, si		; Logical Exclusive OR
jmp	loc_1BDE4	; Jump

loc_1BC83:		; CODE XREF: sub_1BC65:loc_1BDEAj
mov	bx, [bp+arg_8]
cmp	bx, 3		; switch 4 cases
jbe	short loc_1BC8E	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_1BDE3	; default

loc_1BC8E:		; CODE XREF: sub_1BC65+24j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_1BDFD+bx] ; switch jump

loc_1BC95:		; DATA XREF: seg019:off_1BDFDo
push	[bp+arg_A]	; case 0x0

loc_1BC98:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [es:bx]	; Add
push	ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx

loc_1BCB0:		; Add
add	bx, ax
push	[word ptr es:bx]
mov	ax, si

loc_1BCB7:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1A5D5	; Call Procedure
add	sp, 8		; Add
jmp	loc_1BDE3	; default

loc_1BCCD:		; CODE XREF: sub_1BC65+2Bj
			; DATA XREF: seg019:off_1BDFDo
push	[bp+arg_A]	; case 0x1
push	[bp+arg_4]
mov	ax, si

loc_1BCD5:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx

loc_1BCDB:		; Add
add	bx, ax
mov	ax, di
add	ax, [es:bx]	; Add

loc_1BCE2:
push	ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]

loc_1BCFD:		; Call Procedure
call	sub_1A9A8
jmp	short loc_1BD4C	; Jump

loc_1BD04:		; CODE XREF: sub_1BC65+2Bj
			; DATA XREF: seg019:off_1BDFDo
push	[bp+arg_A]	; case 0x2
push	[bp+arg_4]

loc_1BD0A:
mov	ax, si

loc_1BD0C:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [es:bx]	; Add
push	ax
mov	ax, si

loc_1BD1C:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, dx		; Add
add	ax, [es:bx]	; Add
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
call	sub_1A9DF	; Call Procedure

loc_1BD4C:		; CODE XREF: sub_1BC65+9Dj
add	sp, 0Ah		; Add
jmp	loc_1BDE3	; default

loc_1BD52:		; CODE XREF: sub_1BC65+2Bj
			; DATA XREF: seg019:off_1BDFDo
mov	ax, [word_3C540] ; case	0x3
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jz	short loc_1BDAC	; Jump if Zero (ZF=1)
push	[bp+arg_A]
mov	ax, si

loc_1BD5F:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C538] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
mov	dx, si
shl	dx, 1		; Shift	Logical	Left

loc_1BD6E:		; Load Full Pointer to ES:xx
les	bx, [dword_3C53C]
add	bx, dx		; Add
sub	ax, [es:bx]	; Integer Subtraction
push	ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [es:bx]	; Add
push	ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]

loc_1BD95:
mov	ax, si

loc_1BD97:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1AA1C	; Call Procedure
add	sp, 0Ah		; Add
jmp	short loc_1BDE1	; Jump

loc_1BDAC:		; CODE XREF: sub_1BC65+F3j
push	[bp+arg_A]

loc_1BDAF:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C530] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di

loc_1BDBB:		; Add
add	ax, [es:bx]
push	ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
les	bx, [dword_3C534] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]

loc_1BDCC:
mov	ax, si

loc_1BDCE:		; Shift	Logical	Left
shl	ax, 1
les	bx, [dword_3C53C] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1A5D5	; Call Procedure
add	sp, 8		; Add

loc_1BDE1:		; CODE XREF: sub_1BC65+145j
jmp	short $+2	; Jump

loc_1BDE3:		; CODE XREF: sub_1BC65+26j
			; sub_1BC65+65j
			; sub_1BC65+EAj
inc	si		; default

loc_1BDE4:		; CODE XREF: sub_1BC65+1Bj
cmp	si, [word_3C540] ; Compare Two Operands
jge	short loc_1BDED	; Jump if Greater or Equal (SF=OF)

loc_1BDEA:		; Jump
jmp	loc_1BC83

loc_1BDED:		; CODE XREF: sub_1BC65+183j
push	di
push	cs
call	near ptr sub_1BBD3 ; Call Procedure
pop	cx

loc_1BDF3:
mov	[word_3602A], 0
pop	di
pop	si
pop	bp

locret_1BDFC:		; Return Far from Procedure
retf
endp sub_1BC65

off_1BDFD dw offset loc_1BC95
			; DATA XREF: sub_1BC65+2Br
dw offset loc_1BCCD	; jump table for switch	statement
dw offset loc_1BD04
dw offset loc_1BD52


; Attributes: bp-based frame

proc hrmLotsOfFarMallocStoreSW far
			; CODE XREF: LBX_Load_FontsStyleData+88P
push	bp
mov	bp, sp
push	si
mov	[word_36028], 1
mov	ax, 8
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	si, ax
push	si
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3C53C+2], dx
mov	[word ptr dword_3C53C],	ax
mov	ax, 8
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	si, ax
push	si
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3C538+2], dx
mov	[word ptr dword_3C538],	ax
mov	ax, 8
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	si, ax
push	si
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3C534+2], dx
mov	[word ptr dword_3C534],	ax
mov	ax, 8
push	ax

loc_1BE61:		; Call Procedure
call	ST_AllocateSpace

loc_1BE66:
pop	cx

loc_1BE67:
mov	si, ax
push	si

loc_1BE6A:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_1BE70:
mov	[word ptr dword_3C530+2], dx

loc_1BE74:
mov	[word ptr dword_3C530],	ax
pop	si
pop	bp
retf			; Return Far from Procedure
endp hrmLotsOfFarMallocStoreSW

ends seg019


; Segment type:	Pure code
segment	seg020 byte public 'CODE' use16
assume cs:seg020
;org 0Ah
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; _main+2DE
; mov	  ax, -1
; push	  ax
; xor	  ax, ax
; push	  ax
; call	  ILSe_prepare_palette
;
; _main+3AA
; mov	  ax, -1
; push	  ax
; xor	  ax, ax
; push	  ax
; call	  ILSe_prepare_palette
;
; _sub_137EA+9C
; mov	  ax, -1
; push	  ax
; mov	  ax, 2
; push	  ax
; call	  ILSe_prepare_palette
;
; sub_3DBA6+139
; mov	  ax, -1
; push	  ax
; mov	  ax, 1
; push	  ax
; call	  ILSe_prepare_palette
;
; sub_3E1DE+5D
; mov	  ax, -1
; push	  ax
; xor	  ax, ax
; push	  ax
; call	  ILSe_prepare_palette
;
; sub_56450+139
; mov	  ax, -1
; push	  ax
; xor	  ax, ax
; push	  ax
; call	  ILSe_prepare_palette
;
; Attributes: bp-based frame

; int __cdecl __far ILSe_prepare_palette(int argPaletteNumber, int argColorIndex, int argColorCount)
proc ILSe_prepare_palette far
			; CODE XREF: _f010109_main+2DEP
			; _f010109_main+3AAP
			; _f010509_MainMenuScreen+9CP
			; sub_3DBA6+139P
			; sub_3E1DE+5DP
			; sub_56450+139P

varColorIndex= word ptr	-4
varColorCount= word ptr	-2
argPaletteNumber= word ptr  6
argColorIndex= word ptr	 8
argColorCount= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di


Load Pallete #0

push	[idk_FontsLbx1_5568] ; argPtrBuffer_EMS
mov	ax, [bp+argPaletteNumber]
add	ax, 2		; ? Maybe, +2 to skip the first	two entries (Font Styles) ?
			; Thereby, making this 'Palette Number',
			;  rather than 'Entry Number'.
			;
push	ax		; argEntryNumber
mov	ax, offset g_FontsFileName
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ;
			; Returns varLbxMemBuf,	from LBX_Load_Entry
			;
			; LBX_Load_Entry_0_1(argLbxFileName = g_FontsFileName,
			;		     argLbxEntryNumber = 2,
			;		     argPtrBuffer_EMS =	idk_FontsLbx1)
			;
			; LBX_Load_Entry(argLbxFileName	= g_FontsFileName,
			;		 argLbxEntryNumber = 2,
			;		 argPtrBuffer_EMS = idk_FontsLbx1,
			;		 arg_idk_FLAG_0_1_2 = 1,
			;		 argSomethingElseOrZero	= 0)
add	sp, 6		; Add


mov	[ptrFontsLbx2],	ax


mov	ax, [ptrFontsLbx2]
add	ax, 48		; Add
mov	[ptrFontsLbx2_@48], ax


mov	ax, [ptrFontsLbx2_@48]
add	ax, 16		; Add
mov	[ptrFontsLbx2_@64], ax


mov	ax, [ptrFontsLbx2_@64]
add	ax, 16		; Add
mov	[ptrFontsLbx2_@80], ax


mov	ax, [ptrFontsLbx2_@80]
add	ax, 256		; Add
mov	[ptrFontsLbx2_@336], ax


db 83h,7Eh,8,0FFh ; <BAD>cmp	 [bp+argColorIndex], -1	; Compare Two Operands
jnz	short PARTIAL_PALETTE ;	Jump if	Not Zero (ZF=0)

FULL_PALETTE:
mov	[bp+varColorIndex], 0
mov	[bp+varColorCount], 256
jmp	short loc_1BEE2	; Jump

PARTIAL_PALETTE:	; CODE XREF: ILSe_prepare_palette+4Aj
mov	ax, [bp+argColorIndex]
mov	[bp+varColorIndex], ax
mov	ax, [bp+argColorCount]
sub	ax, [bp+argColorIndex] ; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+varColorCount], ax

loc_1BEE2:		; CODE XREF: ILSe_prepare_palette+56j
push	si
push	di
push	es
push	ds


mov	di, [bp+varColorIndex]


mov	bx, di
add	bx, 768		; Add


mov	ax, di


shl	di, 1		; Shift	Logical	Left
add	di, ax		; Add
mov	si, di


mov	cx, [bp+varColorCount]
mov	ax, [ptrFontsLbx2]
mov	dx, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	es, dx

loc_1BF05:		; CODE XREF: ILSe_prepare_palette+ADj
lodsb			; Load String
cmp	al, [es:di]	; Compare Two Operands
jz	short loc_1BF0F	; Jump if Zero (ZF=1)

loc_1BF0B:
mov	[byte ptr es:bx], 1

loc_1BF0F:		; CODE XREF: ILSe_prepare_palette+8Fj
stosb			; Store	String
lodsb			; Load String
cmp	al, [es:di]	; Compare Two Operands
jz	short loc_1BF1A	; Jump if Zero (ZF=1)
mov	[byte ptr es:bx], 1

loc_1BF1A:		; CODE XREF: ILSe_prepare_palette+9Aj
stosb			; Store	String
lodsb			; Load String
cmp	al, [es:di]	; Compare Two Operands
jz	short loc_1BF25	; Jump if Zero (ZF=1)

loc_1BF21:
mov	[byte ptr es:bx], 1

loc_1BF25:		; CODE XREF: ILSe_prepare_palette+A5j
stosb			; Store	String
inc	bx		; Increment by 1
loop	loc_1BF05	; Loop while CX	!= 0

loc_1BF29:
pop	ds
pop	es
pop	di
pop	si


xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx


db 83h,7Eh,8,0FFh ; <BAD>cmp	 [bp+argColorIndex], -1	; Compare Two Operands
jnz	short UPDATE_PARTIAL_PALETTE ; Jump if Not Zero	(ZF=0)

UPDATE_FULL_PALETTE:
mov	ax, 255
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
jmp	short loc_1BF4F	; Jump

UPDATE_PARTIAL_PALETTE:	; CODE XREF: ILSe_prepare_palette+C4j
push	[bp+argColorCount] ; argCount
push	[bp+argColorIndex] ; argOffset

loc_1BF4F:		; CODE XREF: ILSe_prepare_palette+CDj
nop			; No Operation
push	cs
call	near ptr idk_Set_FontsLbx1_256arr_to_1 ; Call Procedure


pop	cx
pop	cx
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ILSe_prepare_palette



; Attributes: bp-based frame

proc sub_1BF5C far	; CODE XREF: sub_4E9F4+1B5P
			; sub_4E9F4+1F9P
			; sub_4EF74+1CFP
			; sub_4EF74+20DP
push	bp

loc_1BF5D:
mov	bp, sp

loc_1BF5F:
mov	ax, 32h	; '2'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1BF66:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_1BF69:		; Logical Exclusive OR
xor	ax, ax

loc_1BF6B:
push	ax

loc_1BF6C:		; Logical Exclusive OR
xor	ax, ax

loc_1BF6E:
push	ax

loc_1BF6F:		; Call Procedure
call	idk_PAL_s1C8D5
add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1BF5C



; Attributes: bp-based frame

proc sub_1BF79 far	; CODE XREF: sub_56450+161P
push	bp
mov	bp, sp
push	si
push	di
mov	ax, 50
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_PAL_s1C8D5	; Call Procedure
add	sp, 0Ah		; Add


mov	si, 1
jmp	short loc_1BFEE	; Jump

loc_1BF9B:		; CODE XREF: sub_1BF79+78j
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
mov	di, ax
mov	ax, di
add	ax, 3		; Add
push	ax
push	[ptrFontsLbx2_@336]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx


push	ax
mov	ax, di
add	ax, 2		; Add
push	ax
push	[ptrFontsLbx2_@336]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx


push	ax
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	[ptrFontsLbx2_@336]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx


push	ax
push	di
push	[ptrFontsLbx2_@336]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx


push	ax
push	si
call	idk_PAL_s1C8D5	; Call Procedure
add	sp, 0Ah		; Add
inc	si		; Increment by 1

loc_1BFEE:		; CODE XREF: sub_1BF79+20j
cmp	si, 24		; Compare Two Operands
jl	short loc_1BF9B	; Jump if Less (SF!=OF)
pop	di
pop	si
pop	bp

locret_1BFF6:		; Return Far from Procedure
retf
endp sub_1BF79



; Attributes: bp-based frame

proc sub_1BFF7 far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	si
push	di
mov	ax, [bp+arg_2]

loc_1BFFF:		; Compare Two Operands
cmp	ax, [bp+arg_0]
jge	short loc_1C013	; Jump if Greater or Equal (SF=OF)
lea	ax, [bp+arg_2]	; Load Effective Address
push	ax
lea	ax, [bp+arg_0]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_1C013:		; CODE XREF: sub_1BFF7+Bj
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_1C036	; Jump if Not Zero (ZF=0)
mov	ax, 32h	; '2'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1C020:		; Logical Exclusive OR
xor	ax, ax
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_PAL_s1C8D5	; Call Procedure
add	sp, 0Ah		; Add
mov	[bp+arg_0], 1

loc_1C036:		; CODE XREF: sub_1BFF7+20j
mov	si, [bp+arg_0]
jmp	short loc_1C08E	; Jump

loc_1C03B:		; CODE XREF: sub_1BFF7+9Aj
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left

loc_1C041:
mov	di, ax
mov	ax, di
add	ax, 3		; Add
push	ax
push	[ptrFontsLbx2_@336]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
push	ax

loc_1C055:
mov	ax, di

loc_1C057:		; Add
add	ax, 2
push	ax
push	[ptrFontsLbx2_@336]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
push	ax
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	[ptrFontsLbx2_@336]

loc_1C06F:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx
push	ax
push	di
push	[ptrFontsLbx2_@336]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
push	ax
push	si
call	idk_PAL_s1C8D5	; Call Procedure
add	sp, 0Ah		; Add
inc	si		; Increment by 1

loc_1C08E:		; CODE XREF: sub_1BFF7+42j
cmp	si, [bp+arg_2]	; Compare Two Operands
jle	short loc_1C03B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1BFF7



; Attributes: bp-based frame

; int __cdecl __far idk_Set_FontsLbx1_256arr_to_1(int argOffset, int argCount)
proc idk_Set_FontsLbx1_256arr_to_1 far
			; CODE XREF: ILSe_prepare_palette+D7p
			; sub_1C130+25p
			; sub_1C15C+3Dp
			; sub_1C40F:loc_1C4BCp
			; sub_43349+15P
			; sub_43381+15P
			; sub_4E9F4+19FP
			; sub_4E9F4+1E3P
			; sub_4EF74+1B9P
			; sub_4EF74+1F7P
			; sub_55B7F+15P
			; sub_55BB7+15P
			; sub_55BEF+15P
			; sub_55C27:loc_55C3CP
			; sub_55C5E+15P
			; sub_56450+15AP

argOffset= word	ptr  6
argCount= word ptr  8

push	bp
mov	bp, sp
push	si


mov	si, [bp+argOffset]
jmp	short loc_1C0B2	; Jump

LoadByteLoop:		; CODE XREF: idk_Set_FontsLbx1_256arr_to_1+1Ej
mov	ax, 1
push	ax
push	si
push	[idk_FontsLbx1_1024_@48]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add


inc	si		; Increment by 1

loc_1C0B2:		; CODE XREF: idk_Set_FontsLbx1_256arr_to_1+7j
cmp	si, [bp+argCount] ; Compare Two	Operands
jle	short LoadByteLoop ; Jump if Less or Equal (ZF=1 | SF!=OF)

loc_1C0B7:
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_Set_FontsLbx1_256arr_to_1



; Attributes: bp-based frame

proc idk_Set_FontsLbx1_256arr_to_0 far
			; CODE XREF: sub_4E9F4+1AEP
			; sub_4E9F4+1F2P
			; sub_4EF74+1C8P
			; sub_4EF74+206P
			; sub_56450+14CP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp

loc_1C0BD:
push	si

loc_1C0BE:
mov	si, [bp+arg_0]
jmp	short loc_1C0D4	; Jump

loc_1C0C3:		; CODE XREF: idk_Set_FontsLbx1_256arr_to_0+1Dj
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si
push	[idk_FontsLbx1_1024_@48]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_1C0D0:		; Add
add	sp, 6
inc	si		; Increment by 1

loc_1C0D4:		; CODE XREF: idk_Set_FontsLbx1_256arr_to_0+7j
cmp	si, [bp+arg_2]	; Compare Two Operands
jle	short loc_1C0C3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_Set_FontsLbx1_256arr_to_0



; Attributes: bp-based frame

proc sub_1C0DC far

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	di
mov	ax, [bp+arg_2]

loc_1C0E6:		; Integer Subtraction
sub	ax, [bp+arg_0]
inc	ax		; Increment by 1
mov	[bp+var_2], ax
push	es

loc_1C0EE:
push	di
mov	cx, [bp+var_2]
mov	ax, cx
shl	cx, 1		; Shift	Logical	Left
add	cx, ax		; Add
mov	di, [bp+arg_0]
mov	ax, di
shl	di, 1		; Shift	Logical	Left
add	di, ax		; Add
mov	ax, [idk_FontsLbx1_1024B]
mov	es, ax
mov	al, 0
rep stosb		; Store	String
pop	di
pop	es
pop	di
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1C0DC



; Attributes: bp-based frame

proc idk_PAL_s1C111 far
push	bp
mov	bp, sp


mov	ax, 768
push	ax		; int
push	[idk_FontsLbx1_1024B] ;	int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	[idk_FontsLbx1_768B] ; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure


add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
endp idk_PAL_s1C111



; Attributes: bp-based frame

proc sub_1C130 far
push	bp
mov	bp, sp


mov	ax, 768
push	ax		; int
push	[idk_FontsLbx1_768B] ; int


xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	[idk_FontsLbx1_1024B] ;	int


xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ah		; Add


mov	ax, 255
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
push	cs
call	near ptr idk_Set_FontsLbx1_256arr_to_1 ; Call Procedure


pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp sub_1C130



; Attributes: bp-based frame

proc sub_1C15C far

var_2= word ptr	-2
argOffset= word	ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp

loc_1C15F:		; Integer Subtraction
sub	sp, 2
push	si
push	di
mov	si, [bp+argOffset]
mov	di, [bp+arg_2]
mov	ax, ds
mov	[bp+var_2], ax

loc_1C16F:
mov	ax, di

loc_1C171:
mov	dx, 3
imul	dx		; Signed Multiply
push	ax		; int
push	[bp+var_2]	; int

loc_1C17A:		; int
push	[bp+arg_4]

loc_1C17D:		; int
push	[idk_FontsLbx1_1024B]
mov	ax, si
mov	dx, 3
imul	dx		; Signed Multiply
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure

loc_1C18E:		; Add
add	sp, 0Ah
mov	ax, si
add	ax, di		; Add
dec	ax		; Decrement by 1
push	ax		; argCount
push	si		; argOffset
push	cs
call	near ptr idk_Set_FontsLbx1_256arr_to_1 ; Call Procedure
pop	cx
pop	cx
pop	di
pop	si

loc_1C1A0:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1C15C



; Attributes: bp-based frame

proc idk_Set_PalNbr__w3602C_to_neg1 far
			; CODE XREF: sub_56450+140P
push	bp
mov	bp, sp
mov	[idk_PalNbr__w3602C], -1
pop	bp
retf			; Return Far from Procedure
endp idk_Set_PalNbr__w3602C_to_neg1



; Attributes: bp-based frame

proc idk_SetDacReg_s1C1AF far

var_NewValGreen= word ptr -0Ah
var_NewValBlue=	word ptr -8
var_NewValRed= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_DacRegNbr= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
mov	ax, [bp+arg_8]
sub	ax, [bp+arg_2]	; Integer Subtraction
mov	si, ax
mov	ax, [bp+arg_A]
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	di, ax
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_6]	; Integer Subtraction
mov	[bp+var_2], ax
or	si, si		; Logical Inclusive OR
jge	short loc_1C1DA	; Jump if Greater or Equal (SF=OF)
mov	ax, si
neg	ax		; Two's Complement Negation
mov	si, ax

loc_1C1DA:		; CODE XREF: idk_SetDacReg_s1C1AF+23j
or	di, di		; Logical Inclusive OR
jge	short loc_1C1E4	; Jump if Greater or Equal (SF=OF)
mov	ax, di

loc_1C1E0:		; Two's Complement Negation
neg	ax
mov	di, ax

loc_1C1E4:		; CODE XREF: idk_SetDacReg_s1C1AF+2Dj
cmp	[bp+var_2], 0	; Compare Two Operands
jge	short loc_1C1F2	; Jump if Greater or Equal (SF=OF)

loc_1C1EA:
mov	ax, [bp+var_2]
neg	ax		; Two's Complement Negation
mov	[bp+var_2], ax

loc_1C1F2:		; CODE XREF: idk_SetDacReg_s1C1AF+39j
mov	ax, [bp+arg_E]
mov	[word_3C562], ax
mov	[bp+var_4], 2
cmp	si, di		; Compare Two Operands
jl	short loc_1C20D	; Jump if Less (SF!=OF)
cmp	si, [bp+var_2]	; Compare Two Operands
jl	short loc_1C20D	; Jump if Less (SF!=OF)
mov	[bp+var_4], 0
jmp	short loc_1C21B	; Jump

loc_1C20D:		; CODE XREF: idk_SetDacReg_s1C1AF+50j
			; idk_SetDacReg_s1C1AF+55j
cmp	di, si		; Compare Two Operands
jl	short loc_1C21B	; Jump if Less (SF!=OF)
cmp	di, [bp+var_2]	; Compare Two Operands
jl	short loc_1C21B	; Jump if Less (SF!=OF)
mov	[bp+var_4], 1

loc_1C21B:		; CODE XREF: idk_SetDacReg_s1C1AF+5Cj
			; idk_SetDacReg_s1C1AF+60j
			; idk_SetDacReg_s1C1AF+65j
db 83h,3Eh,1Ch,43h,0FFh	; <BAD>cmp     [idk_PalNbr__w3602C], -1	; Compare Two Operands
jnz	short loc_1C24D	; Jump if Not Zero (ZF=0)
mov	[idk_PalNbr__w3602C], 0
mov	ax, [bp+var_4]
or	ax, ax		; Logical Inclusive OR
jz	short loc_1C23B	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_1C243	; Jump if Zero (ZF=1)

loc_1C234:		; Compare Two Operands
cmp	ax, 2
jz	short loc_1C248	; Jump if Zero (ZF=1)
jmp	short loc_1C24D	; Jump

loc_1C23B:		; CODE XREF: idk_SetDacReg_s1C1AF+7Ej
mov	ax, [bp+arg_2]

loc_1C23E:		; CODE XREF: idk_SetDacReg_s1C1AF+97j
			; idk_SetDacReg_s1C1AF+9Cj
mov	[idk_PalNbr_w3C564], ax
jmp	short loc_1C24D	; Jump

loc_1C243:		; CODE XREF: idk_SetDacReg_s1C1AF+83j
mov	ax, [bp+arg_4]
jmp	short loc_1C23E	; Jump

loc_1C248:		; CODE XREF: idk_SetDacReg_s1C1AF+88j
mov	ax, [bp+arg_6]
jmp	short loc_1C23E	; Jump

loc_1C24D:		; CODE XREF: idk_SetDacReg_s1C1AF+71j
			; idk_SetDacReg_s1C1AF+8Aj
			; idk_SetDacReg_s1C1AF+92j
mov	ax, [bp+var_4]
or	ax, ax		; Logical Inclusive OR
jz	short loc_1C264	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_1C2A9	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jnz	short loc_1C261	; Jump if Not Zero (ZF=0)

loc_1C25E:		; Jump
jmp	loc_1C2E4

loc_1C261:		; CODE XREF: idk_SetDacReg_s1C1AF+ADj
jmp	loc_1C328	; Jump

loc_1C264:		; CODE XREF: idk_SetDacReg_s1C1AF+A3j
mov	ax, [idk_PalNbr_w3C564]

loc_1C267:
mov	[bp+var_NewValRed], ax

loc_1C26A:
mov	ax, [bp+arg_A]
sub	ax, [bp+arg_4]	; Integer Subtraction

loc_1C270:
mov	dx, [idk_PalNbr_w3C564]
sub	dx, [bp+arg_2]	; Integer Subtraction

loc_1C277:		; Signed Multiply
imul	dx

loc_1C279:
mov	bx, [bp+arg_8]

loc_1C27C:		; Integer Subtraction
sub	bx, [bp+arg_2]
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_1C282:		; Add
add	ax, [bp+arg_4]
mov	[bp+var_NewValGreen], ax
mov	ax, [bp+arg_C]

loc_1C28B:		; Integer Subtraction
sub	ax, [bp+arg_6]
mov	dx, [idk_PalNbr_w3C564]

loc_1C292:		; Integer Subtraction
sub	dx, [bp+arg_2]
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, [bp+arg_2]	; Integer Subtraction

loc_1C29D:		; CODE XREF: idk_SetDacReg_s1C1AF+133j
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_1C2A0:		; Add
add	ax, [bp+arg_6]
mov	[bp+var_NewValBlue], ax
db 0E9h,7Fh,0 ;	<BAD>jmp     loc_1C328 ; Jump

loc_1C2A9:		; CODE XREF: idk_SetDacReg_s1C1AF+A8j
mov	ax, [idk_PalNbr_w3C564]
mov	[bp+var_NewValGreen], ax
mov	ax, [bp+arg_8]
sub	ax, [bp+arg_2]	; Integer Subtraction
mov	dx, [idk_PalNbr_w3C564]
sub	dx, [bp+arg_4]	; Integer Subtraction

loc_1C2BC:		; Signed Multiply
imul	dx
mov	bx, [bp+arg_A]
sub	bx, [bp+arg_4]	; Integer Subtraction

loc_1C2C4:		; AX ->	DX:AX (with sign)
cwd
idiv	bx		; Signed Divide
add	ax, [bp+arg_2]	; Add
mov	[bp+var_NewValRed], ax
mov	ax, [bp+arg_C]

loc_1C2D0:		; Integer Subtraction
sub	ax, [bp+arg_6]
mov	dx, [idk_PalNbr_w3C564]
sub	dx, [bp+arg_4]	; Integer Subtraction
imul	dx		; Signed Multiply

loc_1C2DC:
mov	bx, [bp+arg_A]
sub	bx, [bp+arg_4]	; Integer Subtraction
jmp	short loc_1C29D	; Jump

loc_1C2E4:		; CODE XREF: idk_SetDacReg_s1C1AF:loc_1C25Ej
mov	ax, [idk_PalNbr_w3C564]
mov	[bp+var_NewValBlue], ax

loc_1C2EA:
mov	ax, [bp+arg_A]
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, [idk_PalNbr_w3C564]
sub	dx, [bp+arg_6]	; Integer Subtraction

loc_1C2F7:		; Signed Multiply
imul	dx
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_6]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_4]	; Add
mov	[bp+var_NewValGreen], ax
mov	ax, [bp+arg_8]

loc_1C30B:		; Integer Subtraction
sub	ax, [bp+arg_2]
mov	dx, [idk_PalNbr_w3C564]
sub	dx, [bp+arg_6]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_6]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_1C320:		; Add
add	ax, [bp+arg_2]

loc_1C323:
mov	[bp+var_NewValRed], ax
jmp	short $+2	; Jump

loc_1C328:		; CODE XREF: idk_SetDacReg_s1C1AF:loc_1C261j
			; idk_SetDacReg_s1C1AF+F7j
mov	ax, [bp+var_4]
or	ax, ax		; Logical Inclusive OR
jz	short loc_1C33B	; Jump if Zero (ZF=1)

loc_1C32F:		; Compare Two Operands
cmp	ax, 1
jz	short loc_1C34C	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands

loc_1C337:		; Jump if Zero (ZF=1)
jz	short loc_1C355
jmp	short loc_1C35E	; Jump

loc_1C33B:		; CODE XREF: idk_SetDacReg_s1C1AF+17Ej
lea	ax, [bp+arg_8]	; Load Effective Address
push	ax

loc_1C33F:		; Load Effective Address
lea	ax, [bp+arg_2]

loc_1C342:		; CODE XREF: idk_SetDacReg_s1C1AF:loc_1C353j
			; idk_SetDacReg_s1C1AF:loc_1C35Cj
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1C37B ; Call Procedure

loc_1C348:
pop	cx
pop	cx
jmp	short loc_1C35E	; Jump

loc_1C34C:		; CODE XREF: idk_SetDacReg_s1C1AF+183j
lea	ax, [bp+arg_A]	; Load Effective Address
push	ax
lea	ax, [bp+arg_4]	; Load Effective Address

loc_1C353:		; Jump
jmp	short loc_1C342

loc_1C355:		; CODE XREF: idk_SetDacReg_s1C1AF:loc_1C337j
lea	ax, [bp+arg_C]	; Load Effective Address
push	ax

loc_1C359:		; Load Effective Address
lea	ax, [bp+arg_6]

loc_1C35C:		; Jump
jmp	short loc_1C342

loc_1C35E:		; CODE XREF: idk_SetDacReg_s1C1AF+18Aj
			; idk_SetDacReg_s1C1AF+19Bj
mov	dx, [bp+var_NewValRed]
mov	dh, dl
mov	ax, [bp+var_NewValGreen]
mov	ch, al
mov	ax, [bp+var_NewValBlue]
mov	cl, al
mov	bx, [bp+arg_DacRegNbr]
mov	ax, 1010h
int	10h		; - VIDEO - SET	INDIVIDUAL DAC REGISTER	(EGA, VGA/MCGA)
			; BX = register	number,	CH = new value for green (0-63)
			; CL = new value for blue (0-63), DH = new value for red (0-63)
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_SetDacReg_s1C1AF



; Attributes: bp-based frame

proc sub_1C37B far	; CODE XREF: idk_SetDacReg_s1C1AF+196p

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]

loc_1C383:
mov	di, [bp+arg_2]

loc_1C386:		; Compare Two Operands
cmp	[idk_PalNbr__w3602C], 0

loc_1C38B:		; Jump if Not Zero (ZF=0)
jnz	short loc_1C3CD
mov	ax, [di]
cmp	ax, [si]	; Compare Two Operands
jle	short loc_1C3B0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_3C562]
add	[idk_PalNbr_w3C564], ax	; Add

loc_1C39A:
mov	ax, [di]

loc_1C39C:		; Compare Two Operands
cmp	ax, [idk_PalNbr_w3C564]

loc_1C3A0:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1C3AE

loc_1C3A2:
mov	ax, [di]
dec	ax		; Decrement by 1
mov	[idk_PalNbr_w3C564], ax

loc_1C3A8:
mov	[idk_PalNbr__w3602C], 1

loc_1C3AE:		; CODE XREF: sub_1C37B:loc_1C3A0j
jmp	short loc_1C3CB	; Jump

loc_1C3B0:		; CODE XREF: sub_1C37B+16j
mov	ax, [word_3C562]

loc_1C3B3:		; Integer Subtraction
sub	[idk_PalNbr_w3C564], ax
mov	ax, [si]
cmp	ax, [idk_PalNbr_w3C564]	; Compare Two Operands
jle	short loc_1C3CB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [si]
inc	ax		; Increment by 1

loc_1C3C2:
mov	[idk_PalNbr_w3C564], ax

loc_1C3C5:
mov	[idk_PalNbr__w3602C], 1

loc_1C3CB:		; CODE XREF: sub_1C37B:loc_1C3AEj
			; sub_1C37B+42j
jmp	short loc_1C40B	; Jump

loc_1C3CD:		; CODE XREF: sub_1C37B:loc_1C38Bj
mov	ax, [di]
cmp	ax, [si]	; Compare Two Operands

loc_1C3D1:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_1C3F0
mov	ax, [word_3C562]
sub	[idk_PalNbr_w3C564], ax	; Integer Subtraction

loc_1C3DA:
mov	ax, [si]

loc_1C3DC:		; Compare Two Operands
cmp	ax, [idk_PalNbr_w3C564]
jle	short loc_1C3EE	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [si]
inc	ax		; Increment by 1
mov	[idk_PalNbr_w3C564], ax
mov	[idk_PalNbr__w3602C], 0

loc_1C3EE:		; CODE XREF: sub_1C37B+65j
jmp	short loc_1C40B	; Jump

loc_1C3F0:		; CODE XREF: sub_1C37B:loc_1C3D1j
mov	ax, [word_3C562]

loc_1C3F3:		; Add
add	[idk_PalNbr_w3C564], ax
mov	ax, [di]
cmp	ax, [idk_PalNbr_w3C564]	; Compare Two Operands

loc_1C3FD:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1C40B
mov	ax, [di]
dec	ax		; Decrement by 1

loc_1C402:
mov	[idk_PalNbr_w3C564], ax
mov	[idk_PalNbr__w3602C], 0

loc_1C40B:		; CODE XREF: sub_1C37B:loc_1C3CBj
			; sub_1C37B:loc_1C3EEj
			; sub_1C37B:loc_1C3FDj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1C37B



; Attributes: bp-based frame

proc sub_1C40F far

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= word	ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp

loc_1C410:
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_2]

loc_1C41A:
mov	ax, ds
mov	[bp+var_2], ax
xor	si, si		; Logical Exclusive OR
jmp	loc_1C4AA	; Jump

loc_1C424:		; CODE XREF: sub_1C40F:loc_1C4AEj
mov	ax, [bp+arg_A]
sub	ax, [bp+arg_4]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, di
dec	bx		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_1C432:		; Add
add	ax, [bp+arg_4]
mov	[bp+var_4], ax
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_6]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, di
dec	bx		; Decrement by 1

loc_1C443:		; AX ->	DX:AX (with sign)
cwd
idiv	bx		; Signed Divide

loc_1C446:		; Add
add	ax, [bp+arg_6]
mov	[bp+var_6], ax

loc_1C44C:
mov	ax, [bp+arg_E]

loc_1C44F:		; Integer Subtraction
sub	ax, [bp+arg_8]
imul	si		; Signed Multiply
mov	bx, di
dec	bx		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_1C45A:		; Add
add	ax, [bp+arg_8]
mov	[bp+var_8], ax
mov	ax, [bp+argOffset]
add	ax, si		; Add
mov	dx, 3
imul	dx		; Signed Multiply
mov	[bp+var_A], ax
push	[bp+var_4]
push	[bp+var_A]
push	[idk_FontsLbx1_1024B]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue
add	sp, 6		; Add
push	[bp+var_6]

loc_1C482:
mov	ax, [bp+var_A]
inc	ax		; Increment by 1
push	ax
push	[idk_FontsLbx1_1024B]

loc_1C48B:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_1C490:		; Add
add	sp, 6
push	[bp+var_8]
mov	ax, [bp+var_A]
add	ax, 2		; Add
push	ax
push	[idk_FontsLbx1_1024B]

loc_1C4A1:		; Store	AX in word ES:DI, update DI
call	fncStoSB	; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_1C4A6:		; Add
add	sp, 6
inc	si		; Increment by 1

loc_1C4AA:		; CODE XREF: sub_1C40F+12j
cmp	si, di		; Compare Two Operands

loc_1C4AC:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1C4B1

loc_1C4AE:		; Jump
jmp	loc_1C424

loc_1C4B1:		; CODE XREF: sub_1C40F:loc_1C4ACj
mov	ax, [bp+argOffset]

loc_1C4B4:		; Add
add	ax, di

loc_1C4B6:		; Decrement by 1
dec	ax
push	ax		; argCount

loc_1C4B8:		; argOffset
push	[bp+argOffset]
push	cs

loc_1C4BC:		; Call Procedure
call	near ptr idk_Set_FontsLbx1_256arr_to_1

loc_1C4BF:
pop	cx

loc_1C4C0:
pop	cx

loc_1C4C1:
pop	di

loc_1C4C2:
pop	si

loc_1C4C3:
mov	sp, bp

loc_1C4C5:
pop	bp

locret_1C4C6:		; Return Far from Procedure
retf
endp sub_1C40F

ends seg020


; Segment type:	Pure code
segment	seg021 byte public 'CODE' use16
assume cs:seg021
;org 8
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
word_1C4C8 dw 0		; DATA XREF: idk_VGA_PAL_s1C638+40w
			; idk_VGA_PAL_s1C638+A0r
			; idk_VGA_PAL_s1C638:loc_1C741r
			; idk_PAL_s1C8D5+10w
			; idk_PAL_s1C8D5+1C5r
word_1C4CA dw 0		; DATA XREF: idk_VGA_PAL_s1C638:loc_1C692w
			; idk_VGA_PAL_s1C638+B6r
			; idk_VGA_PAL_s1C638+113r
			; idk_PAL_s1C8D5+19w
			; idk_PAL_s1C8D5+1EDr
word_1C4CC dw 0		; DATA XREF: idk_VGA_PAL_s1C638+4Dw
			; idk_VGA_PAL_s1C638+ABr
			; idk_VGA_PAL_s1C638:loc_1C746r
			; idk_PAL_s1C8D5+14w
			; idk_PAL_s1C8D5+1DBr
word_1C4CE dw 0		; DATA XREF: idk_VGA_PAL_s1C76E:loc_1C786w
			; idk_VGA_PAL_s1C76E:loc_1C7C7r
word_1C4D0 dw 0		; DATA XREF: idk_VGA_PAL_s1C76E:loc_1C791w
			; idk_VGA_PAL_s1C76E:loc_1C7CCr
word_1C4D2 dw 0		; DATA XREF: idk_VGA_PAL_s1C76E+2Aw
			; idk_VGA_PAL_s1C76E:loc_1C7BCr
word_1C4D4 dw 0		; DATA XREF: idk_VGA_PAL_s1C76E+31w
			; idk_VGA_PAL_s1C76E:loc_1C7FCr
word_1C4D6 dw 0		; DATA XREF: idk_VGA_PAL_s1C76E+38w
			; idk_VGA_PAL_s1C76E+93r
word_1C4D8 dw 0		; DATA XREF: idk_VGA_PAL_s1C76E+45w
			; idk_VGA_PAL_s1C76E+83r
word_1C4DA dw 0		; DATA XREF: idk_VGA_PAL_s1C840+1Fw
			; idk_VGA_PAL_s1C840:loc_1C8A4r
word_1C4DC dw 0		; DATA XREF: idk_VGA_PAL_s1C840+27w
			; idk_VGA_PAL_s1C840:loc_1C884r
word_1C4DE dw 0		; DATA XREF: idk_VGA_PAL_s1C840:loc_1C857w
			; idk_VGA_PAL_s1C840:loc_1C88Br
word_1C4E0 dw 0		; DATA XREF: idk_PAL_s1C8D5+D2w
			; idk_PAL_s1C8D5+149w
			; idk_PAL_s1C8D5+156r
			; idk_PAL_s1C8D5+1ADw
			; idk_PAL_s1C8D5+216w
			; idk_PAL_s1C8D5+221r
word_1C4E2 dw 0		; DATA XREF: idk_PAL_s1C8D5+D9w
			; idk_PAL_s1C8D5+13Dr
			; idk_PAL_s1C8D5+144w
			; idk_PAL_s1C8D5+1B4w
			; idk_PAL_s1C8D5+20Ar
			; idk_PAL_s1C8D5+211w
byte_1C4E4 db 0		; DATA XREF: idk_PAL_s1C8D5+B3w
			; idk_PAL_s1C8D5+F8r
algn_1C4E5:
align 2
byte_1C4E6 db 0		; DATA XREF: idk_PAL_s1C8D5+C0w
			; idk_PAL_s1C8D5+10Er
align 2
byte_1C4E8 db 0		; DATA XREF: idk_PAL_s1C8D5+CDw
			; idk_PAL_s1C8D5+120r
align 2
word_1C4EA dw 0		; DATA XREF: idk_VGA_PAL_s1C638:loc_1C65Cw
			; idk_VGA_PAL_s1C638+61r
			; idk_PAL_s1C8D5+3Bw
			; idk_PAL_s1C8D5+A6r
word_1C4EC dw 0		; DATA XREF: idk_PAL_s1C8D5+83w
			; idk_PAL_s1C8D5:loc_1C95Fr
			; idk_PAL_s1C8D5:loc_1C970r
			; idk_PAL_s1C8D5:loc_1CA26r
			; idk_PAL_s1C8D5:loc_1CA30r
			; idk_PAL_s1C8D5+160w
byte_1C4EE db 0		; DATA XREF: idk_PAL_s1C8D5:loc_1C928w
			; idk_PAL_s1C8D5+AEr
algn_1C4EF:
align 2
byte_1C4F0 db 0		; DATA XREF: idk_PAL_s1C8D5+5Dw
			; idk_PAL_s1C8D5+BBr
align 2
byte_1C4F2 db 0		; DATA XREF: idk_PAL_s1C8D5+67w
			; idk_PAL_s1C8D5+C8r
algn_1C4F3:
align 2



proc idk_SetPalette_s1C4F4 far
			; CODE XREF: _f010109_main+2E5P
			; _f010109_main+3B1P
			; idk_VGA_PAL_s1C554+7Fp
			; idk_VGA_PAL_s1C638:loc_1C702p
			; sub_28963+3CDP
			; sub_2A755+A38P
			; sub_2B1F9:loc_2B40AP
			; sub_2E27D+18P
			; sub_2E27D:loc_2E2ABP
			; sub_2E2B7+18P
			; sub_2E2B7:loc_2E2E5P
			; sub_3EBA0+1FEP
			; sub_3F3C6+1B8P
			; idk_Load_NEWGAME_LBX+60P
			; sub_3F7D8+1E8P
			; sub_3FBE0+280P
			; sub_3FBE0:loc_3FFF4P
			; sub_4067D+7F3P
			; LBX_NewGame_s41A5F+731P
			; sub_4E9F4+1BAP
			; sub_4EF74:loc_4F121P
			; sub_56450+74P
			; sub_56450+189P
push	si
push	di
push	es
push	ds


mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	si, 0
mov	bx, 0
mov	di, 768
mov	cx, 0

LOOP_START:		; CODE XREF: idk_SetPalette_s1C4F4+4Aj
cmp	cx, 0		; Compare Two Operands
jnz	short loc_1C51E	; Jump if Not Zero (ZF=0)

loc_1C50E:		; /* Input Status Register 1 - color emulation */
mov	dx, INPUT_STATUS


mov	cx, 128

WaitForVsync:		; CODE XREF: idk_SetPalette_s1C4F4+23j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jnz	short WaitForVsync ; Jump if Not Zero (ZF=0)

WaitForNotVsync:	; CODE XREF: idk_SetPalette_s1C4F4+28j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jz	short WaitForNotVsync ;	Jump if	Zero (ZF=1)

loc_1C51E:		; CODE XREF: idk_SetPalette_s1C4F4+18j
add	si, 3		; Add
cmp	[byte ptr di], 0 ; Compare Two Operands
jz	short loc_1C539	; Jump if Zero (ZF=1)

OUTPUT_RGB_VALUES:	; Palette Index
mov	dx, PALETTE_INDEX
sub	si, 3		; Integer Subtraction


cli			; Clear	Interrupt Flag


mov	al, bl
out	dx, al


inc	dx		; DX is	now 0x03C9 PALETTE_DATA


lodsb			; ? output Red ?
out	dx, al


lodsb			; ? output Green ?
out	dx, al


lodsb			; ? output Blue	?
out	dx, al


dec	cx		; Decrement by 1


sti			; Set Interrupt	Flag

loc_1C539:		; CODE XREF: idk_SetPalette_s1C4F4+30j
inc	di		; Increment by 1
inc	bx		; Increment by 1
cmp	bh, 0		; ? if BX <= 64	?
jz	short LOOP_START ; Jump	if Zero	(ZF=1)

loc_1C540:
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, 768
mov	cx, 128
mov	ax, 0
rep stosw		;
			; Fill CX words	at ES:[DI] with	AX.
			; ...
			; 128 words = 256 bytes
			; ...
			; mov ax, idk_FontsLbx1_768
			; mov ds, ax
			; mov ax, ds
			; mov es, ax
			; ES:DI	= idk_FontsLbx1_768:[768]
			;


pop	ds
pop	es
assume es:nothing
pop	di
pop	si
retf			; Return Far from Procedure
endp idk_SetPalette_s1C4F4



; ...
; https://web.archive.org/web/20160229124806/https://poizan.dk/blog/2013/11/27/fixing-frequent-freezing-of-wasteland-1-when-using-mouse/
; ...
; drawCursor proc near ; CODE XREF: j_drawCursorj
; cmp mouseEnabled, 0
; jz short end_clean
; mov dx, 3DAh ; dx is the CGA/VGA Input Status	#1 Register
; waitForVSync:
; in al, dx ; Video status bits:
; and al, 8
; jz short waitForVSync
; ...
; https://www.gamedev.net/forums/topic/8770-the-dos-vsync/
; wait_for_retrace
; ...
; https://github.com/torvalds/linux/blob/master/include/video/vga.h
; VGAlib version 1.2 - (c) 1993	Tommy Frandsen
; VGA.H
; #define VGA_IS1_RC	  0x3DA	  /* Input Status Register 1 - color emulation */
;
; Attributes: bp-based frame

proc idk_VGA_PAL_s1C554	far
			; CODE XREF: sub_43349+1DP
			; sub_43381+1DP
			; sub_55B7F+1DP
			; sub_55BB7+1DP
			; sub_55BEF+1DP
			; sub_55C27:loc_55C44P
			; sub_55C5E+1DP

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, 64h	; 'd'
sub	ax, [bp+arg_0]	; Integer Subtraction
jbe	short loc_1C5DC	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_1C563:		; Compare Two Operands
cmp	ax, 64h	; 'd'
jns	short loc_1C5D2	; Jump if Not Sign (SF=0)
mov	bx, 100h
mul	bx		; Unsigned Multiplication of AL	or AX
mov	bx, 64h	; 'd'
div	bx		; Unsigned Divide
mov	dx, [idk_FontsLbx1_1024B]
mov	ds, dx
mov	si, 0
mov	bl, al
mov	bh, 0
mov	di, 768
mov	cx, 0

loc_1C585:		; CODE XREF: idk_VGA_PAL_s1C554+73j
cmp	cx, 0		; Compare Two Operands
jnz	short loc_1C59A	; Jump if Not Zero (ZF=0)
mov	dx, INPUT_STATUS
mov	cx, 128

WaitForVsync_:		; CODE XREF: idk_VGA_PAL_s1C554+3Fj
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jnz	short WaitForVsync_ ; Jump if Not Zero (ZF=0)

WaitForNotVsync_:	; CODE XREF: idk_VGA_PAL_s1C554+44j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jz	short WaitForNotVsync_ ; Jump if Zero (ZF=1)

loc_1C59A:		; CODE XREF: idk_VGA_PAL_s1C554+34j
add	si, 3		; Add
cmp	[byte ptr di], 0 ; Compare Two Operands
jz	short loc_1C5C1	; Jump if Zero (ZF=1)

loc_1C5A2:
mov	dx, PALETTE_INDEX
sub	si, 3		; Integer Subtraction
cli			; Clear	Interrupt Flag
mov	al, bh
out	dx, al
inc	dx		; Increment by 1
lodsb			; Load String
mul	bl		; Unsigned Multiplication of AL	or AX
mov	al, ah
out	dx, al
lodsb			; Load String
mul	bl		; Unsigned Multiplication of AL	or AX
mov	al, ah
out	dx, al
lodsb			; Load String
mul	bl		; Unsigned Multiplication of AL	or AX
mov	al, ah
out	dx, al
sti			; Set Interrupt	Flag
dec	cx		; Decrement by 1

loc_1C5C1:		; CODE XREF: idk_VGA_PAL_s1C554+4Cj
inc	di		; Increment by 1
inc	bh		; Increment by 1
cmp	bh, 0		; Compare Two Operands
jnz	short loc_1C585	; Jump if Not Zero (ZF=0)
jmp	short loc_1C623	; Jump
align 2
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1C5D2:		; CODE XREF: idk_VGA_PAL_s1C554+12j
push	cs
call	near ptr idk_SetPalette_s1C4F4 ; Call Procedure
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1C5DC:		; CODE XREF: idk_VGA_PAL_s1C554+Dj
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	si, 0
mov	bx, 0
mov	di, 768
mov	cx, 0

loc_1C5ED:		; CODE XREF: idk_VGA_PAL_s1C554+CDj
cmp	cx, 0		; Compare Two Operands
jnz	short loc_1C602	; Jump if Not Zero (ZF=0)
mov	dx, 3DAh
mov	cx, 128

WaitForVsync:		; CODE XREF: idk_VGA_PAL_s1C554+A7j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jnz	short WaitForVsync ; Jump if Not Zero (ZF=0)

WaitForNotVsync:	; CODE XREF: idk_VGA_PAL_s1C554+ACj
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jz	short WaitForNotVsync ;	Jump if	Zero (ZF=1)

loc_1C602:		; CODE XREF: idk_VGA_PAL_s1C554+9Cj
add	si, 3		; Add
cmp	[byte ptr di], 0 ; Compare Two Operands
jz	short loc_1C61C	; Jump if Zero (ZF=1)

loc_1C60A:
mov	dx, PALETTE_INDEX
sub	si, 3		; Integer Subtraction
cli			; Clear	Interrupt Flag
mov	al, bl
out	dx, al
inc	dx		; Increment by 1
xor	al, al		; Logical Exclusive OR
out	dx, al
out	dx, al
out	dx, al
sti			; Set Interrupt	Flag
dec	cx		; Decrement by 1

loc_1C61C:		; CODE XREF: idk_VGA_PAL_s1C554+B4j
inc	di		; Increment by 1
inc	bx		; Increment by 1
cmp	bh, 0		; Compare Two Operands
jz	short loc_1C5ED	; Jump if Zero (ZF=1)

loc_1C623:		; CODE XREF: idk_VGA_PAL_s1C554+75j
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, 768
mov	cx, 128
mov	ax, 0
rep stosw		; Store	String
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_VGA_PAL_s1C554



; Attributes: bp-based frame

proc idk_VGA_PAL_s1C638	far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds

loc_1C63F:
mov	ax, 64h	; 'd'
sub	ax, [bp+arg_0]	; Integer Subtraction

loc_1C645:		; Jump if Above	(CF=0 &	ZF=0)
ja	short loc_1C64A
jmp	loc_1C70B	; Jump

loc_1C64A:		; CODE XREF: idk_VGA_PAL_s1C638:loc_1C645j
cmp	ax, 64h	; 'd'   ; Compare Two Operands
js	short loc_1C652	; Jump if Sign (SF=1)
jmp	loc_1C701	; Jump

loc_1C652:		; CODE XREF: idk_VGA_PAL_s1C638+15j
mov	bx, 256
mul	bx		; Unsigned Multiplication of AL	or AX
mov	bx, 64h	; 'd'
div	bx		; Unsigned Divide

loc_1C65C:
mov	[cs:word_1C4EA], ax

loc_1C660:
mov	ax, [bp+arg_0]
mov	bx, 256
mul	bx		; Unsigned Multiplication of AL	or AX
mov	bx, 64h	; 'd'
div	bx		; Unsigned Divide
mov	bx, ax

loc_1C66F:
mov	ax, [bp+arg_2]
mul	bl		; Unsigned Multiplication of AL	or AX
mov	al, ah
xor	ah, ah		; Logical Exclusive OR
mov	[cs:word_1C4C8], ax
mov	ax, [bp+arg_4]
mul	bl		; Unsigned Multiplication of AL	or AX
mov	al, ah
xor	ah, ah		; Logical Exclusive OR
mov	[cs:word_1C4CC], ax
mov	ax, [bp+arg_6]
mul	bl		; Unsigned Multiplication of AL	or AX
mov	al, ah

loc_1C690:		; Logical Exclusive OR
xor	ah, ah

loc_1C692:
mov	[cs:word_1C4CA], ax

loc_1C696:
mov	si, 3
mov	bx, [cs:word_1C4EA]

loc_1C69E:
mov	bh, 1

loc_1C6A0:
mov	di, 303h

loc_1C6A3:
mov	cx, 0
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax

loc_1C6AB:		; CODE XREF: idk_VGA_PAL_s1C638:loc_1C6FCj
cmp	cx, 0		; Compare Two Operands
jnz	short loc_1C6C0	; Jump if Not Zero (ZF=0)
mov	dx, INPUT_STATUS
mov	cx, 128

loc_1C6B6:		; CODE XREF: idk_VGA_PAL_s1C638+81j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jnz	short loc_1C6B6	; Jump if Not Zero (ZF=0)

loc_1C6BB:		; CODE XREF: idk_VGA_PAL_s1C638+86j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.

loc_1C6BC:		; Logical AND
and	al, 8
jz	short loc_1C6BB	; Jump if Zero (ZF=1)

loc_1C6C0:		; CODE XREF: idk_VGA_PAL_s1C638+76j
add	si, 3		; Add

loc_1C6C3:		; Compare Two Operands
cmp	[byte ptr di], 0
jz	short loc_1C6F6	; Jump if Zero (ZF=1)
mov	dx, PALETTE_INDEX
sub	si, 3		; Integer Subtraction
cli			; Clear	Interrupt Flag
mov	al, bh
out	dx, al
inc	dx		; Increment by 1
lodsb			; Load String
mul	bl		; Unsigned Multiplication of AL	or AX

loc_1C6D6:
mov	al, ah
add	al, [byte ptr cs:word_1C4C8] ; Add
out	dx, al
lodsb			; Load String

loc_1C6DF:		; Unsigned Multiplication of AL	or AX
mul	bl
mov	al, ah
add	al, [byte ptr cs:word_1C4CC] ; Add
out	dx, al
lodsb			; Load String

loc_1C6EA:		; Unsigned Multiplication of AL	or AX
mul	bl

loc_1C6EC:
mov	al, ah
add	al, [byte ptr cs:word_1C4CA] ; Add
out	dx, al

loc_1C6F4:		; Set Interrupt	Flag
sti
dec	cx		; Decrement by 1

loc_1C6F6:		; CODE XREF: idk_VGA_PAL_s1C638+8Ej
inc	di		; Increment by 1
inc	bh		; Increment by 1
cmp	bh, 0		; Compare Two Operands

loc_1C6FC:		; Jump if Not Zero (ZF=0)
jnz	short loc_1C6AB
jmp	short loc_1C759	; Jump
db 90h

loc_1C701:		; CODE XREF: idk_VGA_PAL_s1C638+17j
push	cs

loc_1C702:		; Call Procedure
call	near ptr idk_SetPalette_s1C4F4
pop	ds
pop	es

loc_1C707:
pop	di

loc_1C708:
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1C70B:		; CODE XREF: idk_VGA_PAL_s1C638+Fj
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	bx, 0
mov	di, 768
mov	cx, 0

loc_1C719:		; CODE XREF: idk_VGA_PAL_s1C638+11Fj
cmp	cx, 0		; Compare Two Operands

loc_1C71C:		; Jump if Not Zero (ZF=0)
jnz	short loc_1C72E

loc_1C71E:
mov	dx, INPUT_STATUS
mov	cx, 128

loc_1C724:		; CODE XREF: idk_VGA_PAL_s1C638+EFj
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.

loc_1C725:		; Logical AND
and	al, 8
jnz	short loc_1C724	; Jump if Not Zero (ZF=0)

loc_1C729:		; CODE XREF: idk_VGA_PAL_s1C638+F4j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.

loc_1C72A:		; Logical AND
and	al, 8
jz	short loc_1C729	; Jump if Zero (ZF=1)

loc_1C72E:		; CODE XREF: idk_VGA_PAL_s1C638:loc_1C71Cj
add	si, 3		; Add
cmp	[byte ptr di], 0 ; Compare Two Operands
jz	short loc_1C752	; Jump if Zero (ZF=1)
mov	dx, PALETTE_INDEX

loc_1C739:		; Integer Subtraction
sub	si, 3

loc_1C73C:		; Clear	Interrupt Flag
cli

loc_1C73D:
mov	al, bl

loc_1C73F:
out	dx, al

loc_1C740:		; Increment by 1
inc	dx

loc_1C741:
mov	al, [byte ptr cs:word_1C4C8]
out	dx, al

loc_1C746:
mov	al, [byte ptr cs:word_1C4CC]
out	dx, al
mov	al, [byte ptr cs:word_1C4CA]
out	dx, al

loc_1C750:		; Set Interrupt	Flag
sti
dec	cx		; Decrement by 1

loc_1C752:		; CODE XREF: idk_VGA_PAL_s1C638+FCj
inc	di		; Increment by 1
inc	bx		; Increment by 1
cmp	bh, 0		; Compare Two Operands
jz	short loc_1C719	; Jump if Zero (ZF=1)

loc_1C759:		; CODE XREF: idk_VGA_PAL_s1C638+C6j
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, 768
mov	cx, 128

loc_1C763:
mov	ax, 0
rep stosw		; Store	String
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_VGA_PAL_s1C638



; Attributes: bp-based frame

proc idk_VGA_PAL_s1C76E	far
			; CODE XREF: sub_4EC17+26P
			; sub_4EC17+4FP
			; sub_4EC17+31AP
			; sub_4EC17+343P
			; sub_4F1AB+18P
			; sub_4F1AB+252P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si

loc_1C772:
push	di
push	es
push	ds
mov	dx, 0

loc_1C778:
mov	ax, [bp+arg_4]

loc_1C77B:
mov	bx, [bp+arg_2]

loc_1C77E:		; Unsigned Divide
div	bx

loc_1C780:
mov	[bp+arg_4], dx
add	dx, [bp+arg_0]	; Add

loc_1C786:
mov	[cs:word_1C4CE], dx

loc_1C78B:
mov	ax, [bp+arg_2]
sub	ax, [bp+arg_4]	; Integer Subtraction

loc_1C791:
mov	[cs:word_1C4D0], ax
mov	ax, [bp+arg_0]
mov	[cs:word_1C4D2], ax
mov	ax, [bp+arg_0]
mov	[cs:word_1C4D4], ax

loc_1C7A3:
mov	ax, [bp+arg_4]
mov	[cs:word_1C4D6], ax
mov	ax, [bp+arg_2]
sub	ax, [bp+arg_4]	; Integer Subtraction
add	ax, [bp+arg_0]	; Add
mov	[cs:word_1C4D8], ax

loc_1C7B7:
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax

loc_1C7BC:
mov	si, [cs:word_1C4D2]

loc_1C7C1:
mov	ax, si

loc_1C7C3:		; Shift	Logical	Left
shl	si, 1
add	si, ax		; Add

loc_1C7C7:
mov	bx, [cs:word_1C4CE]

loc_1C7CC:
mov	cx, [cs:word_1C4D0]
mov	dx, INPUT_STATUS

loc_1C7D4:		; CODE XREF: idk_VGA_PAL_s1C76E:loc_1C7D7j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.

loc_1C7D5:		; Logical AND
and	al, 8

loc_1C7D7:		; Jump if Not Zero (ZF=0)
jnz	short loc_1C7D4

loc_1C7D9:		; CODE XREF: idk_VGA_PAL_s1C76E+6Ej
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.

loc_1C7DA:		; Logical AND
and	al, 8
jz	short loc_1C7D9	; Jump if Zero (ZF=1)
mov	dx, PALETTE_INDEX

loc_1C7E1:		; CODE XREF: idk_VGA_PAL_s1C76E:loc_1C7EFj
cli			; Clear	Interrupt Flag
mov	al, bl

loc_1C7E4:
out	dx, al
inc	dx		; Increment by 1
lodsb			; Load String
out	dx, al
lodsb			; Load String
out	dx, al
lodsb			; Load String
out	dx, al
sti			; Set Interrupt	Flag
dec	dx		; Decrement by 1
inc	bx		; Increment by 1

loc_1C7EF:		; Loop while CX	!= 0
loop	loc_1C7E1
mov	si, [cs:word_1C4D8]

loc_1C7F6:
mov	ax, si
shl	si, 1		; Shift	Logical	Left
add	si, ax		; Add

loc_1C7FC:
mov	bx, [cs:word_1C4D4]
mov	cx, [cs:word_1C4D6]
cmp	cx, 0		; Compare Two Operands
jz	short loc_1C82B	; Jump if Zero (ZF=1)
mov	dx, INPUT_STATUS

loc_1C80E:		; CODE XREF: idk_VGA_PAL_s1C76E+A3j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jnz	short loc_1C80E	; Jump if Not Zero (ZF=0)

loc_1C813:		; CODE XREF: idk_VGA_PAL_s1C76E:loc_1C816j
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND

loc_1C816:		; Jump if Zero (ZF=1)
jz	short loc_1C813

loc_1C818:
mov	dx, PALETTE_INDEX

loc_1C81B:		; CODE XREF: idk_VGA_PAL_s1C76E+BBj
cli			; Clear	Interrupt Flag
mov	al, bl
out	dx, al
inc	dx		; Increment by 1
lodsb			; Load String
out	dx, al
lodsb			; Load String
out	dx, al

loc_1C824:		; Load String
lodsb
out	dx, al
sti			; Set Interrupt	Flag
dec	dx		; Decrement by 1
inc	bx		; Increment by 1
loop	loc_1C81B	; Loop while CX	!= 0

loc_1C82B:		; CODE XREF: idk_VGA_PAL_s1C76E+9Bj
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, 768
mov	cx, 128
mov	ax, 0
rep stosw		; Store	String
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_VGA_PAL_s1C76E



; Attributes: bp-based frame

proc idk_VGA_PAL_s1C840	far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	dx, 0
mov	ax, [bp+arg_4]
mov	bx, [bp+arg_2]
shl	bx, 1		; Shift	Logical	Left
div	bx		; Unsigned Divide
mov	[bp+arg_4], dx

loc_1C857:
mov	[cs:word_1C4DE], dx
mov	bx, [bp+arg_0]
mov	[cs:word_1C4DA], bx
mov	cx, [bp+arg_2]
mov	[cs:word_1C4DC], cx

loc_1C86C:
mov	di, 0
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax

loc_1C874:
mov	dx, INPUT_STATUS

loc_1C877:		; CODE XREF: idk_VGA_PAL_s1C840+3Aj
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND
jnz	short loc_1C877	; Jump if Not Zero (ZF=0)

loc_1C87C:		; CODE XREF: idk_VGA_PAL_s1C840:loc_1C87Fj
in	al, dx		; Video	status bits:
			; 0: retrace.  1=display is in vert or horiz retrace.
			; 1: 1=light pen is triggered; 0=armed
			; 2: 1=light pen switch	is open; 0=closed
			; 3: 1=vertical	sync pulse is occurring.
and	al, 8		; Logical AND

loc_1C87F:		; Jump if Zero (ZF=1)
jz	short loc_1C87C
mov	dx, PALETTE_INDEX

loc_1C884:		; CODE XREF: idk_VGA_PAL_s1C840+7Ej
mov	si, [cs:word_1C4DC]
mov	ax, di

loc_1C88B:		; Add
add	ax, [cs:word_1C4DE]
cmp	ax, si		; Compare Two Operands
js	short loc_1C8A4	; Jump if Sign (SF=1)
sub	ax, si		; Integer Subtraction
cmp	ax, si		; Compare Two Operands
js	short loc_1C89F	; Jump if Sign (SF=1)

loc_1C89A:		; Integer Subtraction
sub	ax, si
jmp	short loc_1C8A4	; Jump
byte_1C89E db 90h

loc_1C89F:		; CODE XREF: idk_VGA_PAL_s1C840+58j
sub	si, ax		; Integer Subtraction
dec	si		; Decrement by 1
mov	ax, si

loc_1C8A4:		; CODE XREF: idk_VGA_PAL_s1C840+52j
			; idk_VGA_PAL_s1C840+5Cj
add	ax, [cs:word_1C4DA] ; Add
mov	si, ax
shl	si, 1		; Shift	Logical	Left
add	si, ax		; Add
cli			; Clear	Interrupt Flag

loc_1C8B0:
mov	al, bl
out	dx, al
inc	dx		; Increment by 1
lodsb			; Load String
out	dx, al
lodsb			; Load String
out	dx, al
lodsb			; Load String
out	dx, al
sti			; Set Interrupt	Flag
dec	dx		; Decrement by 1
inc	di		; Increment by 1
inc	bx		; Increment by 1
loop	loc_1C884	; Loop while CX	!= 0
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, 768

loc_1C8C7:
mov	cx, 128
mov	ax, 0
rep stosw		; Store	String
pop	ds

loc_1C8D0:
pop	es
assume es:nothing
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_VGA_PAL_s1C840



; Attributes: bp-based frame

proc idk_PAL_s1C8D5 far	; CODE XREF: sub_1BF5C:loc_1BF6FP
			; sub_1BF79+15P
			; sub_1BF79+6CP
			; sub_1BFF7+32P
			; sub_1BFF7+8EP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, [bp+arg_2]
mov	bx, [bp+arg_4]
mov	cx, [bp+arg_6]
mov	[cs:word_1C4C8], ax
mov	[cs:word_1C4CC], bx
mov	[cs:word_1C4CA], cx
mov	ax, 64h	; 'd'
sub	ax, [bp+arg_8]	; Integer Subtraction
ja	short loc_1C8FE	; Jump if Above	(CF=0 &	ZF=0)

loc_1C8FB:		; Jump
jmp	loc_1CA6B

loc_1C8FE:		; CODE XREF: idk_PAL_s1C8D5+24j
cmp	ax, 64h	; 'd'   ; Compare Two Operands
js	short loc_1C906	; Jump if Sign (SF=1)
jmp	loc_1CA47	; Jump

loc_1C906:		; CODE XREF: idk_PAL_s1C8D5+2Cj
mov	bx, 256
mul	bx		; Unsigned Multiplication of AL	or AX
mov	bx, 64h	; 'd'
div	bx		; Unsigned Divide
mov	[cs:word_1C4EA], ax
mov	ax, [bp+arg_8]
mov	bx, 256
mul	bx		; Unsigned Multiplication of AL	or AX
mov	bx, 64h	; 'd'
div	bx		; Unsigned Divide
mov	bx, ax
mov	al, [byte ptr bp+arg_2]
mul	bl		; Unsigned Multiplication of AL	or AX

loc_1C928:
mov	[cs:byte_1C4EE], ah

loc_1C92D:
mov	al, [byte ptr bp+arg_4]
mul	bl		; Unsigned Multiplication of AL	or AX
mov	[cs:byte_1C4F0], ah
mov	al, [byte ptr bp+arg_6]
mul	bl		; Unsigned Multiplication of AL	or AX
mov	[cs:byte_1C4F2], ah
mov	bx, [bp+arg_0]
shl	bx, 1		; Shift	Logical	Left
shl	bx, 1		; Shift	Logical	Left
shl	bx, 1		; Shift	Logical	Left
shl	bx, 1		; Shift	Logical	Left
mov	ax, [idk_FontsLbx1_6144B]
add	ax, bx		; Add
mov	es, ax
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	[cs:word_1C4EC], 0

loc_1C95F:		; CODE XREF: idk_PAL_s1C8D5+169j
mov	si, [cs:word_1C4EC]
add	si, 768		; Add
lodsb			; Load String
or	al, al		; Logical Inclusive OR
jnz	short loc_1C970	; Jump if Not Zero (ZF=0)

loc_1C96D:		; Jump
jmp	loc_1CA30

loc_1C970:		; CODE XREF: idk_PAL_s1C8D5+96j
mov	si, [cs:word_1C4EC]
mov	ax, si
shl	si, 1		; Shift	Logical	Left
add	si, ax		; Add
mov	bl, [byte ptr cs:word_1C4EA]
lodsb			; Load String
mul	bl		; Unsigned Multiplication of AL	or AX
add	ah, [cs:byte_1C4EE] ; Add
mov	[cs:byte_1C4E4], ah
lodsb			; Load String
mul	bl		; Unsigned Multiplication of AL	or AX
add	ah, [cs:byte_1C4F0] ; Add
mov	[cs:byte_1C4E6], ah
lodsb			; Load String
mul	bl		; Unsigned Multiplication of AL	or AX
add	ah, [cs:byte_1C4F2] ; Add
mov	[cs:byte_1C4E8], ah
mov	[cs:word_1C4E0], 0
mov	[cs:word_1C4E2], 2710h
mov	cx, 256
mov	si, 0
mov	di, 0

loc_1C9BE:		; CODE XREF: idk_PAL_s1C8D5+14Fj
mov	al, [di+768]
add	si, 3		; Add
or	al, al		; Logical Inclusive OR
jz	short loc_1CA23	; Jump if Zero (ZF=1)

loc_1C9C9:		; Integer Subtraction
sub	si, 3
lodsb			; Load String
sub	al, [cs:byte_1C4E4] ; Integer Subtraction
jns	short loc_1C9D6	; Jump if Not Sign (SF=0)

loc_1C9D4:		; Two's Complement Negation
neg	al

loc_1C9D6:		; CODE XREF: idk_PAL_s1C8D5+FDj
add	si, 2		; Add
cmp	al, 21		; Compare Two Operands
jns	short loc_1CA23	; Jump if Not Sign (SF=0)
sub	si, 2		; Integer Subtraction
mov	bl, al
lodsb			; Load String
sub	al, [cs:byte_1C4E6] ; Integer Subtraction
jns	short loc_1C9EC	; Jump if Not Sign (SF=0)
neg	al		; Two's Complement Negation

loc_1C9EC:		; CODE XREF: idk_PAL_s1C8D5+113j
inc	si		; Increment by 1
cmp	al, 21		; Compare Two Operands
jns	short loc_1CA23	; Jump if Not Sign (SF=0)
dec	si		; Decrement by 1
mov	bh, al
lodsb			; Load String
sub	al, [cs:byte_1C4E8] ; Integer Subtraction
jns	short loc_1C9FE	; Jump if Not Sign (SF=0)

loc_1C9FC:		; Two's Complement Negation
neg	al

loc_1C9FE:		; CODE XREF: idk_PAL_s1C8D5+125j
cmp	al, 15h		; Compare Two Operands
jns	short loc_1CA23	; Jump if Not Sign (SF=0)
mul	al		; Unsigned Multiplication of AL	or AX
mov	dx, ax
mov	al, bl
mul	al		; Unsigned Multiplication of AL	or AX
add	dx, ax		; Add
mov	al, bh
mul	al		; Unsigned Multiplication of AL	or AX
add	dx, ax		; Add
cmp	dx, [cs:word_1C4E2] ; Compare Two Operands
jnb	short loc_1CA23	; Jump if Not Below (CF=0)
mov	[cs:word_1C4E2], dx
mov	[cs:word_1C4E0], di

loc_1CA23:		; CODE XREF: idk_PAL_s1C8D5+F2j
			; idk_PAL_s1C8D5+106j
			; idk_PAL_s1C8D5+11Aj
			; idk_PAL_s1C8D5+12Bj
			; idk_PAL_s1C8D5+142j
inc	di		; Increment by 1
loop	loc_1C9BE	; Loop while CX	!= 0

loc_1CA26:
mov	di, [cs:word_1C4EC]
mov	al, [byte ptr cs:word_1C4E0]
stosb			; Store	String

loc_1CA30:		; CODE XREF: idk_PAL_s1C8D5:loc_1C96Dj
mov	ax, [cs:word_1C4EC]
inc	ax		; Increment by 1
mov	[cs:word_1C4EC], ax
cmp	ah, 0		; Compare Two Operands
jnz	short loc_1CA41	; Jump if Not Zero (ZF=0)
jmp	loc_1C95F	; Jump

loc_1CA41:		; CODE XREF: idk_PAL_s1C8D5+167j
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1CA47:		; CODE XREF: idk_PAL_s1C8D5+2Ej
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, [idk_FontsLbx1_6144B] ; Add
mov	es, ax
mov	di, 0
mov	al, 0
mov	cx, 256

loc_1CA60:		; CODE XREF: idk_PAL_s1C8D5+18Ej
stosb			; Store	String
inc	al		; Increment by 1
loop	loc_1CA60	; Loop while CX	!= 0
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1CA6B:		; CODE XREF: idk_PAL_s1C8D5:loc_1C8FBj
mov	bx, [bp+arg_0]
shl	bx, 1		; Shift	Logical	Left
shl	bx, 1		; Shift	Logical	Left
shl	bx, 1		; Shift	Logical	Left
shl	bx, 1		; Shift	Logical	Left
mov	ax, [idk_FontsLbx1_6144B]
add	ax, bx		; Add
mov	es, ax
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	[cs:word_1C4E0], 0
mov	[cs:word_1C4E2], 2710h
mov	cx, 256
mov	si, 0
mov	di, 0

loc_1CA99:		; CODE XREF: idk_PAL_s1C8D5+21Cj
lodsb			; Load String
sub	al, [byte ptr cs:word_1C4C8] ; Integer Subtraction
jns	short loc_1CAA3	; Jump if Not Sign (SF=0)

loc_1CAA1:		; Two's Complement Negation
neg	al

loc_1CAA3:		; CODE XREF: idk_PAL_s1C8D5+1CAj
add	si, 2		; Add
cmp	al, 21		; Compare Two Operands
jns	short loc_1CAF0	; Jump if Not Sign (SF=0)
sub	si, 2		; Integer Subtraction
mov	bl, al
lodsb			; Load String
sub	al, [byte ptr cs:word_1C4CC] ; Integer Subtraction
jns	short loc_1CAB9	; Jump if Not Sign (SF=0)
neg	al		; Two's Complement Negation

loc_1CAB9:		; CODE XREF: idk_PAL_s1C8D5+1E0j
inc	si		; Increment by 1
cmp	al, 21		; Compare Two Operands
jns	short loc_1CAF0	; Jump if Not Sign (SF=0)
dec	si		; Decrement by 1
mov	bh, al
lodsb			; Load String
sub	al, [byte ptr cs:word_1C4CA] ; Integer Subtraction
jns	short loc_1CACB	; Jump if Not Sign (SF=0)

loc_1CAC9:		; Two's Complement Negation
neg	al

loc_1CACB:		; CODE XREF: idk_PAL_s1C8D5+1F2j
cmp	al, 15h		; Compare Two Operands
jns	short loc_1CAF0	; Jump if Not Sign (SF=0)
mul	al		; Unsigned Multiplication of AL	or AX
mov	dx, ax
mov	al, bl
mul	al		; Unsigned Multiplication of AL	or AX
add	dx, ax		; Add
mov	al, bh
mul	al		; Unsigned Multiplication of AL	or AX
add	dx, ax		; Add
cmp	dx, [cs:word_1C4E2] ; Compare Two Operands
jns	short loc_1CAF0	; Jump if Not Sign (SF=0)
mov	[cs:word_1C4E2], dx
mov	[cs:word_1C4E0], di

loc_1CAF0:		; CODE XREF: idk_PAL_s1C8D5+1D3j
			; idk_PAL_s1C8D5+1E7j
			; idk_PAL_s1C8D5+1F8j
			; idk_PAL_s1C8D5+20Fj
inc	di		; Increment by 1
loop	loc_1CA99	; Loop while CX	!= 0

loc_1CAF3:
mov	di, 0
mov	al, [byte ptr cs:word_1C4E0]
mov	cx, 256
rep stosb		; Store	String


pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_PAL_s1C8D5



; Attributes: bp-based frame

proc idk_Font_s1CB05 far
			; CODE XREF: sub_1F61E:loc_1F649P
			; sub_1F655:loc_1F6B0P
			; idk_VidLib_s1F743+106P
			; sub_1F8FD+50P
			; LBX_Load_IntroLbx_s21977+6CP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp

loc_1CB08:
push	si
push	di
push	es
push	ds
mov	cx, [bp+arg_2]
mov	ax, [bp+arg_0]

loc_1CB12:
mov	dx, [idk_FontsLbx1_1024B]
mov	ds, ax

loc_1CB18:
mov	es, dx

loc_1CB1A:
mov	bl, [byte_31D1A]
cmp	bl, 0		; Compare Two Operands
jnz	short loc_1CB75	; Jump if Not Zero (ZF=0)

loc_1CB23:
mov	di, 0

loc_1CB26:		; CODE XREF: idk_Font_s1CB05+9Aj
mov	si, 14
add	si, di		; Add
lodsw			; Load String
add	ax, di		; Add
mov	si, ax
mov	bx, ax
cmp	cx, 0		; Compare Two Operands
jz	short loc_1CB65	; Jump if Zero (ZF=1)

loc_1CB37:		; Compare Two Operands
cmp	[byte ptr bx+6], 0
jz	short loc_1CB65	; Jump if Zero (ZF=1)
dec	cx		; Decrement by 1
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	si, cx		; Add
add	si, 8		; Add
lodsw			; Load String

loc_1CB48:
mov	dx, ax
add	dx, di		; Add
lodsw			; Load String
cmp	ah, 0		; Compare Two Operands
jz	short loc_1CB5F	; Jump if Zero (ZF=1)
mov	cl, ah
xor	ch, ch		; Logical Exclusive OR
xor	ah, ah		; Logical Exclusive OR
mov	di, ax
mov	si, dx
jmp	short loc_1CBA1	; Jump
db 90h

loc_1CB5F:		; CODE XREF: idk_Font_s1CB05+4Bj
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1CB65:		; CODE XREF: idk_Font_s1CB05+30j
			; idk_Font_s1CB05+36j
lodsw			; Load String

loc_1CB66:
mov	dx, ax
add	dx, di		; Add
lodsw			; Load String
mov	di, ax
lodsw			; Load String
mov	cx, ax
mov	si, dx
jmp	short loc_1CBA1	; Jump
db 90h

loc_1CB75:		; CODE XREF: idk_Font_s1CB05+1Cj
mov	di, [word_31D1C]
xor	bh, bh		; Logical Exclusive OR
mov	dx, bx
push	dx
mov	ax, 4400h
mov	bl, [byte_31D1B]
xor	bh, bh		; Logical Exclusive OR
int	67h		; DOS -	LIM EMS	- MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
pop	dx
mov	bl, [byte_31D1B]
xor	bh, bh		; Logical Exclusive OR
mov	ax, 4401h

loc_1CB93:		; DOS -	LIM EMS	- MAP MEMORY
int	67h		; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status

loc_1CB95:
mov	ax, seg	dseg

loc_1CB98:
mov	ds, ax

loc_1CB9A:
mov	ax, [EMM_PageFrameSegmentAddress]

loc_1CB9D:
mov	ds, ax
jmp	short loc_1CB26	; Jump

loc_1CBA1:		; CODE XREF: idk_Font_s1CB05+57j
			; idk_Font_s1CB05+6Dj
mov	bx, di

loc_1CBA3:		; Shift	Logical	Left
shl	di, 1

loc_1CBA5:		; Add
add	di, bx

loc_1CBA7:		; Add
add	bx, 768

loc_1CBAB:		; CODE XREF: idk_Font_s1CB05:loc_1CBB2j
movsw			; Move Byte(s) from String to String

loc_1CBAC:		; Move Byte(s) from String to String
movsb

loc_1CBAD:
mov	[byte ptr es:bx], 1

loc_1CBB1:		; Increment by 1
inc	bx

loc_1CBB2:		; Loop while CX	!= 0
loop	loc_1CBAB

loc_1CBB4:
pop	ds

loc_1CBB5:
pop	es

loc_1CBB6:
pop	di

loc_1CBB7:
pop	si

loc_1CBB8:
pop	bp

locret_1CBB9:		; Return Far from Procedure
retf
endp idk_Font_s1CB05

ends seg021


; Segment type:	Pure code
segment	seg022 byte public 'CODE' use16
assume cs:seg022
;org 0Ah
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_1CBBA far
push	bp

loc_1CBBB:
mov	bp, sp

loc_1CBBD:		; Logical Exclusive OR
xor	bx, bx

loc_1CBBF:
mov	ax, 0E07h

loc_1CBC2:		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
int	10h		; AL = character, BH = display page (alpha modes)
			; BL = foreground color	(graphics modes)

loc_1CBC4:
pop	bp
retf			; Return Far from Procedure
endp sub_1CBBA



; Attributes: bp-based frame

proc sub_1CBC6 far
push	bp

loc_1CBC7:
mov	bp, sp

loc_1CBC9:
mov	ah, 0

loc_1CBCB:		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
int	16h		; Return: AH = scan code, AL = character
pop	bp

locret_1CBCE:		; Return Far from Procedure
retf
endp sub_1CBC6



; Attributes: bp-based frame

proc sub_1CBCF far
push	bp

loc_1CBD0:
mov	bp, sp
call	_f020105_bios_timeofday	; Call Procedure

loc_1CBD7:
mov	ax, 30
push	ax

loc_1CBDB:		; Call Procedure
call	_f020305_idk_SleepWaitPause

loc_1CBE0:
pop	cx
pop	bp

locret_1CBE2:		; Return Far from Procedure
retf
endp sub_1CBCF



; Attributes: bp-based frame

proc sub_1CBE3 far
push	bp
mov	bp, sp
call	idk_VGA_s1E4BA	; Call Procedure

loc_1CBEB:		; Logical Exclusive OR
xor	ax, ax

loc_1CBED:
push	ax

loc_1CBEE:
mov	ax, 199

loc_1CBF1:
push	ax

loc_1CBF2:
mov	ax, 319
push	ax

loc_1CBF6:		; Logical Exclusive OR
xor	ax, ax

loc_1CBF8:
push	ax

loc_1CBF9:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_1CBFC:		; args(10, 0, 0, 319, 199, 0)
call	idk_VGA_ScData_s186BC

loc_1CC01:		; Add
add	sp, 10

loc_1CC04:		; Call Procedure
call	VGA_MathThenSetVarToVgaLoc
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1CC0C:
mov	ax, 199

loc_1CC0F:
push	ax

loc_1CC10:
mov	ax, 319
push	ax

loc_1CC14:		; Logical Exclusive OR
xor	ax, ax

loc_1CC16:
push	ax

loc_1CC17:		; Logical Exclusive OR
xor	ax, ax

loc_1CC19:
push	ax

loc_1CC1A:		; Call Procedure
call	idk_VGA_ScData_s186BC

loc_1CC1F:		; Add
add	sp, 10

loc_1CC22:
pop	bp
retf			; Return Far from Procedure
endp sub_1CBE3



; Attributes: bp-based frame

proc sub_1CC24 far	; CODE XREF: sub_4F808+24P
			; sub_4F808+9EEP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
mov	ax, [bp+arg_0]
mov	[idk_RND_w3602E], ax
mov	ax, [bp+arg_2]
mov	[idk_RND_w36030], ax
pop	bp
retf			; Return Far from Procedure
endp sub_1CC24



; Attributes: bp-based frame

proc sub_1CC35 far	; CODE XREF: sub_4F808+11P

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp

loc_1CC38:		; Integer Subtraction
sub	sp, 4

loc_1CC3B:
mov	ax, [idk_RND_w36030]

loc_1CC3E:		; Logical Exclusive OR
xor	dx, dx

loc_1CC40:		; Add
add	dx, [idk_RND_w3602E]

loc_1CC44:		; Add with Carry
adc	ax, 0

loc_1CC47:
mov	[bp+var_2], ax
mov	[bp+var_4], dx

loc_1CC4D:
mov	dx, [bp+var_2]

loc_1CC50:
mov	ax, [bp+var_4]

loc_1CC53:		; Jump
jmp	short $+2
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1CC35



; Attributes: bp-based frame

proc ILSe_RndCopySeed_s1CC59 far
			; CODE XREF: Load_Fonts_SndDrv+90P
			; idk_Load_FntSty_SndDrv_Mos:loc_17E5CP

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	es
mov	ax, 0
mov	es, ax
assume es:nothing
mov	ax, [es:maybe_w3217C]
mov	[bp+var_2], ax
mov	ax, [es:maybe_w3217E]
mov	[bp+var_4], ax
pop	es
assume es:nothing
mov	ax, [bp+var_2]
mov	[idk_RND_w3602E], ax
mov	ax, [bp+var_4]
mov	[idk_RND_w36030], ax
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ILSe_RndCopySeed_s1CC59



; Attributes: bp-based frame

proc idk_Arg_0Fail_ElseMathyDiSi far
			; CODE XREF: sub_3EAD2+3AP
			; sub_3EAD2+4EP
			; sub_3EAD2+62P
			; sub_3EAD2+76P
			; sub_3EAD2+8AP
			; sub_3EAD2+9EP
			; sub_438C4+FEP
			; sub_438C4+110P
			; sub_438C4:loc_439EAP
			; sub_438C4+136P
			; sub_43C95+28P
			; sub_43C95+38P
			; sub_43C95+80P
			; sub_43E4F+6CP
			; sub_43E4F+7CP
			; sub_43E4F+33BP
			; sub_43E4F+3CAP
			; sub_43E4F+44FP
			; sub_44A0E+106P
			; sub_44A0E+1DAP
			; sub_44CBB+5FP
			; sub_44CBB+E0P
			; sub_44CBB+130P
			; sub_44CBB+140P
			; sub_44CBB+1C5P
			; sub_44CBB+1DDP
			; sub_44CBB+2B2P
			; sub_44CBB+2C0P
			; sub_44CBB+353P
			; sub_44CBB+36BP
			; sub_450F6+13EP
			; sub_450F6+1DFP
			; sub_450F6+1EEP
			; sub_450F6+233P
			; sub_450F6+242P
			; sub_45389+B7P
			; sub_45389+C7P
			; sub_45389+127P
			; sub_45389+152P
			; sub_45389+164P
			; sub_45389+173P
			; sub_45389+203P
			; sub_45389+21BP
			; sub_45645+33P
			; sub_45645+44P
			; sub_45645+D0P
			; sub_45645+187P
			; sub_45645+2A4P
			; sub_45645+2B5P
			; sub_45645+341P
			; sub_45645+40CP
			; sub_45B42+24P
			; sub_45B42+32P
			; sub_45B42+DBP
			; sub_45B42+E9P
			; sub_45B42+F7P
			; sub_45B42:loc_45C52P
			; sub_45DC9+13FP
			; sub_45DC9+14CP
			; sub_45DC9+159P
			; sub_46406+15P
			; sub_46406+119P
			; sub_46406+1A1P
			; sub_46406+1AFP
			; sub_46406:loc_465C5P
			; sub_46406+242P
			; sub_46406+256P
			; sub_46406+295P
			; sub_46406+2A3P
			; sub_46406+2B3P
			; sub_46406+33EP
			; sub_467A7+DEP
			; sub_467A7+1D3P
			; sub_467A7+250P
			; sub_467A7+27DP
			; sub_467A7+2B4P
			; sub_467A7+3C0P
			; sub_467A7+49DP
			; sub_467A7+6FDP
			; sub_467A7:loc_46EBFP
			; sub_467A7+744P
			; sub_467A7+778P
			; sub_467A7+794P
			; sub_467A7+7DAP
			; sub_467A7+840P
			; sub_467A7+8F9P
			; sub_467A7+985P
			; sub_47247+13P
			; LBX_Terrtype_s48821+6FP
			; LBX_Terrtype_s48821+146P
			; LBX_Terrtype_s48821+1FAP
			; LBX_Terrtype_s48821+2D1P
			; LBX_Terrtype_s48821+385P
			; sub_48C63+10P
			; sub_48C63+20P
			; sub_48C63+1AFP
			; sub_48C63+1CCP
			; sub_48C63+1E9P
			; sub_4910F+116P
			; sub_4A942+20P
			; sub_4A942+A5P
			; sub_4A942+10CP
			; sub_4A942+11CP
			; sub_4A942+38FP
			; sub_4A942+492P
			; sub_4A942+514P
			; sub_4A942+5B1P
			; sub_4A942+5E6P
			; sub_4A942+5F5P
			; LBX_Cityname_s4B973+3BP
			; LBX_Cityname_s4B973+9DP
			; sub_4BF93+7EP
			; sub_4BF93+91P
			; sub_4BF93+216P
			; sub_4BF93+228P
			; sub_4C37F+11P
			; sub_4C37F+1DP
			; sub_4C3E1+11P
			; sub_4C3E1+1DP
			; sub_4C46D:loc_4C47EP
			; sub_4C46D+1DP
			; sub_4CE35+41P
			; sub_4CE35+96P
			; sub_4F808+3FP
			; sub_4F808+7BP
			; sub_4F808+B8P
			; sub_4F808+F3P
			; sub_4F808+1B3P
			; sub_4F808+1E3P
			; sub_4F808+211P
			; sub_4F808+23EP
			; sub_4F808+2E3P
			; sub_4F808+313P
			; sub_4F808+341P
			; sub_4F808+372P
			; sub_4F808+40BP
			; sub_4F808+43BP
			; sub_4F808+46BP
			; sub_4F808+514P
			; sub_4F808+544P
			; sub_4F808+572P
			; sub_4F808+59FP
			; sub_4F808+640P
			; sub_4F808+670P
			; sub_4F808+69EP
			; sub_4F808+6CBP
			; sub_4F808+767P
			; sub_4F808+797P
			; sub_4F808+7C7P
			; sub_4F808+865P
			; sub_4F808+893P
			; sub_4F808+8C1P
			; sub_4F808+95BP
			; sub_4F808+989P
			; sub_4F808+9B7P
			; sub_523A3+88P
			; sub_52792+3F5P
			; sub_52792:loc_52BD8P
			; sub_5301E+3EP
			; sub_5301E+196P
			; sub_5301E+238P
			; sub_5301E+247P
			; sub_5301E+257P
			; sub_5301E+267P
			; sub_5301E+272P
			; sub_5301E+296P
			; sub_5301E+453P
			; sub_5301E+460P
			; sub_5301E+629P
			; sub_5301E+977P
			; sub_53A06+7EFP
			; sub_53A06+924P
			; sub_53A06:loc_5444CP
			; sub_53A06:loc_54569P
			; sub_5474D+D1P
			; sub_54E71+2BP
			; sub_54E71+B2P
			; sub_54E71+139P
			; sub_54E71+1C0P
			; sub_54E71+247P
			; sub_54E71+2CEP
			; sub_54E71+355P
			; sub_54E71+3DCP
			; sub_55315+59P

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_1CC87:		; Integer Subtraction
sub	sp, 4
push	si
push	di
cmp	[bp+arg_0], 0	; Compare Two Operands

loc_1CC90:		; Jump Not Zero	/ Jump Equal
jnz	short loc_1CC9C

loc_1CC92:		; "RND no 0's"
mov	ax, offset arg0_PrintString

loc_1CC95:		; arg0_PrintString
push	ax

loc_1CC96:		; Call Procedure
call	_f050207_EXIT_CleanUp

loc_1CC9B:
pop	cx

loc_1CC9C:		; CODE XREF: idk_Arg_0Fail_ElseMathyDiSi:loc_1CC90j
mov	[bp+var_4], 0

loc_1CCA1:
push	si
push	di
mov	si, [idk_RND_w3602E]

loc_1CCA7:
mov	di, [idk_RND_w36030]

loc_1CCAB:
mov	cx, 9

loc_1CCAE:		; CODE XREF: idk_Arg_0Fail_ElseMathyDiSi+61j
mov	ax, si

loc_1CCB0:
mov	bx, si
mov	dx, di
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
xor	ax, bx		; Logical Exclusive OR
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
xor	ax, bx		; Logical Exclusive OR

loc_1CCC0:		; Shift	Logical	Right
shr	dx, 1
rcr	bx, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
xor	ax, bx		; Logical Exclusive OR
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
xor	ax, bx		; Logical Exclusive OR
shr	dx, 1		; Shift	Logical	Right

loc_1CCD6:		; Logical Exclusive OR
xor	al, dh

loc_1CCD8:
mov	dx, ax
shr	dx, 1		; Shift	Logical	Right
rcl	[bp+var_4], 1	; Rotate Through Carry Left
shr	ax, 1		; Shift	Logical	Right
rcr	di, 1		; Rotate Through Carry Right
rcr	si, 1		; Rotate Through Carry Right
loop	loc_1CCAE	; Loop while CX	!= 0
cmp	si, 0		; Compare Two Operands
jnz	short loc_1CCF4	; Jump if Not Zero (ZF=0)
cmp	di, 0		; Compare Two Operands

loc_1CCEF:		; Jump if Not Zero (ZF=0)
jnz	short loc_1CCF4
mov	si, 30BEh

loc_1CCF4:		; CODE XREF: idk_Arg_0Fail_ElseMathyDiSi+66j
			; idk_Arg_0Fail_ElseMathyDiSi:loc_1CCEFj
mov	[idk_RND_w3602E], si
mov	[idk_RND_w36030], di
pop	di
pop	si
mov	ax, [bp+var_4]
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+arg_0]	; Signed Divide
inc	dx		; Increment by 1
mov	[bp+var_2], dx
mov	ax, [bp+var_2]

loc_1CD0C:		; ?Align or Cache-Skip?
jmp	short $+2

loc_1CD0E:
pop	di

loc_1CD0F:
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_Arg_0Fail_ElseMathyDiSi



; Attributes: bp-based frame

proc sub_1CD14 far

arg_0= word ptr	 6

push	bp

loc_1CD15:
mov	bp, sp
mov	cx, [bp+arg_0]
xor	dx, dx		; Logical Exclusive OR
jmp	short loc_1CD3F	; Jump

loc_1CD1E:		; CODE XREF: sub_1CD14+32j
mov	bx, cx

loc_1CD20:		; Add
add	bx, dx
cmp	[byte ptr bx], 61h ; 'a' ; Compare Two Operands
jl	short loc_1CD3E	; Jump if Less (SF!=OF)
mov	bx, cx
add	bx, dx		; Add
cmp	[byte ptr bx], 7Ah ; 'z' ; Compare Two Operands
jg	short loc_1CD3E	; Jump if Greater (ZF=0	& SF=OF)

loc_1CD30:
mov	bx, cx
add	bx, dx		; Add
mov	al, [bx]

loc_1CD36:		; Add
add	al, 0E0h ; ''
mov	bx, cx
add	bx, dx		; Add
mov	[bx], al

loc_1CD3E:		; CODE XREF: sub_1CD14+11j
			; sub_1CD14+1Aj
inc	dx		; Increment by 1

loc_1CD3F:		; CODE XREF: sub_1CD14+8j
mov	bx, cx
add	bx, dx		; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jnz	short loc_1CD1E	; Jump if Not Zero (ZF=0)
pop	bp
retf			; Return Far from Procedure
endp sub_1CD14



; Attributes: bp-based frame

proc sub_1CD4A far

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	cx, [bp+arg_0]
xor	dx, dx		; Logical Exclusive OR
jmp	short loc_1CD75	; Jump

loc_1CD54:		; CODE XREF: sub_1CD4A+32j
mov	bx, cx
add	bx, dx		; Add
cmp	[byte ptr bx], 41h ; 'A' ; Compare Two Operands
jl	short loc_1CD74	; Jump if Less (SF!=OF)
mov	bx, cx
add	bx, dx		; Add

loc_1CD61:		; Compare Two Operands
cmp	[byte ptr bx], 5Ah ; 'Z'
jg	short loc_1CD74	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, cx
add	bx, dx		; Add
mov	al, [bx]
add	al, 20h	; ' '   ; Add
mov	bx, cx
add	bx, dx		; Add
mov	[bx], al

loc_1CD74:		; CODE XREF: sub_1CD4A+11j
			; sub_1CD4A+1Aj
inc	dx		; Increment by 1

loc_1CD75:		; CODE XREF: sub_1CD4A+8j
mov	bx, cx
add	bx, dx		; Add

loc_1CD79:		; Compare Two Operands
cmp	[byte ptr bx], 0
jnz	short loc_1CD54	; Jump if Not Zero (ZF=0)
pop	bp
retf			; Return Far from Procedure
endp sub_1CD4A



; Attributes: bp-based frame

proc sub_1CD80 far	; CODE XREF: sub_28963+2EP
			; sub_2A755+8BP
			; sub_2B1F9+69P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_1CD81:
mov	bp, sp
push	si
push	di
cmp	[bp+arg_4], 0	; Compare Two Operands

loc_1CD89:		; Jump if Not Zero (ZF=0)
jnz	short loc_1CD8F
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1CDA4	; Jump

loc_1CD8F:		; CODE XREF: sub_1CD80:loc_1CD89j
push	es
push	si
push	di
mov	ax, ds

loc_1CD94:
mov	es, ax
assume es:dseg
mov	di, [bp+arg_0]
mov	si, [bp+arg_2]

loc_1CD9C:
mov	cx, [bp+arg_4]
rep movsb		; Move Byte(s) from String to String
pop	di
pop	si
pop	es
assume es:nothing

loc_1CDA4:		; CODE XREF: sub_1CD80+Dj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1CD80



; Attributes: bp-based frame

proc sub_1CDA8 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di

loc_1CDAD:		; Compare Two Operands
cmp	[bp+arg_4], 0
jnz	short loc_1CDB7	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1CDD5	; Jump

loc_1CDB7:		; CODE XREF: sub_1CDA8+9j
push	es
push	si
push	di
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, [bp+arg_0]

loc_1CDC1:
mov	si, [bp+arg_2]
mov	cx, [bp+arg_4]

loc_1CDC7:		; CODE XREF: sub_1CDA8:loc_1CDD0j
lodsb			; Load String
cmp	[es:di], al	; Compare Two Operands
jb	short loc_1CDCF	; Jump if Below	(CF=1)
stosb			; Store	String
dec	di		; Decrement by 1

loc_1CDCF:		; CODE XREF: sub_1CDA8+23j
inc	di		; Increment by 1

loc_1CDD0:		; Loop while CX	!= 0
loop	loc_1CDC7
pop	di
pop	si
pop	es
assume es:nothing

loc_1CDD5:		; CODE XREF: sub_1CDA8+Dj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1CDA8



; Attributes: bp-based frame

proc sub_1CDD9 far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	si
push	di
cmp	[bp+arg_2], 0	; Compare Two Operands
jnz	short loc_1CDE8	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1CDFC	; Jump

loc_1CDE8:		; CODE XREF: sub_1CDD9+9j
push	es
push	si

loc_1CDEA:
push	di
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, [bp+arg_0]
mov	cx, [bp+arg_2]
mov	al, 0

loc_1CDF7:		; Store	String
rep stosb
pop	di

loc_1CDFA:
pop	si
pop	es
assume es:nothing

loc_1CDFC:		; CODE XREF: sub_1CDD9+Dj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1CDD9



; Attributes: bp-based frame

proc sub_1CE00 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si

loc_1CE04:
push	di
cmp	[bp+arg_2], 0	; Compare Two Operands
jnz	short loc_1CE0F	; Jump if Not Zero (ZF=0)

loc_1CE0B:		; Logical Exclusive OR
xor	ax, ax
jmp	short loc_1CE24	; Jump

loc_1CE0F:		; CODE XREF: sub_1CE00+9j
push	es

loc_1CE10:
push	si
push	di
mov	ax, ds
mov	es, ax
assume es:dseg
mov	di, [bp+arg_0]
mov	cx, [bp+arg_2]
mov	ax, [bp+arg_4]

loc_1CE1F:		; Store	String
rep stosb
pop	di
pop	si
pop	es
assume es:nothing

loc_1CE24:		; CODE XREF: sub_1CE00+Dj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1CE00



; Attributes: bp-based frame

proc sub_1CE28 far

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp

loc_1CE2B:		; Integer Subtraction
sub	sp, 4

loc_1CE2E:
push	si
push	di
mov	ax, [bp+arg_4]

loc_1CE33:		; Signed Multiply
imul	[bp+arg_0]
mov	[bp+var_2], ax
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_0]	; Integer Subtraction
dec	ax		; Decrement by 1

loc_1CE40:		; Signed Multiply
imul	[bp+arg_4]
mov	[bp+var_4], ax
cmp	[bp+var_4], 0	; Compare Two Operands
jge	short loc_1CE50	; Jump if Greater or Equal (SF=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1CE98	; Jump

loc_1CE50:		; CODE XREF: sub_1CE28+22j
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_1CE77	; Jump if Not Zero (ZF=0)
push	es
push	si
push	di
mov	ax, ds
mov	es, ax
assume es:dseg
mov	ax, [bp+arg_6]

loc_1CE60:		; Decrement by 1
dec	ax
mov	bx, [bp+arg_4]
mul	bx		; Unsigned Multiplication of AL	or AX
add	ax, [bp+arg_2]	; Add
mov	di, ax
mov	cx, [bp+arg_4]

loc_1CE6E:
mov	al, 0

loc_1CE70:		; Store	String
rep stosb
pop	di
pop	si
pop	es
assume es:nothing
jmp	short loc_1CE98	; Jump

loc_1CE77:		; CODE XREF: sub_1CE28+2Cj
push	es
push	si
push	di
mov	ax, ds
mov	es, ax
assume es:dseg

loc_1CE7E:
mov	di, [bp+var_2]
add	di, [bp+arg_2]	; Add
mov	si, di

loc_1CE86:		; Add
add	si, [bp+arg_4]
mov	cx, [bp+var_4]
rep movsb		; Move Byte(s) from String to String
mov	al, 0
mov	cx, [bp+arg_4]
rep stosb		; Store	String
pop	di
pop	si
pop	es
assume es:nothing

loc_1CE98:		; CODE XREF: sub_1CE28+26j
			; sub_1CE28+4Dj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1CE28



; Attributes: bp-based frame

proc sub_1CE9E far

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp

loc_1CE9F:
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	bx, [bp+arg_0]
cmp	[bp+arg_4], 0	; Compare Two Operands
jnz	short loc_1CEB4	; Jump if Not Zero (ZF=0)

loc_1CEAF:
mov	ax, ds

loc_1CEB1:
mov	[bp+arg_4], ax

loc_1CEB4:		; CODE XREF: sub_1CE9E+Fj
mov	ax, bx
inc	ax		; Increment by 1
cmp	ax, [bp+arg_8]	; Compare Two Operands

loc_1CEBA:		; Jump if Below	(CF=1)
jb	short loc_1CEC0
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1CEF9	; Jump

loc_1CEC0:		; CODE XREF: sub_1CE9E:loc_1CEBAj
mov	ax, [bp+arg_6]
imul	bx		; Signed Multiply
mov	[bp+var_2], ax
mov	ax, [bp+arg_8]
sub	ax, bx		; Integer Subtraction
dec	ax		; Decrement by 1

loc_1CECE:		; Signed Multiply
imul	[bp+arg_6]
mov	[bp+var_4], ax
cmp	[bp+var_4], 0	; Compare Two Operands
jz	short loc_1CEF9	; Jump if Zero (ZF=1)
push	ds
push	es
push	si
push	di
mov	di, [bp+var_2]
add	di, [bp+arg_2]	; Add

loc_1CEE4:
mov	si, di
add	si, [bp+arg_6]	; Add

loc_1CEE9:
mov	cx, [bp+var_4]
mov	ax, [bp+arg_4]
mov	es, ax

loc_1CEF1:
mov	ds, ax
rep movsb		; Move Byte(s) from String to String
pop	di
pop	si
pop	es
pop	ds

loc_1CEF9:		; CODE XREF: sub_1CE9E+20j
			; sub_1CE9E+3Aj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1CE9E



; Attributes: bp-based frame

proc sub_1CEFF far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	si
push	di
cmp	[bp+arg_8], 0	; Compare Two Operands
jnz	short loc_1CF0E	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1CF4A	; Jump

loc_1CF0E:		; CODE XREF: sub_1CEFF+9j
cmp	[bp+arg_2], 0	; Compare Two Operands
jnz	short loc_1CF19	; Jump if Not Zero (ZF=0)
mov	ax, ds

loc_1CF16:
mov	[bp+arg_2], ax

loc_1CF19:		; CODE XREF: sub_1CEFF+13j
cmp	[bp+arg_6], 0	; Compare Two Operands

loc_1CF1D:		; Jump if Not Zero (ZF=0)
jnz	short loc_1CF24

loc_1CF1F:
mov	ax, ds

loc_1CF21:
mov	[bp+arg_6], ax

loc_1CF24:		; CODE XREF: sub_1CEFF:loc_1CF1Dj
push	ds
push	es
push	si
push	di
mov	di, [bp+arg_0]

loc_1CF2B:
mov	si, [bp+arg_4]

loc_1CF2E:
mov	cx, [bp+arg_8]
mov	bx, [bp+arg_6]
mov	ax, [bp+arg_2]
mov	es, ax
mov	ds, bx

loc_1CF3B:		; CODE XREF: sub_1CEFF+45j
lodsb			; Load String
cmp	[es:di], al	; Compare Two Operands

loc_1CF3F:		; Jump if Below	(CF=1)
jb	short loc_1CF43
stosb			; Store	String
dec	di		; Decrement by 1

loc_1CF43:		; CODE XREF: sub_1CEFF:loc_1CF3Fj
inc	di		; Increment by 1
loop	loc_1CF3B	; Loop while CX	!= 0

loc_1CF46:
pop	di
pop	si
pop	es
pop	ds

loc_1CF4A:		; CODE XREF: sub_1CEFF+Dj
pop	di
pop	si

loc_1CF4C:
pop	bp
retf			; Return Far from Procedure
endp sub_1CEFF



; Attributes: bp-based frame

proc sub_1CF4E far	; CODE XREF: ST_LoadSaveGamByNbr+3D3P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
cmp	[bp+arg_4], 0	; Compare Two Operands
jnz	short loc_1CF5D	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1CF81	; Jump

loc_1CF5D:		; CODE XREF: sub_1CF4E+9j
cmp	[bp+arg_2], 0	; Compare Two Operands
jnz	short loc_1CF68	; Jump if Not Zero (ZF=0)
mov	ax, ds
mov	[bp+arg_2], ax

loc_1CF68:		; CODE XREF: sub_1CF4E+13j
push	ds
push	es
push	si
push	di
mov	di, [bp+arg_0]
mov	cx, [bp+arg_4]
mov	ax, [bp+arg_2]
mov	es, ax
mov	ds, ax
mov	al, 0
rep stosb		; Store	String
pop	di
pop	si
pop	es
pop	ds

loc_1CF81:		; CODE XREF: sub_1CF4E+Dj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1CF4E



; Attributes: bp-based frame

proc sub_1CF85 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	si
push	di

loc_1CF8A:		; Compare Two Operands
cmp	[bp+arg_4], 0
jnz	short loc_1CF94	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1CFB9	; Jump

loc_1CF94:		; CODE XREF: sub_1CF85+9j
cmp	[bp+arg_2], 0	; Compare Two Operands

loc_1CF98:		; Jump if Not Zero (ZF=0)
jnz	short loc_1CF9F

loc_1CF9A:
mov	ax, ds
mov	[bp+arg_2], ax

loc_1CF9F:		; CODE XREF: sub_1CF85:loc_1CF98j
push	ds
push	es

loc_1CFA1:
push	si
push	di
mov	di, [bp+arg_0]
mov	cx, [bp+arg_4]
mov	ax, [bp+arg_6]
mov	bx, [bp+arg_2]
mov	es, bx
mov	ds, bx
rep stosb		; Store	String
pop	di
pop	si
pop	es
pop	ds

loc_1CFB9:		; CODE XREF: sub_1CF85+Dj
pop	di

loc_1CFBA:
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1CF85



; Attributes: bp-based frame

proc sub_1CFBD far	; CODE XREF: sub_1BFF7+15P
			; sub_1EF3C+52P
			; sub_1EF3C:loc_1EF9DP
			; idk_VidLib_s1FBBF+E9P
			; idk_VidLib_s1FBBF+106P
			; idk_VidLib_s1FBBF:loc_1FCE2P
			; idk_VidLib_s1FBBF:loc_1FD42P
			; idk_VidLib_s1FBBF+192P
			; idk_VidLib_s1FBBF:loc_1FD60P
			; sub_4F44D+64P
			; sub_4F44D+7BP
			; sub_4F44D+92P
			; sub_4F44D+A9P
			; sub_4F44D+1DAP
			; sub_4F44D+1F1P
			; sub_4F44D+2A0P
			; sub_4F44D+2B7P
			; sub_4F808+52P
			; sub_4F808+61P
			; sub_4F808+70P

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
mov	ax, [si]
mov	[bp+var_2], ax
mov	ax, [di]
mov	[si], ax
mov	ax, [bp+var_2]
mov	[di], ax
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1CFBD



; Attributes: bp-based frame

proc sub_1CFDF far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
mov	ax, [bp+arg_0]
cmp	ax, [bp+arg_2]	; Compare Two Operands
jnz	short loc_1CFF0	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1D00E	; Jump

loc_1CFF0:		; CODE XREF: sub_1CFDF+Bj
push	es
push	si
push	di

loc_1CFF3:
mov	ax, ds
mov	es, ax
assume es:dseg
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
mov	cx, [bp+arg_4]

loc_1D000:		; CODE XREF: sub_1CFDF+2Aj
mov	bl, [es:di]
movsb			; Move Byte(s) from String to String
dec	si		; Decrement by 1
mov	[es:si], bl
inc	si		; Increment by 1
loop	loc_1D000	; Loop while CX	!= 0
pop	di

loc_1D00C:
pop	si
pop	es
assume es:nothing

loc_1D00E:		; CODE XREF: sub_1CFDF+Fj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1CFDF



; Attributes: bp-based frame

; int __cdecl __far idk_Mov_Sb_Sw_or_0(int, int, int, int, int)
proc idk_Mov_Sb_Sw_or_0	far
			; CODE XREF: idk_PAL_s1C111+15P
			; sub_1C130+15P
			; sub_1C15C+2DP
			; sub_1EE71:loc_1EEABP
			; sub_1F61E+19P
			; sub_1F655:loc_1F674P
			; idk_VidLib_s1F743+32P
			; sub_1F8FD+19P
			; sub_46406+90P
			; sub_4F44D+154P
			; sub_4F44D+33BP
			; sub_50356+1DP
			; sub_50356+3FP
			; sub_503A0+1DP
			; sub_503A0+3FP
			; idk_OVR_LoadLbxHelp:loc_55CD8P
			; idk_OVR_LoadLbxHelp:loc_55CFBP
			; idk_OVR_LoadLbxHelp:loc_55D32P
			; idk_OVR_LoadLbxHelp:loc_561BBP
			; idk_OVR_LoadLbxHelp:loc_561E4P
			; idk_OVR_LoadLbxHelp+567P

arg_0_ZERO= word ptr  6
arg_ptrBuf2= word ptr  8
arg_4_ZERO= word ptr  0Ah
arg_ptrBuf1= word ptr  0Ch
arg_RepCount= word ptr	0Eh

push	bp
mov	bp, sp
push	si
push	di
cmp	[bp+arg_RepCount], 0 ; Compare Two Operands

loc_1D01B:		; Jump if Not Zero (ZF=0)
jnz	short loc_1D021

BAIL:			; Logical Exclusive OR
xor	ax, ax
jmp	short loc_1D07C	; Jump

loc_1D021:		; CODE XREF: idk_Mov_Sb_Sw_or_0:loc_1D01Bj
cmp	[bp+arg_ptrBuf2], 0 ; Compare Two Operands
jnz	short loc_1D02C	; Jump if Not Zero (ZF=0)
mov	ax, ds
mov	[bp+arg_ptrBuf2], ax

loc_1D02C:		; CODE XREF: idk_Mov_Sb_Sw_or_0+13j
cmp	[bp+arg_ptrBuf1], 0 ; Compare Two Operands
jnz	short loc_1D037	; Jump if Not Zero (ZF=0)
mov	ax, ds
mov	[bp+arg_ptrBuf1], ax

loc_1D037:		; CODE XREF: idk_Mov_Sb_Sw_or_0+1Ej
test	[bp+arg_RepCount], 1 ; Logical Compare
jz	short MOVSW	; Jump if Zero (ZF=1)

MOVSB:
push	ds
push	es
push	si
push	di
mov	ax, [bp+arg_ptrBuf2]
mov	es, ax
mov	di, [bp+arg_0_ZERO]
mov	bx, [bp+arg_ptrBuf1]
mov	si, [bp+arg_4_ZERO]
mov	cx, [bp+arg_RepCount]
mov	ds, bx
rep movsb		; Move Byte(s) from String to String
pop	di
pop	si
pop	es
pop	ds
jmp	short loc_1D07C	; Jump

MOVSW:			; CODE XREF: idk_Mov_Sb_Sw_or_0+2Aj
push	ds
push	es
push	si
push	di
mov	ax, [bp+arg_ptrBuf2]
mov	es, ax
mov	di, [bp+arg_0_ZERO]
mov	bx, [bp+arg_ptrBuf1]
mov	si, [bp+arg_4_ZERO]
mov	cx, [bp+arg_RepCount]
shr	cx, 1		; Shift	Logical	Right
mov	ds, bx
rep movsw		; Move Byte(s) from String to String
pop	di
pop	si
pop	es
pop	ds

loc_1D07C:		; CODE XREF: idk_Mov_Sb_Sw_or_0+Dj
			; idk_Mov_Sb_Sw_or_0+49j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_Mov_Sb_Sw_or_0



; Attributes: bp-based frame

proc sub_1D080 far

arg_0= word ptr	 6
arg_2= dword ptr  8

push	bp
mov	bp, sp
mov	dx, [bp+arg_0]
mov	ax, dx
mov	cl, 3
sar	ax, cl		; Shift	Arithmetic Right

loc_1D08C:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_2]
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	bx, dx
and	bx, 7		; Logical AND
shl	bx, 1		; Shift	Logical	Left
test	[bx+4322h], ax	; Logical Compare
jz	short loc_1D0A7	; Jump if Zero (ZF=1)
mov	ax, 1

loc_1D0A5:		; CODE XREF: sub_1D080+29j
jmp	short loc_1D0AB	; Jump

loc_1D0A7:		; CODE XREF: sub_1D080+20j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1D0A5	; Jump

loc_1D0AB:		; CODE XREF: sub_1D080:loc_1D0A5j
pop	bp
retf			; Return Far from Procedure
endp sub_1D080



; Attributes: bp-based frame

proc sub_1D0AD far

arg_0= word ptr	 6
arg_2= dword ptr  8

push	bp
mov	bp, sp
push	si
mov	dx, [bp+arg_0]
mov	ax, dx
mov	cl, 3
sar	ax, cl		; Shift	Arithmetic Right
mov	si, ax
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	al, [es:bx]
mov	bx, dx
and	bx, 7		; Logical AND
shl	bx, 1		; Shift	Logical	Left
or	al, [bx+4322h]	; Logical Inclusive OR
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	[es:bx], al
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1D0AD



; Attributes: bp-based frame

proc sub_1D0DA far

arg_0= word ptr	 6
arg_2= dword ptr  8

push	bp
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]
mov	ax, si
mov	cl, 3
sar	ax, cl		; Shift	Arithmetic Right
mov	di, ax
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
mov	bx, si

loc_1D0F4:		; Logical AND
and	bx, 7
shl	bx, 1		; Shift	Logical	Left
mov	dl, 0FFh

loc_1D0FB:		; Integer Subtraction
sub	dl, [bx+4322h]
and	al, dl		; Logical AND
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	[es:bx], al
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1D0DA



; Attributes: bp-based frame

proc sub_1D10D far

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	si

loc_1D115:
mov	si, [bp+arg_2]
mov	ax, [bp+arg_0]
mov	cx, ax
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
add	si, ax		; Add

loc_1D125:		; Logical AND
db 81h,0E1h,7,0	; <BAD>and     cx, 7
lodsb			; Load String
cmp	cx, 0		; Compare Two Operands
jz	short loc_1D133	; Jump if Zero (ZF=1)

loc_1D12F:		; CODE XREF: sub_1D10D+24j
shr	al, 1		; Shift	Logical	Right
loop	loc_1D12F	; Loop while CX	!= 0

loc_1D133:		; CODE XREF: sub_1D10D+20j
and	ax, 1		; Logical AND
mov	[bp+var_2], ax
pop	si
mov	ax, [bp+var_2]
jmp	short $+2	; Jump
pop	si

loc_1D140:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1D10D



; Attributes: bp-based frame

proc sub_1D144 far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_1D145:
mov	bp, sp
mov	bx, [bp+arg_2]
mov	ax, [bp+arg_0]
mov	cx, ax
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
add	bx, ax		; Add
db 81h,0E1h,7,0	; <BAD>and     cx, 7 ; Logical AND

loc_1D15B:
mov	al, 1
cmp	cx, 0		; Compare Two Operands
jz	short loc_1D166	; Jump if Zero (ZF=1)

loc_1D162:		; CODE XREF: sub_1D144+20j
shl	al, 1		; Shift	Logical	Left
loop	loc_1D162	; Loop while CX	!= 0

loc_1D166:		; CODE XREF: sub_1D144+1Cj
mov	cl, [bx]

loc_1D168:		; Logical Inclusive OR
or	al, cl

loc_1D16A:
mov	[bx], al
pop	bp
retf			; Return Far from Procedure
endp sub_1D144



; Attributes: bp-based frame

proc sub_1D16E far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
mov	bx, [bp+arg_2]

loc_1D174:
mov	ax, [bp+arg_0]

loc_1D177:
mov	cx, ax
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
shr	ax, 1		; Shift	Logical	Right
add	bx, ax		; Add

loc_1D181:		; Logical AND
db 81h,0E1h,7,0	; <BAD>and     cx, 7
mov	al, 1
cmp	cx, 0		; Compare Two Operands
jz	short loc_1D190	; Jump if Zero (ZF=1)

loc_1D18C:		; CODE XREF: sub_1D16E+20j
shl	al, 1		; Shift	Logical	Left
loop	loc_1D18C	; Loop while CX	!= 0

loc_1D190:		; CODE XREF: sub_1D16E+1Cj
mov	cl, [bx]
xor	al, cl		; Logical Exclusive OR
mov	[bx], al
pop	bp
retf			; Return Far from Procedure
endp sub_1D16E



; Attributes: bp-based frame

proc sub_1D198 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	[word_36048], ax
mov	ax, [bp+arg_0]
mov	[word_36042], ax
mov	ax, [bp+arg_2]

loc_1D1AA:
mov	[word_36044], ax
mov	ax, [bp+arg_6]
mov	[word_36046], ax
pop	bp
retf			; Return Far from Procedure
endp sub_1D198



; Attributes: bp-based frame

proc sub_1D1B5 far

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di

loc_1D1BD:
mov	di, [bp+arg_2]

loc_1D1C0:
mov	[bp+var_2], 0
mov	[bp+var_A], 0FC18h

loc_1D1CA:
mov	[bp+var_4], 0FC18h
mov	[bp+var_6], 0FC18h

loc_1D1D4:
mov	[bp+var_8], 0FC18h
call	sub_2E257	; Call Procedure
jmp	loc_1D3FE	; Jump

loc_1D1E1:		; CODE XREF: sub_1D1B5+24Fj
call	sub_2B97A	; Call Procedure
mov	si, ax

loc_1D1E8:		; Compare Two Operands
cmp	si, [bp+var_A]
jz	short loc_1D1F2	; Jump if Zero (ZF=1)
db 83h,0FEh,0FFh ; <BAD>cmp	si, 0FFFFh ; Compare Two Operands
jnz	short loc_1D1F8	; Jump if Not Zero (ZF=0)

loc_1D1F2:		; CODE XREF: sub_1D1B5+36j
mov	ax, [bp+arg_8]

loc_1D1F5:		; CODE XREF: sub_1D1B5:loc_1D200j
			; sub_1D1B5+55j
			; sub_1D1B5+5Fj
jmp	loc_1D407	; Jump

loc_1D1F8:		; CODE XREF: sub_1D1B5+3Bj
cmp	si, [bp+var_4]	; Compare Two Operands

loc_1D1FB:		; Jump if Not Zero (ZF=0)
jnz	short loc_1D202
mov	ax, [bp+arg_A]

loc_1D200:		; Jump
jmp	short loc_1D1F5

loc_1D202:		; CODE XREF: sub_1D1B5:loc_1D1FBj
cmp	si, [bp+var_6]	; Compare Two Operands
jnz	short loc_1D20C	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_C]
jmp	short loc_1D1F5	; Jump

loc_1D20C:		; CODE XREF: sub_1D1B5+50j
cmp	si, [bp+var_8]	; Compare Two Operands

loc_1D20F:		; Jump if Not Zero (ZF=0)
jnz	short loc_1D216
mov	ax, [bp+arg_E]
jmp	short loc_1D1F5	; Jump

loc_1D216:		; CODE XREF: sub_1D1B5:loc_1D20Fj
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure

loc_1D21B:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_1D21E:
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1D22C:		; Call Procedure
call	idk_VGA_ScData_s186BC
add	sp, 0Ah		; Add
push	[word_36042]

loc_1D238:
push	[word_36042]
push	[word_36042]

loc_1D240:
push	[word_36042]
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 5
push	ax
mov	ax, 5
push	ax

loc_1D254:		; Call Procedure
call	sub_184BE
add	sp, 10h		; Add
push	[word_36042]
push	[word_36042]
push	[word_36042]
push	[word_36042]

loc_1D26C:
mov	ax, 6Eh	; 'n'
push	ax
mov	ax, 0DCh ; ''
push	ax
mov	ax, 5Ah	; 'Z'
push	ax

loc_1D278:
mov	ax, 64h	; 'd'
push	ax

loc_1D27C:		; Call Procedure
call	sub_184BE
add	sp, 10h		; Add

loc_1D284:		; int
push	[word_36046]
push	[word_36048]	; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx

loc_1D293:		; int
push	[bp+arg_0]
mov	ax, 62h	; 'b'
push	ax		; int
mov	ax, 0A0h ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh

loc_1D2AB:		; Compare Two Operands
cmp	[byte ptr di], 0
jz	short loc_1D30C	; Jump if Zero (ZF=1)
push	[word_36042]
push	[word_36042]
push	[word_36042]

loc_1D2BC:
push	[word_36042]
mov	ax, 91h	; ''
push	ax

loc_1D2C4:
mov	ax, 0C8h ; ''
push	ax

loc_1D2C8:
mov	ax, 82h	; ''
push	ax
mov	ax, 78h	; 'x'
push	ax

loc_1D2D0:		; Call Procedure
call	sub_184BE
add	sp, 10h		; Add
push	di		; int
mov	ax, 88h	; ''
push	ax		; int
mov	ax, 0A0h ; ''
push	ax		; int

loc_1D2E1:		; Call Procedure
call	sub_196ED
add	sp, 6		; Add
mov	ax, 4345h
push	ax

loc_1D2ED:
mov	ax, 4344h

loc_1D2F0:
push	ax
mov	ax, 91h	; ''
push	ax
mov	ax, 0C8h ; ''

loc_1D2F8:
push	ax

loc_1D2F9:
mov	ax, 82h	; ''

loc_1D2FC:
push	ax

loc_1D2FD:
mov	ax, 78h	; 'x'
push	ax

loc_1D301:		; Call Procedure
call	idk_Mouse_s29A0B

loc_1D306:		; Add
add	sp, 0Ch
mov	[bp+var_4], ax

loc_1D30C:		; CODE XREF: sub_1D1B5+F9j
mov	bx, [bp+arg_4]
cmp	[byte ptr bx], 0 ; Compare Two Operands
jz	short loc_1D372	; Jump if Zero (ZF=1)
push	[word_36042]
push	[word_36042]
push	[word_36042]

loc_1D320:
push	[word_36042]

loc_1D324:
mov	ax, 0A5h ; ''
push	ax

loc_1D328:
mov	ax, 0C8h ; ''
push	ax
mov	ax, 96h	; ''
push	ax
mov	ax, 78h	; 'x'
push	ax
call	sub_184BE	; Call Procedure
add	sp, 10h		; Add
push	[bp+arg_4]	; int

loc_1D33F:
mov	ax, 9Ch	; ''
push	ax		; int
mov	ax, 0A0h ; ''
push	ax		; int

loc_1D347:		; Call Procedure
call	sub_196ED

loc_1D34C:		; Add
add	sp, 6
mov	ax, 4345h
push	ax

loc_1D353:
mov	ax, 4344h
push	ax
mov	ax, 0A5h ; ''
push	ax
mov	ax, 0C8h ; ''
push	ax

loc_1D35F:
mov	ax, 96h	; ''
push	ax
mov	ax, 78h	; 'x'
push	ax

loc_1D367:		; Call Procedure
call	idk_Mouse_s29A0B
add	sp, 0Ch		; Add
mov	[bp+var_6], ax

loc_1D372:		; CODE XREF: sub_1D1B5+15Dj
mov	bx, [bp+arg_6]

loc_1D375:		; Compare Two Operands
cmp	[byte ptr bx], 0
jz	short loc_1D3D8	; Jump if Zero (ZF=1)
push	[word_36042]

loc_1D37E:
push	[word_36042]
push	[word_36042]
push	[word_36042]
mov	ax, 0B9h ; ''
push	ax

loc_1D38E:
mov	ax, 0C8h ; ''
push	ax
mov	ax, 0AAh ; ''
push	ax

loc_1D396:
mov	ax, 78h	; 'x'
push	ax

loc_1D39A:		; Call Procedure
call	sub_184BE
add	sp, 10h		; Add

loc_1D3A2:		; int
push	[bp+arg_6]
mov	ax, 0B0h ; ''
push	ax		; int
mov	ax, 0A0h ; ''
push	ax		; int

loc_1D3AD:		; Call Procedure
call	sub_196ED
add	sp, 6		; Add
mov	ax, 4345h
push	ax
mov	ax, 4344h

loc_1D3BC:
push	ax
mov	ax, 0B9h ; ''
push	ax

loc_1D3C1:
mov	ax, 0C8h ; ''
push	ax
mov	ax, 0AAh ; ''
push	ax

loc_1D3C9:
mov	ax, 78h	; 'x'
push	ax

loc_1D3CD:		; Call Procedure
call	idk_Mouse_s29A0B

loc_1D3D2:		; Add
add	sp, 0Ch
mov	[bp+var_8], ax

loc_1D3D8:		; CODE XREF: sub_1D1B5+1C3j
mov	ax, 0FFFFh
push	ax

loc_1D3DC:
mov	ax, 4344h
push	ax

loc_1D3E0:
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1D3EB:		; Logical Exclusive OR
xor	ax, ax
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_A], ax
call	sub_2E303	; Call Procedure

loc_1D3FE:		; CODE XREF: sub_1D1B5+29j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_1D407	; Jump if Not Zero (ZF=0)
jmp	loc_1D1E1	; Jump

loc_1D407:		; CODE XREF: sub_1D1B5:loc_1D1F5j
			; sub_1D1B5+24Dj
pop	di

loc_1D408:
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1D1B5



; Attributes: bp-based frame

proc sub_1D40D far

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp

loc_1D410:		; Integer Subtraction
sub	sp, 0Ah

loc_1D413:
push	si

loc_1D414:
push	di
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh

loc_1D41A:
mov	ax, [bp+arg_6]
inc	ax		; Increment by 1
mov	si, ax
push	si

loc_1D421:
mov	ax, 0C8h ; ''
push	ax
mov	ax, 140h

loc_1D428:
push	ax
call	hrmStoreSWSB	; Call Procedure
add	sp, 6		; Add
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_1D595 ; Call Procedure
pop	cx

loc_1D440:		; Call Procedure
call	sub_1E525

loc_1D445:
push	[idk_AddrEmsHandle]
mov	ax, 7D00h
push	ax
xor	ax, ax		; Logical Exclusive OR

loc_1D44F:		; Logical Exclusive OR
xor	dx, dx
push	ax

loc_1D452:
push	dx

loc_1D453:
push	si
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1D457:		; Call Procedure
call	idk_EmsMapMem_s16337
add	sp, 0Ch		; Add

loc_1D45F:
push	[idk_AddrEmsHandle]
mov	ax, 7D00h

loc_1D466:
push	ax
xor	ax, ax		; Logical Exclusive OR

loc_1D469:
mov	dx, 7D00h
push	ax
push	dx
mov	ax, si
add	ax, 7D0h	; Add
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_EmsMapMem_s16337 ; Call Procedure

loc_1D47C:		; Add
add	sp, 0Ch

loc_1D47F:		; Logical Exclusive OR
xor	di, di
jmp	loc_1D587	; Jump

loc_1D484:		; CODE XREF: sub_1D40D+17Fj
call	_f020105_bios_timeofday	; Call Procedure
push	[idk_AddrEmsHandle] ; arg6_EmsHandle
mov	ax, 7D00h
push	ax		; arg5_ByteCount
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax		; arg4_6
push	dx		; arg3_4
push	si		; arg2_ES
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
push	[idk_AddrEmsHandle] ; arg6_EmsHandle
mov	ax, 7D00h
push	ax		; arg5_ByteCount
xor	ax, ax		; Logical Exclusive OR
mov	dx, 7D00h
push	ax		; arg4_6
push	dx		; arg3_4

loc_1D4B2:
mov	ax, si
add	ax, 7D0h	; Add
push	ax		; arg2_ES
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure

loc_1D4C0:		; Add
add	sp, 0Ch
mov	ax, di
inc	ax		; Increment by 1
imul	[bp+arg_0]	; Signed Multiply
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+arg_4]	; Signed Divide
mov	dx, [bp+arg_0]
sub	dx, ax		; Integer Subtraction
mov	[bp+var_2], dx
mov	ax, di
inc	ax		; Increment by 1
imul	[bp+arg_2]	; Signed Multiply
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+arg_4]	; Signed Divide
mov	dx, [bp+arg_2]
sub	dx, ax		; Integer Subtraction

loc_1D4E4:
mov	[bp+var_4], dx
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 64h	; 'd'
imul	dx		; Signed Multiply
cwd			; AX ->	DX:AX (with sign)

loc_1D4F0:		; Signed Divide
idiv	[bp+arg_4]
mov	[bp+var_A], ax

loc_1D4F6:
mov	ax, [bp+var_A]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+var_2]	; Add
mov	[bp+var_6], ax
mov	ax, [bp+var_A]
shl	ax, 1		; Shift	Logical	Left

loc_1D50E:		; Add
add	ax, [bp+var_4]
mov	[bp+var_8], ax

loc_1D514:		; Compare Two Operands
cmp	[bp+var_6], 140h
jle	short loc_1D530	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_A]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 140h
sub	dx, ax		; Integer Subtraction

loc_1D52D:
mov	[bp+var_2], dx

loc_1D530:		; CODE XREF: sub_1D40D+10Cj
cmp	[bp+var_8], 0C8h ; '' ; Compare Two Operands
jle	short loc_1D544	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_A]
shl	ax, 1		; Shift	Logical	Left
mov	dx, 0C8h ; ''
sub	dx, ax		; Integer Subtraction
mov	[bp+var_4], dx

loc_1D544:		; CODE XREF: sub_1D40D+128j
push	[bp+var_A]
push	[bp+var_A]
push	si
call	sub_21829	; Call Procedure
add	sp, 6		; Add

loc_1D553:
mov	ax, 1
push	ax

loc_1D557:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_1D55A:
push	si
call	sub_23129	; Call Procedure
add	sp, 6		; Add
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
push	si

loc_1D569:
push	[bp+var_4]
push	[bp+var_2]

loc_1D56F:		; Call Procedure
call	sub_21014
add	sp, 6		; Add

loc_1D577:		; Call Procedure
call	sub_2E303

loc_1D57C:
mov	ax, 1

loc_1D57F:
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_1D586:		; Increment by 1
inc	di

loc_1D587:		; CODE XREF: sub_1D40D+74j
cmp	di, [bp+arg_4]	; Compare Two Operands
jge	short loc_1D58F	; Jump if Greater or Equal (SF=OF)
jmp	loc_1D484	; Jump

loc_1D58F:		; CODE XREF: sub_1D40D+17Dj
pop	di
pop	si

loc_1D591:
mov	sp, bp
pop	bp

locret_1D594:		; Return Far from Procedure
retf
endp sub_1D40D



; Attributes: bp-based frame

proc sub_1D595 far	; CODE XREF: sub_1D40D+2Fp

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di
push	ds
push	es
push	si
push	di

loc_1D59E:
mov	ax, [bp+arg_0]
mov	es, ax
mov	ax, [g_ptrVideoRamBuffer]

loc_1D5A6:
mov	ds, ax
mov	bx, 140h

loc_1D5AB:
mov	ah, 0

loc_1D5AD:
mov	si, 0
mov	di, 0

loc_1D5B3:		; CODE XREF: sub_1D595:loc_1D5D4j
push	si

loc_1D5B4:
mov	al, 4

loc_1D5B6:
mov	dx, GC_INDEX
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.

loc_1D5BA:		; Increment by 1
inc	dx

loc_1D5BB:
mov	al, ah
out	dx, al		; EGA port: graphics controller	data register

loc_1D5BE:
mov	cx, 0C8h ; ''

loc_1D5C1:		; CODE XREF: sub_1D595:loc_1D5C6j
lodsb			; Load String

loc_1D5C2:		; Store	String
stosb

loc_1D5C3:		; Add
add	si, 4Fh	; 'O'

loc_1D5C6:		; Loop while CX	!= 0
loop	loc_1D5C1

loc_1D5C8:
pop	si

loc_1D5C9:		; Increment by 1
inc	ah

loc_1D5CB:		; Compare Two Operands
cmp	ah, 4

loc_1D5CE:		; Jump if Sign (SF=1)
js	short loc_1D5D3

loc_1D5D0:
mov	ah, 0

loc_1D5D2:		; Increment by 1
inc	si

loc_1D5D3:		; CODE XREF: sub_1D595:loc_1D5CEj
dec	bx		; Decrement by 1

loc_1D5D4:		; Jump if Not Zero (ZF=0)
jnz	short loc_1D5B3

loc_1D5D6:
pop	di

loc_1D5D7:
pop	si

loc_1D5D8:
pop	es

loc_1D5D9:
pop	ds

loc_1D5DA:
pop	di

loc_1D5DB:
pop	si

loc_1D5DC:
pop	bp

locret_1D5DD:		; Return Far from Procedure
retf
endp sub_1D595

ends seg022


; Segment type:	Pure code
segment	seg023 byte public 'CODE' use16
assume cs:seg023
;org 0Eh
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_1D5DE far

var_6= word ptr	-6
var_4= word ptr	-4
x= word	ptr -2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp

loc_1D5DF:
mov	bp, sp

loc_1D5E1:		; Integer Subtraction
sub	sp, 6

loc_1D5E4:
push	si
push	di

loc_1D5E6:
mov	si, [bp+arg_0]

loc_1D5E9:
mov	di, [bp+arg_2]

loc_1D5EC:		; Compare Two Operands
cmp	[bp+arg_8], 0

loc_1D5F0:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_1D600

loc_1D5F2:
mov	ax, [si]

loc_1D5F4:		; Compare Two Operands
cmp	ax, [bp+arg_4]

loc_1D5F7:		; Jump if Not Zero (ZF=0)
jnz	short loc_1D605
mov	ax, [di]

loc_1D5FB:		; Compare Two Operands
cmp	ax, [bp+arg_6]

loc_1D5FE:		; Jump if Not Zero (ZF=0)
jnz	short loc_1D605

loc_1D600:		; CODE XREF: sub_1D5DE:loc_1D5F0j
xor	ax, ax		; Logical Exclusive OR

loc_1D602:		; Jump
jmp	loc_1D6D3

loc_1D605:		; CODE XREF: sub_1D5DE:loc_1D5F7j
			; sub_1D5DE:loc_1D5FEj
mov	ax, [bp+arg_4]
sub	ax, [si]	; Integer Subtraction

loc_1D60A:
mov	[bp+x],	ax

loc_1D60D:
mov	ax, [bp+arg_6]

loc_1D610:		; Integer Subtraction
sub	ax, [di]

loc_1D612:
mov	[bp+var_4], ax

loc_1D615:		; x
push	[bp+x]
call	_abs		; Call Procedure
pop	cx

loc_1D61E:		; Compare Two Operands
cmp	ax, 0FFh

loc_1D621:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_1D631
push	[bp+var_4]	; x

loc_1D626:		; Call Procedure
call	_abs
pop	cx

loc_1D62C:		; Compare Two Operands
cmp	ax, 0FFh

loc_1D62F:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_1D645

loc_1D631:		; CODE XREF: sub_1D5DE:loc_1D621j
mov	ax, [bp+var_4]

loc_1D634:		; AX ->	DX:AX (with sign)
cwd

loc_1D635:		; Integer Subtraction
sub	ax, dx

loc_1D637:		; Shift	Arithmetic Right
sar	ax, 1

loc_1D639:
push	ax

loc_1D63A:
mov	ax, [bp+x]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction

loc_1D640:		; Shift	Arithmetic Right
sar	ax, 1

loc_1D642:
push	ax

loc_1D643:		; Jump
jmp	short loc_1D64B

loc_1D645:		; CODE XREF: sub_1D5DE:loc_1D62Fj
push	[bp+var_4]

loc_1D648:
push	[bp+x]

loc_1D64B:		; CODE XREF: sub_1D5DE:loc_1D643j
call	sub_23937	; Call Procedure

loc_1D650:
pop	cx
pop	cx
mov	[bp+var_6], ax
mov	ax, [si]

loc_1D657:		; Compare Two Operands
cmp	ax, [bp+arg_4]

loc_1D65A:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1D679

loc_1D65C:
push	[bp+arg_8]

loc_1D65F:
push	[bp+var_6]

loc_1D662:		; Call Procedure
call	sub_23A3D
pop	cx
pop	cx

loc_1D669:		; Add
add	[si], ax
mov	ax, [si]

loc_1D66D:		; Compare Two Operands
cmp	ax, [bp+arg_4]

loc_1D670:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_1D677

loc_1D672:
mov	ax, [bp+arg_4]
mov	[si], ax

loc_1D677:		; CODE XREF: sub_1D5DE:loc_1D670j
jmp	short loc_1D694	; Jump

loc_1D679:		; CODE XREF: sub_1D5DE:loc_1D65Aj
push	[bp+arg_8]

loc_1D67C:
push	[bp+var_6]

loc_1D67F:		; Call Procedure
call	sub_23A3D

loc_1D684:
pop	cx

loc_1D685:
pop	cx
add	[si], ax	; Add

loc_1D688:
mov	ax, [si]

loc_1D68A:		; Compare Two Operands
cmp	ax, [bp+arg_4]
jge	short loc_1D694	; Jump if Greater or Equal (SF=OF)

loc_1D68F:
mov	ax, [bp+arg_4]
mov	[si], ax

loc_1D694:		; CODE XREF: sub_1D5DE:loc_1D677j
			; sub_1D5DE+AFj
mov	ax, [di]

loc_1D696:		; Compare Two Operands
cmp	ax, [bp+arg_6]
jge	short loc_1D6B8	; Jump if Greater or Equal (SF=OF)

loc_1D69B:
push	[bp+arg_8]

loc_1D69E:
push	[bp+var_6]
call	sub_23ACB	; Call Procedure

loc_1D6A6:
pop	cx

loc_1D6A7:
pop	cx
add	[di], ax	; Add
mov	ax, [di]
cmp	ax, [bp+arg_6]	; Compare Two Operands

loc_1D6AF:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_1D6B6

loc_1D6B1:
mov	ax, [bp+arg_6]

loc_1D6B4:
mov	[di], ax

loc_1D6B6:		; CODE XREF: sub_1D5DE:loc_1D6AFj
jmp	short loc_1D6D3	; Jump

loc_1D6B8:		; CODE XREF: sub_1D5DE+BBj
push	[bp+arg_8]

loc_1D6BB:
push	[bp+var_6]

loc_1D6BE:		; Call Procedure
call	sub_23ACB
pop	cx

loc_1D6C4:
pop	cx

loc_1D6C5:		; Add
add	[di], ax

loc_1D6C7:
mov	ax, [di]

loc_1D6C9:		; Compare Two Operands
cmp	ax, [bp+arg_6]

loc_1D6CC:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1D6D3

loc_1D6CE:
mov	ax, [bp+arg_6]
mov	[di], ax

loc_1D6D3:		; CODE XREF: sub_1D5DE:loc_1D602j
			; sub_1D5DE:loc_1D6B6j
			; sub_1D5DE:loc_1D6CCj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1D5DE



; Attributes: bp-based frame

proc sub_1D6D9 far	; CODE XREF: sub_43E4F+1AEP
			; sub_4A942+1D4P
			; sub_4A942+297P
			; sub_4A942+2DCP
			; sub_4A942+33AP
			; sub_4BA53+165P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	si
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
mov	bx, ax
mov	ax, [bp+arg_6]

loc_1D6E8:		; Integer Subtraction
sub	ax, [bp+arg_2]

loc_1D6EB:
mov	cx, ax
or	bx, bx		; Logical Inclusive OR
jge	short loc_1D6F7	; Jump if Greater or Equal (SF=OF)

loc_1D6F1:
mov	ax, bx

loc_1D6F3:		; Two's Complement Negation
neg	ax

loc_1D6F5:
mov	bx, ax

loc_1D6F7:		; CODE XREF: sub_1D6D9+16j
or	cx, cx		; Logical Inclusive OR

loc_1D6F9:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1D701
mov	ax, cx
neg	ax		; Two's Complement Negation
mov	cx, ax

loc_1D701:		; CODE XREF: sub_1D6D9:loc_1D6F9j
cmp	bx, cx		; Compare Two Operands
jle	short loc_1D710	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, cx
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, bx

loc_1D70E:		; Jump
jmp	short loc_1D719

loc_1D710:		; CODE XREF: sub_1D6D9+2Aj
mov	ax, bx
cwd			; AX ->	DX:AX (with sign)

loc_1D713:		; Integer Subtraction
sub	ax, dx
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, cx

loc_1D719:		; CODE XREF: sub_1D6D9:loc_1D70Ej
add	dx, ax		; Add
mov	si, dx
mov	ax, si

loc_1D71F:		; Jump
jmp	short $+2
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1D6D9



; Attributes: bp-based frame

proc sub_1D724 far	; CODE XREF: sub_43C95+BEP
			; sub_43C95+106P
			; sub_43E4F+FEP
			; sub_43E4F+160P
			; sub_43E4F+219P
			; sub_45645+111P
			; sub_45645+396P
			; sub_46406+21BP
			; sub_46406+30FP
			; sub_4A942+238P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	si

loc_1D728:
push	di

loc_1D729:
mov	si, [bp+arg_0]

loc_1D72C:
mov	di, [bp+arg_4]

loc_1D72F:
mov	ax, di
sub	ax, si		; Integer Subtraction
mov	dx, ax

loc_1D735:
mov	ax, [bp+arg_6]

loc_1D738:		; Integer Subtraction
sub	ax, [bp+arg_2]
mov	cx, ax
or	dx, dx		; Logical Inclusive OR

loc_1D73F:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1D747
mov	ax, dx
neg	ax		; Two's Complement Negation

loc_1D745:
mov	dx, ax

loc_1D747:		; CODE XREF: sub_1D724:loc_1D73Fj
or	cx, cx		; Logical Inclusive OR
jge	short loc_1D751	; Jump if Greater or Equal (SF=OF)
mov	ax, cx
neg	ax		; Two's Complement Negation

loc_1D74F:
mov	cx, ax

loc_1D751:		; CODE XREF: sub_1D724+25j
cmp	di, si		; Compare Two Operands
jge	short loc_1D75C	; Jump if Greater or Equal (SF=OF)

loc_1D755:
mov	ax, di
add	ax, [bp+arg_8]	; Add
jmp	short loc_1D761	; Jump

loc_1D75C:		; CODE XREF: sub_1D724+2Fj
mov	ax, di

loc_1D75E:		; Integer Subtraction
sub	ax, [bp+arg_8]

loc_1D761:		; CODE XREF: sub_1D724+36j
sub	ax, si		; Integer Subtraction

loc_1D763:
mov	bx, ax

loc_1D765:		; Logical Inclusive OR
or	bx, bx
jge	short loc_1D76F	; Jump if Greater or Equal (SF=OF)
mov	ax, bx
neg	ax		; Two's Complement Negation

loc_1D76D:
mov	bx, ax

loc_1D76F:		; CODE XREF: sub_1D724+43j
cmp	dx, bx		; Compare Two Operands
jle	short loc_1D775	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	dx, bx

loc_1D775:		; CODE XREF: sub_1D724+4Dj
cmp	dx, cx		; Compare Two Operands
jle	short loc_1D77D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, dx

loc_1D77B:		; CODE XREF: sub_1D724:loc_1D77Fj
jmp	short loc_1D781	; Jump

loc_1D77D:		; CODE XREF: sub_1D724+53j
mov	ax, cx

loc_1D77F:		; Jump
jmp	short loc_1D77B

loc_1D781:		; CODE XREF: sub_1D724:loc_1D77Bj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1D724



; Attributes: bp-based frame

proc sub_1D785 far

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
push	si
push	di

loc_1D78D:
mov	si, [bp+arg_8]
mov	di, [bp+arg_A]
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
mov	[bp+var_2], ax
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_2]	; Integer Subtraction

loc_1D7A2:
mov	[bp+var_4], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jge	short loc_1D7BA	; Jump if Greater or Equal (SF=OF)

loc_1D7AB:
mov	ax, [bp+var_2]
neg	ax		; Two's Complement Negation
mov	[bp+var_2], ax

loc_1D7B3:
mov	[bp+var_6], 0FFFFh
jmp	short loc_1D7BF	; Jump

loc_1D7BA:		; CODE XREF: sub_1D785+24j
mov	[bp+var_6], 1

loc_1D7BF:		; CODE XREF: sub_1D785+33j
cmp	[bp+var_4], 0	; Compare Two Operands
jge	short loc_1D7D4	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_4]
neg	ax		; Two's Complement Negation

loc_1D7CA:
mov	[bp+var_4], ax

loc_1D7CD:
mov	[bp+var_8], 0FFFFh
jmp	short loc_1D7D9	; Jump

loc_1D7D4:		; CODE XREF: sub_1D785+3Ej
mov	[bp+var_8], 1

loc_1D7D9:		; CODE XREF: sub_1D785+4Dj
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+arg_0]
mov	[bp+var_A], ax
mov	ax, [bp+arg_2]

loc_1D7E4:
mov	[bp+var_C], ax
mov	ax, [bp+var_2]
cmp	ax, [bp+var_4]	; Compare Two Operands
jge	short loc_1D861	; Jump if Greater or Equal (SF=OF)

loc_1D7EF:
mov	[bp+var_10], 8000h
mov	dx, [bp+var_2]
mov	ax, 0

loc_1D7FA:
mov	bx, [bp+var_4]
div	bx		; Unsigned Divide
mov	[bp+var_E], ax
cmp	[bp+var_6], 1	; Compare Two Operands
jnz	short loc_1D834	; Jump if Not Zero (ZF=0)
jmp	short loc_1D82D	; Jump

loc_1D80A:		; CODE XREF: sub_1D785+ABj
mov	ax, [bp+var_8]
add	[bp+var_C], ax	; Add
mov	ax, [bp+var_10]
add	ax, [bp+var_E]	; Add

loc_1D816:		; Jump if Not Below (CF=0)
jnb	short loc_1D81B
inc	[bp+var_A]	; Increment by 1

loc_1D81B:		; CODE XREF: sub_1D785:loc_1D816j
mov	[bp+var_10], ax
mov	bx, cx
mov	al, [byte ptr bp+var_A]
mov	[bx+si], al
mov	bx, cx
mov	al, [byte ptr bp+var_C]
mov	[bx+di], al

loc_1D82C:		; Increment by 1
inc	cx

loc_1D82D:		; CODE XREF: sub_1D785+83j
cmp	cx, [bp+var_4]	; Compare Two Operands
jl	short loc_1D80A	; Jump if Less (SF!=OF)
jmp	short loc_1D85E	; Jump

loc_1D834:		; CODE XREF: sub_1D785+81j
jmp	short loc_1D859	; Jump

loc_1D836:		; CODE XREF: sub_1D785:loc_1D85Cj
mov	ax, [bp+var_8]
add	[bp+var_C], ax	; Add
mov	ax, [bp+var_10]

loc_1D83F:		; Add
add	ax, [bp+var_E]
jnb	short loc_1D847	; Jump if Not Below (CF=0)
dec	[bp+var_A]	; Decrement by 1

loc_1D847:		; CODE XREF: sub_1D785+BDj
mov	[bp+var_10], ax
mov	bx, cx

loc_1D84C:
mov	al, [byte ptr bp+var_A]
mov	[bx+si], al
mov	bx, cx
mov	al, [byte ptr bp+var_C]
mov	[bx+di], al
inc	cx		; Increment by 1

loc_1D859:		; CODE XREF: sub_1D785:loc_1D834j
cmp	cx, [bp+var_4]	; Compare Two Operands

loc_1D85C:		; Jump if Less (SF!=OF)
jl	short loc_1D836

loc_1D85E:		; CODE XREF: sub_1D785+ADj
jmp	loc_1D8FC	; Jump

loc_1D861:		; CODE XREF: sub_1D785+68j
mov	ax, [bp+var_4]
cmp	ax, [bp+var_2]	; Compare Two Operands
jge	short loc_1D8DA	; Jump if Greater or Equal (SF=OF)

loc_1D869:
mov	[bp+var_10], 8000h

loc_1D86E:
mov	dx, [bp+var_4]
mov	ax, 0
mov	bx, [bp+var_2]
div	bx		; Unsigned Divide
mov	[bp+var_E], ax
cmp	[bp+var_8], 1	; Compare Two Operands

loc_1D880:		; Jump if Not Zero (ZF=0)
jnz	short loc_1D8AE
jmp	short loc_1D8A7	; Jump

loc_1D884:		; CODE XREF: sub_1D785:loc_1D8AAj
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	ax, [bp+var_10]

loc_1D88D:		; Add
add	ax, [bp+var_E]
jnb	short loc_1D895	; Jump if Not Below (CF=0)
inc	[bp+var_C]	; Increment by 1

loc_1D895:		; CODE XREF: sub_1D785+10Bj
mov	[bp+var_10], ax
mov	bx, cx

loc_1D89A:
mov	al, [byte ptr bp+var_A]

loc_1D89D:
mov	[bx+si], al

loc_1D89F:
mov	bx, cx
mov	al, [byte ptr bp+var_C]
mov	[bx+di], al
inc	cx		; Increment by 1

loc_1D8A7:		; CODE XREF: sub_1D785+FDj
cmp	cx, [bp+var_2]	; Compare Two Operands

loc_1D8AA:		; Jump if Less (SF!=OF)
jl	short loc_1D884
jmp	short loc_1D8D8	; Jump

loc_1D8AE:		; CODE XREF: sub_1D785:loc_1D880j
jmp	short loc_1D8D3	; Jump

loc_1D8B0:		; CODE XREF: sub_1D785:loc_1D8D6j
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	ax, [bp+var_10]

loc_1D8B9:		; Add
add	ax, [bp+var_E]
jnb	short loc_1D8C1	; Jump if Not Below (CF=0)

loc_1D8BE:		; Decrement by 1
dec	[bp+var_C]

loc_1D8C1:		; CODE XREF: sub_1D785+137j
mov	[bp+var_10], ax
mov	bx, cx
mov	al, [byte ptr bp+var_A]
mov	[bx+si], al
mov	bx, cx
mov	al, [byte ptr bp+var_C]

loc_1D8D0:
mov	[bx+di], al

loc_1D8D2:		; Increment by 1
inc	cx

loc_1D8D3:		; CODE XREF: sub_1D785:loc_1D8AEj
cmp	cx, [bp+var_2]	; Compare Two Operands

loc_1D8D6:		; Jump if Less (SF!=OF)
jl	short loc_1D8B0

loc_1D8D8:		; CODE XREF: sub_1D785+127j
jmp	short loc_1D8FC	; Jump

loc_1D8DA:		; CODE XREF: sub_1D785+E2j
jmp	short loc_1D8F7	; Jump

loc_1D8DC:		; CODE XREF: sub_1D785:loc_1D8FAj
mov	ax, [bp+var_8]
add	[bp+var_C], ax	; Add
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	bx, cx
mov	al, [byte ptr bp+var_A]
mov	[bx+si], al

loc_1D8EF:
mov	bx, cx
mov	al, [byte ptr bp+var_C]

loc_1D8F4:
mov	[bx+di], al
inc	cx		; Increment by 1

loc_1D8F7:		; CODE XREF: sub_1D785:loc_1D8DAj
cmp	cx, [bp+var_4]	; Compare Two Operands

loc_1D8FA:		; Jump if Less (SF!=OF)
jl	short loc_1D8DC

loc_1D8FC:		; CODE XREF: sub_1D785:loc_1D85Ej
			; sub_1D785:loc_1D8D8j
mov	ax, cx
jmp	short $+2	; Jump

loc_1D900:
pop	di
pop	si

loc_1D902:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1D785



; Attributes: bp-based frame

proc sub_1D906 far	; CODE XREF: sub_4BA53+18EP
			; sub_50B16+EFP

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction

loc_1D90C:
push	si
push	di

loc_1D90E:
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_4]	; Integer Subtraction
add	ax, [bp+arg_0]	; Add
push	ax		; x

loc_1D918:		; Call Procedure
call	_abs
pop	cx
push	ax
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
push	ax		; x

loc_1D926:		; Call Procedure
call	_abs
pop	cx
pop	dx
cmp	dx, ax		; Compare Two Operands
jge	short loc_1D93A	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+arg_4]

loc_1D934:		; Integer Subtraction
sub	ax, [bp+arg_C]
mov	[bp+arg_4], ax

loc_1D93A:		; CODE XREF: sub_1D906+29j
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_0]	; Integer Subtraction

loc_1D940:		; Add
add	ax, [bp+arg_4]
push	ax		; x
call	_abs		; Call Procedure
pop	cx
push	ax

loc_1D94B:
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
push	ax		; x
call	_abs		; Call Procedure
pop	cx
pop	dx
cmp	dx, ax		; Compare Two Operands
jge	short loc_1D966	; Jump if Greater or Equal (SF=OF)

loc_1D95D:
mov	ax, [bp+arg_4]

loc_1D960:		; Add
add	ax, [bp+arg_C]
mov	[bp+arg_4], ax

loc_1D966:		; CODE XREF: sub_1D906+55j
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction

loc_1D96C:
mov	[bp+var_2], ax
mov	ax, [bp+arg_6]

loc_1D972:		; Integer Subtraction
sub	ax, [bp+arg_2]
mov	[bp+var_4], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jge	short loc_1D98D	; Jump if Greater or Equal (SF=OF)

loc_1D97E:
mov	ax, [bp+var_2]
neg	ax		; Two's Complement Negation

loc_1D983:
mov	[bp+var_2], ax

loc_1D986:
mov	[bp+var_6], 0FFFFh
jmp	short loc_1D992	; Jump

loc_1D98D:		; CODE XREF: sub_1D906+76j
mov	[bp+var_6], 1

loc_1D992:		; CODE XREF: sub_1D906+85j
cmp	[bp+var_4], 0	; Compare Two Operands
jge	short loc_1D9A7	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_4]
neg	ax		; Two's Complement Negation

loc_1D99D:
mov	[bp+var_4], ax

loc_1D9A0:
mov	[bp+var_8], 0FFFFh
jmp	short loc_1D9AC	; Jump

loc_1D9A7:		; CODE XREF: sub_1D906+90j
mov	[bp+var_8], 1

loc_1D9AC:		; CODE XREF: sub_1D906+9Fj
xor	si, si		; Logical Exclusive OR
mov	ax, [bp+arg_0]
mov	[bp+var_A], ax
mov	ax, [bp+arg_2]

loc_1D9B7:
mov	[bp+var_C], ax
mov	ax, [bp+var_2]
cmp	ax, [bp+var_4]	; Compare Two Operands

loc_1D9C0:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1DA40
mov	[bp+var_10], 8000h
mov	dx, [bp+var_2]
mov	ax, 0
mov	bx, [bp+var_4]
div	bx		; Unsigned Divide

loc_1D9D2:
mov	[bp+var_E], ax
cmp	[bp+var_6], 1	; Compare Two Operands

loc_1D9D9:		; Jump if Not Zero (ZF=0)
jnz	short loc_1DA0D
jmp	short loc_1DA06	; Jump

loc_1D9DD:		; CODE XREF: sub_1D906+103j
mov	ax, [bp+var_8]

loc_1D9E0:		; Add
add	[bp+var_C], ax
mov	ax, [bp+var_10]
add	ax, [bp+var_E]	; Add
jnb	short loc_1D9EE	; Jump if Not Below (CF=0)

loc_1D9EB:		; Increment by 1
inc	[bp+var_A]

loc_1D9EE:		; CODE XREF: sub_1D906+E3j
mov	[bp+var_10], ax
mov	bx, [bp+arg_8]
add	bx, si		; Add
mov	al, [byte ptr bp+var_A]
mov	[bx], al
mov	bx, [bp+arg_A]
add	bx, si		; Add

loc_1DA00:
mov	al, [byte ptr bp+var_C]
mov	[bx], al
inc	si		; Increment by 1

loc_1DA06:		; CODE XREF: sub_1D906+D5j
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_1D9DD	; Jump if Less (SF!=OF)
jmp	short loc_1DA3D	; Jump

loc_1DA0D:		; CODE XREF: sub_1D906:loc_1D9D9j
jmp	short loc_1DA38	; Jump

loc_1DA0F:		; CODE XREF: sub_1D906:loc_1DA3Bj
mov	ax, [bp+var_8]
add	[bp+var_C], ax	; Add
mov	ax, [bp+var_10]
add	ax, [bp+var_E]	; Add
jnb	short loc_1DA20	; Jump if Not Below (CF=0)

loc_1DA1D:		; Decrement by 1
dec	[bp+var_A]

loc_1DA20:		; CODE XREF: sub_1D906+115j
mov	[bp+var_10], ax
mov	bx, [bp+arg_8]
add	bx, si		; Add
mov	al, [byte ptr bp+var_A]
mov	[bx], al
mov	bx, [bp+arg_A]
add	bx, si		; Add
mov	al, [byte ptr bp+var_C]
mov	[bx], al
inc	si		; Increment by 1

loc_1DA38:		; CODE XREF: sub_1D906:loc_1DA0Dj
cmp	si, [bp+var_4]	; Compare Two Operands

loc_1DA3B:		; Jump if Less (SF!=OF)
jl	short loc_1DA0F

loc_1DA3D:		; CODE XREF: sub_1D906+105j
jmp	loc_1DAED	; Jump

loc_1DA40:		; CODE XREF: sub_1D906:loc_1D9C0j
mov	ax, [bp+var_4]
cmp	ax, [bp+var_2]	; Compare Two Operands
jge	short loc_1DAC5	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_10], 8000h
mov	dx, [bp+var_4]
mov	ax, 0
mov	bx, [bp+var_2]

loc_1DA56:		; Unsigned Divide
div	bx
mov	[bp+var_E], ax
cmp	[bp+var_8], 1	; Compare Two Operands

loc_1DA5F:		; Jump if Not Zero (ZF=0)
jnz	short loc_1DA93
jmp	short loc_1DA8C	; Jump

loc_1DA63:		; CODE XREF: sub_1D906+189j
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	ax, [bp+var_10]
add	ax, [bp+var_E]	; Add

loc_1DA6F:		; Jump if Not Below (CF=0)
jnb	short loc_1DA74
inc	[bp+var_C]	; Increment by 1

loc_1DA74:		; CODE XREF: sub_1D906:loc_1DA6Fj
mov	[bp+var_10], ax
mov	bx, [bp+arg_8]
add	bx, si		; Add

loc_1DA7C:
mov	al, [byte ptr bp+var_A]

loc_1DA7F:
mov	[bx], al
mov	bx, [bp+arg_A]
add	bx, si		; Add
mov	al, [byte ptr bp+var_C]
mov	[bx], al
inc	si		; Increment by 1

loc_1DA8C:		; CODE XREF: sub_1D906+15Bj
cmp	si, [bp+var_2]	; Compare Two Operands
jl	short loc_1DA63	; Jump if Less (SF!=OF)
jmp	short loc_1DAC3	; Jump

loc_1DA93:		; CODE XREF: sub_1D906:loc_1DA5Fj
jmp	short loc_1DABE	; Jump

loc_1DA95:		; CODE XREF: sub_1D906+1BBj
mov	ax, [bp+var_6]

loc_1DA98:		; Add
add	[bp+var_A], ax
mov	ax, [bp+var_10]
add	ax, [bp+var_E]	; Add
jnb	short loc_1DAA6	; Jump if Not Below (CF=0)
dec	[bp+var_C]	; Decrement by 1

loc_1DAA6:		; CODE XREF: sub_1D906+19Bj
mov	[bp+var_10], ax
mov	bx, [bp+arg_8]
add	bx, si		; Add
mov	al, [byte ptr bp+var_A]

loc_1DAB1:
mov	[bx], al

loc_1DAB3:
mov	bx, [bp+arg_A]
add	bx, si		; Add

loc_1DAB8:
mov	al, [byte ptr bp+var_C]
mov	[bx], al
inc	si		; Increment by 1

loc_1DABE:		; CODE XREF: sub_1D906:loc_1DA93j
cmp	si, [bp+var_2]	; Compare Two Operands
jl	short loc_1DA95	; Jump if Less (SF!=OF)

loc_1DAC3:		; CODE XREF: sub_1D906+18Bj
jmp	short loc_1DAED	; Jump

loc_1DAC5:		; CODE XREF: sub_1D906+140j
jmp	short loc_1DAE8	; Jump

loc_1DAC7:		; CODE XREF: sub_1D906+1E5j
mov	ax, [bp+var_8]
add	[bp+var_C], ax	; Add
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	bx, [bp+arg_8]
add	bx, si		; Add

loc_1DAD8:
mov	al, [byte ptr bp+var_A]
mov	[bx], al
mov	bx, [bp+arg_A]
add	bx, si		; Add
mov	al, [byte ptr bp+var_C]
mov	[bx], al
inc	si		; Increment by 1

loc_1DAE8:		; CODE XREF: sub_1D906:loc_1DAC5j
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_1DAC7	; Jump if Less (SF!=OF)

loc_1DAED:		; CODE XREF: sub_1D906:loc_1DA3Dj
			; sub_1D906:loc_1DAC3j
xor	di, di		; Logical Exclusive OR

loc_1DAEF:		; Jump
jmp	short loc_1DB0D

loc_1DAF1:		; CODE XREF: sub_1D906+209j
mov	bx, [bp+arg_8]
add	bx, di		; Add

loc_1DAF6:		; Compare Two Operands
cmp	[byte ptr bx], 0
jge	short loc_1DB0C	; Jump if Greater or Equal (SF=OF)
mov	bx, [bp+arg_8]

loc_1DAFE:		; Add
add	bx, di

loc_1DB00:
mov	al, [bx]

loc_1DB02:		; Add
add	al, [byte ptr bp+arg_C]
mov	bx, [bp+arg_8]
add	bx, di		; Add
mov	[bx], al

loc_1DB0C:		; CODE XREF: sub_1D906+1F3j
inc	di		; Increment by 1

loc_1DB0D:		; CODE XREF: sub_1D906:loc_1DAEFj
cmp	di, si		; Compare Two Operands
jl	short loc_1DAF1	; Jump if Less (SF!=OF)
xor	di, di		; Logical Exclusive OR
jmp	short loc_1DB34	; Jump

loc_1DB15:		; CODE XREF: sub_1D906:loc_1DB36j
mov	bx, [bp+arg_8]
add	bx, di		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_C]	; Compare Two Operands
jl	short loc_1DB33	; Jump if Less (SF!=OF)

loc_1DB22:
mov	bx, [bp+arg_8]

loc_1DB25:		; Add
add	bx, di

loc_1DB27:
mov	al, [bx]

loc_1DB29:		; Integer Subtraction
sub	al, [byte ptr bp+arg_C]

loc_1DB2C:
mov	bx, [bp+arg_8]
add	bx, di		; Add

loc_1DB31:
mov	[bx], al

loc_1DB33:		; CODE XREF: sub_1D906+21Aj
inc	di		; Increment by 1

loc_1DB34:		; CODE XREF: sub_1D906+20Dj
cmp	di, si		; Compare Two Operands

loc_1DB36:		; Jump if Less (SF!=OF)
jl	short loc_1DB15

loc_1DB38:
mov	ax, si

loc_1DB3A:		; Jump
jmp	short $+2

loc_1DB3C:
pop	di

loc_1DB3D:
pop	si

loc_1DB3E:
mov	sp, bp

loc_1DB40:
pop	bp

locret_1DB41:		; Return Far from Procedure
retf
endp sub_1D906

ends seg023


; Segment type:	Pure code
segment	seg024 byte public 'CODE' use16
assume cs:seg024
;org 2
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc IfDebugExitWithMemDiag far
			; CODE XREF: sub_24DAE:IS_KeyCode_145P
			; sub_26026+81P
			; sub_27CC0:loc_27D27P
			; sub_27CC0:loc_27DA8P
push	bp

loc_1DB43:
mov	bp, sp

loc_1DB45:		; Compare Two Operands
cmp	[FLAG_DebugMode], 1

loc_1DB4A:		; Jump if Not Zero (ZF=0)
jnz	short loc_1DB50

loc_1DB4C:		; Logical Exclusive OR
xor	ax, ax

loc_1DB4E:		; Jump
jmp	short loc_1DB55

loc_1DB50:		; CODE XREF: IfDebugExitWithMemDiag:loc_1DB4Aj
call	ST_ExitWithMemDiag ; Call Procedure

loc_1DB55:		; CODE XREF: IfDebugExitWithMemDiag:loc_1DB4Ej
pop	bp

locret_1DB56:		; Return Far from Procedure
retf
endp IfDebugExitWithMemDiag



; Attributes: bp-based frame

proc ST_ScreenDump far	; CODE XREF: sub_24DAE+7AP
			; sub_26026:loc_260B7P
			; sub_27CC0+78P
			; sub_27CC0+F9P

argPtrCharArr= byte ptr	-186h
argFileName= FILE ptr -176h
argNumber= word	ptr -8
varFileStream= word ptr	-6
argPtrWriteBuffer= word	ptr -4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 186h	; Integer Subtraction
push	si
push	di		; argSrc


cmp	[FLAG_DebugMode], 1 ; Compare Two Operands
jnz	short DEBUG_MODE_SET ; Jump if Not Zero	(ZF=0)

NOT_DEBUG_MODE:		; AX = 0
xor	ax, ax
jmp	END_FUNC	; Jump

DEBUG_MODE_SET:		; CODE XREF: ST_ScreenDump+Ej
call	idk_VGA_s1E4BA	;
			; mov	  ax, word_35ED6
			; mov	  ah, al
			; xor	  al, al
			; shl	  ax, 1
			; shl	  ax, 1
			; add	  ax, 0A000h
			; mov	  word_35ED4, ax
			;

loc_1DB71:		; FLAG_w360BE =	FLAG_w3609E, FLAG_w3609E = 0
call	Disable_Set_FLAG_Mouse_Skip


mov	[bp+argNumber],	0
mov	ax, offset strSCRDMP00FLI ; "SCRDMP00.FLI"
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc


jmp	loc_1DC0F	; Jump

loc_1DB8C:		; CODE XREF: ST_ScreenDump:loc_1DC26j
inc	[bp+argNumber]	; Increment by 1

loc_1DB8F:		; Compare Two Operands
cmp	[bp+argNumber],	10
jnb	short loc_1DBCC	; Jump if Not Below (CF=0)

loc_1DB95:		; "0"
mov	ax, offset a0
push	ax
lea	ax, [bp+argFileName.istemp] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argFileName.istemp] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
jmp	short BUILD_FILENAME ; Jump

loc_1DBCC:		; CODE XREF: ST_ScreenDump+3Cj
mov	ax, 10
push	ax
lea	ax, [bp+argFileName.istemp] ; Load Effective Address
push	ax		; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add

BUILD_FILENAME:		; CODE XREF: ST_ScreenDump+73j
mov	ax, offset strSCRDMP ; "SCRDMP"
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argFileName.istemp] ; "SCRDMP" + ? + ".FLI"
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, (offset strSCRDMP00FLI+8) ;	i.e. ".FLI"
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)

loc_1DC0F:		; CODE XREF: ST_ScreenDump+32j
pop	cx
pop	cx
lea	ax, [bp+argFileName.istemp] ; Load Effective Address
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; Does SCRNDMP??.FLI exist?
pop	cx
pop	cx
or	ax, ax		; If AX	== 0 Then Jmp
jz	short WRITE_SCRNDMP ; i.e. Jmp If SCRNDMP??.FLI	does not exist.

loc_1DC26:		; Jump
jmp	loc_1DB8C

WRITE_SCRNDMP:		; CODE XREF: ST_ScreenDump+CDj
mov	ax, offset strWB_SCRNDMP ; "wb"
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	si, ax
mov	[bp+var_2], 0
mov	[bp+argPtrWriteBuffer],	64944 ;	File Size
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], e_FLI_MagSig ;
			; FLIC File Type: FLI
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 1 ;
			; Number of Frames
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 320	;
			; Screen Width
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 200	;
			; Screen Height
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 8 ;
			; Pixel	Depth
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 0 ;
			; Flags	(always	0)
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 5 ;
			; speed	(tickets between frames)
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 0
xor	di, di		; Logical Exclusive OR
jmp	short LOOP_x55	; Jump

ALL_ZEROES:		; CODE XREF: ST_ScreenDump+1DBj
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
inc	di		; Increment by 1

LOOP_x55:		; CODE XREF: ST_ScreenDump+1C0j
cmp	di, 55		;
			; 4 bytes for 'next'
			; 4 bytes for 'frit'
			; 102 bytes for	'expand'
			;
jb	short ALL_ZEROES ; Jump	if Below (CF=1)
mov	[bp+var_2], 0
mov	[bp+argPtrWriteBuffer],	64800 ;
			; Frame	Size
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], e_FLI_Frame_MagSig
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 2 ;
			; Number of Chunks
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+var_2], 0
mov	[bp+argPtrWriteBuffer],	0 ;
			; 8 bytes for 'expand'
			;
			; NOTE:	can not	yet imagine why	it is
			;  two writes of 4 instead of 1	of 8,
			;  per the header definition
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+var_2], 0
mov	[bp+argPtrWriteBuffer],	778 ;
			; chunk	size
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 11 ;
			; chunk	type
			; 11 FLI_COLOR compressed color	map
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 1 ;
			; packet count
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 0 ;
			; number of colors to skip
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
xor	di, di		; Logical Exclusive OR
jmp	short loc_1DE50	; Jump

LOOP_x4:		; CODE XREF: ST_ScreenDump+2FCj
lea	ax, [bp+argFileName.istemp] ; Load Effective Address
push	ax
push	di		; DI ... {0,1,2,3}
nop			; No Operation
push	cs
call	near ptr DOS_ReadBlockOfDacRegisters ; Call Procedure
pop	cx
pop	cx
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 192
push	ax
lea	ax, [bp+argFileName.istemp] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
inc	di		; Increment by 1

loc_1DE50:		; CODE XREF: ST_ScreenDump+2D3j
cmp	di, 4		;
			; 4 * 192 = 768
			; 192 =	64 * 3
			; 768 =	256 pixels * 3 colors (RGB)
			;
jb	short LOOP_x4	; Jump if Below	(CF=1)
mov	[bp+var_2], 0
mov	[bp+argPtrWriteBuffer],	64006 ;
			; chunk	size
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], 16 ;
			; chunk	type
			; 16 FLIP_COPY indicates uncompressed 64000 bytes
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
xor	di, di		; Logical Exclusive OR
jmp	short loc_1DEB6	; Jump

LOOP_x200:		; CODE XREF: ST_ScreenDump+363j
lea	ax, [bp+argFileName.istemp] ; Load Effective Address
push	ax		; argBuffer
push	di		; argScreenPosition_Y
nop			; No Operation
push	cs
call	near ptr ST_Read_VGA_Buffer ; Call Procedure
pop	cx
pop	cx


push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 320
push	ax
lea	ax, [bp+argFileName.istemp] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add


inc	di		; Increment by 1

loc_1DEB6:		; CODE XREF: ST_ScreenDump+339j
cmp	di, 200		;
			; Write	all screen pixels to file
			;
			; 200 *	320 = 64000
			;
jb	short LOOP_x200	; Jump if Below	(CF=1)
mov	[bp+var_2], 0	;
			; No idea why they are writing an empty	frame...
			; But, maybe...
			; Per the Animator Pro docs.:
			; "
			; If the frame is absolutely identical
			;  to the last frame
			;  there will be no chunks at all.
			; "
			;
mov	[bp+argPtrWriteBuffer],	16 ;
			; bytes	in frame
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+varFileStream], e_FLI_Frame_MagSig
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
mov	[bp+var_2], 0
mov	[bp+argPtrWriteBuffer],	0
mov	[bp+varFileStream], 0 ;
			; Number of Chunks in Frame
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 2
push	ax
lea	ax, [bp+varFileStream] ; Load Effective	Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		;
			; SEE ABOVE:
			; this is, presumably, the 8 byte of zero
			;  for the field 'expand'
			;
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
push	si		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 4
push	ax
lea	ax, [bp+argPtrWriteBuffer] ; Load Effective Address
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
push	si		; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx


call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure

END_FUNC:		; CODE XREF: ST_ScreenDump+12j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_ScreenDump



; Attributes: bp-based frame

proc DOS_ReadBlockOfDacRegisters far
			; CODE XREF: ST_ScreenDump+2DDp

varStartingPaletteRegister= word ptr -2
argPaletteRegister= word ptr  6
argBuffer= word	ptr  8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
mov	ax, [bp+argPaletteRegister]
mov	cl, 6
shl	ax, cl		; AX = AX / 64
mov	[bp+varStartingPaletteRegister], ax
push	es
mov	ah, 10h
mov	al, 17h
mov	bx, [bp+varStartingPaletteRegister]
mov	cx, 64
mov	dx, ds
mov	es, dx
assume es:dseg
mov	dx, [bp+argBuffer]
int	10h		; DOS -	VIDEO -	READ BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)
			; BX = starting	palette	register, CX = number of palette registers to read
			; ES:DX	-> buffer (3 * CX bytes	in size)
			; Return: CX number of red, green and blue triples in buffer
pop	es
assume es:nothing
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp DOS_ReadBlockOfDacRegisters



; Attributes: bp-based frame

; int __cdecl __far ST_Read_VGA_Buffer(int argScreenPosition_Y,	int argBuffer)
proc ST_Read_VGA_Buffer	far
			; CODE XREF: ST_ScreenDump+343p

argScreenPosition_Y= word ptr  6
argBuffer= word	ptr  8

push	bp
mov	bp, sp
push	si
push	di
push	si
push	di
push	ds
push	es
mov	di, [bp+argBuffer]
mov	ax, [bp+argScreenPosition_Y]
mov	dx, 80
mul	dx		; ? AX = AX * 80 ?
			; ...
			;   0 *	80
			;   1 *	80
			; ...
			; 199 *	80
			;
			; ? read 4 bytes 80 times = 320	bytes ?
			;
mov	si, ax
mov	ax, ds
mov	es, ax
assume es:dseg
mov	ax, [g_ptrVideoRamBuffer]
mov	ds, ax
mov	cx, 80

LOOP_x80:		; CODE XREF: ST_Read_VGA_Buffer+51j
mov	al, 4		;
			; Read Mode
			;
			; Bit Plane
			; 3  blue
			; 2  green
			; 1  red
			; 0  intensity
			;
			;
mov	dx, GC_INDEX
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_1DFAC:
mov	al, 0

loc_1DFAE:		; EGA port: graphics controller	data register
out	dx, al		;
movsb			;
			;
			;
dec	si		; Decrement by 1
mov	al, 4
mov	dx, GC_INDEX
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, 1
out	dx, al		; EGA port: graphics controller	data register
movsb			;
			;
			;
dec	si		; Decrement by 1
mov	al, 4
mov	dx, GC_INDEX
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, 2
out	dx, al		; EGA port: graphics controller	data register
movsb			;
			;
			;
dec	si		; Decrement by 1
mov	al, 4
mov	dx, GC_INDEX
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, 3
out	dx, al		; EGA port: graphics controller	data register
movsb			;
			;
			;
loop	LOOP_x80	; Loop while CX	!= 0
pop	es
assume es:nothing
pop	ds
pop	di
pop	si
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp ST_Read_VGA_Buffer



; Attributes: bp-based frame

proc ST_SetDebugModeTrue far
			; CODE XREF: _f010109_main+2C3P
push	bp
mov	bp, sp
mov	[FLAG_DebugMode], 1
pop	bp
retf			; Return Far from Procedure
endp ST_SetDebugModeTrue



; Attributes: bp-based frame

proc fncCheckDebugMode far
			; CODE XREF: MemBlocksErrorExit+BP
			; sub_19DD1+BP
			; sub_19E6E+3P
			; sub_19E92+3P
			; sub_19ECC+6P
			; sub_19F09+6P
			; sub_19F49+6P
			; sub_24DAE:loc_24E81P
			; sub_24DAE+F7P
push	bp
mov	bp, sp
mov	ax, [FLAG_DebugMode]

loc_1DFEF:		; Jump
jmp	short $+2
pop	bp
retf			; Return Far from Procedure
endp fncCheckDebugMode

push	bp
mov	bp, sp
push	si
push	di
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, [bp+0Ah]

loc_1E000:		; Integer Subtraction
sub	ax, [bp+6]
inc	ax		; Increment by 1
mov	si, ax

loc_1E006:
mov	ax, [bp+0Ch]
sub	ax, [bp+8]	; Integer Subtraction
inc	ax		; Increment by 1
mov	di, ax
or	si, si		; Logical Inclusive OR
jge	short loc_1E019	; Jump if Greater or Equal (SF=OF)
mov	ax, si
neg	ax		; Two's Complement Negation
mov	si, ax

loc_1E019:		; CODE XREF: seg024:04D1j
or	di, di		; Logical Inclusive OR
jge	short loc_1E023	; Jump if Greater or Equal (SF=OF)
mov	ax, di

loc_1E01F:		; Two's Complement Negation
neg	ax
mov	di, ax

loc_1E023:		; CODE XREF: seg024:04DBj
push	[word ptr bp+0Eh]
push	di
push	si
call	hrmStoreSWSB	; Call Procedure
add	sp, 6		; Add
push	[word ptr bp+0Ch]
push	[word ptr bp+0Ah]
push	[word ptr bp+8]
push	[word ptr bp+6]
mov	ax, [bp+0Eh]
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs

loc_1E043:		; Call Procedure
call	near ptr _idk_EGA_s1E04D
add	sp, 0Ah		; Add
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure


; Attributes: bp-based frame

proc _idk_EGA_s1E04D far
			; CODE XREF: seg024:loc_1E043p
			; sub_4F44D+13FP

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
mov	ax, [bp+arg_6]

loc_1E058:		; Integer Subtraction
sub	ax, [bp+arg_2]
inc	ax		; Increment by 1
mov	[bp+var_2], ax
mov	ax, [bp+arg_8]
sub	ax, [bp+arg_4]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	ax, [bp+arg_4]
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_2]
mov	bx, 4
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
add	dx, ax		; Add
mov	[bp+var_6], dx
push	ds
push	es
push	si
push	di
mov	ax, [bp+arg_0]
mov	es, ax
mov	bx, [bp+var_2]
mov	si, [bp+var_6]
mov	ax, [bp+arg_2]
and	al, 3		; Logical AND
mov	ah, al
mov	di, [bp+var_4]
mov	dx, [g_ptrVideoRamBuffer]
mov	ds, dx
mov	dx, di
mov	di, 0

loc_1E0A5:		; CODE XREF: _idk_EGA_s1E04D:loc_1E0C7j
push	si
push	dx
mov	al, 4
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, ah
out	dx, al		; EGA port: graphics controller	data register
pop	dx
mov	cx, dx

loc_1E0B4:		; CODE XREF: _idk_EGA_s1E04D+6Cj
lodsb			; Load String
stosb			; Store	String

loc_1E0B6:		; Add
add	si, 4Fh	; 'O'
loop	loc_1E0B4	; Loop while CX	!= 0
pop	si
inc	ah		; Increment by 1

loc_1E0BE:		; Compare Two Operands
cmp	ah, 4
js	short loc_1E0C6	; Jump if Sign (SF=1)

loc_1E0C3:
mov	ah, 0
inc	si		; Increment by 1

loc_1E0C6:		; CODE XREF: _idk_EGA_s1E04D+74j
dec	bx		; Decrement by 1

loc_1E0C7:		; Jump if Not Zero (ZF=0)
jnz	short loc_1E0A5

loc_1E0C9:
pop	di

loc_1E0CA:
pop	si
pop	es

loc_1E0CC:
pop	ds
pop	di

loc_1E0CE:
pop	si

loc_1E0CF:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp _idk_EGA_s1E04D

ends seg024


; Segment type:	Pure code
segment	seg025 byte public 'CODE' use16
assume cs:seg025
;org 4
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
idk_MemAndVid_w1E0D4 dw	0
			; DATA XREF: idk_MemAndVid_s1E0DA:loc_1E152w
			; sub_1E2A1+3w
			; sub_1E2A1+Br
			; sub_1E2A1+1Ar
word_1E0D6 dw 0		; DATA XREF: idk_MemAndVid_s1E0DA:loc_1E16Cw
			; sub_1E2A1:loc_1E2B1r
			; sub_1E2A1+20r
ST_LibMalloc_w31D10 dw 0
			; DATA XREF: idk_MemAndVid_s1E0DA+11w
			; idk_MemAndVid_s1E0DA+FAr
			; idk_VidLib_s1E2D0+42r


; Attributes: bp-based frame

proc idk_MemAndVid_s1E0DA far
			; CODE XREF: LBX_Load_IntroLbx_s21977+13DP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	si

loc_1E0DE:
push	di
push	es
push	ds
mov	ax, [bp+arg_4]
mov	ds, ax
mov	es, ax
mov	ax, [LibMalloc_w31D10]
mov	[cs:ST_LibMalloc_w31D10], ax
mov	si, 10
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
mov	dx, ax
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
mov	bx, ax
lodsw			; Load String
mov	si, ax
mov	di, si
push	bx
push	dx
mov	ax, 4400h

loc_1E106:		;  - LIM EMS - MAP MEMORY
int	67h		; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status

loc_1E108:
mov	ax, 4401h
pop	dx

loc_1E10C:
pop	bx

loc_1E10D:		; Increment by 1
inc	bx

loc_1E10E:		;  - LIM EMS - MAP MEMORY
int	67h		; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg_6]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add
add	si, 18		; Add
mov	ax, [EMM_PageFrameSegmentAddress]
mov	ds, ax
lodsw			; Load String
mov	dx, ax
lodsw			; Load String
inc	dx		; Increment by 1
adc	ax, 0		; Add with Carry
shl	dx, 1		; Shift	Logical	Left
rcl	ax, 1		; Rotate Through Carry Left
shl	dx, 1		; Shift	Logical	Left
rcl	ax, 1		; Rotate Through Carry Left
shr	dx, 1		; Shift	Logical	Right
shr	dx, 1		; Shift	Logical	Right
add	al, [es:0Bh]	; Add
adc	ah, 0		; Add with Carry
add	dx, [es:0Ch]	; Add
cmp	dx, 16384	; Compare Two Operands
jb	short loc_1E152	; Jump if Below	(CF=1)

loc_1E14D:		; Logical AND
and	dx, 3FFFh
inc	ax		; Increment by 1

loc_1E152:		; CODE XREF: idk_MemAndVid_s1E0DA+71j
mov	[cs:idk_MemAndVid_w1E0D4], ax
mov	bx, 17

loc_1E159:		; Add
add	bx, di

loc_1E15B:
mov	bl, [bx]

loc_1E15D:		; Logical Exclusive OR
xor	bh, bh

loc_1E15F:
mov	di, bx

loc_1E161:
mov	si, dx
mov	bx, ax

loc_1E165:
mov	dl, [es:0Ah]
xor	dh, dh		; Logical Exclusive OR

loc_1E16C:
mov	[cs:word_1E0D6], dx
push	bx
push	dx
mov	ax, 4400h
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4401h

loc_1E17B:
pop	dx
pop	bx
inc	bx		; Increment by 1

loc_1E17E:		;  - LIM EMS - MAP MEMORY
int	67h		; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status

loc_1E180:		; Compare Two Operands
cmp	di, 0

loc_1E183:		; Jump if Zero (ZF=1)
jz	short loc_1E19D

loc_1E185:
push	[bp+arg_4]
nop			; No Operation

loc_1E189:
push	[bp+arg_2]
push	[bp+arg_0]

loc_1E18F:
push	cs

loc_1E190:		; Call Procedure
call	near ptr idk_VidLib_s1E2D0
nop			; No Operation
add	sp, 6		; Add

loc_1E197:
pop	ds

loc_1E198:
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1E19D:		; CODE XREF: idk_MemAndVid_s1E0DA:loc_1E183j
mov	ax, seg	dseg
mov	ds, ax
mov	dx, SC_INDEX
mov	al, 2

loc_1E1A7:		; EGA: sequencer address reg
out	dx, al		; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	ax, [bp+arg_2]
mov	bx, ax
shl	ax, 1		; Shift	Logical	Left

loc_1E1AF:		; Shift	Logical	Left
shl	ax, 1
add	ax, bx		; Add

loc_1E1B3:		; Add
add	ax, [g_ptrVideoRamBuffer]

loc_1E1B7:
mov	es, ax

loc_1E1B9:
mov	ax, [bp+arg_0]

loc_1E1BC:
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right

loc_1E1C0:		; Shift	Logical	Right
shr	bx, 1
mov	di, bx
and	ax, 3		; Logical AND

loc_1E1C7:
mov	bx, offset unk_3607C

loc_1E1CA:		; Add
add	bx, ax

loc_1E1CC:
mov	ah, [bx]

loc_1E1CE:
mov	bx, [EMM_PageFrameSegmentAddress]
mov	ds, bx
mov	bx, [cs:ST_LibMalloc_w31D10]

loc_1E1D9:		; CODE XREF: idk_MemAndVid_s1E0DA:loc_1E235j
			; idk_MemAndVid_s1E0DA:loc_1E298j
push	di
cmp	si, offset unk_39910 ; Compare Two Operands
jb	short loc_1E1E3	; Jump if Below	(CF=1)
call	sub_1E2A1	; Call Procedure

loc_1E1E3:		; CODE XREF: idk_MemAndVid_s1E0DA+104j
mov	dx, SC_DATA
mov	al, ah
out	dx, al		; EGA port: sequencer data register
lodsb			; Load String
cmp	al, 0FFh	; Compare Two Operands
jz	short loc_1E227	; Jump if Zero (ZF=1)
mov	dh, al
lodsb			; Load String
mov	dl, al
cmp	dh, 0		; Compare Two Operands

loc_1E1F6:		; Jump if Sign (SF=1)
js	short loc_1E237

loc_1E1F8:		; CODE XREF: idk_MemAndVid_s1E0DA+14Bj
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR
mov	al, cl

loc_1E1FF:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add

loc_1E205:		; Add with Carry
adc	ch, 0
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_1E20E:		; Shift	Logical	Left
shl	cx, 1

loc_1E210:		; Add
add	di, cx
lodsb			; Load String
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1E21C:		; CODE XREF: idk_MemAndVid_s1E0DA:loc_1E220j
movsb			; Move Byte(s) from String to String
add	di, 4Fh	; 'O'   ; Add

loc_1E220:		; Loop while CX	!= 0
loop	loc_1E21C
cmp	dx, 1		; Compare Two Operands
jns	short loc_1E1F8	; Jump if Not Sign (SF=0)

loc_1E227:		; CODE XREF: idk_MemAndVid_s1E0DA+112j
			; idk_MemAndVid_s1E0DA+195j
pop	di
dec	bx		; Decrement by 1

loc_1E229:		; Jump if Zero (ZF=1)
jz	short loc_1E29B

loc_1E22B:		; Shift	Logical	Left
shl	ah, 1

loc_1E22D:		; Compare Two Operands
cmp	ah, 9
js	short loc_1E235	; Jump if Sign (SF=1)
mov	ah, 1
inc	di		; Increment by 1

loc_1E235:		; CODE XREF: idk_MemAndVid_s1E0DA+156j
jmp	short loc_1E1D9	; Jump

loc_1E237:		; CODE XREF: idk_MemAndVid_s1E0DA:loc_1E1F6j
and	dx, 7FFFh	; Logical AND

loc_1E23B:		; CODE XREF: idk_MemAndVid_s1E0DA+193j
			; idk_MemAndVid_s1E0DA:loc_1E288j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR
mov	al, cl
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_1E24F:		; Shift	Logical	Left
shl	cx, 1

loc_1E251:		; Shift	Logical	Left
shl	cx, 1
add	di, cx		; Add
lodsb			; Load String

loc_1E256:
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1E25F:		; CODE XREF: idk_MemAndVid_s1E0DA+18Ej
			; idk_MemAndVid_s1E0DA+1A9j
lodsb			; Load String

loc_1E260:		; Compare Two Operands
cmp	al, 0E0h ; ''
jnb	short loc_1E271	; Jump if Not Below (CF=0)
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1E25F	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_1E23B	; Jump if Not Sign (SF=0)
jmp	short loc_1E227	; Jump

loc_1E271:		; CODE XREF: idk_MemAndVid_s1E0DA+188j
and	al, 1Fh		; Logical AND

loc_1E273:		; Increment by 1
inc	al
push	cx
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
lodsb			; Load String

loc_1E27B:		; CODE XREF: idk_MemAndVid_s1E0DA+1A5j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1E27B	; Loop while CX	!= 0

loc_1E281:
pop	cx
dec	cx		; Decrement by 1
loop	loc_1E25F	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_1E288:		; Jump if Not Sign (SF=0)
jns	short loc_1E23B
pop	di
dec	bx		; Decrement by 1
jz	short loc_1E29B	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_1E298	; Jump if Sign (SF=1)
mov	ah, 1
inc	di		; Increment by 1

loc_1E298:		; CODE XREF: idk_MemAndVid_s1E0DA+1B9j
jmp	loc_1E1D9	; Jump

loc_1E29B:		; CODE XREF: idk_MemAndVid_s1E0DA:loc_1E229j
			; idk_MemAndVid_s1E0DA+1B2j
pop	ds
pop	es
pop	di
pop	si
pop	bp

locret_1E2A0:		; Return Far from Procedure
retf
endp idk_MemAndVid_s1E0DA




proc sub_1E2A1 near	; CODE XREF: idk_MemAndVid_s1E0DA+106p
			; idk_VidLib_s1E2D0+4Ep
push	bx

loc_1E2A2:
mov	cx, ax
inc	[cs:idk_MemAndVid_w1E0D4] ; Increment by 1

loc_1E2A9:
mov	ax, 4400h
mov	bx, [cs:idk_MemAndVid_w1E0D4]

loc_1E2B1:
mov	dx, [cs:word_1E0D6]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status

loc_1E2B8:
mov	ax, 4401h
mov	bx, [cs:idk_MemAndVid_w1E0D4]
inc	bx		; Increment by 1
mov	dx, [cs:word_1E0D6]
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status

loc_1E2C8:		; Integer Subtraction
sub	si, 4000h
mov	ax, cx
pop	bx
retn			; Return Near from Procedure
endp sub_1E2A1



; Attributes: bp-based frame

proc idk_VidLib_s1E2D0 far
			; CODE XREF: idk_MemAndVid_s1E0DA:loc_1E190p

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg_2]
mov	bx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
mov	di, bx
and	ax, 3		; Logical AND
mov	cl, al
shl	cl, 1		; Shift	Logical	Left
shl	cl, 1		; Shift	Logical	Left
shl	cl, 1		; Shift	Logical	Left
shl	cl, 1		; Shift	Logical	Left
mov	bx, offset unk_3607C
add	bx, ax		; Add
mov	al, [bx]
mov	ah, al
or	ah, cl		; Logical Inclusive OR
mov	bx, [EMM_PageFrameSegmentAddress]
mov	ds, bx
mov	bx, [cs:ST_LibMalloc_w31D10]

loc_1E317:		; CODE XREF: idk_VidLib_s1E2D0+D2j
push	di
cmp	si, offset unk_39910 ; Compare Two Operands
jb	short loc_1E321	; Jump if Below	(CF=1)
call	sub_1E2A1	; Call Procedure

loc_1E321:		; CODE XREF: idk_VidLib_s1E2D0+4Cj
mov	dx, GC_INDEX
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, ah
shr	al, 1		; Shift	Logical	Right

loc_1E32C:		; Shift	Logical	Right
shr	al, 1
shr	al, 1		; Shift	Logical	Right

loc_1E330:		; Shift	Logical	Right
shr	al, 1
out	dx, al		; EGA port: graphics controller	data register
mov	dx, SC_INDEX

loc_1E336:
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, ah
and	al, 1111b	; Logical AND
out	dx, al		; EGA port: sequencer data register
lodsb			; Load String

loc_1E340:		; Compare Two Operands
cmp	al, 255
jz	short loc_1E385	; Jump if Zero (ZF=1)
mov	dh, al

loc_1E346:		; Load String
lodsb
mov	dl, al

loc_1E349:		; Compare Two Operands
cmp	dh, 0
jns	short loc_1E351	; Jump if Not Sign (SF=0)

loc_1E34E:		; Jump
jmp	loc_1E3DE

loc_1E351:		; CODE XREF: idk_VidLib_s1E2D0+7Cj
			; idk_VidLib_s1E2D0:loc_1E383j
			; idk_VidLib_s1E2D0+10Bj
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR
mov	al, cl
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_1E35C:		; Add
add	cl, al
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	di, cx		; Add
lodsb			; Load String
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1

loc_1E371:		; Decrement by 1
dec	dx

loc_1E372:		; Decrement by 1
dec	dx
sub	dx, cx		; Integer Subtraction

loc_1E375:		; CODE XREF: idk_VidLib_s1E2D0+AEj
			; idk_VidLib_s1E2D0:loc_1E3D4j
lodsb			; Load String
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_1E3A7	; Jump if Not Below (CF=0)
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1E375	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_1E383:		; Jump if Not Sign (SF=0)
jns	short loc_1E351

loc_1E385:		; CODE XREF: idk_VidLib_s1E2D0+72j
			; idk_VidLib_s1E2D0:loc_1E3D9j
			; idk_VidLib_s1E2D0:loc_1E41Aj
			; idk_VidLib_s1E2D0+183j
			; idk_VidLib_s1E2D0+1A3j
			; idk_VidLib_s1E2D0:loc_1E4B4j
pop	di
dec	bx		; Decrement by 1
jz	short loc_1E3A5	; Jump if Zero (ZF=1)
mov	cl, ah
and	cl, 11110000b	; Logical AND

loc_1E38E:		; Add
add	cl, 16
and	ah, 1111b	; Logical AND
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_1E3A0	; Jump if Sign (SF=1)
mov	cl, 0
mov	ah, 1
inc	di		; Increment by 1

loc_1E3A0:		; CODE XREF: idk_VidLib_s1E2D0+C9j
or	ah, cl		; Logical Inclusive OR
jmp	loc_1E317	; Jump

loc_1E3A5:		; CODE XREF: idk_VidLib_s1E2D0+B7j
pop	bp
retf			; Return Far from Procedure

loc_1E3A7:		; CODE XREF: idk_VidLib_s1E2D0+A8j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds
mov	si, seg	dseg
mov	ds, si

loc_1E3B0:
mov	si, ax
and	si, 0FFh	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left

loc_1E3BC:		; Shift	Logical	Left
shl	si, 1
add	si, [idk_FontsLbx1_6144B] ; Add
mov	ds, si
mov	al, [es:di]

loc_1E3C7:
mov	si, ax
and	si, 0FFh	; Logical AND
lodsb			; Load String

loc_1E3CE:
pop	ds
pop	si

loc_1E3D0:		; Store	String
stosb

loc_1E3D1:		; Add
add	di, 4Fh	; 'O'

loc_1E3D4:		; Loop while CX	!= 0
loop	loc_1E375

loc_1E3D6:		; Compare Two Operands
cmp	dx, 1

loc_1E3D9:		; Jump if Sign (SF=1)
js	short loc_1E385
jmp	loc_1E351	; Jump

loc_1E3DE:		; CODE XREF: idk_VidLib_s1E2D0:loc_1E34Ej
			; idk_VidLib_s1E2D0+181j
and	dx, 7FFFh	; Logical AND

loc_1E3E2:		; CODE XREF: idk_VidLib_s1E2D0+148j
			; idk_VidLib_s1E2D0:loc_1E476j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR
mov	al, cl
shl	cx, 1		; Shift	Logical	Left

loc_1E3EB:		; Shift	Logical	Left
shl	cx, 1
add	cl, al		; Add
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	di, cx		; Add
lodsb			; Load String
mov	cl, al

loc_1E3FF:		; Logical Exclusive OR
xor	ch, ch
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1E406:		; CODE XREF: idk_VidLib_s1E2D0:loc_1E413j
			; idk_VidLib_s1E2D0+17Cj
			; idk_VidLib_s1E2D0+19Cj
			; idk_VidLib_s1E2D0:loc_1E4ACj
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands
jnb	short loc_1E456	; Jump if Not Below (CF=0)

loc_1E40B:		; Compare Two Operands
cmp	al, 0E8h ; ''
jnb	short loc_1E41F	; Jump if Not Below (CF=0)
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add

loc_1E413:		; Loop while CX	!= 0
loop	loc_1E406
cmp	dx, 1		; Compare Two Operands
jns	short loc_1E3E2	; Jump if Not Sign (SF=0)

loc_1E41A:		; Jump
jmp	loc_1E385
pop	bp
retf			; Return Far from Procedure

loc_1E41F:		; CODE XREF: idk_VidLib_s1E2D0+13Dj
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds

loc_1E423:
mov	si, seg	dseg
mov	ds, si

loc_1E428:
mov	si, ax
and	si, 0FFh	; Logical AND

loc_1E42E:		; Shift	Logical	Left
shl	si, 1

loc_1E430:		; Shift	Logical	Left
shl	si, 1
shl	si, 1		; Shift	Logical	Left

loc_1E434:		; Shift	Logical	Left
shl	si, 1

loc_1E436:		; Add
add	si, [idk_FontsLbx1_6144B]
mov	ds, si
mov	al, [es:di]
mov	si, ax

loc_1E441:		; Logical AND
and	si, 11111111b
lodsb			; Load String

loc_1E446:
pop	ds
pop	si

loc_1E448:		; Store	String
stosb

loc_1E449:		; Add
add	di, 4Fh	; 'O'
loop	loc_1E406	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_1E3DE	; Jump if Not Sign (SF=0)
jmp	loc_1E385	; Jump

loc_1E456:		; CODE XREF: idk_VidLib_s1E2D0+139j
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
push	cx

loc_1E45B:
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
lodsb			; Load String
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_1E479	; Jump if Not Below (CF=0)

loc_1E464:		; CODE XREF: idk_VidLib_s1E2D0+198j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1E464	; Loop while CX	!= 0
pop	cx
dec	cx		; Decrement by 1
loop	loc_1E406	; Loop while CX	!= 0

loc_1E46E:		; Compare Two Operands
cmp	dx, 1

loc_1E471:		; Jump if Not Sign (SF=0)
jns	short loc_1E476
jmp	loc_1E385	; Jump

loc_1E476:		; CODE XREF: idk_VidLib_s1E2D0:loc_1E471j
			; idk_VidLib_s1E2D0:loc_1E4B2j
jmp	loc_1E3E2	; Jump

loc_1E479:		; CODE XREF: idk_VidLib_s1E2D0+192j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds

loc_1E47D:
mov	si, seg	dseg

loc_1E480:
mov	ds, si
mov	si, ax
and	si, 0FFh	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left

loc_1E490:		; Add
add	si, [idk_FontsLbx1_6144B]

loc_1E494:
mov	ds, si

loc_1E496:		; CODE XREF: idk_VidLib_s1E2D0:loc_1E4A3j
mov	al, [es:di]

loc_1E499:
mov	si, ax

loc_1E49B:		; Logical AND
and	si, 11111111b
movsb			; Move Byte(s) from String to String

loc_1E4A0:		; Add
add	di, 4Fh	; 'O'

loc_1E4A3:		; Loop while CX	!= 0
loop	loc_1E496
pop	ds

loc_1E4A6:
pop	si
pop	cx

loc_1E4A8:		; Decrement by 1
dec	cx

loc_1E4A9:		; Decrement by 1
dec	cx

loc_1E4AA:		; Jump if Zero (ZF=1)
jz	short loc_1E4AF

loc_1E4AC:		; Jump
jmp	loc_1E406

loc_1E4AF:		; CODE XREF: idk_VidLib_s1E2D0:loc_1E4AAj
cmp	dx, 1		; Compare Two Operands

loc_1E4B2:		; Jump if Not Sign (SF=0)
jns	short loc_1E476

loc_1E4B4:		; Jump
jmp	loc_1E385
endp idk_VidLib_s1E2D0


loc_1E4B7:
pop	bp

locret_1E4B8:		; Return Far from Procedure
retf
ends seg025


; Segment type:	Pure code
segment	seg026 byte public 'CODE' use16
assume cs:seg026
;org 0Ah
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing



proc idk_VGA_s1E4BA far	; CODE XREF: _f010109_main+359P
			; _f010509_MainMenuScreen+71P
			; sub_19F94+6DP
			; sub_1CBE3+3P
			; ST_ScreenDump:DEBUG_MODE_SETP
			; sub_2E00A+197P
			; sub_3DBA6+10EP
			; sub_3E1DE+33P
			; sub_3E1DE+1D9P
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, VIDEO_RAM	; Add
mov	[g_ptrVideoRamBuffer], ax
retf			; Return Far from Procedure
endp idk_VGA_s1E4BA




proc VGA_MathThenSetVarToVgaLoc	far
			; CODE XREF: _f010109_main+377P
			; _f010509_MainMenuScreen+8FP
			; _f010609_DrawMainMenuScreen+16P
			; Load_Fonts_SndDrv+95P
			; sub_19F94+C4P
			; sub_1CBE3:loc_1CC04P
			; sub_1D1B5:loc_1D216P
			; sub_1D40D+24P
			; sub_1D40D+156P
			; ST_ScreenDump+3F8P
			; seg024:04B8P
			; idk_VGA_CRTR_s1E4F1+2Cp
			; sub_28963+DP
			; sub_2B97A+3EP
			; sub_2BA41+25P
			; sub_2E00A+1B1P
			; sub_2E27D+FP
			; sub_2E2B7:loc_2E2C6P
			; sub_3DBA6+12CP
			; sub_3DF8C+3AP
			; sub_3E1DE+51P
			; sub_3E1DE+1F7P
			; idk_BuildingWorlds+41P
			; sub_4CAF3+AP
			; sub_4D7A1+29P
			; sub_4DA02:loc_4DA2BP
			; sub_4DB4D:loc_4DDC9P
			; sub_4E9F4+CFP
			; sub_4E9F4+1CBP
			; sub_4EC17+8DP
			; sub_4EF74+D4P
			; sub_4EF74+1E0P
			; sub_4F1AB+68P
			; sub_4F44D+12AP
			; sub_4F44D+23BP
			; sub_4F7B3:loc_4F7C1P
			; sub_4F808+CP
			; ST_LoadMusicSoundfxIntro:loc_558E5P
			; idk_OVR_LoadLbxHelp+2F9P
			; sub_56450+25P
			; sub_56450+48P
			; sub_56450+166P
			; idk_HoF_s565F2+57P
mov	ax, 1

loc_1E4CF:		; Integer Subtraction
sub	ax, [idk_VGA_w35ED6]

loc_1E4D3:
mov	ah, al

loc_1E4D5:		; Logical Exclusive OR
xor	al, al

loc_1E4D7:		; Shift	Logical	Left
shl	ax, 1
shl	ax, 1		; Shift	Logical	Left

loc_1E4DB:		; The offset to	video memory.
add	ax, 0A000h
mov	[g_ptrVideoRamBuffer], ax
retf			; Return Far from Procedure
endp VGA_MathThenSetVarToVgaLoc




proc sub_1E4E2 far	; CODE XREF: ST_execl_WizardsExe+FP
mov	ax, [g_ptrVideoRamBuffer]
cmp	ax, 0A000h	; Compare Two Operands
jz	short loc_1E4EE	; Jump if Zero (ZF=1)

loc_1E4EA:
mov	ax, 1
retf			; Return Far from Procedure

loc_1E4EE:		; CODE XREF: sub_1E4E2+6j
sub	ax, ax		; Integer Subtraction
retf			; Return Far from Procedure
endp sub_1E4E2




proc idk_VGA_CRTR_s1E4F1 far
			; CODE XREF: sub_2E303:loc_2E33AP
push	es
push	ds
push	si
push	di
mov	ax, 1
sub	ax, [idk_VGA_w35ED6] ; Integer Subtraction
mov	[idk_VGA_w35ED6], ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
mov	dx, CRTC_INDEX
mov	al, 0Ch
out	dx, al		; Video: CRT cntrlr addr
			; regen	start address (high)


inc	dx		; DX is	now 0x0D CRTC_DATA
mov	al, bl
out	dx, al		; Video: CRT controller	internal registers


call	_f020505_WaitForVsync ;	Call Procedure
push	cs
call	near ptr VGA_MathThenSetVarToVgaLoc ; Call Procedure
pop	di
pop	si
pop	ds
pop	es
retf			; Return Far from Procedure
endp idk_VGA_CRTR_s1E4F1




proc sub_1E525 far	; CODE XREF: _f010509_MainMenuScreen+499P
			; ST_execl_WizardsExe:loc_143EEP
			; sub_1D40D:loc_1D440P
			; sub_2A755+A48P
			; sub_2B1F9+221P
			; sub_3CFC0+378P
			; sub_3DBA6+3B6P
			; sub_3E1DE+408P
			; sub_3EBA0+213P
			; sub_3F3C6+1C9P
			; sub_3F7D8+1FDP
			; sub_3FBE0+295P
			; sub_3FBE0:loc_40009P
			; sub_4067D+808P
			; LBX_NewGame_s41A5F+746P
			; idk_BuildingWorlds+3CP
			; idk_BuildingWorlds+8CP
			; sub_4D5B0:loc_4D62BP
			; sub_4D8FA:loc_4D97DP
			; sub_4DB4D+DP
			; sub_4E9F4+C4P
			; sub_4EF74+C9P
			; sub_4F44D+15CP
			; ST_LoadMusicSoundfxIntro:loc_55B3CP
			; idk_OVR_LoadLbxHelp:loc_55CA8P
			; idk_OVR_LoadLbxHelp+4E2P
push	ds
push	es
push	si
push	di
call	sub_23FDC	; Call Procedure
cmp	ax, 0		; Compare Two Operands
jz	short loc_1E53D	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_1E547 ; Call Procedure
nop			; No Operation
pop	di
pop	si
pop	es
pop	ds
retf			; Return Far from Procedure

loc_1E53D:		; CODE XREF: sub_1E525+Cj
push	cs
call	near ptr sub_1E60D ; Call Procedure
nop			; No Operation
pop	di
pop	si
pop	es
pop	ds

locret_1E546:		; Return Far from Procedure
retf
endp sub_1E525



; Attributes: bp-based frame

proc sub_1E547 far	; CODE XREF: sub_1E525+Fp

var_A= word ptr	-0Ah
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp

loc_1E548:
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	ds

loc_1E54E:
push	es

loc_1E54F:
push	si

loc_1E550:
push	di
mov	ax, ds
mov	[bp+var_A], ax
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0

loc_1E55B:		; Call Procedure
call	get__Mouse_w360A4
mov	[bp+var_4], ax

loc_1E563:		; Call Procedure
call	get__Mouse_w360A6

loc_1E568:
mov	[bp+var_6], ax

loc_1E56B:
mov	ax, [idk_VGA_w35ED6]

loc_1E56E:
mov	ah, al

loc_1E570:		; Logical Exclusive OR
xor	al, al
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left

loc_1E576:		; Add
add	ax, 0A000h
mov	ds, ax

loc_1E57B:
mov	[bp+var_2], ax
mov	bx, 0A400h
sub	bx, ax		; Integer Subtraction
add	bx, 0A000h	; Add

loc_1E587:
mov	es, bx
sub	si, si		; Integer Subtraction
sub	di, di		; Integer Subtraction

loc_1E58D:		; CODE XREF: sub_1E547+ADj
mov	dx, 3C4h

loc_1E590:
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_1E593:		; Increment by 1
inc	dx

loc_1E594:
mov	al, 0Fh
out	dx, al		; EGA port: sequencer data register

loc_1E597:
mov	ax, 8

loc_1E59A:
mov	dx, 3CEh

loc_1E59D:		; EGA: graph 1 and 2 addr reg:
out	dx, al		; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1

loc_1E59F:
mov	al, 0

loc_1E5A1:		; EGA port: graphics controller	data register
out	dx, al
mov	cx, 0FA0h
rep movsb		; Move Byte(s) from String to String

loc_1E5A7:
mov	al, 0FFh

loc_1E5A9:		; EGA port: graphics controller	data register
out	dx, al

loc_1E5AA:
mov	ax, [bp+var_A]

loc_1E5AD:
mov	ds, ax

loc_1E5AF:		; Call Procedure
call	sub_2495B
call	get__Mouse_w360A6 ; Call Procedure
push	ax

loc_1E5BA:		; Call Procedure
call	get__Mouse_w360A4
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_1E5CB	; Jump if Not Zero (ZF=0)
pop	bx
cmp	bx, [bp+var_6]	; Compare Two Operands
jz	short loc_1E5ED	; Jump if Zero (ZF=1)
push	bx

loc_1E5CB:		; CODE XREF: sub_1E547+7Bj
push	ax

loc_1E5CC:		; Call Procedure
call	idk_Mouse_s23F82
call	idk_ChkMousDoEga ; Call	Procedure

loc_1E5D6:		; Call Procedure
call	sub_24648
call	idk_Mouse_s23F82 ; Call	Procedure

loc_1E5E0:		; Call Procedure
call	sub_24A74
call	CALL_PositionMouseCursor ; Call	Procedure

loc_1E5EA:		; Add
add	sp, 4

loc_1E5ED:		; CODE XREF: sub_1E547+81j
mov	ds, [bp+var_2]

loc_1E5F0:		; Compare Two Operands
cmp	si, 3E80h
jb	short loc_1E58D	; Jump if Below	(CF=1)
mov	ax, [bp+var_A]
mov	ds, ax
call	sub_2495B	; Call Procedure

loc_1E600:		; FLAG_w3609E =	FLAG_w360BE
call	Restore_Set_FLAG_Mouse_Skip
pop	di
pop	si
pop	es
pop	ds
mov	sp, bp
pop	bp

locret_1E60C:		; Return Far from Procedure
retf
endp sub_1E547




proc sub_1E60D far	; CODE XREF: sub_1E525+19p
push	ds

loc_1E60E:
push	es

loc_1E60F:
push	si
push	di

loc_1E611:		; FLAG_w360BE =	FLAG_w3609E, FLAG_w3609E = 0
call	Disable_Set_FLAG_Mouse_Skip

loc_1E616:
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
mov	ds, ax
mov	bx, 0A400h
sub	bx, ax		; Integer Subtraction
add	bx, 0A000h	; Add

loc_1E62F:
mov	es, bx
mov	dx, 3C4h
mov	al, 2

loc_1E636:		; EGA: sequencer address reg
out	dx, al		; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 0Fh

loc_1E63A:		; EGA port: sequencer data register
out	dx, al
sub	si, si		; Integer Subtraction
sub	di, di		; Integer Subtraction
mov	ax, 8
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1
xor	al, al		; Logical Exclusive OR
out	dx, al		; EGA port: graphics controller	data register
mov	cx, 3E80h

loc_1E64D:		; Move Byte(s) from String to String
rep movsb
mov	al, 0FFh
out	dx, al		; EGA port: graphics controller	data register
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	di
pop	si
pop	es
pop	ds
retf			; Return Far from Procedure
endp sub_1E60D




proc sub_1E65C far	; CODE XREF: sub_4DB4D+12P
			; sub_4E9F4:loc_4EAE2P
			; sub_4EF74:loc_4F067P
			; sub_4F44D+161P
			; sub_56450+79P
push	ds
push	es
push	si
push	di

loc_1E660:
mov	ax, 1
sub	ax, [idk_VGA_w35ED6] ; Integer Subtraction
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left

loc_1E66F:		; Add
add	ax, 0A000h
mov	ds, ax
mov	bx, 0A800h
mov	es, bx
assume es:nothing

loc_1E679:		; Integer Subtraction
sub	si, si
sub	di, di		; Integer Subtraction
mov	dx, 3C4h
mov	al, 2

loc_1E682:		; EGA: sequencer address reg
out	dx, al		; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 0Fh
out	dx, al		; EGA port: sequencer data register
mov	ax, 8
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1
xor	al, al		; Logical Exclusive OR
out	dx, al		; EGA port: graphics controller	data register
mov	cx, 3E80h

loc_1E695:		; Move Byte(s) from String to String
rep movsb
mov	al, 0FFh
out	dx, al		; EGA port: graphics controller	data register
pop	di
pop	si
pop	es
assume es:nothing
pop	ds
retf			; Return Far from Procedure
endp sub_1E65C




proc sub_1E69F far	; CODE XREF: sub_4E031:loc_4E055P
			; sub_4EC17:loc_4EC7CP
			; sub_4F1AB:loc_4F1D9P
			; sub_4F44D+175P
			; idk_HoF_s565F2+61P
push	ds
push	es
push	si
push	di
mov	ax, 1

loc_1E6A6:		; Integer Subtraction
sub	ax, [idk_VGA_w35ED6]
mov	ah, al

loc_1E6AC:		; Logical Exclusive OR
xor	al, al
shl	ax, 1		; Shift	Logical	Left

loc_1E6B0:		; Shift	Logical	Left
shl	ax, 1
add	ax, 0A000h	; Add
mov	es, ax
mov	ax, 0A800h

loc_1E6BA:
mov	ds, ax
assume ds:nothing
sub	si, si		; Integer Subtraction

loc_1E6BE:		; Integer Subtraction
sub	di, di
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 0Fh
out	dx, al		; EGA port: sequencer data register
mov	ax, 8
mov	dx, 3CEh

loc_1E6D0:		; EGA: graph 1 and 2 addr reg:
out	dx, al		; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1

loc_1E6D2:		; Logical Exclusive OR
xor	al, al
out	dx, al		; EGA port: graphics controller	data register
mov	cx, 3E80h
rep movsb		; Move Byte(s) from String to String

loc_1E6DA:
mov	al, 0FFh
out	dx, al		; EGA port: graphics controller	data register
pop	di
pop	si
pop	es

loc_1E6E0:
pop	ds
assume ds:dseg
retf			; Return Far from Procedure
endp sub_1E69F




proc sub_1E6E2 far	; CODE XREF: sub_56450+7EP
push	ds
push	es
push	si
push	di
mov	ax, 1

loc_1E6E9:		; Integer Subtraction
sub	ax, [idk_VGA_w35ED6]
mov	ah, al

loc_1E6EF:		; Logical Exclusive OR
xor	al, al
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left

loc_1E6F5:		; Add
add	ax, 0A000h
mov	ds, ax
mov	bx, 0AC00h
mov	es, bx
assume es:nothing

loc_1E6FF:		; Integer Subtraction
sub	si, si
sub	di, di		; Integer Subtraction
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, 0Fh
out	dx, al		; EGA port: sequencer data register
mov	ax, 8
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; bit mask
			; Bits 0-7 select bits to be masked in all planes

loc_1E714:		; Increment by 1
inc	dx
xor	al, al		; Logical Exclusive OR
out	dx, al		; EGA port: graphics controller	data register
mov	cx, 3E80h
rep movsb		; Move Byte(s) from String to String
mov	al, 0FFh
out	dx, al		; EGA port: graphics controller	data register
pop	di
pop	si
pop	es
assume es:nothing
pop	ds
retf			; Return Far from Procedure
endp sub_1E6E2

push	ds
push	es
push	si

loc_1E728:
push	di
mov	ax, 1

loc_1E72C:		; Integer Subtraction
sub	ax, [idk_VGA_w35ED6]
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left

loc_1E738:		; Add
add	ax, 0A000h
mov	es, ax
mov	ax, 0AC00h
mov	ds, ax
assume ds:nothing

loc_1E742:		; Integer Subtraction
sub	si, si
sub	di, di		; Integer Subtraction
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_1E74C:		; Increment by 1
inc	dx
mov	al, 0Fh
out	dx, al		; EGA port: sequencer data register
mov	ax, 8

loc_1E753:
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1

loc_1E758:		; Logical Exclusive OR
xor	al, al
out	dx, al		; EGA port: graphics controller	data register
mov	cx, 3E80h

loc_1E75E:		; Move Byte(s) from String to String
rep movsb

loc_1E760:
mov	al, 0FFh

loc_1E762:		; EGA port: graphics controller	data register
out	dx, al
pop	di
pop	si
pop	es
pop	ds
assume ds:dseg
retf			; Return Far from Procedure
push	bp
mov	bp, sp
push	ds
push	es
push	si

loc_1E76E:
push	di
mov	ax, [g_ptrVideoRamBuffer]

loc_1E772:
mov	es, ax

loc_1E774:
mov	ax, [bp+6]
mov	ds, ax
mov	dx, 3C5h

loc_1E77C:
mov	al, 1
out	dx, al		; EGA port: sequencer data register

loc_1E77F:		; Integer Subtraction
sub	si, si
sub	di, di		; Integer Subtraction

loc_1E783:
mov	cx, 1F40h

loc_1E786:		; Move Byte(s) from String to String
rep movsw

loc_1E788:
mov	al, 2

loc_1E78A:		; EGA port: sequencer data register
out	dx, al

loc_1E78B:		; Integer Subtraction
sub	di, di

loc_1E78D:
mov	cx, 1F40h

loc_1E790:		; Move Byte(s) from String to String
rep movsw

loc_1E792:
mov	al, 4

loc_1E794:		; EGA port: sequencer data register
out	dx, al

loc_1E795:		; Integer Subtraction
sub	di, di

loc_1E797:
mov	cx, 1F40h

loc_1E79A:		; Move Byte(s) from String to String
rep movsw

loc_1E79C:
mov	al, 8

loc_1E79E:		; EGA port: sequencer data register
out	dx, al

loc_1E79F:		; Integer Subtraction
sub	di, di

loc_1E7A1:
mov	cx, 1F40h

loc_1E7A4:		; Move Byte(s) from String to String
rep movsw

loc_1E7A6:
pop	di

loc_1E7A7:
pop	si

loc_1E7A8:
pop	es

loc_1E7A9:
pop	ds

loc_1E7AA:
pop	bp

locret_1E7AB:		; Return Far from Procedure
retf
ends seg026


; Segment type:	Pure code
segment	seg027 byte public 'CODE' use16
assume cs:seg027
;org 0Ch
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_1E7AC far	; CODE XREF: sub_1F655+BCP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp

loc_1E7AD:
mov	bp, sp

loc_1E7AF:
push	si

loc_1E7B0:
push	di
push	es

loc_1E7B2:
push	ds

loc_1E7B3:
mov	dx, 3C4h

loc_1E7B6:
mov	al, 2

loc_1E7B8:		; EGA: sequencer address reg
out	dx, al		; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_1E7B9:
mov	ax, [bp+arg_2]

loc_1E7BC:
mov	bx, ax

loc_1E7BE:		; Shift	Logical	Left
shl	ax, 1

loc_1E7C0:		; Shift	Logical	Left
shl	ax, 1

loc_1E7C2:		; Add
add	ax, bx

loc_1E7C4:		; Add
add	ax, [g_ptrVideoRamBuffer]

loc_1E7C8:
mov	es, ax

loc_1E7CA:
mov	ax, [bp+arg_0]

loc_1E7CD:
mov	bx, ax

loc_1E7CF:		; Shift	Logical	Right
shr	bx, 1

loc_1E7D1:		; Shift	Logical	Right
shr	bx, 1

loc_1E7D3:
mov	di, bx

loc_1E7D5:		; Logical AND
and	ax, 3

loc_1E7D8:
mov	si, 4372h

loc_1E7DB:		; Add
add	si, ax

loc_1E7DD:		; Load String
lodsb

loc_1E7DE:
mov	ah, al

loc_1E7E0:
mov	si, [bp+arg_6]

loc_1E7E3:
mov	cx, [bp+arg_4]

loc_1E7E6:
mov	bx, [bp+arg_8]

loc_1E7E9:
mov	ds, bx

loc_1E7EB:
mov	bx, cx

loc_1E7ED:		; CODE XREF: sub_1E7AC:loc_1E840j
			; sub_1E7AC:loc_1E8A3j
push	di

loc_1E7EE:
mov	dx, 3C5h

loc_1E7F1:
mov	al, ah
out	dx, al		; EGA port: sequencer data register

loc_1E7F4:		; Load String
lodsb
cmp	al, 0FFh	; Compare Two Operands

loc_1E7F7:		; Jump if Zero (ZF=1)
jz	short loc_1E832
mov	dh, al
lodsb			; Load String

loc_1E7FC:
mov	dl, al

loc_1E7FE:		; Compare Two Operands
cmp	dh, 0

loc_1E801:		; Jump if Sign (SF=1)
js	short loc_1E842

loc_1E803:		; CODE XREF: sub_1E7AC:loc_1E830j
mov	cl, [si+1]

loc_1E806:		; Logical Exclusive OR
xor	ch, ch

loc_1E808:
mov	al, cl
shl	cx, 1		; Shift	Logical	Left

loc_1E80C:		; Shift	Logical	Left
shl	cx, 1
add	cl, al		; Add

loc_1E810:		; Add with Carry
adc	ch, 0

loc_1E813:		; Shift	Logical	Left
shl	cx, 1

loc_1E815:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left

loc_1E819:		; Shift	Logical	Left
shl	cx, 1

loc_1E81B:		; Add
add	di, cx
lodsb			; Load String

loc_1E81E:
mov	cl, al

loc_1E820:		; Logical Exclusive OR
xor	ch, ch
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1E827:		; CODE XREF: sub_1E7AC:loc_1E82Bj
movsb			; Move Byte(s) from String to String

loc_1E828:		; Add
add	di, 4Fh	; 'O'

loc_1E82B:		; Loop while CX	!= 0
loop	loc_1E827

loc_1E82D:		; Compare Two Operands
cmp	dx, 1

loc_1E830:		; Jump if Not Sign (SF=0)
jns	short loc_1E803

loc_1E832:		; CODE XREF: sub_1E7AC:loc_1E7F7j
			; sub_1E7AC+CEj
pop	di
dec	bx		; Decrement by 1
jz	short loc_1E8A6	; Jump if Zero (ZF=1)

loc_1E836:		; Shift	Logical	Left
shl	ah, 1

loc_1E838:		; Compare Two Operands
cmp	ah, 9

loc_1E83B:		; Jump if Sign (SF=1)
js	short loc_1E840

loc_1E83D:
mov	ah, 1

loc_1E83F:		; Increment by 1
inc	di

loc_1E840:		; CODE XREF: sub_1E7AC:loc_1E83Bj
jmp	short loc_1E7ED	; Jump

loc_1E842:		; CODE XREF: sub_1E7AC:loc_1E801j
and	dx, 7FFFh	; Logical AND

loc_1E846:		; CODE XREF: sub_1E7AC+CCj
			; sub_1E7AC:loc_1E893j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR

loc_1E84B:
mov	al, cl

loc_1E84D:		; Shift	Logical	Left
shl	cx, 1

loc_1E84F:		; Shift	Logical	Left
shl	cx, 1
add	cl, al		; Add

loc_1E853:		; Add with Carry
adc	ch, 0
shl	cx, 1		; Shift	Logical	Left

loc_1E858:		; Shift	Logical	Left
shl	cx, 1

loc_1E85A:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left

loc_1E85E:		; Add
add	di, cx

loc_1E860:		; Load String
lodsb
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1
dec	dx		; Decrement by 1

loc_1E867:		; Decrement by 1
dec	dx

loc_1E868:		; Integer Subtraction
sub	dx, cx

loc_1E86A:		; CODE XREF: sub_1E7AC:loc_1E873j
			; sub_1E7AC+E2j
lodsb			; Load String

loc_1E86B:		; Compare Two Operands
cmp	al, 0E0h ; ''

loc_1E86D:		; Jump if Not Below (CF=0)
jnb	short loc_1E87C

loc_1E86F:		; Store	String
stosb

loc_1E870:		; Add
add	di, 4Fh	; 'O'

loc_1E873:		; Loop while CX	!= 0
loop	loc_1E86A

loc_1E875:		; Compare Two Operands
cmp	dx, 1
jns	short loc_1E846	; Jump if Not Sign (SF=0)
jmp	short loc_1E832	; Jump

loc_1E87C:		; CODE XREF: sub_1E7AC:loc_1E86Dj
and	al, 1Fh		; Logical AND

loc_1E87E:		; Increment by 1
inc	al

loc_1E880:
push	cx
mov	cl, al

loc_1E883:		; Logical Exclusive OR
xor	ch, ch

loc_1E885:		; Load String
lodsb

loc_1E886:		; CODE XREF: sub_1E7AC:loc_1E88Aj
stosb			; Store	String

loc_1E887:		; Add
add	di, 4Fh	; 'O'

loc_1E88A:		; Loop while CX	!= 0
loop	loc_1E886
pop	cx

loc_1E88D:		; Decrement by 1
dec	cx
loop	loc_1E86A	; Loop while CX	!= 0

loc_1E890:		; Compare Two Operands
cmp	dx, 1

loc_1E893:		; Jump if Not Sign (SF=0)
jns	short loc_1E846
pop	di
dec	bx		; Decrement by 1

loc_1E897:		; Jump if Zero (ZF=1)
jz	short loc_1E8A6

loc_1E899:		; Shift	Logical	Left
shl	ah, 1

loc_1E89B:		; Compare Two Operands
cmp	ah, 9

loc_1E89E:		; Jump if Sign (SF=1)
js	short loc_1E8A3

loc_1E8A0:
mov	ah, 1
inc	di		; Increment by 1

loc_1E8A3:		; CODE XREF: sub_1E7AC:loc_1E89Ej
jmp	loc_1E7ED	; Jump

loc_1E8A6:		; CODE XREF: sub_1E7AC+88j
			; sub_1E7AC:loc_1E897j
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1E7AC



; Attributes: bp-based frame

proc sub_1E8AC far	; CODE XREF: sub_1F655+CEP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	si

loc_1E8B0:
push	di
push	es
push	ds
mov	ax, [bp+arg_2]
mov	bx, ax

loc_1E8B8:		; Shift	Logical	Left
shl	ax, 1
shl	ax, 1		; Shift	Logical	Left

loc_1E8BC:		; Add
add	ax, bx

loc_1E8BE:		; Add
add	ax, [g_ptrVideoRamBuffer]
mov	es, ax

loc_1E8C4:
mov	ax, [bp+arg_0]

loc_1E8C7:
mov	bx, ax

loc_1E8C9:		; Shift	Logical	Right
shr	bx, 1
shr	bx, 1		; Shift	Logical	Right

loc_1E8CD:
mov	di, bx

loc_1E8CF:		; Logical AND
and	ax, 3
mov	bl, al
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
mov	si, 4372h

loc_1E8DF:		; Add
add	si, ax
lodsb			; Load String
mov	ah, al
or	ah, bl		; Logical Inclusive OR
mov	si, [bp+arg_6]
mov	cx, [bp+arg_4]

loc_1E8EC:
mov	bx, [bp+arg_8]
mov	ds, bx
mov	bx, cx

loc_1E8F3:		; CODE XREF: sub_1E8AC+C9j
push	di

loc_1E8F4:
mov	dx, 3CEh
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_1E8FB:
mov	al, ah

loc_1E8FD:		; Shift	Logical	Right
shr	al, 1

loc_1E8FF:		; Shift	Logical	Right
shr	al, 1
shr	al, 1		; Shift	Logical	Right
shr	al, 1		; Shift	Logical	Right

loc_1E905:		; EGA port: graphics controller	data register
out	dx, al

loc_1E906:
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, ah

loc_1E90F:		; Logical AND
and	al, 0Fh

loc_1E911:		; EGA port: sequencer data register
out	dx, al
lodsb			; Load String

loc_1E913:		; Compare Two Operands
cmp	al, 0FFh
jz	short loc_1E958	; Jump if Zero (ZF=1)
mov	dh, al
lodsb			; Load String
mov	dl, al

loc_1E91C:		; Compare Two Operands
cmp	dh, 0

loc_1E91F:		; Jump if Not Sign (SF=0)
jns	short loc_1E924

loc_1E921:		; Jump
jmp	loc_1E9B5

loc_1E924:		; CODE XREF: sub_1E8AC:loc_1E91Fj
			; sub_1E8AC+AAj
			; sub_1E8AC+106j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR
mov	al, cl

loc_1E92B:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_1E93C:		; Add
add	di, cx
lodsb			; Load String
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1

loc_1E944:		; Decrement by 1
dec	dx
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1E948:		; CODE XREF: sub_1E8AC:loc_1E951j
			; sub_1E8AC+FFj
lodsb			; Load String
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_1E97E	; Jump if Not Below (CF=0)
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add

loc_1E951:		; Loop while CX	!= 0
loop	loc_1E948
cmp	dx, 1		; Compare Two Operands
jns	short loc_1E924	; Jump if Not Sign (SF=0)

loc_1E958:		; CODE XREF: sub_1E8AC+69j
			; sub_1E8AC+104j
			; sub_1E8AC+145j
			; sub_1E8AC:loc_1EA2Ej
			; sub_1E8AC+1A2j
			; sub_1E8AC:loc_1EA8Fj
pop	di
dec	bx		; Decrement by 1
jz	short loc_1E978	; Jump if Zero (ZF=1)

loc_1E95C:
mov	cl, ah

loc_1E95E:		; Logical AND
and	cl, 0F0h
add	cl, 10h		; Add
and	ah, 0Fh		; Logical AND
shl	ah, 1		; Shift	Logical	Left

loc_1E969:		; Compare Two Operands
cmp	ah, 9
js	short loc_1E973	; Jump if Sign (SF=1)
mov	cl, 0

loc_1E970:
mov	ah, 1

loc_1E972:		; Increment by 1
inc	di

loc_1E973:		; CODE XREF: sub_1E8AC+C0j
or	ah, cl		; Logical Inclusive OR
jmp	loc_1E8F3	; Jump

loc_1E978:		; CODE XREF: sub_1E8AC+AEj
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1E97E:		; CODE XREF: sub_1E8AC+9Fj
sub	al, 0E8h ; ''  ; Integer Subtraction

loc_1E980:
push	si
push	ds
mov	si, seg	dseg

loc_1E985:
mov	ds, si
mov	si, ax
and	si, 0FFh	; Logical AND

loc_1E98D:		; Shift	Logical	Left
shl	si, 1
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left

loc_1E993:		; Shift	Logical	Left
shl	si, 1
add	si, [idk_FontsLbx1_6144B] ; Add
mov	ds, si
mov	al, [es:di]

loc_1E99E:
mov	si, ax

loc_1E9A0:		; Logical AND
and	si, 0FFh
lodsb			; Load String
pop	ds
pop	si
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1E948	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
js	short loc_1E958	; Jump if Sign (SF=1)
jmp	loc_1E924	; Jump

loc_1E9B5:		; CODE XREF: sub_1E8AC:loc_1E921j
			; sub_1E8AC+180j
and	dx, 7FFFh	; Logical AND

loc_1E9B9:		; CODE XREF: sub_1E8AC:loc_1E9EFj
			; sub_1E8AC:loc_1EA51j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR
mov	al, cl

loc_1E9C0:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_1E9CD:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left

loc_1E9D1:		; Add
add	di, cx
lodsb			; Load String
mov	cl, al

loc_1E9D6:		; Logical Exclusive OR
xor	ch, ch
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1E9DD:		; CODE XREF: sub_1E8AC+13Ej
			; sub_1E8AC+17Bj
			; sub_1E8AC:loc_1EA47j
			; sub_1E8AC+1DBj
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands

loc_1E9E0:		; Jump if Not Below (CF=0)
jnb	short loc_1EA31
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_1E9FA	; Jump if Not Below (CF=0)
stosb			; Store	String

loc_1E9E7:		; Add
add	di, 4Fh	; 'O'
loop	loc_1E9DD	; Loop while CX	!= 0

loc_1E9EC:		; Compare Two Operands
cmp	dx, 1

loc_1E9EF:		; Jump if Not Sign (SF=0)
jns	short loc_1E9B9
jmp	loc_1E958	; Jump
pop	ds

loc_1E9F5:
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_1E9FA:		; CODE XREF: sub_1E8AC+138j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds

loc_1E9FE:
mov	si, seg	dseg
mov	ds, si
mov	si, ax
and	si, 0FFh	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
add	si, [idk_FontsLbx1_6144B] ; Add

loc_1EA15:
mov	ds, si
mov	al, [es:di]
mov	si, ax

loc_1EA1C:		; Logical AND
and	si, 0FFh
lodsb			; Load String
pop	ds
pop	si
stosb			; Store	String

loc_1EA24:		; Add
add	di, 4Fh	; 'O'
loop	loc_1E9DD	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_1E9B5	; Jump if Not Sign (SF=0)

loc_1EA2E:		; Jump
jmp	loc_1E958

loc_1EA31:		; CODE XREF: sub_1E8AC:loc_1E9E0j
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
push	cx
mov	cl, al
xor	ch, ch		; Logical Exclusive OR

loc_1EA3A:		; Load String
lodsb
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_1EA54	; Jump if Not Below (CF=0)

loc_1EA3F:		; CODE XREF: sub_1E8AC+197j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1EA3F	; Loop while CX	!= 0
pop	cx
dec	cx		; Decrement by 1

loc_1EA47:		; Loop while CX	!= 0
loop	loc_1E9DD

loc_1EA49:		; Compare Two Operands
cmp	dx, 1
jns	short loc_1EA51	; Jump if Not Sign (SF=0)
jmp	loc_1E958	; Jump

loc_1EA51:		; CODE XREF: sub_1E8AC+1A0j
			; sub_1E8AC+1E1j
jmp	loc_1E9B9	; Jump

loc_1EA54:		; CODE XREF: sub_1E8AC+191j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds
mov	si, seg	dseg
mov	ds, si

loc_1EA5D:
mov	si, ax
and	si, 0FFh	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
add	si, [idk_FontsLbx1_6144B] ; Add
mov	ds, si

loc_1EA71:		; CODE XREF: sub_1E8AC:loc_1EA7Ej
mov	al, [es:di]
mov	si, ax

loc_1EA76:		; Logical AND
and	si, 0FFh
movsb			; Move Byte(s) from String to String
add	di, 4Fh	; 'O'   ; Add

loc_1EA7E:		; Loop while CX	!= 0
loop	loc_1EA71
pop	ds
pop	si
pop	cx
dec	cx		; Decrement by 1
dec	cx		; Decrement by 1
jz	short loc_1EA8A	; Jump if Zero (ZF=1)
jmp	loc_1E9DD	; Jump

loc_1EA8A:		; CODE XREF: sub_1E8AC+1D9j
cmp	dx, 1		; Compare Two Operands
jns	short loc_1EA51	; Jump if Not Sign (SF=0)

loc_1EA8F:		; Jump
jmp	loc_1E958
endp sub_1E8AC

pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
word_1EA98 dw 0		; DATA XREF: sub_1EA9E:loc_1EB13w
			; sub_1EC61:loc_1EC64r
			; sub_1EC61:loc_1EC6Cw
word_1EA9A dw 0		; DATA XREF: sub_1EA9E:loc_1EB2Dw
			; sub_1EC61:loc_1EC71r
word_1EA9C dw 0		; DATA XREF: sub_1EA9E+11w
			; sub_1EA9E:loc_1EB94r
			; sub_1EC88:loc_1ECCAr


; Attributes: bp-based frame

proc sub_1EA9E far	; CODE XREF: sub_1F655+E0P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp

loc_1EA9F:
mov	bp, sp
push	si

loc_1EAA2:
push	di
push	es
push	ds
mov	ax, [bp+arg_4]
mov	ds, ax

loc_1EAAA:
mov	es, ax
mov	ax, [LibMalloc_w31D10]
mov	[cs:word_1EA9C], ax
mov	si, 0Ah
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
mov	dx, ax
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
mov	bx, ax
lodsw			; Load String
mov	si, ax
mov	di, si
push	dx
push	bx
call	sub_163FC	; Call Procedure
add	sp, 4		; Add
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg_6]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add

loc_1EADD:		; Add
add	si, 12h
mov	ax, [EMM_PageFrameSegmentAddress]
mov	ds, ax
lodsw			; Load String
mov	dx, ax

loc_1EAE8:		; Load String
lodsw
inc	dx		; Increment by 1
adc	ax, 0		; Add with Carry

loc_1EAED:		; Shift	Logical	Left
shl	dx, 1

loc_1EAEF:		; Rotate Through Carry Left
rcl	ax, 1
shl	dx, 1		; Shift	Logical	Left
rcl	ax, 1		; Rotate Through Carry Left
shr	dx, 1		; Shift	Logical	Right
shr	dx, 1		; Shift	Logical	Right
add	al, [es:0Bh]	; Add

loc_1EAFE:		; Add with Carry
adc	ah, 0
add	dx, [es:0Ch]	; Add
cmp	dx, 0C000h	; Compare Two Operands
jb	short loc_1EB13	; Jump if Below	(CF=1)
sub	dx, 0C000h	; Integer Subtraction

loc_1EB10:		; Increment by 1
inc	ax
inc	ax		; Increment by 1
inc	ax		; Increment by 1

loc_1EB13:		; CODE XREF: sub_1EA9E+6Cj
mov	[cs:word_1EA98], ax
mov	bx, 11h
add	bx, di		; Add
mov	bl, [bx]

loc_1EB1E:		; Logical Exclusive OR
xor	bh, bh
mov	di, bx
mov	si, dx

loc_1EB24:
mov	bx, ax

loc_1EB26:
mov	dl, [es:0Ah]
xor	dh, dh		; Logical Exclusive OR

loc_1EB2D:
mov	[cs:word_1EA9A], dx
push	bx
push	dx
mov	ax, 4400h
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	ax, 4401h
pop	dx
pop	bx
inc	bx		; Increment by 1

loc_1EB3F:		;  - LIM EMS - MAP MEMORY
int	67h		; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
cmp	di, 0		; Compare Two Operands
jz	short loc_1EB5D	; Jump if Zero (ZF=1)
push	[bp+arg_4]
push	[bp+arg_2]

loc_1EB4C:
push	[bp+arg_0]
push	cs
call	near ptr sub_1EC88 ; Call Procedure
nop			; No Operation
add	sp, 6		; Add
pop	ds
pop	es
pop	di
pop	si
pop	bp

locret_1EB5C:		; Return Far from Procedure
retf

loc_1EB5D:		; CODE XREF: sub_1EA9E+A6j
mov	ax, seg	dseg
mov	ds, ax

loc_1EB62:
mov	dx, 3C4h

loc_1EB65:
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	ax, [bp+arg_2]
mov	bx, ax

loc_1EB6D:		; Shift	Logical	Left
shl	ax, 1

loc_1EB6F:		; Shift	Logical	Left
shl	ax, 1

loc_1EB71:		; Add
add	ax, bx
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax

loc_1EB79:
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
mov	di, bx
and	ax, 3		; Logical AND

loc_1EB87:
mov	bx, 4372h
add	bx, ax		; Add

loc_1EB8C:
mov	ah, [bx]

loc_1EB8E:
mov	bx, [EMM_PageFrameSegmentAddress]
mov	ds, bx

loc_1EB94:
mov	bx, [cs:word_1EA9C]

loc_1EB99:		; CODE XREF: sub_1EA9E:loc_1EBF5j
			; sub_1EA9E:loc_1EC58j
push	di

loc_1EB9A:		; Compare Two Operands
cmp	si, 0C000h
jb	short loc_1EBA3	; Jump if Below	(CF=1)

loc_1EBA0:		; Call Procedure
call	sub_1EC61

loc_1EBA3:		; CODE XREF: sub_1EA9E+100j
mov	dx, 3C5h
mov	al, ah
out	dx, al		; EGA port: sequencer data register
lodsb			; Load String
cmp	al, 0FFh	; Compare Two Operands
jz	short loc_1EBE7	; Jump if Zero (ZF=1)
mov	dh, al

loc_1EBB0:		; Load String
lodsb
mov	dl, al
cmp	dh, 0		; Compare Two Operands
js	short loc_1EBF7	; Jump if Sign (SF=1)

loc_1EBB8:		; CODE XREF: sub_1EA9E+147j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR

loc_1EBBD:
mov	al, cl
shl	cx, 1		; Shift	Logical	Left

loc_1EBC1:		; Shift	Logical	Left
shl	cx, 1

loc_1EBC3:		; Add
add	cl, al
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left

loc_1EBCA:		; Shift	Logical	Left
shl	cx, 1

loc_1EBCC:		; Shift	Logical	Left
shl	cx, 1

loc_1EBCE:		; Shift	Logical	Left
shl	cx, 1

loc_1EBD0:		; Add
add	di, cx
lodsb			; Load String

loc_1EBD3:
mov	cl, al

loc_1EBD5:		; Logical Exclusive OR
xor	ch, ch
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1EBDC:		; CODE XREF: sub_1EA9E+142j
movsb			; Move Byte(s) from String to String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1EBDC	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_1EBB8	; Jump if Not Sign (SF=0)

loc_1EBE7:		; CODE XREF: sub_1EA9E+10Ej
			; sub_1EA9E:loc_1EC2Fj
pop	di
dec	bx		; Decrement by 1
jz	short loc_1EC5B	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_1EBF5	; Jump if Sign (SF=1)
mov	ah, 1

loc_1EBF4:		; Increment by 1
inc	di

loc_1EBF5:		; CODE XREF: sub_1EA9E+152j
jmp	short loc_1EB99	; Jump

loc_1EBF7:		; CODE XREF: sub_1EA9E+118j
and	dx, 7FFFh	; Logical AND

loc_1EBFB:		; CODE XREF: sub_1EA9E:loc_1EC2Dj
			; sub_1EA9E+1AAj
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR
mov	al, cl
shl	cx, 1		; Shift	Logical	Left

loc_1EC04:		; Shift	Logical	Left
shl	cx, 1
add	cl, al		; Add
adc	ch, 0		; Add with Carry

loc_1EC0B:		; Shift	Logical	Left
shl	cx, 1

loc_1EC0D:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left

loc_1EC11:		; Shift	Logical	Left
shl	cx, 1
add	di, cx		; Add
lodsb			; Load String
mov	cl, al

loc_1EC18:		; Logical Exclusive OR
xor	ch, ch
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1

loc_1EC1D:		; Integer Subtraction
sub	dx, cx

loc_1EC1F:		; CODE XREF: sub_1EA9E+18Aj
			; sub_1EA9E+1A5j
lodsb			; Load String

loc_1EC20:		; Compare Two Operands
cmp	al, 0E0h ; ''
jnb	short loc_1EC31	; Jump if Not Below (CF=0)

loc_1EC24:		; Store	String
stosb

loc_1EC25:		; Add
add	di, 4Fh	; 'O'
loop	loc_1EC1F	; Loop while CX	!= 0

loc_1EC2A:		; Compare Two Operands
cmp	dx, 1

loc_1EC2D:		; Jump if Not Sign (SF=0)
jns	short loc_1EBFB

loc_1EC2F:		; Jump
jmp	short loc_1EBE7

loc_1EC31:		; CODE XREF: sub_1EA9E+184j
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
push	cx
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
lodsb			; Load String

loc_1EC3B:		; CODE XREF: sub_1EA9E+1A1j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1EC3B	; Loop while CX	!= 0
pop	cx
dec	cx		; Decrement by 1
loop	loc_1EC1F	; Loop while CX	!= 0

loc_1EC45:		; Compare Two Operands
cmp	dx, 1
jns	short loc_1EBFB	; Jump if Not Sign (SF=0)
pop	di
dec	bx		; Decrement by 1
jz	short loc_1EC5B	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left

loc_1EC50:		; Compare Two Operands
cmp	ah, 9
js	short loc_1EC58	; Jump if Sign (SF=1)
mov	ah, 1
inc	di		; Increment by 1

loc_1EC58:		; CODE XREF: sub_1EA9E+1B5j
jmp	loc_1EB99	; Jump

loc_1EC5B:		; CODE XREF: sub_1EA9E+14Bj
			; sub_1EA9E+1AEj
pop	ds

loc_1EC5C:
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_1EA9E




proc sub_1EC61 near	; CODE XREF: sub_1EA9E:loc_1EBA0p
			; sub_1EC88+4Ep
push	bx
mov	cx, ax

loc_1EC64:
mov	bx, [cs:word_1EA98]
inc	bx		; Increment by 1

loc_1EC6A:		; Increment by 1
inc	bx
inc	bx		; Increment by 1

loc_1EC6C:
mov	[cs:word_1EA98], bx

loc_1EC71:
mov	dx, [cs:word_1EA9A]
push	dx
push	bx
call	sub_163FC	; Call Procedure
add	sp, 4		; Add

loc_1EC80:		; Integer Subtraction
sub	si, 0C000h
mov	ax, cx
pop	bx
retn			; Return Near from Procedure
endp sub_1EC61



; Attributes: bp-based frame

proc sub_1EC88 far	; CODE XREF: sub_1EA9E+B2p

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp

loc_1EC8B:
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg_2]
mov	bx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add

loc_1EC9B:		; Add
add	ax, [g_ptrVideoRamBuffer]

loc_1EC9F:
mov	es, ax
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right

loc_1ECAA:
mov	di, bx
and	ax, 3		; Logical AND

loc_1ECAF:
mov	cl, al
shl	cl, 1		; Shift	Logical	Left
shl	cl, 1		; Shift	Logical	Left
shl	cl, 1		; Shift	Logical	Left
shl	cl, 1		; Shift	Logical	Left
mov	bx, offset unk_36082

loc_1ECBC:		; Add
add	bx, ax

loc_1ECBE:
mov	al, [bx]
mov	ah, al
or	ah, cl		; Logical Inclusive OR
mov	bx, [EMM_PageFrameSegmentAddress]
mov	ds, bx

loc_1ECCA:
mov	bx, [cs:word_1EA9C]

loc_1ECCF:		; CODE XREF: sub_1EC88+D2j
push	di
cmp	si, 0C000h	; Compare Two Operands
jb	short loc_1ECD9	; Jump if Below	(CF=1)
call	sub_1EC61	; Call Procedure

loc_1ECD9:		; CODE XREF: sub_1EC88+4Cj
mov	dx, GC_INDEX
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, ah
shr	al, 1		; Shift	Logical	Right
shr	al, 1		; Shift	Logical	Right

loc_1ECE6:		; Shift	Logical	Right
shr	al, 1
shr	al, 1		; Shift	Logical	Right
out	dx, al		; EGA port: graphics controller	data register
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, ah
and	al, 0Fh		; Logical AND

loc_1ECF6:		; EGA port: sequencer data register
out	dx, al
lodsb			; Load String

loc_1ECF8:		; Compare Two Operands
cmp	al, 0FFh
jz	short loc_1ED3D	; Jump if Zero (ZF=1)
mov	dh, al
lodsb			; Load String
mov	dl, al
cmp	dh, 0		; Compare Two Operands

loc_1ED04:		; Jump if Not Sign (SF=0)
jns	short loc_1ED09
jmp	loc_1ED96	; Jump

loc_1ED09:		; CODE XREF: sub_1EC88:loc_1ED04j
			; sub_1EC88+B3j
			; sub_1EC88+10Bj
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR
mov	al, cl
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_1ED1D:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
add	di, cx		; Add

loc_1ED23:		; Load String
lodsb
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1ED2D:		; CODE XREF: sub_1EC88:loc_1ED36j
			; sub_1EC88+104j
lodsb			; Load String
cmp	al, 0E8h ; ''  ; Compare Two Operands

loc_1ED30:		; Jump if Not Below (CF=0)
jnb	short loc_1ED5F
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add

loc_1ED36:		; Loop while CX	!= 0
loop	loc_1ED2D

loc_1ED38:		; Compare Two Operands
cmp	dx, 1
jns	short loc_1ED09	; Jump if Not Sign (SF=0)

loc_1ED3D:		; CODE XREF: sub_1EC88+72j
			; sub_1EC88:loc_1ED91j
			; sub_1EC88+14Aj
			; sub_1EC88+183j
			; sub_1EC88:loc_1EE2Bj
			; sub_1EC88:loc_1EE6Cj
pop	di
dec	bx		; Decrement by 1
jz	short loc_1ED5D	; Jump if Zero (ZF=1)
mov	cl, ah
and	cl, 0F0h	; Logical AND
add	cl, 10h		; Add
and	ah, 0Fh		; Logical AND

loc_1ED4C:		; Shift	Logical	Left
shl	ah, 1
cmp	ah, 9		; Compare Two Operands
js	short loc_1ED58	; Jump if Sign (SF=1)
mov	cl, 0
mov	ah, 1
inc	di		; Increment by 1

loc_1ED58:		; CODE XREF: sub_1EC88+C9j
or	ah, cl		; Logical Inclusive OR
jmp	loc_1ECCF	; Jump

loc_1ED5D:		; CODE XREF: sub_1EC88+B7j
pop	bp
retf			; Return Far from Procedure

loc_1ED5F:		; CODE XREF: sub_1EC88:loc_1ED30j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds

loc_1ED63:
mov	si, seg	dseg
mov	ds, si

loc_1ED68:
mov	si, ax
and	si, 0FFh	; Logical AND
shl	si, 1		; Shift	Logical	Left

loc_1ED70:		; Shift	Logical	Left
shl	si, 1

loc_1ED72:		; Shift	Logical	Left
shl	si, 1
shl	si, 1		; Shift	Logical	Left
add	si, [idk_FontsLbx1_6144B] ; Add
mov	ds, si

loc_1ED7C:
mov	al, [es:di]

loc_1ED7F:
mov	si, ax
and	si, 0FFh	; Logical AND
lodsb			; Load String
pop	ds
pop	si
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1ED2D	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_1ED91:		; Jump if Sign (SF=1)
js	short loc_1ED3D
jmp	loc_1ED09	; Jump

loc_1ED96:		; CODE XREF: sub_1EC88+7Ej
			; sub_1EC88:loc_1EE09j
and	dx, 7FFFh	; Logical AND

loc_1ED9A:		; CODE XREF: sub_1EC88+148j
			; sub_1EC88:loc_1EE2Ej
mov	cl, [si+1]

loc_1ED9D:		; Logical Exclusive OR
xor	ch, ch

loc_1ED9F:
mov	al, cl

loc_1EDA1:		; Shift	Logical	Left
shl	cx, 1

loc_1EDA3:		; Shift	Logical	Left
shl	cx, 1
add	cl, al		; Add

loc_1EDA7:		; Add with Carry
adc	ch, 0
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_1EDAE:		; Shift	Logical	Left
shl	cx, 1

loc_1EDB0:		; Shift	Logical	Left
shl	cx, 1

loc_1EDB2:		; Add
add	di, cx
lodsb			; Load String
mov	cl, al

loc_1EDB7:		; Logical Exclusive OR
xor	ch, ch
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_1EDBE:		; CODE XREF: sub_1EC88+143j
			; sub_1EC88+17Cj
			; sub_1EC88+19Cj
			; sub_1EC88:loc_1EE64j
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands
jnb	short loc_1EE0E	; Jump if Not Below (CF=0)

loc_1EDC3:		; Compare Two Operands
cmp	al, 0E8h ; ''

loc_1EDC5:		; Jump if Not Below (CF=0)
jnb	short loc_1EDD7
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1EDBE	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_1ED9A	; Jump if Not Sign (SF=0)
jmp	loc_1ED3D	; Jump
pop	bp
retf			; Return Far from Procedure

loc_1EDD7:		; CODE XREF: sub_1EC88:loc_1EDC5j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds
mov	si, seg	dseg
mov	ds, si
mov	si, ax

loc_1EDE2:		; Logical AND
and	si, 0FFh
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
add	si, [idk_FontsLbx1_6144B] ; Add

loc_1EDF2:
mov	ds, si
mov	al, [es:di]

loc_1EDF7:
mov	si, ax
and	si, 0FFh	; Logical AND
lodsb			; Load String
pop	ds
pop	si

loc_1EE00:		; Store	String
stosb
add	di, 4Fh	; 'O'   ; Add
loop	loc_1EDBE	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_1EE09:		; Jump if Not Sign (SF=0)
jns	short loc_1ED96
jmp	loc_1ED3D	; Jump

loc_1EE0E:		; CODE XREF: sub_1EC88+139j
and	al, 1Fh		; Logical AND

loc_1EE10:		; Increment by 1
inc	al
push	cx
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
lodsb			; Load String
cmp	al, 0E8h ; ''  ; Compare Two Operands

loc_1EE1A:		; Jump if Not Below (CF=0)
jnb	short loc_1EE31

loc_1EE1C:		; CODE XREF: sub_1EC88+198j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_1EE1C	; Loop while CX	!= 0
pop	cx
dec	cx		; Decrement by 1
loop	loc_1EDBE	; Loop while CX	!= 0

loc_1EE26:		; Compare Two Operands
cmp	dx, 1

loc_1EE29:		; Jump if Not Sign (SF=0)
jns	short loc_1EE2E

loc_1EE2B:		; Jump
jmp	loc_1ED3D

loc_1EE2E:		; CODE XREF: sub_1EC88:loc_1EE29j
			; sub_1EC88:loc_1EE6Aj
jmp	loc_1ED9A	; Jump

loc_1EE31:		; CODE XREF: sub_1EC88:loc_1EE1Aj
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds
mov	si, seg	dseg
mov	ds, si

loc_1EE3A:
mov	si, ax

loc_1EE3C:		; Logical AND
and	si, 0FFh

loc_1EE40:		; Shift	Logical	Left
shl	si, 1

loc_1EE42:		; Shift	Logical	Left
shl	si, 1
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left

loc_1EE48:		; Add
add	si, [idk_FontsLbx1_6144B]

loc_1EE4C:
mov	ds, si

loc_1EE4E:		; CODE XREF: sub_1EC88:loc_1EE5Bj
mov	al, [es:di]
mov	si, ax

loc_1EE53:		; Logical AND
and	si, 0FFh
movsb			; Move Byte(s) from String to String

loc_1EE58:		; Add
add	di, 4Fh	; 'O'

loc_1EE5B:		; Loop while CX	!= 0
loop	loc_1EE4E
pop	ds

loc_1EE5E:
pop	si
pop	cx
dec	cx		; Decrement by 1
dec	cx		; Decrement by 1

loc_1EE62:		; Jump if Zero (ZF=1)
jz	short loc_1EE67

loc_1EE64:		; Jump
jmp	loc_1EDBE

loc_1EE67:		; CODE XREF: sub_1EC88:loc_1EE62j
cmp	dx, 1		; Compare Two Operands

loc_1EE6A:		; Jump if Not Sign (SF=0)
jns	short loc_1EE2E

loc_1EE6C:		; Jump
jmp	loc_1ED3D

loc_1EE6F:
pop	bp

locret_1EE70:		; Return Far from Procedure
retf
endp sub_1EC88

ends seg027


; Segment type:	Pure code
segment	seg028 byte public 'CODE' use16
assume cs:seg028
;org 1
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_1EE71 far

var_2= word ptr	-2
arg_0= word ptr	 6
argOffset= dword ptr  8

push	bp

loc_1EE72:
mov	bp, sp

loc_1EE74:		; Integer Subtraction
sub	sp, 2

loc_1EE77:
push	si

loc_1EE78:
mov	si, [word ptr bp+argOffset]

loc_1EE7B:		; Logical Exclusive OR
xor	ax, ax

loc_1EE7D:
push	ax

loc_1EE7E:		; argOffset
push	si

loc_1EE7F:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset

loc_1EE84:
pop	cx
pop	cx

loc_1EE86:		; argPtrSrcBuf
push	ax

loc_1EE87:
mov	ax, 2

loc_1EE8A:
push	ax

loc_1EE8B:		; argOffset
push	si

loc_1EE8C:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx

loc_1EE92:
pop	cx

loc_1EE93:
mov	dx, ax

loc_1EE95:
pop	ax

loc_1EE96:		; Signed Multiply
imul	dx

loc_1EE98:		; Add
add	ax, 10h

loc_1EE9B:
mov	[bp+var_2], ax

loc_1EE9E:		; int
push	[bp+var_2]
push	si		; int

loc_1EEA2:		; Logical Exclusive OR
xor	ax, ax
push	ax		; int

loc_1EEA5:		; int
push	[bp+arg_0]
xor	ax, ax		; Logical Exclusive OR

loc_1EEAA:		; int
push	ax

loc_1EEAB:		; Call Procedure
call	idk_Mov_Sb_Sw_or_0

loc_1EEB0:		; Add
add	sp, 0Ah
pop	si

loc_1EEB4:
mov	sp, bp

loc_1EEB6:
pop	bp
retf			; Return Far from Procedure
endp sub_1EE71



; Attributes: bp-based frame

proc hrmStoreSWSB far	; CODE XREF: sub_1D40D+1CP
			; seg024:04E8P
			; sub_21829+61p
			; sub_4F44D+10EP
			; sub_56240+78P
			; sub_56413+2DP

var2_StringLength= word	ptr -2
argValue= word ptr  6
arg_2= word ptr	 8
argSegment= word ptr  0Ah

push	bp

loc_1EEB9:
mov	bp, sp

loc_1EEBB:		; Integer Subtraction
sub	sp, 2

loc_1EEBE:
push	si

loc_1EEBF:
push	di

loc_1EEC0:
mov	si, [bp+argValue]
push	si		; argValue
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
push	[bp+argSegment]	; argSegment

loc_1EECA:		; Call Procedure
call	fncStoSW

loc_1EECF:		; Add
add	sp, 6

loc_1EED2:		; argValue
push	[bp+arg_2]

loc_1EED5:
mov	ax, 2

loc_1EED8:		; argOffset
push	ax

loc_1EED9:		; argSegment
push	[bp+argSegment]

loc_1EEDC:		; Call Procedure
call	fncStoSW
add	sp, 6		; Add
mov	ax, 0DE0Ah
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR

loc_1EEF9:		; argValue
push	ax
mov	ax, 6
push	ax		; argOffset

loc_1EEFE:		; argSegment
push	[bp+argSegment]

loc_1EF01:		; Call Procedure
call	fncStoSW
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax		; argValue

loc_1EF0C:
mov	ax, 8
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, si
imul	[bp+arg_2]	; Signed Multiply

loc_1EF20:
mov	[bp+var2_StringLength],	ax
push	es

loc_1EF24:
push	di

loc_1EF25:
mov	ax, [bp+argSegment]

loc_1EF28:
mov	es, ax

loc_1EF2A:
mov	di, 10h

loc_1EF2D:
mov	al, 0
mov	cx, [bp+var2_StringLength]
rep stosb		; Store	String
pop	di
pop	es
pop	di

loc_1EF37:
pop	si

loc_1EF38:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp hrmStoreSWSB



; Attributes: bp-based frame

proc sub_1EF3C far

var_16=	dword ptr -16h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
argOffset= dword ptr  0Eh

push	bp

loc_1EF3D:
mov	bp, sp
sub	sp, 16h		; Integer Subtraction
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_1EF47:		; argOffset
push	[word ptr bp+argOffset]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx

loc_1EF50:
pop	cx

loc_1EF51:
mov	[bp+var_2], ax

loc_1EF54:
mov	ax, 2

loc_1EF57:
push	ax

loc_1EF58:		; argOffset
push	[word ptr bp+argOffset]

loc_1EF5B:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset

loc_1EF60:
pop	cx

loc_1EF61:
pop	cx
mov	[bp+var_4], ax

loc_1EF65:		; Compare Two Operands
cmp	[bp+arg_0], 0

loc_1EF69:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1EF70

loc_1EF6B:
mov	[bp+arg_0], 0

loc_1EF70:		; CODE XREF: sub_1EF3C:loc_1EF69j
mov	ax, [bp+arg_4]

loc_1EF73:		; Compare Two Operands
cmp	ax, [bp+var_2]
jle	short loc_1EF7E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_2]

loc_1EF7B:
mov	[bp+arg_4], ax

loc_1EF7E:		; CODE XREF: sub_1EF3C+3Aj
mov	ax, [bp+arg_0]
cmp	ax, [bp+arg_4]	; Compare Two Operands
jle	short loc_1EFA4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+arg_4]	; Load Effective Address
push	ax

loc_1EF8A:		; Load Effective Address
lea	ax, [bp+arg_0]
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_1EF95:		; Load Effective Address
lea	ax, [bp+arg_6]

loc_1EF98:
push	ax
lea	ax, [bp+arg_2]	; Load Effective Address
push	ax

loc_1EF9D:		; Call Procedure
call	sub_1CFBD
pop	cx
pop	cx

loc_1EFA4:		; CODE XREF: sub_1EF3C+48j
mov	ax, [bp+arg_2]
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR
mov	ax, 3E8h

loc_1EFAF:
pop	cx

loc_1EFB0:
pop	bx
call	LXMUL@		; Call Procedure
mov	[bp+var_C], dx

loc_1EFB9:
mov	[bp+var_E], ax
mov	ax, [bp+arg_4]

loc_1EFBF:		; Compare Two Operands
cmp	ax, [bp+arg_0]
jnz	short loc_1EFD0	; Jump if Not Zero (ZF=0)

loc_1EFC4:
mov	[bp+var_8], 0

loc_1EFC9:
mov	[bp+var_A], 0

loc_1EFCE:		; Jump
jmp	short loc_1EFFB

loc_1EFD0:		; CODE XREF: sub_1EF3C+86j
mov	ax, [bp+arg_4]

loc_1EFD3:		; Integer Subtraction
sub	ax, [bp+arg_0]

loc_1EFD6:		; AX ->	DX:AX (with sign)
cwd
push	dx
push	ax

loc_1EFD9:
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR
mov	ax, 3E8h
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax

loc_1EFF0:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E

loc_1EFF5:
mov	[bp+var_8], dx

loc_1EFF8:
mov	[bp+var_A], ax

loc_1EFFB:		; CODE XREF: sub_1EF3C:loc_1EFCEj
mov	ax, [word ptr bp+argOffset]

loc_1EFFE:		; Increment by 1
inc	ax
push	ax

loc_1F000:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr bp+var_16+2],	dx
mov	[word ptr bp+var_16], ax

loc_1F00C:
mov	ax, [bp+var_4]
imul	[bp+arg_0]	; Signed Multiply
mov	di, ax
mov	ax, [bp+arg_0]
mov	[bp+var_6], ax

loc_1F01A:		; Jump
jmp	loc_1F12E

loc_1F01D:		; CODE XREF: sub_1EF3C+1FAj
xor	ax, ax		; Logical Exclusive OR

loc_1F01F:
mov	dx, 3E8h
push	ax
push	dx
push	[bp+var_C]
push	[bp+var_E]
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_10], ax
cmp	[bp+var_10], 0	; Compare Two Operands
jnz	short loc_1F03B	; Jump if Not Zero (ZF=0)
jmp	loc_1F11C	; Jump

loc_1F03B:		; CODE XREF: sub_1EF3C+FAj
cmp	[bp+var_10], 0	; Compare Two Operands

loc_1F03F:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1F0AD

loc_1F041:
mov	ax, [bp+var_4]

loc_1F044:		; Add
add	ax, [bp+var_10]

loc_1F047:
mov	[bp+var_12], ax

loc_1F04A:		; Compare Two Operands
cmp	[bp+var_12], 0
jle	short loc_1F08E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1F050:
mov	si, di
jmp	short loc_1F06A	; Jump

loc_1F054:		; CODE XREF: sub_1EF3C+135j
mov	ax, si
sub	ax, [bp+var_10]	; Integer Subtraction
les	bx, [bp+var_16]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
les	bx, [bp+var_16]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	[es:bx], al
inc	si		; Increment by 1

loc_1F06A:		; CODE XREF: sub_1EF3C+116j
mov	ax, di
add	ax, [bp+var_12]	; Add

loc_1F06F:		; Compare Two Operands
cmp	ax, si
jg	short loc_1F054	; Jump if Greater (ZF=0	& SF=OF)
mov	si, [bp+var_12]
jmp	short loc_1F087	; Jump

loc_1F078:		; CODE XREF: sub_1EF3C+14Ej
mov	bx, si
add	bx, di		; Add

loc_1F07C:
mov	es, [word ptr bp+var_16+2]
add	bx, [word ptr bp+var_16] ; Add
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_1F087:		; CODE XREF: sub_1EF3C+13Aj
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_1F078	; Jump if Less (SF!=OF)
jmp	short loc_1F0AB	; Jump

loc_1F08E:		; CODE XREF: sub_1EF3C+112j
cmp	[bp+var_12], 0	; Compare Two Operands
jge	short loc_1F0AB	; Jump if Greater or Equal (SF=OF)
mov	si, di
jmp	short loc_1F0A2	; Jump

loc_1F098:		; CODE XREF: sub_1EF3C:loc_1F0A9j
les	bx, [bp+var_16]	; Load Full Pointer to ES:xx
add	bx, si		; Add

loc_1F09D:
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_1F0A2:		; CODE XREF: sub_1EF3C+15Aj
mov	ax, di
add	ax, [bp+var_4]	; Add
cmp	ax, si		; Compare Two Operands

loc_1F0A9:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_1F098

loc_1F0AB:		; CODE XREF: sub_1EF3C+150j
			; sub_1EF3C+156j
jmp	short loc_1F11C	; Jump

loc_1F0AD:		; CODE XREF: sub_1EF3C:loc_1F03Fj
mov	ax, [bp+var_4]
sub	ax, [bp+var_10]	; Integer Subtraction
mov	[bp+var_12], ax

loc_1F0B6:		; Compare Two Operands
cmp	[bp+var_12], 0
jle	short loc_1F0FF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, di
add	ax, [bp+var_4]	; Add
dec	ax		; Decrement by 1
mov	si, ax
jmp	short loc_1F0DC	; Jump

loc_1F0C6:		; CODE XREF: sub_1EF3C+1A7j
mov	ax, si
sub	ax, [bp+var_10]	; Integer Subtraction
les	bx, [bp+var_16]	; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_1F0D0:
mov	al, [es:bx]
les	bx, [bp+var_16]	; Load Full Pointer to ES:xx

loc_1F0D6:		; Add
add	bx, si
mov	[es:bx], al
dec	si		; Decrement by 1

loc_1F0DC:		; CODE XREF: sub_1EF3C+188j
mov	ax, di
add	ax, [bp+var_10]	; Add
cmp	ax, si		; Compare Two Operands
jle	short loc_1F0C6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1F0E5:		; Logical Exclusive OR
xor	si, si
jmp	short loc_1F0F8	; Jump

loc_1F0E9:		; CODE XREF: sub_1EF3C:loc_1F0FBj
mov	bx, si
add	bx, di		; Add

loc_1F0ED:
mov	es, [word ptr bp+var_16+2]
add	bx, [word ptr bp+var_16] ; Add
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_1F0F8:		; CODE XREF: sub_1EF3C+1ABj
cmp	si, [bp+var_10]	; Compare Two Operands

loc_1F0FB:		; Jump if Less (SF!=OF)
jl	short loc_1F0E9
jmp	short loc_1F11C	; Jump

loc_1F0FF:		; CODE XREF: sub_1EF3C+17Ej
cmp	[bp+var_12], 0	; Compare Two Operands
jge	short loc_1F11C	; Jump if Greater or Equal (SF=OF)
mov	si, di
jmp	short loc_1F113	; Jump

loc_1F109:		; CODE XREF: sub_1EF3C+1DEj
les	bx, [bp+var_16]	; Load Full Pointer to ES:xx
add	bx, si		; Add

loc_1F10E:
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_1F113:		; CODE XREF: sub_1EF3C+1CBj
mov	ax, di
add	ax, [bp+var_4]	; Add
cmp	ax, si		; Compare Two Operands
jg	short loc_1F109	; Jump if Greater (ZF=0	& SF=OF)

loc_1F11C:		; CODE XREF: sub_1EF3C+FCj
			; sub_1EF3C:loc_1F0ABj
			; sub_1EF3C+1C1j
			; sub_1EF3C+1C7j
mov	ax, [bp+var_8]
mov	dx, [bp+var_A]

loc_1F122:		; Add
add	[bp+var_E], dx
adc	[bp+var_C], ax	; Add with Carry
add	di, [bp+var_4]	; Add

loc_1F12B:		; Increment by 1
inc	[bp+var_6]

loc_1F12E:		; CODE XREF: sub_1EF3C:loc_1F01Aj
mov	ax, [bp+var_6]
cmp	ax, [bp+arg_4]	; Compare Two Operands
jg	short loc_1F139	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_1F01D	; Jump

loc_1F139:		; CODE XREF: sub_1EF3C+1F8j
pop	di
pop	si

loc_1F13B:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1EF3C



; Attributes: bp-based frame

proc sub_1F13F far

var_E= dword ptr -0Eh
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
argOffset= dword ptr  8

push	bp
mov	bp, sp

loc_1F142:		; Integer Subtraction
sub	sp, 0Eh
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, [word ptr bp+argOffset]
inc	ax		; Increment by 1
push	ax

loc_1F16D:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2

loc_1F172:
pop	cx
mov	[word ptr bp+var_E+2], dx
mov	[word ptr bp+var_E], ax

loc_1F179:		; Logical Exclusive OR
xor	di, di

loc_1F17B:
mov	[bp+var_6], 0

loc_1F180:		; Jump
jmp	loc_1F27F

loc_1F183:		; CODE XREF: sub_1F13F+148j
mov	bx, [bp+arg_0]

loc_1F186:		; Add
add	bx, [bp+var_6]
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_8], ax
cmp	[bp+var_8], 0	; Compare Two Operands
jnz	short loc_1F198	; Jump if Not Zero (ZF=0)
jmp	loc_1F279	; Jump

loc_1F198:		; CODE XREF: sub_1F13F+54j
cmp	[bp+var_8], 0	; Compare Two Operands
jge	short loc_1F20A	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_4]
add	ax, [bp+var_8]	; Add

loc_1F1A4:
mov	[bp+var_A], ax
cmp	[bp+var_A], 0	; Compare Two Operands
jle	short loc_1F1EB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	si, di

loc_1F1AF:		; Jump
jmp	short loc_1F1C7

loc_1F1B1:		; CODE XREF: sub_1F13F+8Fj
mov	ax, si
sub	ax, [bp+var_8]	; Integer Subtraction
les	bx, [bp+var_E]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]

loc_1F1BE:		; Load Full Pointer to ES:xx
les	bx, [bp+var_E]
add	bx, si		; Add
mov	[es:bx], al
inc	si		; Increment by 1

loc_1F1C7:		; CODE XREF: sub_1F13F:loc_1F1AFj
mov	ax, di

loc_1F1C9:		; Add
add	ax, [bp+var_A]

loc_1F1CC:		; Compare Two Operands
cmp	ax, si
jg	short loc_1F1B1	; Jump if Greater (ZF=0	& SF=OF)
mov	si, [bp+var_A]
jmp	short loc_1F1E4	; Jump

loc_1F1D5:		; CODE XREF: sub_1F13F+A8j
mov	bx, si
add	bx, di		; Add
mov	es, [word ptr bp+var_E+2]

loc_1F1DC:		; Add
add	bx, [word ptr bp+var_E]
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_1F1E4:		; CODE XREF: sub_1F13F+94j
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_1F1D5	; Jump if Less (SF!=OF)
jmp	short loc_1F208	; Jump

loc_1F1EB:		; CODE XREF: sub_1F13F+6Cj
cmp	[bp+var_A], 0	; Compare Two Operands
jge	short loc_1F208	; Jump if Greater or Equal (SF=OF)
mov	si, di
jmp	short loc_1F1FF	; Jump

loc_1F1F5:		; CODE XREF: sub_1F13F+C7j
les	bx, [bp+var_E]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_1F1FF:		; CODE XREF: sub_1F13F+B4j
mov	ax, di
add	ax, [bp+var_4]	; Add
cmp	ax, si		; Compare Two Operands
jg	short loc_1F1F5	; Jump if Greater (ZF=0	& SF=OF)

loc_1F208:		; CODE XREF: sub_1F13F+AAj
			; sub_1F13F+B0j
jmp	short loc_1F279	; Jump

loc_1F20A:		; CODE XREF: sub_1F13F+5Dj
mov	ax, [bp+var_4]
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_A], ax
cmp	[bp+var_A], 0	; Compare Two Operands

loc_1F217:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_1F25C

loc_1F219:
mov	ax, di
add	ax, [bp+var_4]	; Add
dec	ax		; Decrement by 1
mov	si, ax
jmp	short loc_1F239	; Jump

loc_1F223:		; CODE XREF: sub_1F13F+101j
mov	ax, si
sub	ax, [bp+var_8]	; Integer Subtraction
les	bx, [bp+var_E]	; Load Full Pointer to ES:xx

loc_1F22B:		; Add
add	bx, ax
mov	al, [es:bx]
les	bx, [bp+var_E]	; Load Full Pointer to ES:xx

loc_1F233:		; Add
add	bx, si

loc_1F235:
mov	[es:bx], al
dec	si		; Decrement by 1

loc_1F239:		; CODE XREF: sub_1F13F+E2j
mov	ax, di

loc_1F23B:		; Add
add	ax, [bp+var_8]

loc_1F23E:		; Compare Two Operands
cmp	ax, si
jle	short loc_1F223	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_1F255	; Jump

loc_1F246:		; CODE XREF: sub_1F13F:loc_1F258j
mov	bx, si
add	bx, di		; Add

loc_1F24A:
mov	es, [word ptr bp+var_E+2]
add	bx, [word ptr bp+var_E]	; Add
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_1F255:		; CODE XREF: sub_1F13F+105j
cmp	si, [bp+var_8]	; Compare Two Operands

loc_1F258:		; Jump if Less (SF!=OF)
jl	short loc_1F246

loc_1F25A:		; Jump
jmp	short loc_1F279

loc_1F25C:		; CODE XREF: sub_1F13F:loc_1F217j
cmp	[bp+var_A], 0	; Compare Two Operands

loc_1F260:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1F279
mov	si, di
jmp	short loc_1F270	; Jump

loc_1F266:		; CODE XREF: sub_1F13F+138j
les	bx, [bp+var_E]	; Load Full Pointer to ES:xx
add	bx, si		; Add

loc_1F26B:
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_1F270:		; CODE XREF: sub_1F13F+125j
mov	ax, di
add	ax, [bp+var_4]	; Add
cmp	ax, si		; Compare Two Operands
jg	short loc_1F266	; Jump if Greater (ZF=0	& SF=OF)

loc_1F279:		; CODE XREF: sub_1F13F+56j
			; sub_1F13F:loc_1F208j
			; sub_1F13F:loc_1F25Aj
			; sub_1F13F:loc_1F260j
add	di, [bp+var_4]	; Add
inc	[bp+var_6]	; Increment by 1

loc_1F27F:		; CODE XREF: sub_1F13F:loc_1F180j
mov	ax, [bp+var_6]
cmp	ax, [bp+var_2]	; Compare Two Operands
jge	short loc_1F28A	; Jump if Greater or Equal (SF=OF)
jmp	loc_1F183	; Jump

loc_1F28A:		; CODE XREF: sub_1F13F+146j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1F13F



; Attributes: bp-based frame

proc sub_1F290 far

var_14=	word ptr -14h
var_12=	dword ptr -12h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
argOffset= dword ptr  8

push	bp
mov	bp, sp
sub	sp, 14h		; Integer Subtraction
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	di, ax

loc_1F2B8:
mov	ax, [word ptr bp+argOffset]
inc	ax		; Increment by 1
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr bp+var_12+2],	dx
mov	[word ptr bp+var_12], ax
mov	[bp+var_A], 0

loc_1F2CE:
mov	ax, [bp+var_2]
imul	di		; Signed Multiply
mov	[bp+var_14], ax
mov	[bp+var_4], 0

loc_1F2DB:		; Jump
jmp	loc_1F3EA

loc_1F2DE:		; CODE XREF: sub_1F290:loc_1F3EFj
mov	bx, [bp+arg_0]
add	bx, [bp+var_4]	; Add
mov	al, [bx]

loc_1F2E6:		; AL ->	AX (with sign)
cbw
mov	[bp+var_6], ax
mov	ax, [bp+var_6]
imul	di		; Signed Multiply
mov	[bp+var_E], ax
cmp	[bp+var_6], 0	; Compare Two Operands
jnz	short loc_1F2FB	; Jump if Not Zero (ZF=0)
jmp	loc_1F3E7	; Jump

loc_1F2FB:		; CODE XREF: sub_1F290+66j
cmp	[bp+var_6], 0	; Compare Two Operands
jge	short loc_1F374	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_2]
add	ax, [bp+var_6]	; Add
mov	[bp+var_C], ax
cmp	[bp+var_C], 0	; Compare Two Operands
jle	short loc_1F357	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	si, [bp+var_4]

loc_1F313:		; Jump
jmp	short loc_1F32C

loc_1F315:		; CODE XREF: sub_1F290+9Fj
mov	ax, si
sub	ax, [bp+var_E]	; Integer Subtraction
les	bx, [bp+var_12]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
les	bx, [bp+var_12]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	[es:bx], al
add	si, di		; Add

loc_1F32C:		; CODE XREF: sub_1F290:loc_1F313j
cmp	si, [bp+var_14]	; Compare Two Operands
jl	short loc_1F315	; Jump if Less (SF!=OF)
mov	ax, di
imul	[bp+var_C]	; Signed Multiply

loc_1F336:
mov	dx, [bp+var_4]
add	dx, ax		; Add
mov	si, dx
jmp	short loc_1F350	; Jump

loc_1F33F:		; CODE XREF: sub_1F290+C3j
mov	bx, si
add	bx, [bp+var_A]	; Add
mov	es, [word ptr bp+var_12+2]
add	bx, [word ptr bp+var_12] ; Add
mov	[byte ptr es:bx], 0

loc_1F34E:		; Add
add	si, di

loc_1F350:		; CODE XREF: sub_1F290+ADj
cmp	si, [bp+var_14]	; Compare Two Operands
jl	short loc_1F33F	; Jump if Less (SF!=OF)
jmp	short loc_1F372	; Jump

loc_1F357:		; CODE XREF: sub_1F290+7Ej
cmp	[bp+var_C], 0	; Compare Two Operands
jge	short loc_1F372	; Jump if Greater or Equal (SF=OF)
mov	si, [bp+var_4]
jmp	short loc_1F36D	; Jump

loc_1F362:		; CODE XREF: sub_1F290+E0j
les	bx, [bp+var_12]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	[byte ptr es:bx], 0
add	si, di		; Add

loc_1F36D:		; CODE XREF: sub_1F290+D0j
cmp	si, [bp+var_14]	; Compare Two Operands
jl	short loc_1F362	; Jump if Less (SF!=OF)

loc_1F372:		; CODE XREF: sub_1F290+C5j
			; sub_1F290+CBj
jmp	short loc_1F3E7	; Jump

loc_1F374:		; CODE XREF: sub_1F290+6Fj
mov	ax, di
sub	ax, [bp+var_6]	; Integer Subtraction
mov	[bp+var_C], ax
cmp	[bp+var_C], 0	; Compare Two Operands
jle	short loc_1F3CC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
les	bx, [bp+var_12]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_8], ax

loc_1F38E:
mov	ax, [bp+var_14]
sub	ax, di		; Integer Subtraction
add	ax, [bp+var_4]	; Add
mov	si, ax
jmp	short loc_1F3B1	; Jump

loc_1F39A:		; CODE XREF: sub_1F290+123j
mov	ax, si
sub	ax, [bp+var_E]	; Integer Subtraction

loc_1F39F:		; Load Full Pointer to ES:xx
les	bx, [bp+var_12]
add	bx, ax		; Add
mov	al, [es:bx]
les	bx, [bp+var_12]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	[es:bx], al

loc_1F3AF:		; Integer Subtraction
sub	si, di

loc_1F3B1:		; CODE XREF: sub_1F290+108j
or	si, si		; Logical Inclusive OR
jge	short loc_1F39A	; Jump if Greater or Equal (SF=OF)
mov	si, [bp+var_4]

loc_1F3B8:		; Jump
jmp	short loc_1F3C5

loc_1F3BA:		; CODE XREF: sub_1F290+138j
les	bx, [bp+var_12]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	[byte ptr es:bx], 0
add	si, di		; Add

loc_1F3C5:		; CODE XREF: sub_1F290:loc_1F3B8j
cmp	si, [bp+var_E]	; Compare Two Operands
jl	short loc_1F3BA	; Jump if Less (SF!=OF)

loc_1F3CA:		; Jump
jmp	short loc_1F3E7

loc_1F3CC:		; CODE XREF: sub_1F290+F0j
cmp	[bp+var_C], 0	; Compare Two Operands

loc_1F3D0:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1F3E7
mov	si, [bp+var_4]

loc_1F3D5:		; Jump
jmp	short loc_1F3E2

loc_1F3D7:		; CODE XREF: sub_1F290:loc_1F3E5j
les	bx, [bp+var_12]	; Load Full Pointer to ES:xx

loc_1F3DA:		; Add
add	bx, si

loc_1F3DC:
mov	[byte ptr es:bx], 0
add	si, di		; Add

loc_1F3E2:		; CODE XREF: sub_1F290:loc_1F3D5j
cmp	si, [bp+var_14]	; Compare Two Operands

loc_1F3E5:		; Jump if Less (SF!=OF)
jl	short loc_1F3D7

loc_1F3E7:		; CODE XREF: sub_1F290+68j
			; sub_1F290:loc_1F372j
			; sub_1F290:loc_1F3CAj
			; sub_1F290:loc_1F3D0j
inc	[bp+var_4]	; Increment by 1

loc_1F3EA:		; CODE XREF: sub_1F290:loc_1F2DBj
cmp	[bp+var_4], di	; Compare Two Operands
jge	short loc_1F3F2	; Jump if Greater or Equal (SF=OF)

loc_1F3EF:		; Jump
jmp	loc_1F2DE

loc_1F3F2:		; CODE XREF: sub_1F290+15Dj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1F290



; Attributes: bp-based frame

proc idk_WriteImageHeader_s1F3F8 far

var_BytesCount=	word ptr -2
argValue= word ptr  6
arg_2= word ptr	 8
argSegment= word ptr  0Ah
arg_BytesValue=	word ptr  0Ch

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di


mov	si, [bp+argValue]
push	si		; argValue
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


push	[bp+arg_2]	; argValue
mov	ax, 2
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, 0DE0Ah
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


xor	ax, ax		; Logical Exclusive OR
push	ax		; argValue
mov	ax, 6
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


xor	ax, ax		; Logical Exclusive OR
push	ax		; argValue
mov	ax, 8
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add


mov	ax, si
imul	[bp+arg_2]	; Signed Multiply
mov	[bp+var_BytesCount], ax
push	es
push	di
mov	ax, [bp+argSegment]
mov	es, ax
mov	di, 16
mov	ax, [bp+arg_BytesValue]
mov	cx, [bp+var_BytesCount]
rep stosb		;
			; REP STOSB
			;  Fill	CX bytes at ES:[DI] with AL.
			; ...
			; REP
			; Repeats a string instruction the number of times specified in	the count register (CX).
			; STOSB
			; Store	AL at address ES:DI.
			;
pop	di
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_WriteImageHeader_s1F3F8



; Attributes: bp-based frame

proc sub_1F47D far

var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
argOffset= dword ptr  0Eh

push	bp
mov	bp, sp

loc_1F480:		; Integer Subtraction
sub	sp, 0Eh
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx

loc_1F492:
mov	[bp+var_4], ax
mov	ax, 2
push	ax

loc_1F499:		; argOffset
push	[word ptr bp+argOffset]

loc_1F49C:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset

loc_1F4A1:
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_2]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_8], ax

loc_1F4B0:
mov	ax, [bp+arg_0]
imul	[bp+var_2]	; Signed Multiply
add	ax, 10h		; Add
sub	ax, [bp+var_2]	; Integer Subtraction
add	ax, [bp+var_8]	; Add
add	ax, [bp+arg_2]	; Add
mov	[bp+var_6], ax
mov	ax, [bp+var_2]
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_C], ax

loc_1F4CE:
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_A], ax
mov	ax, [word ptr bp+argOffset+2]
mov	[bp+var_E], ax
push	ds
push	si

loc_1F4E0:
push	es
push	di

loc_1F4E2:
mov	si, [bp+var_6]
mov	di, [bp+var_6]
mov	bx, [word ptr bp+argOffset+2]

loc_1F4EB:
mov	ax, [bp+var_C]
mov	bh, al
mov	cx, [bp+var_A]
mov	dx, [bp+var_8]
mov	ax, [word ptr bp+argOffset]

loc_1F4F9:
mov	es, ax

loc_1F4FB:
mov	ds, ax

loc_1F4FD:		; CODE XREF: sub_1F47D+92j
mov	al, bh

loc_1F4FF:		; Logical Exclusive OR
xor	ah, ah
add	si, ax		; Add
add	di, ax		; Add
mov	dh, dl

loc_1F507:		; CODE XREF: sub_1F47D+90j
lodsb			; Load String

loc_1F508:		; Add
add	al, bl

loc_1F50A:		; Store	String
stosb
dec	dh		; Decrement by 1
jnz	short loc_1F507	; Jump if Not Zero (ZF=0)
loop	loc_1F4FD	; Loop while CX	!= 0
pop	di

loc_1F512:
pop	es
pop	si
pop	ds
pop	di
pop	si
mov	sp, bp

loc_1F519:
pop	bp
retf			; Return Far from Procedure
endp sub_1F47D



; Attributes: bp-based frame

proc sub_1F51B far

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
argOffset= dword ptr  0Eh
arg_C= word ptr	 12h

push	bp

loc_1F51C:
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si

loc_1F522:
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx

loc_1F530:
mov	[bp+var_4], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_2]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_8], ax
mov	ax, [bp+arg_0]
imul	[bp+var_2]	; Signed Multiply
add	ax, 10h		; Add
sub	ax, [bp+var_2]	; Integer Subtraction

loc_1F55A:		; Add
add	ax, [bp+var_8]

loc_1F55D:		; Add
add	ax, [bp+arg_2]
mov	[bp+var_6], ax

loc_1F563:
mov	ax, [bp+var_2]
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_C], ax
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_A], ax
push	ds
push	si

loc_1F578:
push	es
push	di
mov	si, [bp+var_6]

loc_1F57D:
mov	bx, [bp+arg_C]
mov	ax, [bp+var_C]
mov	bh, al
mov	cx, [bp+var_A]
mov	dx, [bp+var_8]
mov	ax, [word ptr bp+argOffset+2]
mov	ah, al
mov	di, [word ptr bp+argOffset]
mov	es, di

loc_1F595:
mov	ds, di
mov	di, si

loc_1F599:		; CODE XREF: sub_1F51B+98j
push	ax
mov	al, bh
xor	ah, ah		; Logical Exclusive OR

loc_1F59E:		; Add
add	si, ax
add	di, ax		; Add
mov	dh, dl
pop	ax

loc_1F5A5:		; CODE XREF: sub_1F51B+96j
lodsb			; Load String
inc	di		; Increment by 1

loc_1F5A7:		; Compare Two Operands
cmp	al, ah
jnz	short loc_1F5AF	; Jump if Not Zero (ZF=0)
dec	di		; Decrement by 1
mov	al, bl
stosb			; Store	String

loc_1F5AF:		; CODE XREF: sub_1F51B+8Ej
dec	dh		; Decrement by 1
jnz	short loc_1F5A5	; Jump if Not Zero (ZF=0)
loop	loc_1F599	; Loop while CX	!= 0
pop	di
pop	es
pop	si
pop	ds
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1F51B



; Attributes: bp-based frame

proc sub_1F5BF far

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= dword ptr  6

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_4]
imul	[bp+var_2]	; Signed Multiply

loc_1F5EE:
mov	[bp+var_6], ax
push	ds
push	si
push	es
push	di
mov	ax, [word ptr bp+argOffset]
mov	es, ax
mov	di, 10h
mov	cx, [bp+var_6]

loc_1F600:
mov	dx, [word ptr bp+argOffset+2]
mov	ds, ax
mov	si, 10h

loc_1F608:		; CODE XREF: sub_1F5BF:loc_1F612j
lodsb			; Load String
inc	di		; Increment by 1
cmp	al, 0		; Compare Two Operands
jz	short loc_1F612	; Jump if Zero (ZF=1)
dec	di		; Decrement by 1
mov	al, dl
stosb			; Store	String

loc_1F612:		; CODE XREF: sub_1F5BF+4Dj
loop	loc_1F608	; Loop while CX	!= 0
pop	di
pop	es

loc_1F616:
pop	si
pop	ds

loc_1F618:
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1F5BF



; Attributes: bp-based frame

proc sub_1F61E far	; CODE XREF: sub_4E9F4+186P
			; sub_4E9F4+191P
			; sub_4EF74+19CP
			; sub_4EF74+1A7P

var_12=	word ptr -12h
var_4= word ptr	-4
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 12h		; Integer Subtraction
push	si
mov	si, [bp+arg_0]
mov	ax, 10h
push	ax		; int
push	si		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
lea	ax, [bp+var_12]	; Load Effective Address
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ah		; Add

loc_1F63F:		; Compare Two Operands
cmp	[bp+var_4], 0
jz	short loc_1F650	; Jump if Zero (ZF=1)
xor	ax, ax		; Logical Exclusive OR

loc_1F647:
push	ax
push	si

loc_1F649:		; Call Procedure
call	idk_Font_s1CB05
pop	cx
pop	cx

loc_1F650:		; CODE XREF: sub_1F61E+25j
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1F61E



; Attributes: bp-based frame

proc sub_1F655 far	; CODE XREF: _f010609_DrawMainMenuScreen+60P
			; _f010609_DrawMainMenuScreen+7EP
			; _f010609_DrawMainMenuScreen+CDP
			; _f010609_DrawMainMenuScreen+119P
			; _f010609_DrawMainMenuScreen+150P
			; _f010609_DrawMainMenuScreen+187P
			; _f010609_DrawMainMenuScreen+1BEP
			; sub_2BA41+D9P
			; sub_2BA41+218P
			; sub_2BA41+349P
			; sub_2BA41+3A1P
			; sub_2BA41+4E8P
			; sub_2BA41+619P
			; sub_2BA41+671P
			; sub_2BA41+7C7P
			; sub_2BA41+8F8P
			; sub_2BA41+950P
			; sub_2BA41+11D2P
			; sub_2CF44+80P
			; sub_2CF44:loc_2D0F5P
			; sub_2CF44:loc_2D150P
			; sub_2CF44+359P
			; sub_2CF44+48AP
			; sub_2CF44+4E5P
			; sub_2CF44+635P
			; sub_2CF44+766P
			; sub_2CF44+7C1P
			; sub_2CF44+95CP
			; sub_2CF44+A8DP
			; sub_2CF44+AE5P
			; sub_3D378+27P
			; sub_3D378:loc_3D41CP
			; sub_3D378+FAP
			; sub_3D378+13DP
			; sub_3D378+17AP
			; sub_3D378+1CAP
			; sub_3D378:loc_3D598P
			; sub_3D378+248P
			; sub_3D378+272P
			; sub_3DF8C:loc_3DFEEP
			; sub_3DF8C+BBP
			; sub_3DF8C+105P
			; sub_3DF8C+189P
			; sub_3DF8C+1B3P
			; sub_3DF8C+1E4P
			; sub_3DF8C+1FAP
			; sub_3DF8C+20EP
			; sub_3DF8C+222P
			; sub_3E60E+74P
			; sub_3E60E+129P
			; sub_3E60E+15DP
			; sub_3E60E+1C4P
			; sub_3E60E+23BP
			; sub_3E60E+2A2P
			; sub_3E60E+319P
			; sub_3E60E+380P
			; sub_3E60E+3F7P
			; sub_3E60E+45EP
			; sub_3EDD1+55P
			; sub_3EDD1+69P
			; sub_3EDD1+25CP
			; sub_3EDD1+299P
			; sub_3EDD1+313P
			; sub_3EDD1+3BEP
			; sub_3EDD1+438P
			; sub_3F6BF+34P
			; sub_3F6BF+48P
			; sub_3F6BF+87P
			; sub_3FA0C+36P
			; sub_3FA0C+49P
			; sub_3FA0C+88P
			; sub_3FA0C+113P
			; sub_3FA0C+13CP
			; sub_3FA0C+165P
			; sub_3FA0C+18EP
			; sub_3FA0C+1B7P
			; sub_40037:loc_400BBP
			; sub_40037+98P
			; sub_40037+ACP
			; sub_40037+EBP
			; sub_40037+187P
			; sub_40037+1B3P
			; sub_40037+1DFP
			; sub_40037+20BP
			; sub_40037+237P
			; sub_40584+AFP
			; sub_40584+E2P
			; sub_40EC0+84P
			; sub_40EC0:loc_40F60P
			; sub_40EC0+367P
			; sub_40EC0+384P
			; sub_40EC0+3B7P
			; sub_40EC0+3D4P
			; sub_40EC0+407P
			; sub_40EC0+424P
			; sub_40EC0:loc_41317P
			; sub_40EC0:loc_41334P
			; sub_40EC0+4A7P
			; sub_40EC0+4C4P
			; sub_40EC0:loc_413C0P
			; sub_40EC0+516P
			; sub_40EC0+734P
			; sub_40EC0+97BP
			; sub_424BB+3EP
			; sub_424BB+52P
			; sub_424BB+66P
			; sub_424BB+10CP
			; sub_424BB+135P
			; sub_424BB+15EP
			; sub_424BB+187P
			; sub_424BB+1B0P
			; sub_424BB+1EBP
			; sub_424BB+201P
			; sub_4276F+15FP
			; sub_4276F+2B8P
			; sub_4276F+3B1P
			; sub_4276F+541P
			; sub_4276F+63CP
			; sub_4276F+7CCP
			; sub_4276F+8C7P
			; idk_BuildingWorlds+52P
			; sub_4D7A1+73P
			; sub_4DA02+140P
			; sub_4EC17+E9P
			; sub_4EC17+14EP
			; sub_4F1AB+C1P
			; sub_4F1AB+115P
			; sub_56450+6CP

var_1A=	word ptr -1Ah
argValue= word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	byte ptr -10h
var_C= word ptr	-0Ch
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
argSegment= word ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 1Ah		; Integer Subtraction
push	si

loc_1F65C:
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]

loc_1F663:
mov	ax, 10h

loc_1F666:		; int
push	ax
push	[bp+argSegment]	; int
xor	ax, ax		; Logical Exclusive OR

loc_1F66C:		; int
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax		; int

loc_1F670:		; Load Effective Address
lea	ax, [bp+var_1A]
push	ax		; int

loc_1F674:		; Call Procedure
call	idk_Mov_Sb_Sw_or_0
add	sp, 0Ah		; Add
mov	ax, [bp+argValue]

loc_1F67F:
mov	[bp+var_4], ax
inc	[bp+argValue]	; Increment by 1
mov	ax, [bp+argValue]
cmp	ax, [bp+var_14]	; Compare Two Operands
jl	short loc_1F692	; Jump if Less (SF!=OF)
push	[bp+var_12]

loc_1F690:		; Jump
jmp	short loc_1F695

loc_1F692:		; CODE XREF: sub_1F655+36j
push	[bp+argValue]	; argValue

loc_1F695:		; CODE XREF: sub_1F655:loc_1F690j
mov	ax, 4
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
cmp	[bp+var_C], 0	; Compare Two Operands

loc_1F6A8:		; Jump if Zero (ZF=1)
jz	short loc_1F6B7
push	[bp+var_4]
push	[bp+argSegment]

loc_1F6B0:		; Call Procedure
call	idk_Font_s1CB05
pop	cx
pop	cx

loc_1F6B7:		; CODE XREF: sub_1F655:loc_1F6A8j
cmp	[bp+var_10], 0	; Compare Two Operands
jnz	short loc_1F72D	; Jump if Not Zero (ZF=0)
push	es
mov	ax, [bp+argSegment]
mov	es, ax
mov	bx, 11h

loc_1F6C6:
mov	al, [es:bx]
xor	ah, ah		; Logical Exclusive OR
mov	[bp+var_2], ax
inc	bx		; Increment by 1

loc_1F6CF:
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_1F6D8:
mov	ax, [es:bx]
mov	dx, [es:bx+2]
mov	bx, ax
db 81h,0E3h,0Fh,0 ; <BAD>and	 bx, 0Fh ; Logical AND
inc	bx		; Increment by 1
mov	[bp+var_6], bx
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right

loc_1F6F1:		; Shift	Logical	Right
shr	dx, 1
rcr	ax, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
add	ax, [bp+argSegment] ; Add
mov	[bp+var_8], ax
pop	es

loc_1F700:		; Compare Two Operands
cmp	[bp+var_2], 0
jnz	short loc_1F718	; Jump if Not Zero (ZF=0)
push	[bp+var_8]
push	[bp+var_6]

loc_1F70C:
push	[bp+var_1A]
push	di
push	si
call	sub_1E7AC	; Call Procedure
jmp	short loc_1F728	; Jump

loc_1F718:		; CODE XREF: sub_1F655+AFj
push	[bp+var_8]
push	[bp+var_6]

loc_1F71E:
push	[bp+var_1A]
push	di
push	si
call	sub_1E8AC	; Call Procedure

loc_1F728:		; CODE XREF: sub_1F655+C1j
add	sp, 0Ah		; Add
jmp	short loc_1F73D	; Jump

loc_1F72D:		; CODE XREF: sub_1F655+66j
push	[bp+var_4]
push	[bp+argSegment]
push	di
push	si
call	sub_1EA9E	; Call Procedure
add	sp, 8		; Add

loc_1F73D:		; CODE XREF: sub_1F655+D6j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1F655



; Attributes: bp-based frame

proc idk_VidLib_s1F743 far
			; CODE XREF: sub_4D7A1:loc_4D7F6P
			; sub_4DA02+62P
			; sub_4E031+4DP
			; sub_4E031+6EP
			; sub_4E031+11CP
			; sub_4E031+15FP
			; sub_4E031+1E8P
			; sub_4E031+2BDP
			; sub_4E031+300P
			; sub_4E031+397P
			; sub_4E031+3DBP
			; sub_4E031:loc_4E448P
			; sub_4E031+44BP
			; sub_4E031+48DP
			; sub_4E031+4BBP
			; sub_4E031+4E9P
			; sub_4E031+530P
			; sub_4E031+552P
			; sub_4E031+574P
			; sub_4E031+5A4P
			; sub_4EC17+C2P
			; sub_4F1AB+92P
			; idk_OVR_LoadLbxHelp+31CP
			; idk_OVR_LoadLbxHelp:loc_55FD9P

var_26=	word ptr -26h
var_24=	word ptr -24h
argValue= word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	byte ptr -1Ch
var_18=	word ptr -18h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
argSegment= word ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 26h		; Integer Subtraction
push	si
push	di
mov	ax, [bp+arg_0]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jle	short loc_1F759	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

SET_AX_ZERO_AND_RETURN:	; CODE XREF: idk_VidLib_s1F743+1Fj
			; idk_VidLib_s1F743:loc_1F790j
			; idk_VidLib_s1F743+62j
xor	ax, ax		; Logical Exclusive OR
jmp	loc_1F8F7	; Jump

loc_1F759:		; CODE XREF: idk_VidLib_s1F743+Fj
mov	ax, [bp+arg_2]
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_1F764	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	short SET_AX_ZERO_AND_RETURN ; Jump

loc_1F764:		; CODE XREF: idk_VidLib_s1F743+1Dj
mov	ax, 16
push	ax		; int
push	[bp+argSegment]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
lea	ax, [bp+var_26]	; Load Effective Address
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ah		; Add
mov	ax, [bp+arg_0]
add	ax, [bp+var_26]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_6], ax
mov	ax, [bp+var_6]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jge	short loc_1F792	; Jump if Greater or Equal (SF=OF)

loc_1F790:		; Jump
jmp	short SET_AX_ZERO_AND_RETURN

loc_1F792:		; CODE XREF: idk_VidLib_s1F743+4Bj
mov	ax, [bp+arg_2]
add	ax, [bp+var_24]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
mov	ax, [bp+var_8]
cmp	ax, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jge	short loc_1F7A7	; Jump if Greater or Equal (SF=OF)
jmp	short SET_AX_ZERO_AND_RETURN ; Jump

loc_1F7A7:		; CODE XREF: idk_VidLib_s1F743+60j
mov	ax, [bp+arg_0]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jl	short loc_1F7BA	; Jump if Less (SF!=OF)

loc_1F7B0:
mov	[bp+var_E], 0
mov	si, [bp+arg_0]
jmp	short loc_1F7C7	; Jump

loc_1F7BA:		; CODE XREF: idk_VidLib_s1F743+6Bj
mov	ax, [idk_ScrnPosX0_w35EC2]
sub	ax, [bp+arg_0]	; Integer Subtraction
mov	[bp+var_E], ax
mov	si, [idk_ScrnPosX0_w35EC2]

loc_1F7C7:		; CODE XREF: idk_VidLib_s1F743+75j
mov	ax, [bp+arg_2]
cmp	ax, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jl	short loc_1F7DA	; Jump if Less (SF!=OF)

loc_1F7D0:
mov	[bp+var_10], 0
mov	di, [bp+arg_2]
jmp	short loc_1F7E7	; Jump

loc_1F7DA:		; CODE XREF: idk_VidLib_s1F743+8Bj
mov	ax, [idk_ScrnPosY0_w35EC4]
sub	ax, [bp+arg_2]	; Integer Subtraction
mov	[bp+var_10], ax
mov	di, [idk_ScrnPosY0_w35EC4]

loc_1F7E7:		; CODE XREF: idk_VidLib_s1F743+95j
mov	ax, [bp+var_6]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jge	short loc_1F7F5	; Jump if Greater or Equal (SF=OF)

loc_1F7F0:
mov	ax, [bp+var_6]
jmp	short loc_1F7F8	; Jump

loc_1F7F5:		; CODE XREF: idk_VidLib_s1F743+ABj
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_1F7F8:		; CODE XREF: idk_VidLib_s1F743+B0j
sub	ax, si		; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_A], ax
mov	ax, [bp+var_8]
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jge	short loc_1F80C	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_8]
jmp	short loc_1F80F	; Jump

loc_1F80C:		; CODE XREF: idk_VidLib_s1F743+C2j
mov	ax, [idk_ScrnPosY199_w35EC8]

loc_1F80F:		; CODE XREF: idk_VidLib_s1F743+C7j
sub	ax, di		; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_C], ax
mov	ax, [bp+argValue]
mov	[bp+var_4], ax
inc	[bp+argValue]	; Increment by 1
mov	ax, [bp+argValue]
cmp	ax, [bp+var_20]	; Compare Two Operands
jl	short loc_1F82B	; Jump if Less (SF!=OF)
push	[bp+var_1E]
jmp	short loc_1F82E	; Jump

loc_1F82B:		; CODE XREF: idk_VidLib_s1F743+E1j
push	[bp+argValue]	; argValue

loc_1F82E:		; CODE XREF: idk_VidLib_s1F743+E6j
mov	ax, 4
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
cmp	[bp+var_18], 0	; Compare Two Operands
jz	short loc_1F850	; Jump if Zero (ZF=1)
push	[bp+var_4]
push	[bp+argSegment]
call	idk_Font_s1CB05	; Call Procedure
pop	cx
pop	cx

loc_1F850:		; CODE XREF: idk_VidLib_s1F743+FEj
cmp	[bp+var_1C], 0	; Compare Two Operands
jz	short loc_1F859	; Jump if Zero (ZF=1)
jmp	loc_1F8DB	; Jump

loc_1F859:		; CODE XREF: idk_VidLib_s1F743+111j
push	es
mov	ax, [bp+argSegment]
mov	es, ax
mov	bx, 11h
mov	al, [es:bx]
xor	ah, ah		; Logical Exclusive OR
mov	[bp+var_2], ax
inc	bx		; Increment by 1
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	dx, [es:bx+2]
mov	bx, ax
db 81h,0E3h,0Fh,0 ; <BAD>and	 bx, 0Fh ; Logical AND
inc	bx		; Increment by 1
mov	[bp+var_12], bx
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
add	ax, [bp+argSegment] ; Add
mov	[bp+var_14], ax
pop	es
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_1F8BD	; Jump if Not Zero (ZF=0)

loc_1F8A2:
push	[bp+var_14]
push	[bp+var_12]
push	[bp+var_10]
push	[bp+var_E]
push	[bp+var_C]
push	[bp+var_A]
push	di
push	si
call	idk_VGA_ScIndexMapMask_s22194 ;	Call Procedure
jmp	short loc_1F8D6	; Jump

loc_1F8BD:		; CODE XREF: idk_VidLib_s1F743+15Dj
push	[bp+var_14]
push	[bp+var_12]
push	[bp+var_10]
push	[bp+var_E]
push	[bp+var_C]
push	[bp+var_A]
push	di
push	si
call	sub_223C9	; Call Procedure

loc_1F8D6:		; CODE XREF: idk_VidLib_s1F743+178j
add	sp, 10h		; Add
jmp	short loc_1F8F7	; Jump

loc_1F8DB:		; CODE XREF: idk_VidLib_s1F743+113j
push	[bp+var_4]
push	[bp+argSegment]
push	[bp+var_10]
push	[bp+var_E]
push	[bp+var_C]
push	[bp+var_A]
push	di
push	si
call	sub_226C2	; Call Procedure
add	sp, 10h		; Add

loc_1F8F7:		; CODE XREF: idk_VidLib_s1F743+13j
			; idk_VidLib_s1F743+196j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_VidLib_s1F743



; Attributes: bp-based frame

proc sub_1F8FD far	; CODE XREF: sub_4EC17:loc_4ED7CP
			; sub_4EC17+19EP
			; sub_4F1AB+12CP
			; sub_4F1AB+160P
			; idk_OVR_LoadLbxHelp:loc_55DFFP
			; idk_OVR_LoadLbxHelp+3EBP

var_24=	word ptr -24h
argValue= word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	byte ptr -1Ah
var_19=	byte ptr -19h
var_18=	word ptr -18h
var_16=	word ptr -16h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argSegment= word ptr  6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 24h		; Integer Subtraction
push	si
push	di
mov	ax, 10h
push	ax		; int
push	[bp+argSegment]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR

loc_1F911:		; int
push	ax
lea	ax, [bp+var_24]	; Load Effective Address
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ah		; Add
mov	si, [bp+argValue]
inc	[bp+argValue]	; Increment by 1

loc_1F924:
mov	ax, [bp+argValue]
cmp	ax, [bp+var_1E]	; Compare Two Operands
jl	short loc_1F931	; Jump if Less (SF!=OF)
push	[bp+var_1C]
jmp	short loc_1F934	; Jump

loc_1F931:		; CODE XREF: sub_1F8FD+2Dj
push	[bp+argValue]	; argValue

loc_1F934:		; CODE XREF: sub_1F8FD+32j
mov	ax, 4
push	ax		; argOffset

loc_1F938:		; argSegment
push	[bp+argSegment]
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_1F954	; Jump if Zero (ZF=1)
push	si
push	[bp+argSegment]
call	idk_Font_s1CB05	; Call Procedure
pop	cx
pop	cx

loc_1F954:		; CODE XREF: sub_1F8FD+4Aj
push	si

loc_1F955:
push	[bp+arg_2]
push	[bp+argSegment]
call	sub_22CD8	; Call Procedure
add	sp, 6		; Add
cmp	[bp+var_1A], 0	; Compare Two Operands
jz	short loc_1F96C	; Jump if Zero (ZF=1)

loc_1F969:		; Jump
jmp	loc_1F9F2

loc_1F96C:		; CODE XREF: sub_1F8FD+6Aj
mov	ax, 10h
push	ax

loc_1F970:
push	[bp+argSegment]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure

loc_1F978:
pop	cx
pop	cx
mov	[bp+var_6], ax

loc_1F97D:		; Compare Two Operands
cmp	[bp+var_6], 0
jnz	short loc_1F987	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_1F989	; Jump

loc_1F987:		; CODE XREF: sub_1F8FD+84j
mov	di, si

loc_1F989:		; CODE XREF: sub_1F8FD+88j
mov	[bp+var_8], si
mov	[bp+var_4], di
jmp	short loc_1F9E8	; Jump

loc_1F991:		; CODE XREF: sub_1F8FD+F1j
push	es
mov	ax, [bp+argSegment]
mov	es, ax
mov	bx, 11h
mov	al, [es:bx]
xor	ah, ah		; Logical Exclusive OR
mov	[bp+var_2], ax
inc	bx		; Increment by 1
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	dx, [es:bx+2]
mov	bx, ax
db 81h,0E3h,0Fh,0 ; <BAD>and	 bx, 0Fh ; Logical AND
inc	bx		; Increment by 1
mov	[bp+var_10], bx
shr	dx, 1		; Shift	Logical	Right

loc_1F9BF:		; Rotate Through Carry Right
rcr	ax, 1
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	ax, 1		; Rotate Through Carry Right
add	ax, [bp+argSegment] ; Add
mov	[bp+var_12], ax
pop	es
push	[bp+arg_2]
push	[bp+var_12]
push	[bp+var_10]
call	sub_22D1C	; Call Procedure

loc_1F9E2:		; Add
add	sp, 6
inc	[bp+var_4]	; Increment by 1

loc_1F9E8:		; CODE XREF: sub_1F8FD+92j
mov	ax, [bp+var_4]
cmp	ax, [bp+var_8]	; Compare Two Operands
jle	short loc_1F991	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1F9F0:		; Jump
jmp	short loc_1FA68

loc_1F9F2:		; CODE XREF: sub_1F8FD:loc_1F969j
mov	ax, [bp+var_18]
add	ax, 10h		; Add
mov	[bp+var_A], ax
mov	al, [bp+var_19]
cbw			; AL ->	AX (with sign)
mov	[bp+var_C], ax
mov	al, [bp+var_1A]
cbw			; AL ->	AX (with sign)

loc_1FA06:
mov	[bp+var_E], ax
cmp	[bp+var_A], 4000h ; Compare Two	Operands
jl	short loc_1FA18	; Jump if Less (SF!=OF)
sub	[bp+var_A], 4000h ; Integer Subtraction
inc	[bp+var_C]	; Increment by 1

loc_1FA18:		; CODE XREF: sub_1F8FD+111j
push	ds
mov	bx, [bp+var_C]
xor	bh, bh		; Logical Exclusive OR

loc_1FA1E:
mov	dx, [bp+var_E]
xor	dh, dh		; Logical Exclusive OR
mov	ax, 4400h
int	67h		;  - LIM EMS - MAP MEMORY
			; AL = physical	page number (0-3)
			; BX = logical page number, DX = handle
			; Return: AH = status
mov	bx, [bp+var_A]
mov	ax, [EMM_PageFrameSegmentAddress]
mov	ds, ax
mov	al, [bx]
xor	ah, ah		; Logical Exclusive OR
mov	[bp+var_6], ax
pop	ds
cmp	[bp+var_6], 0	; Compare Two Operands
jnz	short loc_1FA42	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_1FA44	; Jump

loc_1FA42:		; CODE XREF: sub_1F8FD+13Fj
mov	di, si

loc_1FA44:		; CODE XREF: sub_1F8FD+143j
mov	[bp+var_8], si
mov	[bp+var_4], di
jmp	short loc_1FA60	; Jump

loc_1FA4C:		; CODE XREF: sub_1F8FD+169j
push	[bp+arg_2]
push	[bp+var_4]
push	[bp+argSegment]
call	sub_22DC6	; Call Procedure

loc_1FA5A:		; Add
add	sp, 6
inc	[bp+var_4]	; Increment by 1

loc_1FA60:		; CODE XREF: sub_1F8FD+14Dj
mov	ax, [bp+var_4]
cmp	ax, [bp+var_8]	; Compare Two Operands
jle	short loc_1FA4C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_1FA68:		; CODE XREF: sub_1F8FD:loc_1F9F0j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1F8FD



; Attributes: bp-based frame

proc sub_1FA6E far	; CODE XREF: _f010609_DrawMainMenuScreen+48P
			; _f010609_DrawMainMenuScreen+BBP
			; _f010609_DrawMainMenuScreen+100P
			; _f010609_DrawMainMenuScreen+13EP
			; _f010609_DrawMainMenuScreen+175P
			; _f010609_DrawMainMenuScreen+1ACP
			; sub_2BA41+368P
			; sub_2BA41+638P
			; sub_2BA41+917P
			; sub_2CF44:loc_2D114P
			; sub_2CF44+4A9P
			; sub_2CF44+785P
			; sub_2CF44+AACP
			; sub_4E031+B2P
			; sub_4E031+C9P
			; sub_4E031+DBP
			; sub_4E031+185P
			; sub_4E031+198P
			; sub_4E031+1A6P
			; sub_4E031+245P
			; sub_4E031+25CP
			; sub_4E031+26EP
			; sub_4E031+326P
			; sub_4E031+339P
			; sub_4E031+347P

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg0_DestES= dword ptr	6

push	bp

loc_1FA6F:
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di		; arg2_SI
mov	di, [word ptr bp+arg0_DestES]
mov	si, [word ptr bp+arg0_DestES+2]
mov	ax, si

loc_1FA7E:		; Logical AND
and	ax, 7FFFh
mov	si, ax
mov	ax, 6
push	ax
push	di		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, 8
push	ax
push	di		; argOffset

loc_1FA97:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx

loc_1FA9E:
mov	[bp+var_4], ax
mov	ax, [bp+var_2]

loc_1FAA4:		; Integer Subtraction
sub	ax, [bp+var_4]
mov	[bp+var_6], ax
cmp	si, [bp+var_2]	; Compare Two Operands
jb	short loc_1FAC0	; Jump if Below	(CF=1)
mov	ax, si
sub	ax, [bp+var_2]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
div	[bp+var_6]	; Unsigned Divide
mov	ax, [bp+var_4]
add	ax, dx		; Add
mov	si, ax

loc_1FAC0:		; CODE XREF: sub_1FA6E+3Fj
push	si		; argValue
mov	ax, 4
push	ax		; argOffset
push	di		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	di
pop	si

loc_1FAD0:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_1FA6E



; Attributes: bp-based frame

proc sub_1FAD4 far	; CODE XREF: _f010509_MainMenuScreen+3B8P
			; _f010609_DrawMainMenuScreen+ABP
			; _f010609_DrawMainMenuScreen+F0P
			; _f010609_DrawMainMenuScreen+12EP
			; _f010609_DrawMainMenuScreen+165P
			; _f010609_DrawMainMenuScreen+19CP
			; sub_2BA41+9EP
			; sub_2BA41+1DDP
			; sub_2BA41+30EP
			; sub_2BA41+4ADP
			; sub_2BA41+5DEP
			; sub_2BA41+78FP
			; sub_2BA41+8BDP
			; sub_2CF44+45P
			; sub_2CF44+176P
			; sub_2CF44+31EP
			; sub_2CF44+44FP
			; sub_2CF44:loc_2D53EP
			; sub_2CF44+72BP
			; sub_2CF44+924P
			; sub_2CF44+A52P
			; idk_OVR_LoadLbxHelp+14AP
			; idk_OVR_LoadLbxHelp:loc_56076P

argSegment= word ptr  6

push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
push	[bp+argSegment]	; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_1FAD4



; Attributes: bp-based frame

proc sub_1FAEB far	; CODE XREF: _f010609_DrawMainMenuScreen+38P

argOffset= dword ptr  6

push	bp		; arg2_SI
mov	bp, sp
mov	ax, 4
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_1FAEB

push	bp
mov	bp, sp
mov	ax, 6
push	ax
push	[word ptr bp+6]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure


; Attributes: bp-based frame

proc sub_1FB15 far	; CODE XREF: sub_29409+32P
			; sub_29550+EP
			; sub_29731+47P
			; sub_4DB4D+2E9P
			; sub_4DB4D+31BP
			; sub_4DB4D+32CP
			; sub_4DB4D+368P
			; sub_4DB4D+39AP
			; sub_4DB4D:loc_4DF4DP
			; sub_4DB4D+45DP
			; sub_4E031+61P
			; sub_4E031+10FP
			; sub_4E031+151P
			; sub_4E031+1DBP
			; sub_4E031+21EP
			; sub_4E031+2A2P
			; sub_4E031+2B3P
			; sub_4E031+2F2P
			; sub_4E031+37CP
			; sub_4E031+38DP
			; sub_4E031+3CDP
			; sub_4E031+40AP
			; sub_4E031+43BP
			; sub_4E031+47DP
			; sub_4E031+4AEP
			; sub_4E031+4DCP
			; sub_4E031+523P
			; sub_4E031+566P
			; sub_4E031+596P
			; sub_4E031+6A0P
			; sub_4E031+6B1P
			; sub_4E031+6F4P
			; sub_4E751+73P
			; sub_4E751+96P
			; sub_4E751+A5P

argOffset= dword ptr  6

push	bp		; arg2_SI
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_1FB1E:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_1FB15



; Attributes: bp-based frame

proc sub_1FB29 far	; CODE XREF: sub_29409:loc_2946BP
			; sub_29550+1EP
			; sub_29731+78P
			; sub_4DB4D+2C4P
			; sub_4DB4D+2D4P
			; sub_4DB4D:loc_4DE47P
			; sub_4DB4D+30BP
			; sub_4DB4D:loc_4DE90P
			; sub_4DB4D:loc_4DEA0P
			; sub_4DB4D+379P
			; sub_4DB4D+38AP
			; sub_4DB4D+3ECP
			; sub_4DB4D+43BP
			; sub_4DB4D+44FP
			; sub_4E031+EEP
			; sub_4E031+FFP
			; sub_4E031+130P
			; sub_4E031:loc_4E172P
			; sub_4E031+1B5P
			; sub_4E031+1C7P
			; sub_4E031+1F8P
			; sub_4E031+20AP
			; sub_4E031+281P
			; sub_4E031+292P
			; sub_4E031+2D1P
			; sub_4E031+2E2P
			; sub_4E031+356P
			; sub_4E031+368P
			; sub_4E031+3A7P
			; sub_4E031+3B9P
			; sub_4E031+3EBP
			; sub_4E031+3FCP
			; sub_4E031+427P
			; sub_4E031+45BP
			; sub_4E031+46FP
			; sub_4E031+49DP
			; sub_4E031+4CBP
			; sub_4E031+511P
			; sub_4E031+540P
			; sub_4E031+584P
			; sub_4E031+67CP
			; sub_4E031+68DP
			; sub_4E031+6D0P
			; sub_4E031+6E1P
			; sub_4E751+B5P
			; sub_4E751+C3P
			; sub_4E751+D1P

argOffset= dword ptr  6

push	bp		; arg2_SI
mov	bp, sp
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_1FB33:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx

loc_1FB39:
pop	cx
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_1FB29

push	bp
mov	bp, sp

loc_1FB41:		; Integer Subtraction
sub	sp, 0Eh
push	si
push	di
mov	si, [bp+0Ch]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp-0Eh], ax
mov	ax, 2
push	ax
push	si		; arg0_AX
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	di, ax
lea	ax, [bp-0Ch]	; Load Effective Address
push	ax
lea	ax, [bp-0Ah]	; Load Effective Address
push	ax

loc_1FB6D:		; Load Effective Address
lea	ax, [bp-8]

loc_1FB70:
push	ax

loc_1FB71:		; Load Effective Address
lea	ax, [bp-6]
push	ax
lea	ax, [bp-4]	; Load Effective Address
push	ax

loc_1FB79:		; Load Effective Address
lea	ax, [bp-2]
push	ax

loc_1FB7D:		; Load Effective Address
lea	ax, [bp+8]
push	ax
lea	ax, [bp+6]	; Load Effective Address
push	ax
push	di
push	[word ptr bp-0Eh]

loc_1FB89:
push	[word ptr bp+0Ah]
nop			; No Operation
push	cs

loc_1FB8E:		; Call Procedure
call	near ptr sub_20DB5

loc_1FB91:		; Add
add	sp, 16h

loc_1FB94:
push	[word ptr bp-0Eh]
push	di
push	si
push	[word ptr bp-0Ch]
push	[word ptr bp-0Ah]
push	[word ptr bp-8]
push	[word ptr bp-6]
push	[word ptr bp-4]
push	[word ptr bp-2]
push	[word ptr bp+8]
push	[word ptr bp+6]
nop			; No Operation
push	cs
call	near ptr idk_VidLib_s1FBBF ; Call Procedure

loc_1FBB6:		; Add
add	sp, 16h
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure


; Attributes: bp-based frame

proc idk_VidLib_s1FBBF far ; CODE XREF:	seg028:0D43p
			; sub_20C7A+12Fp

var_4E=	word ptr -4Eh
var_4C=	word ptr -4Ch
var_4A=	word ptr -4Ah
var_48=	word ptr -48h
var_46=	word ptr -46h
var_44=	word ptr -44h
var_42=	word ptr -42h
var_40=	word ptr -40h
var_3E=	word ptr -3Eh
var_3C=	word ptr -3Ch
var_3A=	word ptr -3Ah
var_38=	word ptr -38h
var_36=	word ptr -36h
var_34=	word ptr -34h
var_32=	word ptr -32h
var_30=	word ptr -30h
var_2E=	word ptr -2Eh
var_2C=	word ptr -2Ch
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah

push	bp
mov	bp, sp
sub	sp, 4Eh		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_12]

loc_1FBCA:
mov	ax, 8
push	ax

loc_1FBCE:
push	[bp+arg_10]
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_46], ax
mov	ax, [bp+arg_0]
mov	[bp+var_C], ax
mov	ax, [bp+arg_4]
mov	[bp+var_A], ax
mov	ax, [bp+arg_8]

loc_1FBEA:
mov	[bp+var_8], ax
mov	ax, [bp+arg_C]
mov	[bp+var_6], ax
mov	ax, [bp+arg_2]
mov	[bp+var_14], ax

loc_1FBF9:
mov	ax, [bp+arg_6]
mov	[bp+var_12], ax
mov	ax, [bp+arg_A]
mov	[bp+var_10], ax
mov	ax, [bp+arg_E]

loc_1FC08:
mov	[bp+var_E], ax

loc_1FC0B:
mov	[bp+var_1C], 1

loc_1FC10:
mov	[bp+var_1A], 2
mov	[bp+var_18], 3
mov	[bp+var_16], 4
mov	[bp+var_28], 2710h
mov	[bp+var_26], 0
mov	[bp+var_2], 0
jmp	loc_1FCF5	; Jump

loc_1FC31:		; CODE XREF: idk_VidLib_s1FBBF+13Cj
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_14]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_26]	; Compare Two Operands
jnb	short loc_1FC51	; Jump if Not Below (CF=0)
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_14]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]

loc_1FC4E:
mov	[bp+var_26], ax

loc_1FC51:		; CODE XREF: idk_VidLib_s1FBBF+81j
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_14]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_28]	; Compare Two Operands
jbe	short loc_1FC71	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_14]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]

loc_1FC6E:
mov	[bp+var_28], ax

loc_1FC71:		; CODE XREF: idk_VidLib_s1FBBF+A1j
mov	[bp+var_4], 0
jmp	short loc_1FCEC	; Jump

loc_1FC78:		; CODE XREF: idk_VidLib_s1FBBF+131j
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_C]	; Load Effective Address

loc_1FC80:		; Add
add	bx, ax
mov	ax, [bx]

loc_1FC84:
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_A]	; Load Effective Address
add	bx, dx		; Add

loc_1FC8E:		; Compare Two Operands
cmp	ax, [bx]
jbe	short loc_1FCE9	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
lea	dx, [bp+var_A]	; Load Effective Address
add	ax, dx		; Add
push	ax
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
lea	dx, [bp+var_C]	; Load Effective Address
add	ax, dx		; Add
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
lea	dx, [bp+var_12]	; Load Effective Address
add	ax, dx		; Add
push	ax

loc_1FCBA:
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
lea	dx, [bp+var_14]	; Load Effective Address
add	ax, dx		; Add
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx
mov	ax, [bp+var_4]

loc_1FCCF:		; Shift	Logical	Left
shl	ax, 1
lea	dx, [bp+var_1A]	; Load Effective Address
add	ax, dx		; Add
push	ax
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left

loc_1FCDC:		; Load Effective Address
lea	dx, [bp+var_1C]
add	ax, dx		; Add
push	ax

loc_1FCE2:		; Call Procedure
call	sub_1CFBD
pop	cx
pop	cx

loc_1FCE9:		; CODE XREF: idk_VidLib_s1FBBF+D1j
inc	[bp+var_4]	; Increment by 1

loc_1FCEC:		; CODE XREF: idk_VidLib_s1FBBF+B7j
cmp	[bp+var_4], 3	; Compare Two Operands
jl	short loc_1FC78	; Jump if Less (SF!=OF)
inc	[bp+var_2]	; Increment by 1

loc_1FCF5:		; CODE XREF: idk_VidLib_s1FBBF+6Fj
cmp	[bp+var_2], 4	; Compare Two Operands
jge	short loc_1FCFE	; Jump if Greater or Equal (SF=OF)
jmp	loc_1FC31	; Jump

loc_1FCFE:		; CODE XREF: idk_VidLib_s1FBBF+13Aj
mov	ax, [bp+var_C]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands

loc_1FD05:		; Jump if Above	(CF=0 &	ZF=0)
ja	short loc_1FD22

loc_1FD07:
mov	ax, [bp+var_6]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jb	short loc_1FD22	; Jump if Below	(CF=1)
mov	ax, [bp+var_26]

loc_1FD13:		; Compare Two Operands
cmp	ax, [idk_ScrnPosY199_w35EC8]
jg	short loc_1FD22	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [bp+var_28]
cmp	ax, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands

loc_1FD20:		; Jump if Greater or Equal (SF=OF)
jge	short loc_1FD27

loc_1FD22:		; CODE XREF: idk_VidLib_s1FBBF:loc_1FD05j
			; idk_VidLib_s1FBBF+14Fj
			; idk_VidLib_s1FBBF+158j
xor	ax, ax		; Logical Exclusive OR
jmp	loc_20C54	; Jump

loc_1FD27:		; CODE XREF: idk_VidLib_s1FBBF:loc_1FD20j
mov	ax, [bp+var_C]
cmp	ax, [bp+var_A]	; Compare Two Operands
jz	short loc_1FD32	; Jump if Zero (ZF=1)
jmp	loc_20084	; Jump

loc_1FD32:		; CODE XREF: idk_VidLib_s1FBBF+16Ej
mov	ax, [bp+var_14]
cmp	ax, [bp+var_12]	; Compare Two Operands

loc_1FD38:		; Jump if Below	or Equal (CF=1 | ZF=1)
jbe	short loc_1FD67
lea	ax, [bp+var_A]	; Load Effective Address
push	ax
lea	ax, [bp+var_C]	; Load Effective Address

loc_1FD41:
push	ax

loc_1FD42:		; Call Procedure
call	sub_1CFBD
pop	cx
pop	cx

loc_1FD49:		; Load Effective Address
lea	ax, [bp+var_12]
push	ax

loc_1FD4D:		; Load Effective Address
lea	ax, [bp+var_14]

loc_1FD50:
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_1A]	; Load Effective Address
push	ax
lea	ax, [bp+var_1C]	; Load Effective Address

loc_1FD5F:
push	ax

loc_1FD60:		; Call Procedure
call	sub_1CFBD
pop	cx
pop	cx

loc_1FD67:		; CODE XREF: idk_VidLib_s1FBBF:loc_1FD38j
mov	ax, [bp+var_C]
mov	[bp+var_1E], ax
mov	ax, [bp+var_14]
mov	[bp+var_20], ax

loc_1FD73:
mov	ax, [bp+var_12]
sub	ax, [bp+var_14]	; Integer Subtraction

loc_1FD79:		; Increment by 1
inc	ax
mov	[bp+var_4C], ax

loc_1FD7D:
mov	[bp+var_22], 0

loc_1FD82:
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_40], ax
mov	[bp+var_24], 0

loc_1FD91:
mov	[bp+var_2A], 0
mov	[bp+var_2C], 0

loc_1FD9B:
mov	bx, [bp+var_1C]

loc_1FD9E:		; Decrement by 1
dec	bx

loc_1FD9F:		; switch 4 cases
cmp	bx, 3
jbe	short loc_1FDA7	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_1FF06	; default

loc_1FDA7:		; CODE XREF: idk_VidLib_s1FBBF+1E3j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_20C72+bx] ; switch jump

loc_1FDAE:		; DATA XREF: seg028:off_20C72o
mov	[bp+var_4E], 0	; case 0x0

loc_1FDB3:
mov	[bp+var_44], 1
mov	[bp+var_42], si
xor	di, di		; Logical Exclusive OR
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction
inc	ax		; Increment by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax

loc_1FDC8:
mov	ax, [bp+arg_14]
xor	dx, dx		; Logical Exclusive OR

loc_1FDCD:
mov	cl, 8

loc_1FDCF:		; Call Procedure
call	LXLSH@
push	dx
push	ax

loc_1FDD6:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
mov	[bp+var_32], ax
mov	ax, [bp+var_12]
sub	ax, [bp+var_14]	; Integer Subtraction
inc	ax		; Increment by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, si

loc_1FDEB:		; CODE XREF: idk_VidLib_s1FBBF:loc_1FF03j
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8

loc_1FDEF:		; Call Procedure
call	LXLSH@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_38], ax
mov	[bp+var_3C], 0
jmp	loc_1FF06	; default

loc_1FE06:		; CODE XREF: idk_VidLib_s1FBBF+1EAj
			; DATA XREF: seg028:off_20C72o
mov	ax, [bp+arg_14]	; case 0x1

loc_1FE09:		; Decrement by 1
dec	ax
imul	si		; Signed Multiply
mov	[bp+var_4E], ax

loc_1FE0F:
mov	ax, si
neg	ax		; Two's Complement Negation
mov	[bp+var_44], ax
mov	[bp+var_42], 1

loc_1FE1B:
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction
inc	ax		; Increment by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, si
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8
call	LXLSH@		; Call Procedure
push	dx
push	ax

loc_1FE33:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
mov	[bp+var_32], ax
xor	di, di		; Logical Exclusive OR

loc_1FE3D:
mov	[bp+var_3C], 0
mov	ax, [bp+var_12]
sub	ax, [bp+var_14]	; Integer Subtraction

loc_1FE48:		; Increment by 1
inc	ax

loc_1FE49:		; Logical Exclusive OR
xor	dx, dx
push	dx
push	ax
mov	ax, [bp+arg_14]
xor	dx, dx		; Logical Exclusive OR

loc_1FE52:
mov	cl, 8

loc_1FE54:		; Call Procedure
call	LXLSH@
push	dx
push	ax

loc_1FE5B:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E

loc_1FE60:
mov	[bp+var_38], ax
jmp	loc_1FF06	; default

loc_1FE66:		; CODE XREF: idk_VidLib_s1FBBF+1EAj
			; DATA XREF: seg028:off_20C72o
mov	ax, [bp+arg_14]	; case 0x2
imul	si		; Signed Multiply
dec	ax		; Decrement by 1
mov	[bp+var_4E], ax

loc_1FE6F:
mov	[bp+var_44], 0FFFFh
mov	ax, si
neg	ax		; Two's Complement Negation
mov	[bp+var_42], ax
mov	ax, [bp+var_8]

loc_1FE7E:		; Integer Subtraction
sub	ax, [bp+var_C]
inc	ax		; Increment by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, [bp+arg_14]
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8

loc_1FE8D:		; Call Procedure
call	LXLSH@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E

loc_1FE99:
mov	[bp+var_32], ax

loc_1FE9C:		; Logical Exclusive OR
xor	di, di

loc_1FE9E:
mov	[bp+var_3C], 0
mov	ax, [bp+var_12]

loc_1FEA6:		; Integer Subtraction
sub	ax, [bp+var_14]
inc	ax		; Increment by 1
xor	dx, dx		; Logical Exclusive OR
push	dx

loc_1FEAD:
push	ax
mov	ax, si
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8

loc_1FEB4:		; Call Procedure
call	LXLSH@

loc_1FEB9:
push	dx
push	ax

loc_1FEBB:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E

loc_1FEC0:
mov	[bp+var_38], ax
jmp	short loc_1FF06	; default

loc_1FEC5:		; CODE XREF: idk_VidLib_s1FBBF+1EAj
			; DATA XREF: seg028:off_20C72o
mov	ax, si		; case 0x3
dec	ax		; Decrement by 1
mov	[bp+var_4E], ax

loc_1FECB:
mov	[bp+var_44], si

loc_1FECE:
mov	[bp+var_42], 0FFFFh
xor	di, di		; Logical Exclusive OR
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction
inc	ax		; Increment by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, si
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8
call	LXLSH@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_32], ax
mov	ax, [bp+var_12]
sub	ax, [bp+var_14]	; Integer Subtraction

loc_1FEFB:		; Increment by 1
inc	ax
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax

loc_1FF00:
mov	ax, [bp+arg_14]

loc_1FF03:		; Jump
jmp	loc_1FDEB

loc_1FF06:		; CODE XREF: idk_VidLib_s1FBBF+1E5j
			; idk_VidLib_s1FBBF+244j
			; idk_VidLib_s1FBBF+2A4j
			; idk_VidLib_s1FBBF+304j
mov	[bp+var_2E], 0	; default

loc_1FF0B:		; Compare Two Operands
cmp	di, 100h
jl	short loc_1FF29	; Jump if Less (SF!=OF)
mov	ax, di

loc_1FF13:
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_44]	; Signed Multiply
mov	[bp+var_2E], ax

loc_1FF1F:
mov	ax, di
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	di, dx

loc_1FF29:		; CODE XREF: idk_VidLib_s1FBBF+350j
cmp	[bp+var_32], 100h ; Compare Two	Operands
jl	short loc_1FF4B	; Jump if Less (SF!=OF)
mov	ax, [bp+var_32]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_42]	; Signed Multiply
add	[bp+var_2E], ax	; Add
mov	ax, [bp+var_32]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_1FF48:
mov	[bp+var_32], dx

loc_1FF4B:		; CODE XREF: idk_VidLib_s1FBBF+36Fj
mov	[bp+var_36], 0

loc_1FF50:		; Compare Two Operands
cmp	[bp+var_38], 100h

loc_1FF55:		; Jump if Less (SF!=OF)
jl	short loc_1FF72
mov	ax, [bp+var_38]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)

loc_1FF5E:		; Signed Divide
idiv	bx
imul	[bp+var_44]	; Signed Multiply
mov	[bp+var_36], ax
mov	ax, [bp+var_38]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_1FF6F:
mov	[bp+var_38], dx

loc_1FF72:		; CODE XREF: idk_VidLib_s1FBBF:loc_1FF55j
cmp	[bp+var_3C], 100h ; Compare Two	Operands
jl	short loc_1FF94	; Jump if Less (SF!=OF)
mov	ax, [bp+var_3C]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)

loc_1FF80:		; Signed Divide
idiv	bx
imul	[bp+var_42]	; Signed Multiply
add	[bp+var_36], ax	; Add

loc_1FF88:
mov	ax, [bp+var_3C]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_3C], dx

loc_1FF94:		; CODE XREF: idk_VidLib_s1FBBF+3B8j
mov	ax, [bp+var_8]

loc_1FF97:		; Compare Two Operands
cmp	ax, [idk_ScrnPosX0_w35EC2]
jnb	short loc_1FFA0	; Jump if Not Below (CF=0)

loc_1FF9D:		; Jump
jmp	loc_20081

loc_1FFA0:		; CODE XREF: idk_VidLib_s1FBBF+3DCj
mov	ax, [bp+var_C]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jbe	short loc_1FFAC	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_20081	; Jump

loc_1FFAC:		; CODE XREF: idk_VidLib_s1FBBF+3E8j
mov	ax, [idk_ScrnPosX0_w35EC2]
sub	ax, [bp+var_C]	; Integer Subtraction
dec	ax		; Decrement by 1
mov	[bp+var_48], ax
mov	ax, [idk_ScrnPosX319_w35EC6]
cmp	ax, [bp+var_8]	; Compare Two Operands
jnb	short loc_1FFC8	; Jump if Not Below (CF=0)

loc_1FFBE:
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_1FFC1:		; Integer Subtraction
sub	ax, [bp+var_C]
inc	ax		; Increment by 1

loc_1FFC5:
mov	[bp+var_40], ax

loc_1FFC8:		; CODE XREF: idk_VidLib_s1FBBF+3FDj
cmp	[bp+var_46], 0	; Compare Two Operands
jnz	short loc_20027	; Jump if Not Zero (ZF=0)

loc_1FFCE:
mov	ax, [idk_ScrnPosX319_w35EC6]
inc	ax		; Increment by 1
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
push	[bp+var_48]

loc_1FFE4:
push	[bp+var_42]

loc_1FFE7:
push	[bp+var_3C]

loc_1FFEA:
push	[bp+var_44]
push	[bp+var_38]

loc_1FFF0:
push	[bp+var_36]

loc_1FFF3:
push	[bp+var_42]
push	[bp+var_32]

loc_1FFF9:
push	[bp+var_44]

loc_1FFFC:
push	di

loc_1FFFD:
push	[bp+var_2E]
mov	ax, [bp+arg_10]
inc	ax		; Increment by 1
push	ax
push	[bp+var_4E]
push	[bp+var_2C]

loc_2000B:
push	[bp+var_2A]
push	[bp+var_24]
push	[bp+var_22]
push	[bp+var_4C]
push	[bp+var_40]
push	[bp+var_20]
push	[bp+var_1E]
call	sub_23B75	; Call Procedure
jmp	short loc_2007E	; Jump

loc_20027:		; CODE XREF: idk_VidLib_s1FBBF+40Dj
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_2002A:		; Increment by 1
inc	ax
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply

loc_20030:
push	ax
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax

loc_2003A:
push	[bp+var_48]
push	[bp+var_42]
push	[bp+var_3C]
push	[bp+var_44]
push	[bp+var_38]
push	[bp+var_36]
push	[bp+var_42]
push	[bp+var_32]
push	[bp+var_44]
push	di
push	[bp+var_2E]
mov	ax, [bp+arg_10]
inc	ax		; Increment by 1
push	ax
push	[bp+var_4E]
push	[bp+var_2C]
push	[bp+var_2A]
push	[bp+var_24]
push	[bp+var_22]
push	[bp+var_4C]

loc_20070:
push	[bp+var_40]
push	[bp+var_20]
push	[bp+var_1E]
call	sub_23CF1	; Call Procedure

loc_2007E:		; CODE XREF: idk_VidLib_s1FBBF+466j
add	sp, 2Eh		; Add

loc_20081:		; CODE XREF: idk_VidLib_s1FBBF:loc_1FF9Dj
			; idk_VidLib_s1FBBF+3EAj
jmp	loc_20C54	; Jump

loc_20084:		; CODE XREF: idk_VidLib_s1FBBF+170j
mov	ax, [bp+var_C]
mov	[bp+var_1E], ax

loc_2008A:
mov	ax, [bp+var_14]
mov	[bp+var_20], ax
mov	ax, [bp+var_A]
sub	ax, [bp+var_C]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_40], ax
mov	ax, [bp+var_12]
cmp	ax, [bp+var_14]	; Compare Two Operands
jnb	short loc_200D1	; Jump if Not Below (CF=0)
mov	ax, [bp+var_10]
sub	ax, [bp+var_14]	; Integer Subtraction
mov	dx, [bp+var_A]

loc_200AB:		; Integer Subtraction
sub	dx, [bp+var_C]
imul	dx		; Signed Multiply

loc_200B0:
mov	bx, [bp+var_8]
sub	bx, [bp+var_C]	; Integer Subtraction

loc_200B6:		; Logical Exclusive OR
xor	dx, dx

loc_200B8:		; Unsigned Divide
div	bx
add	ax, [bp+var_14]	; Add

loc_200BD:		; Integer Subtraction
sub	ax, [bp+var_12]

loc_200C0:		; Increment by 1
inc	ax
mov	[bp+var_4A], ax

loc_200C4:		; Compare Two Operands
cmp	[bp+var_4C], 1
jnb	short loc_200CF	; Jump if Not Below (CF=0)
mov	[bp+var_4C], 1

loc_200CF:		; CODE XREF: idk_VidLib_s1FBBF+509j
jmp	short loc_200F3	; Jump

loc_200D1:		; CODE XREF: idk_VidLib_s1FBBF+4E1j
mov	ax, [bp+var_14]

loc_200D4:		; Integer Subtraction
sub	ax, [bp+var_10]
mov	dx, [bp+var_A]
sub	dx, [bp+var_C]	; Integer Subtraction
imul	dx		; Signed Multiply

loc_200DF:
mov	bx, [bp+var_8]
sub	bx, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
add	ax, [bp+var_12]	; Add
sub	ax, [bp+var_14]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_4A], ax

loc_200F3:		; CODE XREF: idk_VidLib_s1FBBF:loc_200CFj
mov	[bp+var_4C], 1
mov	bx, [bp+var_40]
dec	bx		; Decrement by 1

loc_200FC:
mov	ax, [bp+var_4A]
sub	ax, [bp+var_4C]	; Integer Subtraction
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	[bp+var_22], ax

loc_2010D:
mov	[bp+var_2C], 0FFB0h
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_20129	; Jump if Not Below (CF=0)
mov	ax, [bp+var_14]
sub	ax, [bp+var_12]	; Integer Subtraction
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left

loc_20124:
mov	bx, [bp+var_A]
jmp	short loc_20136	; Jump

loc_20129:		; CODE XREF: idk_VidLib_s1FBBF+559j
mov	ax, [bp+var_14]
sub	ax, [bp+var_10]	; Integer Subtraction

loc_2012F:
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left
mov	bx, [bp+var_8]

loc_20136:		; CODE XREF: idk_VidLib_s1FBBF+568j
sub	bx, [bp+var_C]	; Integer Subtraction

loc_20139:		; Logical Exclusive OR
xor	dx, dx
div	bx		; Unsigned Divide

loc_2013D:
mov	[bp+var_2A], ax
cmp	[bp+var_2A], 100h ; Compare Two	Operands
jge	short loc_2014E	; Jump if Greater or Equal (SF=OF)

loc_20147:
mov	[bp+var_24], 0

loc_2014C:		; Jump
jmp	short loc_2016B

loc_2014E:		; CODE XREF: idk_VidLib_s1FBBF+586j
mov	ax, [bp+var_2A]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 0FFB0h
imul	dx		; Signed Multiply
mov	[bp+var_24], ax

loc_2015F:
mov	ax, [bp+var_2A]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_20168:
mov	[bp+var_2A], dx

loc_2016B:		; CODE XREF: idk_VidLib_s1FBBF:loc_2014Cj
cmp	[bp+var_1C], 1	; Compare Two Operands

loc_2016F:		; Jump if Zero (ZF=1)
jz	short loc_2017A
cmp	[bp+var_1C], 3	; Compare Two Operands
jz	short loc_2017A	; Jump if Zero (ZF=1)
jmp	loc_2023D	; Jump

loc_2017A:		; CODE XREF: idk_VidLib_s1FBBF:loc_2016Fj
			; idk_VidLib_s1FBBF+5B6j
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands

loc_20180:		; Jump if Not Below (CF=0)
jnb	short loc_201DA

loc_20182:
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
push	dx

loc_20189:
push	ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR

loc_20190:
mov	cl, 8
call	LXLSH@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_3C], ax
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
push	dx

loc_201AA:
push	ax
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, si
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8

loc_201BA:		; Call Procedure
call	LXLSH@
push	ax

loc_201C0:
mov	ax, [bp+var_A]
sub	ax, [bp+var_C]	; Integer Subtraction
push	dx

loc_201C7:		; Logical Exclusive OR
xor	dx, dx
pop	cx
pop	bx

loc_201CB:		; Call Procedure
call	LXMUL@
push	dx
push	ax

loc_201D2:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
cwd			; AX ->	DX:AX (with sign)
jmp	short loc_20230	; Jump

loc_201DA:		; CODE XREF: idk_VidLib_s1FBBF:loc_20180j
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction

loc_201E0:		; Logical Exclusive OR
xor	dx, dx
push	dx

loc_201E3:
push	ax

loc_201E4:
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8

loc_201F4:		; Call Procedure
call	LXLSH@
push	ax
mov	ax, [bp+var_A]
sub	ax, [bp+var_C]	; Integer Subtraction
push	dx
xor	dx, dx		; Logical Exclusive OR
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_3C], ax
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1

loc_20220:		; Logical Exclusive OR
xor	dx, dx

loc_20222:
push	dx
push	ax
mov	ax, si
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8
call	LXLSH@		; Call Procedure

loc_20230:		; CODE XREF: idk_VidLib_s1FBBF+619j
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_38], ax

loc_2023A:		; Jump
jmp	loc_202FD

loc_2023D:		; CODE XREF: idk_VidLib_s1FBBF+5B8j
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_2029D	; Jump if Not Below (CF=0)
mov	ax, [bp+var_6]
sub	ax, [bp+var_A]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8

loc_2025F:		; Call Procedure
call	LXLSH@
push	ax
mov	ax, [bp+var_6]
sub	ax, [bp+var_8]	; Integer Subtraction
push	dx

loc_2026C:		; Logical Exclusive OR
xor	dx, dx
pop	cx
pop	bx

loc_20270:		; Call Procedure
call	LXMUL@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax

loc_2027F:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
mov	[bp+var_3C], ax
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, si
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8
call	LXLSH@		; Call Procedure

loc_2029B:		; Jump
jmp	short loc_202F3

loc_2029D:		; CODE XREF: idk_VidLib_s1FBBF+684j
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8
call	LXLSH@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_3C], ax
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, si
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8
call	LXLSH@		; Call Procedure
push	ax
mov	ax, [bp+var_A]
sub	ax, [bp+var_C]	; Integer Subtraction
push	dx
xor	dx, dx		; Logical Exclusive OR
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
cwd			; AX ->	DX:AX (with sign)

loc_202F3:		; CODE XREF: idk_VidLib_s1FBBF:loc_2029Bj
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E

loc_202FA:
mov	[bp+var_38], ax

loc_202FD:		; CODE XREF: idk_VidLib_s1FBBF:loc_2023Aj
mov	bx, [bp+var_1C]

loc_20300:		; Decrement by 1
dec	bx
cmp	bx, 3		; switch 4 cases
jbe	short loc_20309	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_20449	; default

loc_20309:		; CODE XREF: idk_VidLib_s1FBBF+745j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_20C6A+bx] ; switch jump

loc_20310:		; DATA XREF: seg028:off_20C6Ao
mov	[bp+var_4E], 0	; case 0x0
mov	[bp+var_30], 1
mov	[bp+var_34], si
mov	[bp+var_3A], 1
mov	ax, si
neg	ax		; Two's Complement Negation
mov	[bp+var_3E], ax
xor	di, di		; Logical Exclusive OR

loc_2032B:
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_20338	; Jump if Not Below (CF=0)

loc_20333:
mov	ax, [bp+var_A]
jmp	short loc_2033B	; Jump

loc_20338:		; CODE XREF: idk_VidLib_s1FBBF+772j
mov	ax, [bp+var_8]

loc_2033B:		; CODE XREF: idk_VidLib_s1FBBF+777j
sub	ax, [bp+var_C]	; Integer Subtraction

loc_2033E:		; Logical Exclusive OR
xor	dx, dx
push	dx
push	ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8

loc_2034A:		; Call Procedure
call	LXLSH@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_32], ax
jmp	loc_20449	; default

loc_2035C:		; CODE XREF: idk_VidLib_s1FBBF+74Cj
			; DATA XREF: seg028:off_20C6Ao
mov	ax, [bp+arg_14]	; case 0x1
dec	ax		; Decrement by 1
imul	si		; Signed Multiply
mov	[bp+var_4E], ax

loc_20365:
mov	[bp+var_30], 1
mov	ax, si
neg	ax		; Two's Complement Negation
mov	[bp+var_34], ax
mov	[bp+var_3A], 0FFFFh

loc_20376:
mov	ax, si

loc_20378:		; Two's Complement Negation
neg	ax
mov	[bp+var_3E], ax

loc_2037D:
mov	[bp+var_32], 0
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_2038F	; Jump if Not Below (CF=0)
mov	ax, [bp+var_A]
jmp	short loc_20392	; Jump

loc_2038F:		; CODE XREF: idk_VidLib_s1FBBF+7C9j
mov	ax, [bp+var_8]

loc_20392:		; CODE XREF: idk_VidLib_s1FBBF+7CEj
sub	ax, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	ax, si
dec	ax		; Decrement by 1

loc_2039C:		; Logical Exclusive OR
xor	dx, dx
mov	cl, 8

loc_203A0:		; Call Procedure
call	LXLSH@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E

loc_203AC:
mov	di, ax

loc_203AE:		; default
jmp	loc_20449

loc_203B1:		; CODE XREF: idk_VidLib_s1FBBF+74Cj
			; DATA XREF: seg028:off_20C6Ao
mov	ax, [bp+arg_14]	; case 0x2
imul	si		; Signed Multiply
dec	ax		; Decrement by 1
mov	[bp+var_4E], ax

loc_203BA:
mov	[bp+var_30], 0FFFFh
mov	ax, si
neg	ax		; Two's Complement Negation

loc_203C3:
mov	[bp+var_34], ax
mov	[bp+var_3A], 0FFFFh
mov	[bp+var_3E], si
xor	di, di		; Logical Exclusive OR
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_203DD	; Jump if Not Below (CF=0)
mov	ax, [bp+var_A]
jmp	short loc_203E0	; Jump

loc_203DD:		; CODE XREF: idk_VidLib_s1FBBF+817j
mov	ax, [bp+var_8]

loc_203E0:		; CODE XREF: idk_VidLib_s1FBBF+81Cj
sub	ax, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR

loc_203E5:
push	dx
push	ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8

loc_203EF:		; Call Procedure
call	LXLSH@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_32], ax

loc_203FE:		; default
jmp	short loc_20449

loc_20400:		; CODE XREF: idk_VidLib_s1FBBF+74Cj
			; DATA XREF: seg028:off_20C6Ao
mov	ax, si		; case 0x3
dec	ax		; Decrement by 1
mov	[bp+var_4E], ax

loc_20406:
mov	[bp+var_30], 0FFFFh
mov	[bp+var_34], si

loc_2040E:
mov	[bp+var_3A], 1
mov	[bp+var_3E], si

loc_20416:
mov	[bp+var_32], 0
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_20428	; Jump if Not Below (CF=0)

loc_20423:
mov	ax, [bp+var_A]
jmp	short loc_2042B	; Jump

loc_20428:		; CODE XREF: idk_VidLib_s1FBBF+862j
mov	ax, [bp+var_8]

loc_2042B:		; CODE XREF: idk_VidLib_s1FBBF+867j
sub	ax, [bp+var_C]	; Integer Subtraction

loc_2042E:		; Logical Exclusive OR
xor	dx, dx

loc_20430:
push	dx

loc_20431:
push	ax

loc_20432:
mov	ax, si
dec	ax		; Decrement by 1
xor	dx, dx		; Logical Exclusive OR
mov	cl, 8
call	LXLSH@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	di, ax
jmp	short $+2	; Jump

loc_20449:		; CODE XREF: idk_VidLib_s1FBBF+747j
			; idk_VidLib_s1FBBF+79Aj
			; idk_VidLib_s1FBBF:loc_203AEj
			; idk_VidLib_s1FBBF:loc_203FEj
mov	[bp+var_2E], 0	; default
cmp	di, 100h	; Compare Two Operands
jl	short loc_2046C	; Jump if Less (SF!=OF)
mov	ax, di
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_30]	; Signed Multiply

loc_2045F:
mov	[bp+var_2E], ax
mov	ax, di
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	di, dx

loc_2046C:		; CODE XREF: idk_VidLib_s1FBBF+893j
cmp	[bp+var_32], 100h ; Compare Two	Operands

loc_20471:		; Jump if Less (SF!=OF)
jl	short loc_2048E

loc_20473:
mov	ax, [bp+var_32]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_34]	; Signed Multiply

loc_2047F:		; Add
add	[bp+var_2E], ax
mov	ax, [bp+var_32]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_32], dx

loc_2048E:		; CODE XREF: idk_VidLib_s1FBBF:loc_20471j
mov	[bp+var_36], 0
cmp	[bp+var_38], 100h ; Compare Two	Operands
jl	short loc_204B5	; Jump if Less (SF!=OF)
mov	ax, [bp+var_38]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_3A]	; Signed Multiply
mov	[bp+var_36], ax
mov	ax, [bp+var_38]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_38], dx

loc_204B5:		; CODE XREF: idk_VidLib_s1FBBF+8D9j
cmp	[bp+var_3C], 100h ; Compare Two	Operands
jl	short loc_204D7	; Jump if Less (SF!=OF)
mov	ax, [bp+var_3C]

loc_204BF:
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_3E]	; Signed Multiply
add	[bp+var_36], ax	; Add
mov	ax, [bp+var_3C]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_3C], dx

loc_204D7:		; CODE XREF: idk_VidLib_s1FBBF+8FBj
mov	ax, [bp+var_A]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jnb	short loc_204E3	; Jump if Not Below (CF=0)
jmp	loc_205C4	; Jump

loc_204E3:		; CODE XREF: idk_VidLib_s1FBBF+91Fj
mov	ax, [bp+var_C]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jbe	short loc_204EF	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_205C4	; Jump

loc_204EF:		; CODE XREF: idk_VidLib_s1FBBF+92Bj
mov	ax, [idk_ScrnPosX0_w35EC2]

loc_204F2:		; Integer Subtraction
sub	ax, [bp+var_C]

loc_204F5:		; Decrement by 1
dec	ax

loc_204F6:
mov	[bp+var_48], ax
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_204FC:		; Compare Two Operands
cmp	ax, [bp+var_A]
jnb	short loc_2050B	; Jump if Not Below (CF=0)
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_20504:		; Integer Subtraction
sub	ax, [bp+var_C]
inc	ax		; Increment by 1
mov	[bp+var_40], ax

loc_2050B:		; CODE XREF: idk_VidLib_s1FBBF+940j
cmp	[bp+var_46], 0	; Compare Two Operands
jnz	short loc_2056A	; Jump if Not Zero (ZF=0)
mov	ax, [idk_ScrnPosX319_w35EC6]
inc	ax		; Increment by 1
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax

loc_2051B:
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
push	[bp+var_48]

loc_20527:
push	[bp+var_3E]

loc_2052A:
push	[bp+var_3C]
push	[bp+var_3A]
push	[bp+var_38]

loc_20533:
push	[bp+var_36]
push	[bp+var_34]
push	[bp+var_32]

loc_2053C:
push	[bp+var_30]
push	di
push	[bp+var_2E]
mov	ax, [bp+arg_10]
inc	ax		; Increment by 1
push	ax
push	[bp+var_4E]

loc_2054B:
push	[bp+var_2C]
push	[bp+var_2A]
push	[bp+var_24]
push	[bp+var_22]
push	[bp+var_4C]

loc_2055A:
push	[bp+var_40]
push	[bp+var_20]

loc_20560:
push	[bp+var_1E]

loc_20563:		; Call Procedure
call	sub_23B75
jmp	short loc_205C1	; Jump

loc_2056A:		; CODE XREF: idk_VidLib_s1FBBF+950j
mov	ax, [idk_ScrnPosX319_w35EC6]
inc	ax		; Increment by 1
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
push	[bp+var_48]
push	[bp+var_3E]
push	[bp+var_3C]
push	[bp+var_3A]
push	[bp+var_38]
push	[bp+var_36]
push	[bp+var_34]
push	[bp+var_32]
push	[bp+var_30]
push	di

loc_20599:
push	[bp+var_2E]

loc_2059C:
mov	ax, [bp+arg_10]

loc_2059F:		; Increment by 1
inc	ax
push	ax

loc_205A1:
push	[bp+var_4E]

loc_205A4:
push	[bp+var_2C]
push	[bp+var_2A]
push	[bp+var_24]
push	[bp+var_22]
push	[bp+var_4C]
push	[bp+var_40]
push	[bp+var_20]
push	[bp+var_1E]
call	sub_23CF1	; Call Procedure

loc_205C1:		; CODE XREF: idk_VidLib_s1FBBF+9A9j
add	sp, 2Eh		; Add

loc_205C4:		; CODE XREF: idk_VidLib_s1FBBF+921j
			; idk_VidLib_s1FBBF+92Dj
mov	ax, [bp+var_A]
mov	[bp+var_1E], ax
mov	ax, [bp+var_8]
sub	ax, [bp+var_A]	; Integer Subtraction

loc_205D0:		; Increment by 1
inc	ax
mov	[bp+var_40], ax
mov	ax, [bp+var_4A]
mov	[bp+var_4C], ax
mov	[bp+var_22], 0
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_20636	; Jump if Not Below (CF=0)

loc_205E7:
mov	ax, [bp+var_12]
mov	[bp+var_20], ax

loc_205ED:
mov	[bp+var_2C], 50h ; 'P'
mov	ax, [bp+var_E]
sub	ax, [bp+var_12]	; Integer Subtraction
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left

loc_205FC:
mov	bx, [bp+var_6]
sub	bx, [bp+var_A]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	[bp+var_2A], ax
cmp	[bp+var_2A], 100h ; Compare Two	Operands
jge	short loc_20617	; Jump if Greater or Equal (SF=OF)

loc_20610:
mov	[bp+var_24], 0

loc_20615:		; Jump
jmp	short loc_20634

loc_20617:		; CODE XREF: idk_VidLib_s1FBBF+A4Fj
mov	ax, [bp+var_2A]

loc_2061A:
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
mov	[bp+var_24], ax

loc_20628:
mov	ax, [bp+var_2A]

loc_2062B:
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_20631:
mov	[bp+var_2A], dx

loc_20634:		; CODE XREF: idk_VidLib_s1FBBF:loc_20615j
jmp	short loc_20656	; Jump

loc_20636:		; CODE XREF: idk_VidLib_s1FBBF+A26j
mov	ax, [bp+var_14]

loc_20639:		; Integer Subtraction
sub	ax, [bp+var_10]

loc_2063C:
mov	dx, [bp+var_A]
sub	dx, [bp+var_C]	; Integer Subtraction
imul	dx		; Signed Multiply

loc_20644:
mov	bx, [bp+var_8]
sub	bx, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide

loc_2064E:
mov	dx, [bp+var_14]
sub	dx, ax		; Integer Subtraction
mov	[bp+var_20], dx

loc_20656:		; CODE XREF: idk_VidLib_s1FBBF:loc_20634j
mov	bx, [bp+var_1C]
dec	bx		; Decrement by 1

loc_2065A:		; switch 4 cases
cmp	bx, 3
jbe	short loc_20662	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_2065F:		; default
jmp	loc_207CD

loc_20662:		; CODE XREF: idk_VidLib_s1FBBF+A9Ej
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_20C62+bx] ; switch jump

loc_20669:		; DATA XREF: seg028:off_20C62o
mov	ax, [bp+var_12]	; case 0x0

loc_2066C:		; Compare Two Operands
cmp	ax, [bp+var_10]
jnb	short loc_20694	; Jump if Not Below (CF=0)
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
imul	si		; Signed Multiply
mov	[bp+var_4E], ax

loc_2067A:
mov	[bp+var_32], 0
mov	ax, si
dec	ax		; Decrement by 1
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left
mov	bx, [bp+var_6]
sub	bx, [bp+var_A]	; Integer Subtraction

loc_2068C:		; Logical Exclusive OR
xor	dx, dx

loc_2068E:		; Unsigned Divide
div	bx
mov	di, ax
jmp	short loc_206BD	; Jump

loc_20694:		; CODE XREF: idk_VidLib_s1FBBF+AB0j
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax

loc_2069E:
mov	bx, [bp+arg_14]
dec	bx		; Decrement by 1
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+var_A]
sub	ax, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR

loc_206AC:		; Call Procedure
call	LXMUL@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
imul	si		; Signed Multiply
mov	[bp+var_4E], ax

loc_206BD:		; CODE XREF: idk_VidLib_s1FBBF+AD3j
jmp	loc_207CD	; default

loc_206C0:		; CODE XREF: idk_VidLib_s1FBBF+AA5j
			; DATA XREF: seg028:off_20C62o
mov	ax, [bp+var_12]	; case 0x1
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_206EA	; Jump if Not Below (CF=0)
mov	ax, [bp+arg_14]
imul	si		; Signed Multiply
dec	ax		; Decrement by 1
mov	[bp+var_4E], ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left
mov	bx, [bp+var_6]

loc_206DC:		; Integer Subtraction
sub	bx, [bp+var_A]
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	[bp+var_32], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_2071A	; Jump

loc_206EA:		; CODE XREF: idk_VidLib_s1FBBF+B07j
mov	ax, [bp+var_8]

loc_206ED:		; Integer Subtraction
sub	ax, [bp+var_C]
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	bx, si
dec	bx		; Decrement by 1
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+var_A]
sub	ax, [bp+var_C]	; Integer Subtraction

loc_206FF:		; Logical Exclusive OR
xor	dx, dx
call	LXMUL@		; Call Procedure

loc_20706:
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
push	ax

loc_2070E:
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
imul	si		; Signed Multiply
pop	dx
add	ax, dx		; Add

loc_20717:
mov	[bp+var_4E], ax

loc_2071A:		; CODE XREF: idk_VidLib_s1FBBF+B29j
jmp	loc_207CD	; default

loc_2071D:		; CODE XREF: idk_VidLib_s1FBBF+AA5j
			; DATA XREF: seg028:off_20C62o
mov	ax, [bp+var_12]	; case 0x2

loc_20720:		; Compare Two Operands
cmp	ax, [bp+var_10]
jnb	short loc_20745	; Jump if Not Below (CF=0)

loc_20725:
mov	ax, si
dec	ax		; Decrement by 1

loc_20728:
mov	[bp+var_4E], ax
mov	[bp+var_32], 0
mov	ax, si
dec	ax		; Decrement by 1
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left
mov	bx, [bp+var_6]

loc_2073A:		; Integer Subtraction
sub	bx, [bp+var_A]
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	di, ax
jmp	short loc_20778	; Jump

loc_20745:		; CODE XREF: idk_VidLib_s1FBBF+B64j
mov	ax, [bp+var_8]
sub	ax, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax

loc_2074F:
mov	bx, [bp+arg_14]
dec	bx		; Decrement by 1
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+var_A]

loc_20758:		; Integer Subtraction
sub	ax, [bp+var_C]
xor	dx, dx		; Logical Exclusive OR
call	LXMUL@		; Call Procedure

loc_20762:
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
imul	si		; Signed Multiply
push	ax

loc_2076C:
mov	ax, [bp+arg_14]
imul	si		; Signed Multiply
dec	ax		; Decrement by 1
pop	dx
sub	ax, dx		; Integer Subtraction
mov	[bp+var_4E], ax

loc_20778:		; CODE XREF: idk_VidLib_s1FBBF+B84j
jmp	short loc_207CD	; default

loc_2077A:		; CODE XREF: idk_VidLib_s1FBBF+AA5j
			; DATA XREF: seg028:off_20C62o
mov	ax, [bp+var_12]	; case 0x3
cmp	ax, [bp+var_10]	; Compare Two Operands

loc_20780:		; Jump if Not Below (CF=0)
jnb	short loc_207A0
mov	[bp+var_4E], 0
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left

loc_2078F:
mov	bx, [bp+var_6]
sub	bx, [bp+var_A]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide

loc_20799:
mov	[bp+var_32], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_207CB	; Jump

loc_207A0:		; CODE XREF: idk_VidLib_s1FBBF:loc_20780j
mov	ax, [bp+var_8]

loc_207A3:		; Integer Subtraction
sub	ax, [bp+var_C]
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	bx, si
dec	bx		; Decrement by 1
xor	cx, cx		; Logical Exclusive OR

loc_207AF:
mov	ax, [bp+var_A]
sub	ax, [bp+var_C]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	dx, si
dec	dx		; Decrement by 1
sub	dx, ax		; Integer Subtraction
mov	[bp+var_4E], dx

loc_207CB:		; CODE XREF: idk_VidLib_s1FBBF+BDFj
jmp	short $+2	; Jump

loc_207CD:		; CODE XREF: idk_VidLib_s1FBBF:loc_2065Fj
			; idk_VidLib_s1FBBF:loc_206BDj
			; idk_VidLib_s1FBBF:loc_2071Aj
			; idk_VidLib_s1FBBF:loc_20778j
mov	ax, [bp+var_12]	; default
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_2081A	; Jump if Not Below (CF=0)
mov	[bp+var_2E], 0
cmp	di, 100h	; Compare Two Operands
jl	short loc_207F8	; Jump if Less (SF!=OF)
mov	ax, di
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_30]	; Signed Multiply
mov	[bp+var_2E], ax
mov	ax, di
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	di, dx

loc_207F8:		; CODE XREF: idk_VidLib_s1FBBF+C1Fj
cmp	[bp+var_32], 100h ; Compare Two	Operands
jl	short loc_2081A	; Jump if Less (SF!=OF)
mov	ax, [bp+var_32]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_34]	; Signed Multiply
add	[bp+var_2E], ax	; Add

loc_2080E:
mov	ax, [bp+var_32]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_20817:
mov	[bp+var_32], dx

loc_2081A:		; CODE XREF: idk_VidLib_s1FBBF+C14j
			; idk_VidLib_s1FBBF+C3Ej
mov	ax, [bp+var_8]

loc_2081D:		; Compare Two Operands
cmp	ax, [idk_ScrnPosX0_w35EC2]
jnb	short loc_20826	; Jump if Not Below (CF=0)
jmp	loc_20907	; Jump

loc_20826:		; CODE XREF: idk_VidLib_s1FBBF+C62j
mov	ax, [bp+var_A]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jbe	short loc_20832	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_20907	; Jump

loc_20832:		; CODE XREF: idk_VidLib_s1FBBF+C6Ej
mov	ax, [idk_ScrnPosX0_w35EC2]
sub	ax, [bp+var_A]	; Integer Subtraction
dec	ax		; Decrement by 1
mov	[bp+var_48], ax
mov	ax, [idk_ScrnPosX319_w35EC6]
cmp	ax, [bp+var_8]	; Compare Two Operands
jnb	short loc_2084E	; Jump if Not Below (CF=0)

loc_20844:
mov	ax, [idk_ScrnPosX319_w35EC6]
sub	ax, [bp+var_A]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_40], ax

loc_2084E:		; CODE XREF: idk_VidLib_s1FBBF+C83j
cmp	[bp+var_46], 0	; Compare Two Operands
jnz	short loc_208AD	; Jump if Not Zero (ZF=0)
mov	ax, [idk_ScrnPosX319_w35EC6]
inc	ax		; Increment by 1
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
push	[bp+var_48]
push	[bp+var_3E]
push	[bp+var_3C]

loc_20870:
push	[bp+var_3A]

loc_20873:
push	[bp+var_38]
push	[bp+var_36]

loc_20879:
push	[bp+var_34]
push	[bp+var_32]

loc_2087F:
push	[bp+var_30]
push	di
push	[bp+var_2E]
mov	ax, [bp+arg_10]
inc	ax		; Increment by 1
push	ax
push	[bp+var_4E]
push	[bp+var_2C]
push	[bp+var_2A]
push	[bp+var_24]
push	[bp+var_22]
push	[bp+var_4C]
push	[bp+var_40]

loc_208A0:
push	[bp+var_20]
push	[bp+var_1E]
call	sub_23B75	; Call Procedure
jmp	short loc_20904	; Jump

loc_208AD:		; CODE XREF: idk_VidLib_s1FBBF+C93j
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_208B0:		; Increment by 1
inc	ax

loc_208B1:
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply

loc_208BF:
push	ax

loc_208C0:
push	[bp+var_48]
push	[bp+var_3E]

loc_208C6:
push	[bp+var_3C]
push	[bp+var_3A]
push	[bp+var_38]

loc_208CF:
push	[bp+var_36]

loc_208D2:
push	[bp+var_34]

loc_208D5:
push	[bp+var_32]

loc_208D8:
push	[bp+var_30]
push	di
push	[bp+var_2E]

loc_208DF:
mov	ax, [bp+arg_10]
inc	ax		; Increment by 1
push	ax
push	[bp+var_4E]
push	[bp+var_2C]
push	[bp+var_2A]
push	[bp+var_24]
push	[bp+var_22]
push	[bp+var_4C]
push	[bp+var_40]
push	[bp+var_20]
push	[bp+var_1E]
call	sub_23CF1	; Call Procedure

loc_20904:		; CODE XREF: idk_VidLib_s1FBBF+CECj
add	sp, 2Eh		; Add

loc_20907:		; CODE XREF: idk_VidLib_s1FBBF+C64j
			; idk_VidLib_s1FBBF+C70j
mov	ax, [bp+var_8]
mov	[bp+var_1E], ax
mov	ax, [bp+var_6]
sub	ax, [bp+var_8]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_40], ax
mov	bx, [bp+var_40]
dec	bx		; Decrement by 1
mov	ax, [bp+var_4A]
dec	ax		; Decrement by 1
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
neg	ax		; Two's Complement Negation

loc_20929:
mov	[bp+var_22], ax
mov	ax, [bp+var_12]
cmp	ax, [bp+var_10]	; Compare Two Operands

loc_20932:		; Jump if Not Below (CF=0)
jnb	short loc_20956
mov	ax, [bp+var_E]

loc_20937:		; Integer Subtraction
sub	ax, [bp+var_12]
mov	dx, [bp+var_6]
sub	dx, [bp+var_8]	; Integer Subtraction

loc_20940:		; Signed Multiply
imul	dx
mov	bx, [bp+var_6]
sub	bx, [bp+var_A]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR

loc_2094A:		; Unsigned Divide
div	bx
mov	dx, [bp+var_E]

loc_2094F:		; Integer Subtraction
sub	dx, ax

loc_20951:
mov	[bp+var_20], dx
jmp	short loc_209A3	; Jump

loc_20956:		; CODE XREF: idk_VidLib_s1FBBF:loc_20932j
mov	ax, [bp+var_10]
mov	[bp+var_20], ax
mov	[bp+var_2C], 50h ; 'P'
mov	ax, [bp+var_E]
sub	ax, [bp+var_10]	; Integer Subtraction
mov	cl, 8
shl	ax, cl		; Shift	Logical	Left
mov	bx, [bp+var_6]

loc_2096E:		; Integer Subtraction
sub	bx, [bp+var_8]
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	[bp+var_2A], ax
cmp	[bp+var_2A], 100h ; Compare Two	Operands
jge	short loc_20986	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_24], 0
jmp	short loc_209A3	; Jump

loc_20986:		; CODE XREF: idk_VidLib_s1FBBF+DBEj
mov	ax, [bp+var_2A]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_2098F:
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
mov	[bp+var_24], ax
mov	ax, [bp+var_2A]
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_209A0:
mov	[bp+var_2A], dx

loc_209A3:		; CODE XREF: idk_VidLib_s1FBBF+D95j
			; idk_VidLib_s1FBBF+DC5j
mov	bx, [bp+var_1C]
dec	bx		; Decrement by 1
cmp	bx, 3		; switch 4 cases
jbe	short loc_209AF	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_209AC:		; default
jmp	loc_20B1A

loc_209AF:		; CODE XREF: idk_VidLib_s1FBBF+DEBj
shl	bx, 1		; Shift	Logical	Left

loc_209B1:		; switch jump
jmp	[cs:off_20C5A+bx]

loc_209B6:		; DATA XREF: seg028:off_20C5Ao
mov	ax, [bp+var_12]	; case 0x0

loc_209B9:		; Compare Two Operands
cmp	ax, [bp+var_10]
jnb	short loc_209F0	; Jump if Not Below (CF=0)

loc_209BE:
mov	ax, [bp+var_6]

loc_209C1:		; Integer Subtraction
sub	ax, [bp+var_A]

loc_209C4:		; Logical Exclusive OR
xor	dx, dx

loc_209C6:
push	dx
push	ax
mov	bx, si
dec	bx		; Decrement by 1
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+var_8]
sub	ax, [bp+var_A]	; Integer Subtraction

loc_209D3:		; Logical Exclusive OR
xor	dx, dx
call	LXMUL@		; Call Procedure
push	dx
push	ax

loc_209DC:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
push	ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add

loc_209EB:
mov	[bp+var_4E], dx
jmp	short loc_20A11	; Jump

loc_209F0:		; CODE XREF: idk_VidLib_s1FBBF+DFDj
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
imul	si		; Signed Multiply

loc_209F6:
mov	[bp+var_4E], ax

loc_209F9:
mov	[bp+var_32], 0
mov	ax, si

loc_20A00:		; Decrement by 1
dec	ax

loc_20A01:
mov	cl, 8

loc_20A03:		; Shift	Logical	Left
shl	ax, cl
mov	bx, [bp+var_6]
sub	bx, [bp+var_8]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR

loc_20A0D:		; Unsigned Divide
div	bx

loc_20A0F:
mov	di, ax

loc_20A11:		; CODE XREF: idk_VidLib_s1FBBF+E2Fj
jmp	loc_20B1A	; default

loc_20A14:		; CODE XREF: idk_VidLib_s1FBBF:loc_209B1j
			; DATA XREF: seg028:off_20C5Ao
mov	ax, [bp+var_12]	; case 0x1
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_20A51	; Jump if Not Below (CF=0)

loc_20A1C:
mov	ax, [bp+var_6]
sub	ax, [bp+var_A]	; Integer Subtraction

loc_20A22:		; Logical Exclusive OR
xor	dx, dx

loc_20A24:
push	dx
push	ax
mov	bx, [bp+arg_14]
dec	bx		; Decrement by 1
xor	cx, cx		; Logical Exclusive OR

loc_20A2C:
mov	ax, [bp+var_8]
sub	ax, [bp+var_A]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR

loc_20A34:		; Call Procedure
call	LXMUL@
push	dx
push	ax

loc_20A3B:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
imul	si		; Signed Multiply
push	ax
mov	ax, [bp+arg_14]
imul	si		; Signed Multiply
dec	ax		; Decrement by 1
pop	dx
sub	ax, dx		; Integer Subtraction

loc_20A4C:
mov	[bp+var_4E], ax

loc_20A4F:		; Jump
jmp	short loc_20A71

loc_20A51:		; CODE XREF: idk_VidLib_s1FBBF+E5Bj
mov	ax, [bp+arg_14]
imul	si		; Signed Multiply
dec	ax		; Decrement by 1
mov	[bp+var_4E], ax
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
mov	cl, 8

loc_20A60:		; Shift	Logical	Left
shl	ax, cl

loc_20A62:
mov	bx, [bp+var_6]
sub	bx, [bp+var_8]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide

loc_20A6C:
mov	[bp+var_32], ax
xor	di, di		; Logical Exclusive OR

loc_20A71:		; CODE XREF: idk_VidLib_s1FBBF:loc_20A4Fj
jmp	loc_20B1A	; default

loc_20A74:		; CODE XREF: idk_VidLib_s1FBBF:loc_209B1j
			; DATA XREF: seg028:off_20C5Ao
mov	ax, [bp+var_12]	; case 0x2

loc_20A77:		; Compare Two Operands
cmp	ax, [bp+var_10]
jnb	short loc_20AA9	; Jump if Not Below (CF=0)

loc_20A7C:
mov	ax, [bp+var_6]

loc_20A7F:		; Integer Subtraction
sub	ax, [bp+var_A]
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	bx, si
dec	bx		; Decrement by 1
xor	cx, cx		; Logical Exclusive OR

loc_20A8B:
mov	ax, [bp+var_8]
sub	ax, [bp+var_A]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E

loc_20A9F:
mov	dx, si
dec	dx		; Decrement by 1
sub	dx, ax		; Integer Subtraction

loc_20AA4:
mov	[bp+var_4E], dx
jmp	short loc_20AC7	; Jump

loc_20AA9:		; CODE XREF: idk_VidLib_s1FBBF+EBBj
mov	ax, si
dec	ax		; Decrement by 1

loc_20AAC:
mov	[bp+var_4E], ax
mov	[bp+var_32], 0

loc_20AB4:
mov	ax, si
dec	ax		; Decrement by 1
mov	cl, 8

loc_20AB9:		; Shift	Logical	Left
shl	ax, cl
mov	bx, [bp+var_6]

loc_20ABE:		; Integer Subtraction
sub	bx, [bp+var_8]
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	di, ax

loc_20AC7:		; CODE XREF: idk_VidLib_s1FBBF+EE8j
jmp	short loc_20B1A	; default

loc_20AC9:		; CODE XREF: idk_VidLib_s1FBBF:loc_209B1j
			; DATA XREF: seg028:off_20C5Ao
mov	ax, [bp+var_12]	; case 0x3
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_20AFC	; Jump if Not Below (CF=0)
mov	ax, [bp+var_6]

loc_20AD4:		; Integer Subtraction
sub	ax, [bp+var_A]
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax
mov	bx, [bp+arg_14]
dec	bx		; Decrement by 1
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+var_8]
sub	ax, [bp+var_A]	; Integer Subtraction
xor	dx, dx		; Logical Exclusive OR

loc_20AE9:		; Call Procedure
call	LXMUL@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
imul	si		; Signed Multiply
mov	[bp+var_4E], ax
jmp	short loc_20B18	; Jump

loc_20AFC:		; CODE XREF: idk_VidLib_s1FBBF+F10j
mov	[bp+var_4E], 0
mov	ax, [bp+arg_14]
dec	ax		; Decrement by 1
mov	cl, 8

loc_20B07:		; Shift	Logical	Left
shl	ax, cl
mov	bx, [bp+var_6]

loc_20B0C:		; Integer Subtraction
sub	bx, [bp+var_8]
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide

loc_20B13:
mov	[bp+var_32], ax
xor	di, di		; Logical Exclusive OR

loc_20B18:		; CODE XREF: idk_VidLib_s1FBBF+F3Bj
jmp	short $+2	; Jump

loc_20B1A:		; CODE XREF: idk_VidLib_s1FBBF:loc_209ACj
			; idk_VidLib_s1FBBF:loc_20A11j
			; idk_VidLib_s1FBBF:loc_20A71j
			; idk_VidLib_s1FBBF:loc_20AC7j
mov	ax, [bp+var_12]	; default

loc_20B1D:		; Compare Two Operands
cmp	ax, [bp+var_10]
jb	short loc_20B67	; Jump if Below	(CF=1)
mov	[bp+var_2E], 0
cmp	di, 100h	; Compare Two Operands
jl	short loc_20B45	; Jump if Less (SF!=OF)
mov	ax, di
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_30]	; Signed Multiply
mov	[bp+var_2E], ax
mov	ax, di
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	di, dx

loc_20B45:		; CODE XREF: idk_VidLib_s1FBBF+F6Cj
cmp	[bp+var_32], 100h ; Compare Two	Operands
jl	short loc_20B67	; Jump if Less (SF!=OF)
mov	ax, [bp+var_32]

loc_20B4F:
mov	bx, 100h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
imul	[bp+var_34]	; Signed Multiply
add	[bp+var_2E], ax	; Add

loc_20B5B:
mov	ax, [bp+var_32]
mov	bx, 100h

loc_20B61:		; AX ->	DX:AX (with sign)
cwd
idiv	bx		; Signed Divide
mov	[bp+var_32], dx

loc_20B67:		; CODE XREF: idk_VidLib_s1FBBF+F61j
			; idk_VidLib_s1FBBF+F8Bj
mov	ax, [bp+var_6]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jnb	short loc_20B73	; Jump if Not Below (CF=0)
jmp	loc_20C54	; Jump

loc_20B73:		; CODE XREF: idk_VidLib_s1FBBF+FAFj
mov	ax, [bp+var_8]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jbe	short loc_20B7F	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_20C54	; Jump

loc_20B7F:		; CODE XREF: idk_VidLib_s1FBBF+FBBj
mov	ax, [idk_ScrnPosX0_w35EC2]
sub	ax, [bp+var_8]	; Integer Subtraction
dec	ax		; Decrement by 1
mov	[bp+var_48], ax

loc_20B89:
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_20B8C:		; Compare Two Operands
cmp	ax, [bp+var_6]
jnb	short loc_20B9B	; Jump if Not Below (CF=0)
mov	ax, [idk_ScrnPosX319_w35EC6]
sub	ax, [bp+var_8]	; Integer Subtraction
inc	ax		; Increment by 1

loc_20B98:
mov	[bp+var_40], ax

loc_20B9B:		; CODE XREF: idk_VidLib_s1FBBF+FD0j
cmp	[bp+var_46], 0	; Compare Two Operands
jnz	short loc_20BFA	; Jump if Not Zero (ZF=0)

loc_20BA1:
mov	ax, [idk_ScrnPosX319_w35EC6]
inc	ax		; Increment by 1
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
mov	ax, [idk_ScrnPosX0_w35EC2]

loc_20BAE:
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
push	[bp+var_48]
push	[bp+var_3E]

loc_20BBA:
push	[bp+var_3C]
push	[bp+var_3A]
push	[bp+var_38]
push	[bp+var_36]
push	[bp+var_34]
push	[bp+var_32]
push	[bp+var_30]
push	di
push	[bp+var_2E]
mov	ax, [bp+arg_10]
inc	ax		; Increment by 1
push	ax
push	[bp+var_4E]
push	[bp+var_2C]
push	[bp+var_2A]
push	[bp+var_24]

loc_20BE4:
push	[bp+var_22]
push	[bp+var_4C]
push	[bp+var_40]
push	[bp+var_20]
push	[bp+var_1E]
call	sub_23B75	; Call Procedure
jmp	short loc_20C51	; Jump

loc_20BFA:		; CODE XREF: idk_VidLib_s1FBBF+FE0j
mov	ax, [idk_ScrnPosX319_w35EC6]
inc	ax		; Increment by 1

loc_20BFE:
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply
push	ax
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	dx, 50h	; 'P'
imul	dx		; Signed Multiply

loc_20C0C:
push	ax
push	[bp+var_48]

loc_20C10:
push	[bp+var_3E]
push	[bp+var_3C]

loc_20C16:
push	[bp+var_3A]
push	[bp+var_38]
push	[bp+var_36]
push	[bp+var_34]

loc_20C22:
push	[bp+var_32]
push	[bp+var_30]

loc_20C28:
push	di

loc_20C29:
push	[bp+var_2E]
mov	ax, [bp+arg_10]
inc	ax		; Increment by 1
push	ax
push	[bp+var_4E]
push	[bp+var_2C]
push	[bp+var_2A]

loc_20C3A:
push	[bp+var_24]
push	[bp+var_22]
push	[bp+var_4C]
push	[bp+var_40]
push	[bp+var_20]
push	[bp+var_1E]

loc_20C4C:		; Call Procedure
call	sub_23CF1

loc_20C51:		; CODE XREF: idk_VidLib_s1FBBF+1039j
add	sp, 2Eh		; Add

loc_20C54:		; CODE XREF: idk_VidLib_s1FBBF+165j
			; idk_VidLib_s1FBBF:loc_20081j
			; idk_VidLib_s1FBBF+FB1j
			; idk_VidLib_s1FBBF+FBDj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_VidLib_s1FBBF

off_20C5A dw offset loc_209B6
			; DATA XREF: idk_VidLib_s1FBBF:loc_209B1r
dw offset loc_20A14	; jump table for switch	statement
dw offset loc_20A74
dw offset loc_20AC9
off_20C62 dw offset loc_20669
			; DATA XREF: idk_VidLib_s1FBBF+AA5r
dw offset loc_206C0	; jump table for switch	statement
dw offset loc_2071D
dw offset loc_2077A
off_20C6A dw offset loc_20310
			; DATA XREF: idk_VidLib_s1FBBF+74Cr
dw offset loc_2035C	; jump table for switch	statement
dw offset loc_203B1
dw offset loc_20400
off_20C72 dw offset loc_1FDAE
			; DATA XREF: idk_VidLib_s1FBBF+1EAr
dw offset loc_1FE06	; jump table for switch	statement
dw offset loc_1FE66
dw offset loc_1FEC5


; Attributes: bp-based frame

proc sub_20C7A far

var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
argOffset= dword ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_0]

loc_20C85:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_20C88:		; argOffset
push	[word ptr bp+argOffset]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx

loc_20C91:
pop	cx
mov	[bp+var_E], ax

loc_20C95:
mov	ax, 2

loc_20C98:
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_20C9C:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx
mov	si, ax
mov	ax, 8
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_20CAC:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx

loc_20CB3:
mov	[bp+var_12], ax
mov	ax, [bp+arg_4]

loc_20CB9:		; Integer Subtraction
sub	ax, di
mov	[bp+var_C], ax
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_2]	; Integer Subtraction
mov	[bp+var_A], ax

loc_20CC7:
push	[bp+var_A]
push	[bp+var_C]
call	sub_23937	; Call Procedure
pop	cx
pop	cx
mov	[bp+var_10], ax

loc_20CD7:
mov	ax, 5Ah	; 'Z'
sub	ax, [bp+var_10]	; Integer Subtraction

loc_20CDD:
mov	[bp+var_14], ax
cmp	[bp+var_14], 0	; Compare Two Operands
jge	short loc_20CEB	; Jump if Greater or Equal (SF=OF)

loc_20CE6:		; Add
add	[bp+var_14], 168h

loc_20CEB:		; CODE XREF: sub_20C7A+6Aj
push	si
push	[bp+var_14]

loc_20CEF:		; Call Procedure
call	sub_23A3D
pop	cx
pop	cx
cwd			; AX ->	DX:AX (with sign)

loc_20CF7:		; Integer Subtraction
sub	ax, dx
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_16], ax
push	si
push	[bp+var_14]
call	sub_23ACB	; Call Procedure

loc_20D07:
pop	cx
pop	cx
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_18], ax

loc_20D11:		; Add
add	di, [bp+var_16]

loc_20D14:
mov	ax, [bp+var_18]
sub	[bp+arg_2], ax	; Integer Subtraction
mov	ax, [bp+var_16]
add	[bp+arg_4], ax	; Add

loc_20D20:
mov	ax, [bp+var_18]
sub	[bp+arg_6], ax	; Integer Subtraction

loc_20D26:
mov	ax, si

loc_20D28:
mov	dx, 0Ch
imul	dx		; Signed Multiply
push	ax

loc_20D2E:
push	[bp+var_10]

loc_20D31:		; Call Procedure
call	sub_23ACB
pop	cx
pop	cx
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide

loc_20D3E:
mov	dx, [bp+arg_4]
sub	dx, ax		; Integer Subtraction
mov	[bp+var_2], dx
push	si
push	[bp+var_10]

loc_20D4A:		; Call Procedure
call	sub_23A3D
pop	cx
pop	cx
mov	dx, [bp+arg_6]
add	dx, ax		; Add
mov	[bp+var_4], dx
mov	ax, si
mov	dx, 0Ch
imul	dx		; Signed Multiply
push	ax
push	[bp+var_10]

loc_20D64:		; Call Procedure
call	sub_23ACB
pop	cx

loc_20D6A:
pop	cx
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)

loc_20D6F:		; Signed Divide
idiv	bx
mov	dx, di
sub	dx, ax		; Integer Subtraction
mov	[bp+var_6], dx
push	si
push	[bp+var_10]

loc_20D7C:		; Call Procedure
call	sub_23A3D
pop	cx

loc_20D82:
pop	cx
mov	dx, [bp+arg_2]
add	dx, ax		; Add
mov	[bp+var_8], dx
push	[bp+var_E]
push	si
push	[word ptr bp+argOffset]

loc_20D92:
push	[bp+var_8]
push	[bp+var_6]

loc_20D98:
push	[bp+var_4]
push	[bp+var_2]

loc_20D9E:
push	[bp+arg_6]

loc_20DA1:
push	[bp+arg_4]
push	[bp+arg_2]
push	di
push	cs
call	near ptr idk_VidLib_s1FBBF ; Call Procedure
add	sp, 16h		; Add
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_20C7A



; Attributes: bp-based frame

proc sub_20DB5 far	; CODE XREF: seg028:loc_1FB8Ep

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]

loc_20DC0:
mov	di, [bp+arg_6]
mov	ax, [bp+arg_2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [di]

loc_20DCD:		; Add
add	dx, ax

loc_20DCF:
mov	[bp+var_2], dx

loc_20DD2:
mov	ax, [bp+arg_4]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	bx, [bp+arg_8]

loc_20DDD:
mov	dx, [bx]
add	dx, ax		; Add

loc_20DE1:
mov	[bp+var_4], dx
mov	ax, [di]
add	ax, [bp+arg_2]	; Add
dec	ax		; Decrement by 1
mov	bx, [bp+arg_A]
mov	[bx], ax

loc_20DEF:
mov	bx, [bp+arg_8]
mov	ax, [bx]

loc_20DF4:
mov	bx, [bp+arg_C]
mov	[bx], ax
mov	ax, [di]
add	ax, [bp+arg_2]	; Add
dec	ax		; Decrement by 1
mov	bx, [bp+arg_E]
mov	[bx], ax

loc_20E04:
mov	bx, [bp+arg_8]
mov	ax, [bx]
add	ax, [bp+arg_4]	; Add
dec	ax		; Decrement by 1
mov	bx, [bp+arg_10]

loc_20E10:
mov	[bx], ax
mov	ax, [di]
mov	bx, [bp+arg_12]
mov	[bx], ax
mov	bx, [bp+arg_8]
mov	ax, [bx]
add	ax, [bp+arg_4]	; Add

loc_20E21:		; Decrement by 1
dec	ax
mov	bx, [bp+arg_14]

loc_20E25:
mov	[bx], ax
mov	ax, [di]
mov	[bp+var_6], ax

loc_20E2C:
mov	ax, [di]
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
push	si

loc_20E33:		; Call Procedure
call	sub_23A3D
pop	cx
pop	cx
mov	dx, [bp+var_2]
add	dx, ax		; Add
push	dx
mov	bx, [bp+arg_8]

loc_20E43:
mov	ax, [bx]
sub	ax, [bp+var_4]	; Integer Subtraction
mov	dx, 0Ch
imul	dx		; Signed Multiply
push	ax
push	si

loc_20E4F:		; Call Procedure
call	sub_23ACB
pop	cx
pop	cx
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
sub	dx, ax		; Integer Subtraction

loc_20E5F:
mov	[di], dx
mov	bx, [bp+arg_8]
mov	ax, [bx]
sub	ax, [bp+var_4]	; Integer Subtraction
push	ax
push	si

loc_20E6B:		; Call Procedure
call	sub_23A3D
pop	cx
pop	cx

loc_20E72:
mov	dx, [bp+var_4]
add	dx, ax		; Add
push	dx

loc_20E78:
mov	ax, [bp+var_6]
sub	ax, [bp+var_2]	; Integer Subtraction
mov	dx, 16h
imul	dx		; Signed Multiply
push	ax
push	si
call	sub_23ACB	; Call Procedure
pop	cx
pop	cx
mov	bx, 19h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
add	dx, ax		; Add
mov	bx, [bp+arg_8]
mov	[bx], dx
mov	bx, [bp+arg_A]
mov	ax, [bx]

loc_20E9F:
mov	[bp+var_6], ax
mov	bx, [bp+arg_A]
mov	ax, [bx]
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
push	si

loc_20EAC:		; Call Procedure
call	sub_23A3D
pop	cx
pop	cx
mov	dx, [bp+var_2]
add	dx, ax		; Add
push	dx
mov	bx, [bp+arg_C]
mov	ax, [bx]
sub	ax, [bp+var_4]	; Integer Subtraction
mov	dx, 0Ch
imul	dx		; Signed Multiply
push	ax
push	si
call	sub_23ACB	; Call Procedure
pop	cx
pop	cx
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
sub	dx, ax		; Integer Subtraction
mov	bx, [bp+arg_A]
mov	[bx], dx
mov	bx, [bp+arg_C]
mov	ax, [bx]
sub	ax, [bp+var_4]	; Integer Subtraction
push	ax
push	si

loc_20EE7:		; Call Procedure
call	sub_23A3D
pop	cx
pop	cx
mov	dx, [bp+var_4]
add	dx, ax		; Add
push	dx
mov	ax, [bp+var_6]
sub	ax, [bp+var_2]	; Integer Subtraction

loc_20EFA:
mov	dx, 16h
imul	dx		; Signed Multiply
push	ax

loc_20F00:
push	si
call	sub_23ACB	; Call Procedure
pop	cx
pop	cx

loc_20F08:
mov	bx, 19h
cwd			; AX ->	DX:AX (with sign)

loc_20F0C:		; Signed Divide
idiv	bx
pop	dx

loc_20F0F:		; Add
add	dx, ax
mov	bx, [bp+arg_C]
mov	[bx], dx

loc_20F16:
mov	bx, [bp+arg_E]
mov	ax, [bx]
mov	[bp+var_6], ax

loc_20F1E:
mov	bx, [bp+arg_E]
mov	ax, [bx]
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
push	si
call	sub_23A3D	; Call Procedure
pop	cx
pop	cx
mov	dx, [bp+var_2]
add	dx, ax		; Add
push	dx

loc_20F35:
mov	bx, [bp+arg_10]
mov	ax, [bx]
sub	ax, [bp+var_4]	; Integer Subtraction
mov	dx, 0Ch
imul	dx		; Signed Multiply
push	ax
push	si
call	sub_23ACB	; Call Procedure
pop	cx
pop	cx
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)

loc_20F4F:		; Signed Divide
idiv	bx
pop	dx
sub	dx, ax		; Integer Subtraction

loc_20F54:
mov	bx, [bp+arg_E]
mov	[bx], dx
mov	bx, [bp+arg_10]
mov	ax, [bx]
sub	ax, [bp+var_4]	; Integer Subtraction
push	ax

loc_20F62:
push	si
call	sub_23A3D	; Call Procedure
pop	cx
pop	cx

loc_20F6A:
mov	dx, [bp+var_4]
add	dx, ax		; Add
push	dx
mov	ax, [bp+var_6]
sub	ax, [bp+var_2]	; Integer Subtraction
mov	dx, 16h
imul	dx		; Signed Multiply
push	ax
push	si
call	sub_23ACB	; Call Procedure
pop	cx
pop	cx
mov	bx, 19h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
add	dx, ax		; Add
mov	bx, [bp+arg_10]
mov	[bx], dx
mov	bx, [bp+arg_12]
mov	ax, [bx]
mov	[bp+var_6], ax
mov	bx, [bp+arg_12]
mov	ax, [bx]

loc_20F9F:		; Integer Subtraction
sub	ax, [bp+var_2]
push	ax
push	si
call	sub_23A3D	; Call Procedure
pop	cx

loc_20FAA:
pop	cx
mov	dx, [bp+var_2]
add	dx, ax		; Add

loc_20FB0:
push	dx
mov	bx, [bp+arg_14]
mov	ax, [bx]
sub	ax, [bp+var_4]	; Integer Subtraction
mov	dx, 0Ch
imul	dx		; Signed Multiply
push	ax
push	si
call	sub_23ACB	; Call Procedure
pop	cx
pop	cx
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
sub	dx, ax		; Integer Subtraction
mov	bx, [bp+arg_12]
mov	[bx], dx

loc_20FD5:
mov	bx, [bp+arg_14]

loc_20FD8:
mov	ax, [bx]
sub	ax, [bp+var_4]	; Integer Subtraction
push	ax

loc_20FDE:
push	si
call	sub_23A3D	; Call Procedure
pop	cx
pop	cx
mov	dx, [bp+var_4]
add	dx, ax		; Add
push	dx
mov	ax, [bp+var_6]
sub	ax, [bp+var_2]	; Integer Subtraction
mov	dx, 16h
imul	dx		; Signed Multiply
push	ax
push	si
call	sub_23ACB	; Call Procedure
pop	cx
pop	cx
mov	bx, 19h

loc_21003:		; AX ->	DX:AX (with sign)
cwd
idiv	bx		; Signed Divide
pop	dx
add	dx, ax		; Add
mov	bx, [bp+arg_14]
mov	[bx], dx
pop	di
pop	si

loc_21010:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_20DB5



; Attributes: bp-based frame

proc sub_21014 far	; CODE XREF: sub_1D40D:loc_1D56FP
			; sub_4EC17+187P
			; sub_4EC17+1C0P
			; sub_4F1AB+149P
			; sub_4F1AB+17CP
			; sub_4F44D+31CP
			; idk_OVR_LoadLbxHelp+443P

arg_0= word ptr	 6
arg_2= word ptr	 8
argOffset= dword ptr  0Ah

push	bp
mov	bp, sp
push	si

loc_21018:
mov	si, [word ptr bp+argOffset]
xor	ax, ax		; Logical Exclusive OR
push	ax		; argPtrSrcBuf

loc_2101E:
mov	ax, 2
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
push	ax		; argPtrSrcBuf
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
push	ax
push	si
mov	ax, 10h
push	ax

loc_2103C:
push	[bp+arg_2]
push	[bp+arg_0]
call	sub_22F25	; Call Procedure
add	sp, 0Eh		; Add
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_21014



; Attributes: bp-based frame

proc idk_VidLib_s2104D far
			; CODE XREF: sub_56240+1C0P

var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
argOffset= dword ptr  0Ah

push	bp
mov	bp, sp

loc_21050:		; Integer Subtraction
sub	sp, 18h
push	si
push	di		; arg2_SI
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
cmp	si, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands

loc_2105F:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_21066

loc_21061:		; CODE XREF: idk_VidLib_s2104D:loc_2106Cj
			; idk_VidLib_s2104D+54j
			; idk_VidLib_s2104D+68j
xor	ax, ax		; Logical Exclusive OR
jmp	loc_21174	; Jump

loc_21066:		; CODE XREF: idk_VidLib_s2104D:loc_2105Fj
cmp	di, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_2106E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_2106C:		; Jump
jmp	short loc_21061

loc_2106E:		; CODE XREF: idk_VidLib_s2104D+1Dj
xor	ax, ax		; Logical Exclusive OR

loc_21070:
push	ax

loc_21071:		; argOffset
push	[word ptr bp+argOffset]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_8], ax
mov	ax, 2
push	ax

loc_21082:		; argOffset
push	[word ptr bp+argOffset]

loc_21085:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx

loc_2108C:
mov	[bp+var_A], ax
mov	ax, si

loc_21091:		; Add
add	ax, [bp+var_8]
dec	ax		; Decrement by 1
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands

loc_2109F:		; Jump if Greater or Equal (SF=OF)
jge	short loc_210A3
jmp	short loc_21061	; Jump

loc_210A3:		; CODE XREF: idk_VidLib_s2104D:loc_2109Fj
mov	ax, di
add	ax, [bp+var_A]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
cmp	ax, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jge	short loc_210B7	; Jump if Greater or Equal (SF=OF)
jmp	short loc_21061	; Jump

loc_210B7:		; CODE XREF: idk_VidLib_s2104D+66j
cmp	si, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jl	short loc_210C7	; Jump if Less (SF!=OF)
mov	[bp+var_C], 0
mov	[bp+var_10], si
jmp	short loc_210D5	; Jump

loc_210C7:		; CODE XREF: idk_VidLib_s2104D+6Ej
mov	ax, [idk_ScrnPosX0_w35EC2]

loc_210CA:		; Integer Subtraction
sub	ax, si
mov	[bp+var_C], ax

loc_210CF:
mov	ax, [idk_ScrnPosX0_w35EC2]

loc_210D2:
mov	[bp+var_10], ax

loc_210D5:		; CODE XREF: idk_VidLib_s2104D+78j
cmp	di, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jl	short loc_210E5	; Jump if Less (SF!=OF)
mov	[bp+var_E], 0
mov	[bp+var_12], di
jmp	short loc_210F3	; Jump

loc_210E5:		; CODE XREF: idk_VidLib_s2104D+8Cj
mov	ax, [idk_ScrnPosY0_w35EC4]
sub	ax, di		; Integer Subtraction
mov	[bp+var_E], ax
mov	ax, [idk_ScrnPosY0_w35EC4]
mov	[bp+var_12], ax

loc_210F3:		; CODE XREF: idk_VidLib_s2104D+96j
mov	ax, [bp+var_2]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jge	short loc_21101	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_2]
jmp	short loc_21104	; Jump

loc_21101:		; CODE XREF: idk_VidLib_s2104D+ADj
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_21104:		; CODE XREF: idk_VidLib_s2104D+B2j
sub	ax, [bp+var_10]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_16], ax
mov	ax, [bp+var_16]
cmp	ax, [bp+var_8]	; Compare Two Operands
jle	short loc_21119	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_8]
mov	[bp+var_16], ax

loc_21119:		; CODE XREF: idk_VidLib_s2104D+C4j
mov	ax, [bp+var_4]

loc_2111C:		; Compare Two Operands
cmp	ax, [idk_ScrnPosY199_w35EC8]
jge	short loc_21127	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_4]
jmp	short loc_2112A	; Jump

loc_21127:		; CODE XREF: idk_VidLib_s2104D+D3j
mov	ax, [idk_ScrnPosY199_w35EC8]

loc_2112A:		; CODE XREF: idk_VidLib_s2104D+D8j
sub	ax, [bp+var_12]	; Integer Subtraction

loc_2112D:		; Increment by 1
inc	ax
mov	[bp+var_14], ax

loc_21131:
mov	ax, [bp+var_14]

loc_21134:		; Compare Two Operands
cmp	ax, [bp+var_A]
jle	short loc_2113F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_A]
mov	[bp+var_14], ax

loc_2113F:		; CODE XREF: idk_VidLib_s2104D+EAj
mov	ax, [bp+var_C]
imul	[bp+var_A]	; Signed Multiply
add	ax, [bp+var_E]	; Add
add	ax, 10h		; Add
mov	[bp+var_18], ax

loc_2114E:
mov	ax, [bp+var_A]
sub	ax, [bp+var_14]	; Integer Subtraction
mov	[bp+var_6], ax
push	[bp+var_6]
push	[bp+var_14]
push	[bp+var_16]
push	[word ptr bp+argOffset]
push	[bp+var_18]
push	[bp+var_12]
push	[bp+var_10]

loc_2116C:		; Call Procedure
call	sub_22F25
add	sp, 0Eh		; Add

loc_21174:		; CODE XREF: idk_VidLib_s2104D+16j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_VidLib_s2104D



; Attributes: bp-based frame

proc sub_2117A far

var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
argOffset= dword ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx

loc_2118E:
pop	cx
mov	[bp+var_A], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	si, ax
mov	ax, [bp+var_A]
dec	ax		; Decrement by 1
cmp	ax, [bp+arg_0]	; Compare Two Operands
jge	short loc_211B0	; Jump if Greater or Equal (SF=OF)

loc_211AB:		; CODE XREF: sub_2117A+3Ej
			; sub_2117A+5Cj
			; sub_2117A+7Bj
xor	ax, ax		; Logical Exclusive OR
jmp	loc_212DC	; Jump

loc_211B0:		; CODE XREF: sub_2117A+2Fj
mov	ax, si
dec	ax		; Decrement by 1
cmp	ax, [bp+arg_2]	; Compare Two Operands
jge	short loc_211BA	; Jump if Greater or Equal (SF=OF)
jmp	short loc_211AB	; Jump

loc_211BA:		; CODE XREF: sub_2117A+3Cj
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset+2] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+arg_0]
add	dx, ax		; Add
dec	dx		; Decrement by 1
mov	[bp+var_2], dx

loc_211D0:		; Compare Two Operands
cmp	[bp+var_2], 0
jge	short loc_211D8	; Jump if Greater or Equal (SF=OF)
jmp	short loc_211AB	; Jump

loc_211D8:		; CODE XREF: sub_2117A+5Aj
mov	ax, 2
push	ax
push	[word ptr bp+argOffset+2] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+arg_2]
add	dx, ax		; Add
dec	dx		; Decrement by 1

loc_211EC:
mov	[bp+var_4], dx

loc_211EF:		; Compare Two Operands
cmp	[bp+var_4], 0
jge	short loc_211F7	; Jump if Greater or Equal (SF=OF)
jmp	short loc_211AB	; Jump

loc_211F7:		; CODE XREF: sub_2117A+79j
cmp	[bp+arg_0], 0	; Compare Two Operands
jl	short loc_2120A	; Jump if Less (SF!=OF)
mov	[bp+var_C], 0
mov	ax, [bp+arg_0]
mov	[bp+var_10], ax
jmp	short loc_21217	; Jump

loc_2120A:		; CODE XREF: sub_2117A+81j
mov	ax, [bp+arg_0]
neg	ax		; Two's Complement Negation
mov	[bp+var_C], ax
mov	[bp+var_10], 0

loc_21217:		; CODE XREF: sub_2117A+8Ej
cmp	[bp+arg_2], 0	; Compare Two Operands
jl	short loc_2122A	; Jump if Less (SF!=OF)

loc_2121D:
mov	[bp+var_E], 0
mov	ax, [bp+arg_2]

loc_21225:
mov	[bp+var_12], ax

loc_21228:		; Jump
jmp	short loc_21237

loc_2122A:		; CODE XREF: sub_2117A+A1j
mov	ax, [bp+arg_2]
neg	ax		; Two's Complement Negation
mov	[bp+var_E], ax
mov	[bp+var_12], 0

loc_21237:		; CODE XREF: sub_2117A:loc_21228j
mov	ax, [bp+var_A]
dec	ax		; Decrement by 1
cmp	ax, [bp+var_2]	; Compare Two Operands
jle	short loc_21249	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_2]
sub	ax, [bp+var_10]	; Integer Subtraction
inc	ax		; Increment by 1

loc_21247:		; Jump
jmp	short loc_2124F

loc_21249:		; CODE XREF: sub_2117A+C4j
mov	ax, [bp+var_A]
sub	ax, [bp+var_10]	; Integer Subtraction

loc_2124F:		; CODE XREF: sub_2117A:loc_21247j
mov	[bp+var_14], ax

loc_21252:
mov	ax, [bp+var_14]
cmp	ax, [bp+var_A]	; Compare Two Operands

loc_21258:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_21260

loc_2125A:
mov	ax, [bp+var_A]
mov	[bp+var_14], ax

loc_21260:		; CODE XREF: sub_2117A:loc_21258j
mov	ax, si
dec	ax		; Decrement by 1
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_2126D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_21268:
mov	ax, [bp+var_4]
jmp	short loc_21270	; Jump

loc_2126D:		; CODE XREF: sub_2117A+ECj
mov	ax, si
dec	ax		; Decrement by 1

loc_21270:		; CODE XREF: sub_2117A+F1j
sub	ax, [bp+var_12]	; Integer Subtraction

loc_21273:		; Increment by 1
inc	ax
mov	di, ax
cmp	di, si		; Compare Two Operands

loc_21278:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_2127C

loc_2127A:
mov	di, si

loc_2127C:		; CODE XREF: sub_2117A:loc_21278j
mov	ax, [bp+var_10]
imul	si		; Signed Multiply

loc_21281:		; Add
add	ax, [bp+var_12]

loc_21284:		; Add
add	ax, 10h
mov	[bp+var_18], ax
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	[bp+var_8], ax
mov	ax, 2

loc_21294:
push	ax
push	[word ptr bp+argOffset+2] ; argOffset

loc_21298:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx

loc_2129F:		; Signed Multiply
imul	[bp+var_C]

loc_212A2:		; Add
add	ax, [bp+var_E]
add	ax, 10h		; Add
mov	[bp+var_16], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset+2] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
sub	ax, di		; Integer Subtraction
mov	[bp+var_6], ax
push	di
push	[bp+var_14]
push	[bp+var_6]
push	[bp+var_8]
push	[word ptr bp+argOffset+2]

loc_212CB:
push	[bp+var_16]

loc_212CE:
push	[word ptr bp+argOffset]

loc_212D1:
push	[bp+var_18]
call	sub_2309C	; Call Procedure
add	sp, 10h		; Add

loc_212DC:		; CODE XREF: sub_2117A+33j
pop	di
pop	si

loc_212DE:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2117A



; Attributes: bp-based frame

proc sub_212E2 far

var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
argOffset= dword ptr  0Ah

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx

loc_212F6:
pop	cx
mov	[bp+var_A], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	si, ax
mov	ax, [bp+var_A]
dec	ax		; Decrement by 1
cmp	ax, [bp+arg_0]	; Compare Two Operands
jge	short loc_21318	; Jump if Greater or Equal (SF=OF)

loc_21313:		; CODE XREF: sub_212E2+3Ej
			; sub_212E2+5Cj
			; sub_212E2+7Bj
xor	ax, ax		; Logical Exclusive OR
jmp	loc_21444	; Jump

loc_21318:		; CODE XREF: sub_212E2+2Fj
mov	ax, si
dec	ax		; Decrement by 1
cmp	ax, [bp+arg_2]	; Compare Two Operands
jge	short loc_21322	; Jump if Greater or Equal (SF=OF)
jmp	short loc_21313	; Jump

loc_21322:		; CODE XREF: sub_212E2+3Cj
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset+2] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+arg_0]
add	dx, ax		; Add
dec	dx		; Decrement by 1
mov	[bp+var_2], dx
cmp	[bp+var_2], 0	; Compare Two Operands
jge	short loc_21340	; Jump if Greater or Equal (SF=OF)
jmp	short loc_21313	; Jump

loc_21340:		; CODE XREF: sub_212E2+5Aj
mov	ax, 2
push	ax
push	[word ptr bp+argOffset+2] ; argOffset

loc_21347:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx
mov	dx, [bp+arg_2]
add	dx, ax		; Add
dec	dx		; Decrement by 1
mov	[bp+var_4], dx
cmp	[bp+var_4], 0	; Compare Two Operands
jge	short loc_2135F	; Jump if Greater or Equal (SF=OF)
jmp	short loc_21313	; Jump

loc_2135F:		; CODE XREF: sub_212E2+79j
cmp	[bp+arg_0], 0	; Compare Two Operands
jl	short loc_21372	; Jump if Less (SF!=OF)
mov	[bp+var_C], 0
mov	ax, [bp+arg_0]
mov	[bp+var_10], ax
jmp	short loc_2137F	; Jump

loc_21372:		; CODE XREF: sub_212E2+81j
mov	ax, [bp+arg_0]
neg	ax		; Two's Complement Negation
mov	[bp+var_C], ax
mov	[bp+var_10], 0

loc_2137F:		; CODE XREF: sub_212E2+8Ej
cmp	[bp+arg_2], 0	; Compare Two Operands
jl	short loc_21392	; Jump if Less (SF!=OF)
mov	[bp+var_E], 0
mov	ax, [bp+arg_2]

loc_2138D:
mov	[bp+var_12], ax

loc_21390:		; Jump
jmp	short loc_2139F

loc_21392:		; CODE XREF: sub_212E2+A1j
mov	ax, [bp+arg_2]

loc_21395:		; Two's Complement Negation
neg	ax
mov	[bp+var_E], ax
mov	[bp+var_12], 0

loc_2139F:		; CODE XREF: sub_212E2:loc_21390j
mov	ax, [bp+var_A]
dec	ax		; Decrement by 1
cmp	ax, [bp+var_2]	; Compare Two Operands
jle	short loc_213B1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_2]
sub	ax, [bp+var_10]	; Integer Subtraction
inc	ax		; Increment by 1
jmp	short loc_213B7	; Jump

loc_213B1:		; CODE XREF: sub_212E2+C4j
mov	ax, [bp+var_A]

loc_213B4:		; Integer Subtraction
sub	ax, [bp+var_10]

loc_213B7:		; CODE XREF: sub_212E2+CDj
mov	[bp+var_14], ax
mov	ax, [bp+var_14]
cmp	ax, [bp+var_A]	; Compare Two Operands

loc_213C0:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_213C8

loc_213C2:
mov	ax, [bp+var_A]
mov	[bp+var_14], ax

loc_213C8:		; CODE XREF: sub_212E2:loc_213C0j
mov	ax, si
dec	ax		; Decrement by 1
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_213D5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
jmp	short loc_213D8	; Jump

loc_213D5:		; CODE XREF: sub_212E2+ECj
mov	ax, si
dec	ax		; Decrement by 1

loc_213D8:		; CODE XREF: sub_212E2+F1j
sub	ax, [bp+var_12]	; Integer Subtraction
inc	ax		; Increment by 1
mov	di, ax
cmp	di, si		; Compare Two Operands
jle	short loc_213E4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	di, si

loc_213E4:		; CODE XREF: sub_212E2+FEj
mov	ax, [bp+var_10]
imul	si		; Signed Multiply
add	ax, [bp+var_12]	; Add
add	ax, 10h		; Add

loc_213EF:
mov	[bp+var_18], ax
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	[bp+var_8], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset+2] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
imul	[bp+var_C]	; Signed Multiply
add	ax, [bp+var_E]	; Add
add	ax, 10h		; Add
mov	[bp+var_16], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset+2] ; argOffset

loc_2141A:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx

loc_21420:
pop	cx
sub	ax, di		; Integer Subtraction
mov	[bp+var_6], ax
push	di
push	[bp+var_14]
push	[bp+var_6]
push	[bp+var_8]
push	[word ptr bp+argOffset+2]
push	[bp+var_16]
push	[word ptr bp+argOffset]
push	[bp+var_18]

loc_2143C:		; Call Procedure
call	sub_231D6
add	sp, 10h		; Add

loc_21444:		; CODE XREF: sub_212E2+33j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_212E2



; Attributes: bp-based frame

proc sub_2144A far

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= dword ptr  6
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_6], ax
mov	ax, [bp+var_4]
imul	[bp+var_6]	; Signed Multiply
mov	[bp+var_2], ax
push	ds
push	es
push	si
push	di
mov	si, 10h
mov	di, 10h
mov	cx, [bp+var_2]
mov	bx, [word ptr bp+argOffset+2]
mov	dx, [bp+arg_4]

loc_2148F:
mov	ax, [word ptr bp+argOffset]
mov	es, ax
mov	ds, ax

loc_21496:		; CODE XREF: sub_2144A+5Aj
lodsb			; Load String
cmp	al, bl		; Compare Two Operands
jb	short loc_214A3	; Jump if Below	(CF=1)
cmp	al, dl		; Compare Two Operands
ja	short loc_214A3	; Jump if Above	(CF=0 &	ZF=0)

loc_2149F:		; Logical Exclusive OR
xor	al, al
stosb			; Store	String
dec	di		; Decrement by 1

loc_214A3:		; CODE XREF: sub_2144A+4Fj
			; sub_2144A+53j
inc	di		; Increment by 1
loop	loc_21496	; Loop while CX	!= 0
pop	di
pop	si
pop	es
pop	ds
pop	di
pop	si

loc_214AC:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2144A



; Attributes: bp-based frame

proc sub_214B0 far

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
argOffset= dword ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_4]
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_214BE:		; argOffset
push	[word ptr bp+argOffset]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_214D2:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx
mov	si, ax
mov	ax, [bp+arg_0]
cmp	ax, [bp+var_2]	; Compare Two Operands
jge	short loc_214F2	; Jump if Greater or Equal (SF=OF)
cmp	[bp+arg_2], si	; Compare Two Operands
jge	short loc_214F2	; Jump if Greater or Equal (SF=OF)
or	di, di		; Logical Inclusive OR
jl	short loc_214F2	; Jump if Less (SF!=OF)
cmp	[bp+arg_6], 0	; Compare Two Operands
jge	short loc_2150C	; Jump if Greater or Equal (SF=OF)

loc_214F2:		; CODE XREF: sub_214B0+31j
			; sub_214B0+36j
			; sub_214B0+3Aj
mov	ax, si

loc_214F4:		; Signed Multiply
imul	[bp+var_2]
push	ax

loc_214F8:
push	[word ptr bp+argOffset]
mov	ax, 10h
push	ax
call	sub_23221	; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR

loc_21509:		; Jump
jmp	loc_215D2

loc_2150C:		; CODE XREF: sub_214B0+40j
cmp	[bp+arg_0], 0	; Compare Two Operands
jge	short loc_21517	; Jump if Greater or Equal (SF=OF)

loc_21512:
mov	[bp+arg_0], 0

loc_21517:		; CODE XREF: sub_214B0+60j
cmp	[bp+arg_2], 0	; Compare Two Operands
jge	short loc_21522	; Jump if Greater or Equal (SF=OF)
mov	[bp+arg_2], 0

loc_21522:		; CODE XREF: sub_214B0+6Bj
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands

loc_21528:		; Jump if Greater or Equal (SF=OF)
jge	short loc_21530
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
mov	di, ax

loc_21530:		; CODE XREF: sub_214B0:loc_21528j
mov	ax, si
dec	ax		; Decrement by 1
cmp	ax, [bp+arg_6]	; Compare Two Operands
jge	short loc_2153E	; Jump if Greater or Equal (SF=OF)
mov	ax, si
dec	ax		; Decrement by 1
mov	[bp+arg_6], ax

loc_2153E:		; CODE XREF: sub_214B0+86j
cmp	[bp+arg_0], 0	; Compare Two Operands
jle	short loc_21559	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+arg_0]
imul	si		; Signed Multiply
push	ax

loc_2154A:
push	[word ptr bp+argOffset]
mov	ax, 10h
push	ax
call	sub_23221	; Call Procedure
add	sp, 6		; Add

loc_21559:		; CODE XREF: sub_214B0+92j
mov	ax, si
dec	ax		; Decrement by 1
sub	ax, [bp+arg_6]	; Integer Subtraction

loc_2155F:
mov	[bp+var_6], ax
mov	ax, [bp+arg_0]
mov	[bp+var_4], ax
jmp	short loc_215AA	; Jump

loc_2156A:		; CODE XREF: sub_214B0+FDj
cmp	[bp+arg_2], 0	; Compare Two Operands

loc_2156E:		; Jump if Zero (ZF=1)
jz	short loc_21587
push	[bp+arg_2]
push	[word ptr bp+argOffset]

loc_21576:
mov	ax, [bp+var_4]
imul	si		; Signed Multiply

loc_2157B:		; Add
add	ax, 10h
push	ax
call	sub_23221	; Call Procedure

loc_21584:		; Add
add	sp, 6

loc_21587:		; CODE XREF: sub_214B0:loc_2156Ej
cmp	[bp+var_6], 0	; Compare Two Operands
jz	short loc_215A7	; Jump if Zero (ZF=1)
push	[bp+var_6]

loc_21590:
push	[word ptr bp+argOffset]

loc_21593:
mov	ax, [bp+var_4]
imul	si		; Signed Multiply
add	ax, [bp+arg_6]	; Add
add	ax, 10h		; Add
push	ax

loc_2159F:		; Call Procedure
call	sub_23221
add	sp, 6		; Add

loc_215A7:		; CODE XREF: sub_214B0+DBj
inc	[bp+var_4]	; Increment by 1

loc_215AA:		; CODE XREF: sub_214B0+B8j
cmp	[bp+var_4], di	; Compare Two Operands
jle	short loc_2156A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jle	short loc_215D2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_2]
sub	ax, di		; Integer Subtraction

loc_215BC:		; Signed Multiply
imul	si
push	ax
push	[word ptr bp+argOffset]
mov	ax, di
imul	si		; Signed Multiply
add	ax, 10h		; Add
push	ax
call	sub_23221	; Call Procedure

loc_215CF:		; Add
add	sp, 6

loc_215D2:		; CODE XREF: sub_214B0:loc_21509j
			; sub_214B0+105j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_214B0



; Attributes: bp-based frame

proc sub_215D8 far

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
argOffset= dword ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_215E3:		; argOffset
push	[word ptr bp+argOffset]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_215F7:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx

loc_215FE:
mov	[bp+var_4], ax
mov	ax, [bp+arg_0]

loc_21604:		; Compare Two Operands
cmp	ax, [bp+var_2]

loc_21607:		; Jump if Greater or Equal (SF=OF)
jge	short loc_2161D
mov	ax, [bp+arg_2]

loc_2160C:		; Compare Two Operands
cmp	ax, [bp+var_4]
jge	short loc_2161D	; Jump if Greater or Equal (SF=OF)
cmp	[bp+arg_4], 0	; Compare Two Operands
jl	short loc_2161D	; Jump if Less (SF!=OF)
cmp	[bp+arg_6], 0	; Compare Two Operands
jge	short loc_21638	; Jump if Greater or Equal (SF=OF)

loc_2161D:		; CODE XREF: sub_215D8:loc_21607j
			; sub_215D8+37j
			; sub_215D8+3Dj
mov	ax, [bp+var_4]

loc_21620:		; Signed Multiply
imul	[bp+var_2]
push	ax
push	[word ptr bp+argOffset]
mov	ax, 10h
push	ax

loc_2162B:		; Call Procedure
call	sub_23221
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
jmp	loc_216B8	; Jump

loc_21638:		; CODE XREF: sub_215D8+43j
cmp	[bp+arg_0], 0	; Compare Two Operands
jge	short loc_21643	; Jump if Greater or Equal (SF=OF)

loc_2163E:
mov	[bp+arg_0], 0

loc_21643:		; CODE XREF: sub_215D8+64j
cmp	[bp+arg_2], 0	; Compare Two Operands
jge	short loc_2164E	; Jump if Greater or Equal (SF=OF)
mov	[bp+arg_2], 0

loc_2164E:		; CODE XREF: sub_215D8+6Fj
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
cmp	ax, [bp+arg_4]	; Compare Two Operands
jge	short loc_2165E	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1

loc_2165B:
mov	[bp+arg_4], ax

loc_2165E:		; CODE XREF: sub_215D8+7Dj
mov	ax, [bp+var_4]

loc_21661:		; Decrement by 1
dec	ax
cmp	ax, [bp+arg_6]	; Compare Two Operands
jge	short loc_2166E	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_4]
dec	ax		; Decrement by 1

loc_2166B:
mov	[bp+arg_6], ax

loc_2166E:		; CODE XREF: sub_215D8+8Dj
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_2]	; Integer Subtraction

loc_21674:		; Increment by 1
inc	ax
mov	[bp+var_C], ax

loc_21678:
mov	ax, [bp+var_4]
sub	ax, [bp+var_C]	; Integer Subtraction
mov	[bp+var_6], ax

loc_21681:
mov	ax, [bp+arg_0]

loc_21684:		; Signed Multiply
imul	[bp+var_4]
add	ax, [bp+arg_2]	; Add

loc_2168A:
mov	[bp+var_8], ax
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_0]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_A], ax
push	di
push	es
mov	dx, [bp+var_C]
mov	bx, [bp+var_A]

loc_2169F:
mov	si, [bp+var_6]
mov	di, [bp+var_8]

loc_216A5:
mov	ax, [word ptr bp+argOffset]
inc	ax		; Increment by 1

loc_216A9:
mov	es, ax

loc_216AB:		; Logical Exclusive OR
xor	al, al

loc_216AD:		; CODE XREF: sub_215D8+DCj
mov	cx, dx

loc_216AF:		; Store	String
rep stosb

loc_216B1:		; Add
add	di, si
dec	bx		; Decrement by 1
jnz	short loc_216AD	; Jump if Not Zero (ZF=0)

loc_216B6:
pop	es
pop	di

loc_216B8:		; CODE XREF: sub_215D8+5Dj
pop	di
pop	si
mov	sp, bp

loc_216BC:
pop	bp
retf			; Return Far from Procedure
endp sub_215D8



; Attributes: bp-based frame

proc sub_216BE far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
mov	si, [bp+arg_4]
mov	ax, si
dec	ax		; Decrement by 1
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si
push	[bp+arg_2]
push	[bp+arg_0]

loc_216D3:		; No Operation
nop

loc_216D4:
push	cs
call	near ptr sub_21711 ; Call Procedure
add	sp, 0Ah		; Add
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_216BE



; Attributes: bp-based frame

proc sub_216DE far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp

loc_216DF:
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_4]
mov	di, [bp+arg_6]

loc_216E9:		; Logical Inclusive OR
or	di, di
jge	short loc_216EF	; Jump if Greater or Equal (SF=OF)
xor	di, di		; Logical Exclusive OR

loc_216EF:		; CODE XREF: sub_216DE+Dj
cmp	[bp+arg_8], si	; Compare Two Operands
jl	short loc_216FA	; Jump if Less (SF!=OF)
mov	ax, si
dec	ax		; Decrement by 1

loc_216F7:
mov	[bp+arg_8], ax

loc_216FA:		; CODE XREF: sub_216DE+14j
push	[bp+arg_8]

loc_216FD:
push	di
push	si
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_21711 ; Call Procedure
add	sp, 0Ah		; Add
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_216DE



; Attributes: bp-based frame

proc sub_21711 far	; CODE XREF: sub_216BE+17p
			; sub_216DE+29p

var_106= word ptr -106h
var_6= word ptr	-6
var_4= word ptr	-4
var_2= byte ptr	-2
var_1= byte ptr	-1
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 106h	; Integer Subtraction
push	si
push	di

loc_2171A:
mov	di, [bp+arg_2]

loc_2171D:		; Compare Two Operands
cmp	[bp+arg_4], 0
jnz	short loc_21728	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR

loc_21725:		; Jump
jmp	loc_21823

loc_21728:		; CODE XREF: sub_21711+10j
lea	ax, [bp+var_106] ; Load	Effective Address
push	ax

loc_2172D:
push	[bp+arg_0]
call	sub_23160	; Call Procedure
pop	cx
pop	cx
mov	[bp+var_2], 0
mov	[bp+var_1], 0FFh

loc_2173F:		; Logical Exclusive OR
xor	si, si

loc_21741:		; Jump
jmp	short loc_2176B

loc_21743:		; CODE XREF: sub_21711+5Ej
cmp	[byte ptr bp+si+var_106], 0FFh ; Compare Two Operands
jz	short loc_2176A	; Jump if Zero (ZF=1)

loc_2174A:
mov	al, [byte ptr bp+si+var_106]
cmp	al, [bp+var_1]	; Compare Two Operands
jnb	short loc_2175A	; Jump if Not Below (CF=0)

loc_21753:
mov	al, [byte ptr bp+si+var_106]

loc_21757:
mov	[bp+var_1], al

loc_2175A:		; CODE XREF: sub_21711+40j
mov	al, [byte ptr bp+si+var_106]

loc_2175E:		; Compare Two Operands
cmp	al, [bp+var_2]

loc_21761:		; Jump if Below	or Equal (CF=1 | ZF=1)
jbe	short loc_2176A
mov	al, [byte ptr bp+si+var_106]
mov	[bp+var_2], al

loc_2176A:		; CODE XREF: sub_21711+37j
			; sub_21711:loc_21761j
inc	si		; Increment by 1

loc_2176B:		; CODE XREF: sub_21711:loc_21741j
cmp	si, 100h	; Compare Two Operands
jl	short loc_21743	; Jump if Less (SF!=OF)
mov	al, [bp+var_2]
mov	ah, 0
mov	dl, [bp+var_1]
mov	dh, 0
sub	ax, dx		; Integer Subtraction
mov	[bp+var_4], ax
cmp	[bp+var_4], 0	; Compare Two Operands
jz	short loc_217E6	; Jump if Zero (ZF=1)

loc_21786:		; Logical Exclusive OR
xor	si, si
jmp	short loc_217DE	; Jump

loc_2178A:		; CODE XREF: sub_21711+D1j
cmp	[byte ptr bp+si+var_106], 0FFh ; Compare Two Operands

loc_2178F:		; Jump if Zero (ZF=1)
jz	short loc_217DD
mov	al, [byte ptr bp+si+var_106]
mov	ah, 0
push	ax
mov	ax, [bp+var_4]
cwd			; AX ->	DX:AX (with sign)

loc_2179C:		; Signed Divide
idiv	[bp+arg_4]
cwd			; AX ->	DX:AX (with sign)

loc_217A0:		; Integer Subtraction
sub	ax, dx

loc_217A2:		; Shift	Arithmetic Right
sar	ax, 1
mov	dx, ax
pop	ax
add	ax, dx		; Add
mov	dl, [bp+var_1]
mov	dh, 0
sub	ax, dx		; Integer Subtraction
mov	dx, [bp+arg_4]
dec	dx		; Decrement by 1
imul	dx		; Signed Multiply
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_4]	; Signed Divide
mov	[bp+var_6], ax
mov	ax, [bp+var_6]

loc_217C0:		; Compare Two Operands
cmp	ax, [bp+arg_6]
jl	short loc_217D8	; Jump if Less (SF!=OF)
mov	ax, [bp+var_6]
cmp	ax, [bp+arg_8]	; Compare Two Operands
jg	short loc_217D8	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, [bp+var_6]
mov	al, [bx+di]
mov	[byte ptr bp+si+var_106], al
jmp	short loc_217DD	; Jump

loc_217D8:		; CODE XREF: sub_21711+B2j
			; sub_21711+BAj
mov	[byte ptr bp+si+var_106], 0FFh

loc_217DD:		; CODE XREF: sub_21711:loc_2178Fj
			; sub_21711+C5j
inc	si		; Increment by 1

loc_217DE:		; CODE XREF: sub_21711+77j
cmp	si, 100h	; Compare Two Operands
jl	short loc_2178A	; Jump if Less (SF!=OF)
jmp	short loc_217FE	; Jump

loc_217E6:		; CODE XREF: sub_21711+73j
xor	si, si		; Logical Exclusive OR

loc_217E8:		; Jump
jmp	short loc_217F8

loc_217EA:		; CODE XREF: sub_21711:loc_217FCj
cmp	[byte ptr bp+si+var_106], 0FFh ; Compare Two Operands
jz	short loc_217F7	; Jump if Zero (ZF=1)
mov	al, [di]
mov	[byte ptr bp+si+var_106], al

loc_217F7:		; CODE XREF: sub_21711+DEj
inc	si		; Increment by 1

loc_217F8:		; CODE XREF: sub_21711:loc_217E8j
cmp	si, 100h	; Compare Two Operands

loc_217FC:		; Jump if Less (SF!=OF)
jl	short loc_217EA

loc_217FE:		; CODE XREF: sub_21711+D3j
xor	si, si		; Logical Exclusive OR
jmp	short loc_2181D	; Jump

loc_21802:		; CODE XREF: sub_21711+110j
cmp	[byte ptr bp+si+var_106], 0FFh ; Compare Two Operands
jz	short loc_2181C	; Jump if Zero (ZF=1)

loc_21809:
mov	al, [byte ptr bp+si+var_106]
mov	ah, 0
push	ax

loc_21810:
push	si

loc_21811:
push	[bp+arg_0]

loc_21814:		; Call Procedure
call	sub_23129
add	sp, 6		; Add

loc_2181C:		; CODE XREF: sub_21711+F6j
inc	si		; Increment by 1

loc_2181D:		; CODE XREF: sub_21711+EFj
cmp	si, 100h	; Compare Two Operands
jl	short loc_21802	; Jump if Less (SF!=OF)

loc_21823:		; CODE XREF: sub_21711:loc_21725j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_21711



; Attributes: bp-based frame

proc sub_21829 far	; CODE XREF: sub_1D40D+13EP
			; sub_4F44D+233P
			; sub_50203+136P

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= dword ptr  6
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction
push	si
push	di		; arg2_SI
mov	si, [word ptr bp+argOffset+2]
mov	di, [bp+arg_4]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_2183D:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset

loc_21842:
pop	cx
pop	cx
mov	[bp+var_6], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_2184E:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx
mov	[bp+var_8], ax
or	si, si		; Logical Inclusive OR
jle	short loc_21880	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
or	di, di		; Logical Inclusive OR

loc_2185E:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_21880
mov	ax, [bp+var_6]

loc_21863:		; Signed Multiply
imul	si

loc_21865:
mov	bx, 64h	; 'd'
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, 1		; Compare Two Operands
jl	short loc_21880	; Jump if Less (SF!=OF)

loc_21870:
mov	ax, [bp+var_8]

loc_21873:		; Signed Multiply
imul	di

loc_21875:
mov	bx, 64h	; 'd'
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, 1		; Compare Two Operands

loc_2187E:		; Jump if Greater or Equal (SF=OF)
jge	short loc_21892

loc_21880:		; CODE XREF: sub_21829+31j
			; sub_21829:loc_2185Ej
			; sub_21829+45j
push	[word ptr bp+argOffset]
push	[bp+var_8]
push	[bp+var_6]
push	cs
call	near ptr hrmStoreSWSB ;	Call Procedure
add	sp, 6		; Add
jmp	short loc_218FC	; Jump

loc_21892:		; CODE XREF: sub_21829:loc_2187Ej
mov	[bp+var_2], si
mov	[bp+var_4], di
cmp	si, 64h	; 'd'   ; Compare Two Operands
jge	short loc_218A5	; Jump if Greater or Equal (SF=OF)
cmp	di, 64h	; 'd'   ; Compare Two Operands

loc_218A0:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_218A5
mov	si, 64h	; 'd'

loc_218A5:		; CODE XREF: sub_21829+72j
			; sub_21829:loc_218A0j
cmp	si, 64h	; 'd'   ; Compare Two Operands
jle	short loc_218B2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	di, 64h	; 'd'   ; Compare Two Operands
jge	short loc_218B2	; Jump if Greater or Equal (SF=OF)
mov	di, 64h	; 'd'

loc_218B2:		; CODE XREF: sub_21829+7Fj
			; sub_21829+84j
cmp	si, 64h	; 'd'   ; Compare Two Operands
jg	short loc_218BC	; Jump if Greater (ZF=0	& SF=OF)
cmp	di, 64h	; 'd'   ; Compare Two Operands

loc_218BA:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_218C9

loc_218BC:		; CODE XREF: sub_21829+8Cj
push	di

loc_218BD:
push	si
push	[word ptr bp+argOffset]
call	sub_232ED	; Call Procedure
add	sp, 6		; Add

loc_218C9:		; CODE XREF: sub_21829:loc_218BAj
cmp	[bp+var_2], 64h	; 'd' ; Compare Two Operands
jle	short loc_218D4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_2], 64h	; 'd'

loc_218D4:		; CODE XREF: sub_21829+A4j
cmp	[bp+var_4], 64h	; 'd' ; Compare Two Operands
jle	short loc_218DF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_218DA:
mov	[bp+var_4], 64h	; 'd'

loc_218DF:		; CODE XREF: sub_21829+AFj
cmp	[bp+var_2], 64h	; 'd' ; Compare Two Operands

loc_218E3:		; Jump if Less (SF!=OF)
jl	short loc_218EB
cmp	[bp+var_4], 64h	; 'd' ; Compare Two Operands
jge	short loc_218FC	; Jump if Greater or Equal (SF=OF)

loc_218EB:		; CODE XREF: sub_21829:loc_218E3j
push	[bp+var_4]
push	[bp+var_2]
push	[word ptr bp+argOffset]

loc_218F4:		; Call Procedure
call	sub_23243
add	sp, 6		; Add

loc_218FC:		; CODE XREF: sub_21829+67j
			; sub_21829+C0j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_21829



; Attributes: bp-based frame

; int __fastcall __far LBX_Intro_MemAndReadAndMem(int, int, int, int argIntroLbxEntryNumber, int argIntroLbxFileName)
proc LBX_Intro_MemAndReadAndMem	far
			; CODE XREF: ST_LoadMusicSoundfxIntro+A4P

argIntroLbxFileName= word ptr  6
argIntroLbxEntryNumber=	word ptr  8

push	bp
mov	bp, sp
push	[bp+argIntroLbxFileName] ; argSrc
mov	ax, offset g_IntroLbxFileName
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, [bp+argIntroLbxEntryNumber]
mov	[g_IntroLbxEntryNumber], ax
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
mov	dx, 3FACh
push	ax		; int
push	dx		; int
xor	ax, ax		; int
xor	dx, dx		; int
push	ax		; int
push	dx		; int
nop			; No Operation
push	cs
call	near ptr LBX_MemAndRead	; LBX_MemAndRead(0,0,3FACh,0,0)
add	sp, 0Ah		; Add
push	[idk_AddrEmsHandle] ; arg6_EmsHandle
mov	ax, 16
push	ax		; arg5_ByteCount
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax		; arg4_6
push	dx		; arg3_4
push	[idk_FontsLbx1_32B] ; arg2_ES
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg1_DI
call	EMS_MapMemory_4	; EMS_MapMemory_4(idk_AddrEmsHandle,16,0,0,idk_AddrMemMapES,0)
add	sp, 0Ch		; Add
push	[idk_AddrEmsHandle] ; argValue
mov	ax, 10
push	ax		; argOffset
push	[idk_FontsLbx1_32B] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax		; argValue
mov	ax, 12
push	ax		; argOffset
push	[idk_FontsLbx1_32B] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp LBX_Intro_MemAndReadAndMem	; sp-analysis failed



; Attributes: bp-based frame

proc LBX_Load_IntroLbx_s21977 far
			; CODE XREF: ST_LoadMusicSoundfxIntro:loc_55907P

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
push	si
push	di		; arg2_SI
mov	ax, 4
push	ax
push	[idk_FontsLbx1_32B] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	si, ax
mov	ax, si
inc	ax		; Increment by 1
mov	di, ax
mov	ax, 6
push	ax
push	[idk_FontsLbx1_32B] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, di		; Compare Two Operands
ja	short loc_219BA	; Jump if Above	(CF=0 &	ZF=0)
mov	ax, 8
push	ax
push	[idk_FontsLbx1_32B] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
push	ax
jmp	short loc_219BB	; Jump

loc_219BA:		; CODE XREF: LBX_Load_IntroLbx_s21977+2Fj
push	di		; argValue

loc_219BB:		; CODE XREF: LBX_Load_IntroLbx_s21977+41j
mov	ax, 4
push	ax		; argOffset
push	[idk_FontsLbx1_32B] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 14
push	ax
push	[idk_FontsLbx1_32B] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_219EA	; Jump if Zero (ZF=1)
push	si
push	[idk_FontsLbx1_32B]
call	idk_Font_s1CB05	; Call Procedure
pop	cx
pop	cx

loc_219EA:		; CODE XREF: LBX_Load_IntroLbx_s21977+65j
push	[idk_AddrEmsHandle] ; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
add	ax, 18		; Add
cwd			; AX ->	DX:AX (with sign)
push	dx		; arg4_6
push	ax		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_4]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
push	[idk_AddrEmsHandle] ; arg6_EmsHandle
mov	ax, 4
push	ax		; arg5_ByteCount
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
add	ax, 22		; Add
cwd			; AX ->	DX:AX (with sign)
push	dx		; arg4_6
push	ax		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+var_C]	; Load Effective Address
push	ax		; arg1_DI
call	EMS_MapMemory_4	; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [bp+var_A]
mov	dx, [bp+var_C]
sub	dx, [bp+var_4]	; DX = DX - var_4
			; Subtracts the	second operand (source operand)	from the first operand (destination operand)
			;  and stores the result in the	destination operand.
sbb	ax, [bp+var_2]	; AX = AX - (var_2 + CF)
			; Adds the source operand (second operand) and the carry (CF) flag,
			;  and subtracts the result from the destination operand (first	operand).
			; The SBB instruction is usually executed as part of a multibyte or multiword subtraction
			;  in which a SUB instruction is followed by a SBB instruction.
			;
mov	[bp+var_E], ax
mov	[bp+var_10], dx
cmp	[bp+var_E], 1	; var_E	- 1
			; Compares the first source operand with the second source operand
			;  and sets the	status flags in	the EFLAGS register according to the results.
			; The comparison is performed by subtracting the second	operand	from the first operand
			;  and then setting the	status flags in	the same manner	as the SUB instruction.
			; The CF, OF, SF, ZF, AF, and PF flags are set according to the	result.
			; CF - 1 if unsigned op2 > unsigned op1
			; OF - 1 if sign bit of	OP1 != sign bit	of result
			; SF - 1 if MSB	(aka sign bit) of result = 1
			; ZF - 1 if Result = 0 (i.e. op1=op2)
			; AF - 1 if Carry in the low nibble of result
			; PF - 1 if Parity of Least significant	byte is	even
			;
jl	short loc_21A64	; Jump if Less (SF!=OF)
jg	short loc_21A50	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_10], 0	; Compare Two Operands
jbe	short loc_21A64	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_21A50:		; CODE XREF: LBX_Load_IntroLbx_s21977+D1j
push	[g_IntroLbxEntryNumber]	; argLbxEntryNumber
mov	ax, e_VGA_FRAME_EXCEEDS_65535
push	ax		; ErrNo
mov	ax, offset g_IntroLbxFileName ;	arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_21A64:		; CODE XREF: LBX_Load_IntroLbx_s21977+CFj
			; LBX_Load_IntroLbx_s21977+D7j
mov	[bp+var_6], 0
mov	[bp+var_8], 16384
push	[idk_AddrEmsHandle]
mov	ax, 4
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
add	ax, 18		; Add
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
call	idk_EmsMapMem_s16337 ; Call Procedure
add	sp, 0Ch		; Add
mov	ax, 1		; int
push	ax		; int
push	[bp+var_E]	; int
push	[bp+var_10]	; int
push	[bp+var_2]	; int
push	[bp+var_4]	; int
nop			; No Operation
push	cs
call	near ptr LBX_MemAndRead	; LBX_MemAndRead(1,
			;		 [bp+var_E]
			;		 [bp+var_10]
			;		 [bp+var_2]
			;		 [bp+arg1_DI])
			;
add	sp, 0Ah		; Add
push	si
push	[idk_FontsLbx1_32B]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_MemAndVid_s1E0DA ; Call Procedure
add	sp, 8		; Add
push	[idk_AddrEmsHandle]
mov	ax, 4
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
add	ax, 12h		; Add
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
call	idk_EmsMapMem_s16337 ; Call Procedure
add	sp, 0Ch		; Add
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Load_IntroLbx_s21977 ;	sp-analysis failed



;
; LBX_Intro_MemAndReadAndMem+29
; LBX_MemAndRead(0,0,3FACh,0,0)
;
; LBX_s21977+12C
; LBX_MemAndRead(1,
;		 [bp+var_E]
;		 [bp+var_10]
;		 [bp+var_2]
;		 [bp+arg1_DI])
;
; Attributes: bp-based frame

; int __fastcall __far LBX_MemAndRead(int, int,	int, int, int, int, int, int)
proc LBX_MemAndRead far	; CODE XREF: LBX_Intro_MemAndReadAndMem+29p
			; LBX_Load_IntroLbx_s21977+12Cp

var_MemShort= byte ptr -26h
var_RecordOffsetStart= word ptr	-12h
var_OffsetHigh=	word ptr -10h
var_RecordOffsetEnd= word ptr -0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8_var_C= word ptr -8
varBytes= word ptr -6
varBuffer= word	ptr -4
varReadLoopCount= word ptr -2
arg_Zero_or_One= word ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8_DI= word ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 26h		; Integer Subtraction
push	si
push	di		; int
cmp	[idk_AddrEmsHandle], 0 ; If (AX	!= 0) Then Set (ZF = 1)
jnz	short EMM_OK	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax		; argLbxEntryNumber
mov	ax, e_INSUFFICIENT_EMM ; Case 0xB: Insuff EMM
push	ax		; ErrNo
mov	ax, offset g_IntroLbxFileName ;	arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

EMM_OK:			; CODE XREF: LBX_MemAndRead+Dj
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
lea	ax, [bp+var_RecordOffsetEnd] ; Load Effective Address
push	ax		; int
lea	ax, [bp+var_RecordOffsetStart] ; Load Effective	Address
push	ax		; int
push	[g_IntroLbxEntryNumber]	; int
mov	ax, offset g_IntroLbxFileName ;	int
push	ax		; int
call	LBX_Load_Entry_4bytes ;	LBX_Load_Entry_4bytes(0,
			;			var_E,
			;			arg0_OffsetLow,
			;			g_IntroLbxEntryNumber,
			;			g_IntroLbxFileName)
			; Return:
			; AX is	g_CurrentLbxFileHandle
			; Record Data in g_ptrBufferReadFile
			; var_RecordOffsetStart	is arg_RecordOffsetStart
			; var_RecordOffsetEnd is arg_RecordOffsetEnd
			;
add	sp, 0Ah		;
			;
mov	di, ax		; di = g_CurrentLbxFileHandle
			;
mov	ax, [bp+arg_2]
mov	dx, [bp+arg_Zero_or_One]
add	[bp+var_RecordOffsetStart], dx ; Add
adc	[bp+var_OffsetHigh], ax	; Add with Carry
mov	ax, [bp+arg_2]
mov	dx, [bp+arg_Zero_or_One] ; arg2_ErrNo
sub	[bp+var_RecordOffsetEnd], dx ; Integer Subtraction
sbb	[bp+var_C], ax	; Integer Subtraction with Borrow
cmp	[bp+var_C], 0	; Compare Two Operands
jg	short loc_21B5E	; Jump if Greater (ZF=0	& SF=OF)
jnz	short loc_21B4A	; Jump if Not Zero (ZF=0)
cmp	[bp+var_RecordOffsetEnd], 0 ; Compare Two Operands
ja	short loc_21B5E	; Jump if Above	(CF=0 &	ZF=0)

loc_21B4A:		; CODE XREF: LBX_MemAndRead+5Dj
push	[g_IntroLbxEntryNumber]	; argLbxEntryNumber
mov	ax, e_CORRUPTED
push	ax		; ErrNo
lea	ax, [bp+var_MemShort] ;	arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_21B5E:		; CODE XREF: LBX_MemAndRead+5Bj
			; LBX_MemAndRead+63j
mov	ax, [bp+arg_6]
mov	dx, [bp+arg_4]
cmp	ax, [bp+var_C]	; Compare Two Operands
jg	short loc_21B7C	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_21B70	; Jump if Less (SF!=OF)
cmp	dx, [bp+var_RecordOffsetEnd] ; Compare Two Operands
jnb	short loc_21B7C	; Jump if Not Below (CF=0)

loc_21B70:		; CODE XREF: LBX_MemAndRead+84j
mov	ax, [bp+arg_6]
mov	dx, [bp+arg_4]	; arg2_ErrNo
mov	[bp+var_C], ax
mov	[bp+var_RecordOffsetEnd], dx

loc_21B7C:		; CODE XREF: LBX_MemAndRead+82j
			; LBX_MemAndRead+89j
push	di		; arg4_FileHandle
push	[bp+var_OffsetHigh] ; arg2_OffsetHigh
push	[bp+var_RecordOffsetStart] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short loc_21BA3	; Jump if Not Zero (ZF=0)

FAILURE_DOS_SEEK:	; argLbxEntryNumber
push	[g_IntroLbxEntryNumber]
mov	ax, e_CORRUPTED	; Case 0x01: Has Been Corrupted?
push	ax		; ErrNo
lea	ax, [bp+var_MemShort] ;	arg0_LbxFileName
push	ax		; arg6_MemShort
call	LBX_Load_ErrorHandler ;	Call Procedure
add	sp, 6		; Add

loc_21BA3:		; CODE XREF: LBX_MemAndRead+A8j
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16384
push	ax
push	dx
push	[bp+var_C]
push	[bp+var_RecordOffsetEnd]
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+varReadLoopCount], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16384
push	ax
push	dx
push	[bp+var_C]
push	[bp+var_RecordOffsetEnd]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
or	ax, dx		; Remainder == 0?
jz	short loc_21BD1	; Jump if Zero (ZF=1)

AddOneToCaptureRemainder: ; Increment by 1
inc	[bp+varReadLoopCount]

loc_21BD1:		; CODE XREF: LBX_MemAndRead+E7j
call	fncGetEmmPageFrameSegmentAddress ;   mov     ax, seg dseg
			;   mov	    ds,	ax
			;   mov	    ax,	adrEMM_PageFrameSegment
mov	[bp+varBuffer],	ax
mov	si, [bp+arg_8_DI]
mov	ax, [bp+var_C]
mov	dx, [bp+var_RecordOffsetEnd]
mov	[bp+var_8_var_C], ax
mov	[bp+var_A], dx
mov	[bp+varBytes], 16384
jmp	short loc_21C14	; Jump

loc_21BEF:		; CODE XREF: LBX_MemAndRead+133j
			; LBX_MemAndRead+13Cj
sub	[bp+var_A], 16384 ; Integer Subtraction
sbb	[bp+var_8_var_C], 0 ; Integer Subtraction with Borrow
push	si
push	[idk_AddrEmsHandle]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
push	di		; argFileHandle
push	[bp+varBytes]	; argBytes
push	[bp+varBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
inc	si		; Increment by 1

loc_21C14:		; CODE XREF: LBX_MemAndRead+108j
cmp	[bp+var_8_var_C], 0 ; Compare Two Operands
jg	short loc_21BEF	; Jump if Greater (ZF=0	& SF=OF)

loc_21C1A:		; Jump if Less (SF!=OF)
jl	short loc_21C23

loc_21C1C:		; Compare Two Operands
cmp	[bp+var_A], 16384
jnb	short loc_21BEF	; Jump if Not Below (CF=0)

loc_21C23:		; CODE XREF: LBX_MemAndRead:loc_21C1Aj
cmp	[bp+var_8_var_C], 0 ; Compare Two Operands
jl	short loc_21C52	; Jump if Less (SF!=OF)
jg	short loc_21C31	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_A], 0	; Compare Two Operands

loc_21C2F:		; Jump if Below	or Equal (CF=1 | ZF=1)
jbe	short loc_21C52

loc_21C31:		; CODE XREF: LBX_MemAndRead+144j
mov	ax, [bp+var_A]
mov	[bp+varBytes], ax
push	si
push	[idk_AddrEmsHandle]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
push	di		; argFileHandle
push	[bp+varBytes]	; argBytes
push	[bp+varBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add

loc_21C52:		; CODE XREF: LBX_MemAndRead+142j
			; LBX_MemAndRead:loc_21C2Fj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_MemAndRead ; sp-analysis failed



; Attributes: bp-based frame

proc sub_21C58 far

argValue= word ptr  6

push	bp
mov	bp, sp
mov	ax, 4
push	ax
push	[idk_FontsLbx1_32B] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure

loc_21C68:
pop	cx
pop	cx
jmp	short $+2	; Jump
pop	bp

locret_21C6D:		; Return Far from Procedure
retf
push	bp
mov	bp, sp
push	[bp+argValue]	; argValue
mov	ax, 4
push	ax		; argOffset
push	[idk_FontsLbx1_32B] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_21C58



; Attributes: bp-based frame

proc sub_21C86 far	; CODE XREF: sub_29731+103P

var_6= word ptr	-6
var_4= word ptr	-4
arg1_DI= word ptr -2
argOffset= dword ptr  6

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di

loc_21C8E:
mov	si, [word ptr bp+argOffset]
mov	ax, 0Ah
push	ax
push	si

loc_21C96:		; Call Procedure
call	idk_LODSB_Arg2_Arg1
pop	cx
pop	cx
mov	di, ax
mov	[bp+arg1_DI], 0
or	di, di		; Logical Inclusive OR
jnz	short loc_21CB9	; Jump if Not Zero (ZF=0)
mov	ax, 10h
push	ax
push	si
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx
pop	cx
mov	[bp+arg1_DI], ax

loc_21CB7:		; Jump
jmp	short loc_21D0B

loc_21CB9:		; CODE XREF: sub_21C86+20j
mov	ax, 0Bh
push	ax
push	si
call	idk_LODSB_Arg2_Arg1 ; Call Procedure
pop	cx

loc_21CC4:
pop	cx
xor	dx, dx		; Logical Exclusive OR
mov	cl, 0Eh
call	LXLSH@		; Call Procedure
push	ax
push	dx		; argPtrSrcBuf

loc_21CD0:
mov	ax, 0Ch
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx

loc_21CDC:
pop	dx
pop	bx
add	bx, ax		; Add
adc	dx, 0		; Add with Carry
mov	[bp+var_4], dx
mov	[bp+var_6], bx
push	di		; arg6_EmsHandle
mov	ax, 1
push	ax		; arg5_ByteCount

loc_21CEE:
mov	ax, [bp+var_4]
mov	dx, [bp+var_6]
add	dx, 10h		; Add
adc	ax, 0		; Add with Carry

loc_21CFA:		; arg4_6
push	ax
push	dx		; arg3_4
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg2_ES
lea	ax, [bp+arg1_DI] ; Load	Effective Address
push	ax		; arg1_DI

loc_21D03:		; Call Procedure
call	EMS_MapMemory_4
add	sp, 0Ch		; Add

loc_21D0B:		; CODE XREF: sub_21C86:loc_21CB7j
mov	ax, [bp+arg1_DI]
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_21C86



; Attributes: bp-based frame

proc sub_21D16 far	; CODE XREF: idk_OVR_LoadLbxHelp+417P

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	ax, 1
push	ax
mov	ax, 8
push	ax
push	[bp+arg_0]
call	fncStoSB	; Store	AX in word ES:DI, update DI
			; ES = argSegment
			; DI = argOffset
			; AX = argValue

loc_21D29:		; Add
add	sp, 6
pop	bp
retf			; Return Far from Procedure
endp sub_21D16



; Attributes: bp-based frame

proc sub_21D2E far

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= dword ptr  6

push	bp

loc_21D2F:
mov	bp, sp

loc_21D31:		; Integer Subtraction
sub	sp, 6
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_4]
imul	[bp+var_2]	; Signed Multiply
mov	[bp+var_6], ax

loc_21D60:
push	ds
push	si
push	di
mov	cx, [bp+var_6]
mov	dx, [bp+var_2]
mov	ax, [word ptr bp+argOffset+2]
mov	ah, al
mov	bx, [word ptr bp+argOffset]
inc	bx		; Increment by 1
mov	ds, bx
mov	bx, 0
mov	di, 0

loc_21D7A:
mov	si, 0

loc_21D7D:		; CODE XREF: sub_21D2E:loc_21DA9j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands

loc_21D80:		; Jump if Zero (ZF=1)
jz	short loc_21D94
cmp	al, ah		; Compare Two Operands
jz	short loc_21D94	; Jump if Zero (ZF=1)

loc_21D86:		; Compare Two Operands
cmp	bh, 0
jz	short loc_21D8E	; Jump if Zero (ZF=1)
mov	[si-2],	ah

loc_21D8E:		; CODE XREF: sub_21D2E+5Bj
xor	bh, bh		; Logical Exclusive OR

loc_21D90:
mov	bl, 1
jmp	short loc_21DA0	; Jump

loc_21D94:		; CODE XREF: sub_21D2E:loc_21D80j
			; sub_21D2E+56j
cmp	bl, 0		; Compare Two Operands
jz	short loc_21D9C	; Jump if Zero (ZF=1)

loc_21D99:
mov	[si-1],	ah

loc_21D9C:		; CODE XREF: sub_21D2E+69j
xor	bl, bl		; Logical Exclusive OR
mov	bh, 1

loc_21DA0:		; CODE XREF: sub_21D2E+64j
inc	di		; Increment by 1

loc_21DA1:		; Compare Two Operands
cmp	di, dx
js	short loc_21DA9	; Jump if Sign (SF=1)
xor	di, di		; Logical Exclusive OR
xor	bx, bx		; Logical Exclusive OR

loc_21DA9:		; CODE XREF: sub_21D2E+75j
loop	loc_21D7D	; Loop while CX	!= 0
pop	di

loc_21DAC:
pop	si
pop	ds
push	ds
push	si

loc_21DB0:
push	di
mov	cx, [bp+var_6]
mov	di, cx
mov	dx, [bp+var_2]
mov	ax, [word ptr bp+argOffset+2]
mov	ah, al
mov	bx, [word ptr bp+argOffset]
inc	bx		; Increment by 1
mov	ds, bx
mov	bx, 0
mov	si, 0

loc_21DCA:		; CODE XREF: sub_21D2E:loc_21DFDj
lodsb			; Load String
cmp	al, 0		; Compare Two Operands

loc_21DCD:		; Jump if Zero (ZF=1)
jz	short loc_21DE5

loc_21DCF:		; Compare Two Operands
cmp	al, ah

loc_21DD1:		; Jump if Zero (ZF=1)
jz	short loc_21DE5
cmp	bh, 0		; Compare Two Operands
jz	short loc_21DDF	; Jump if Zero (ZF=1)
sub	si, dx		; Integer Subtraction
mov	[si-1],	ah
add	si, dx		; Add

loc_21DDF:		; CODE XREF: sub_21D2E+A8j
xor	bh, bh		; Logical Exclusive OR
mov	bl, 1
jmp	short loc_21DF1	; Jump

loc_21DE5:		; CODE XREF: sub_21D2E:loc_21DCDj
			; sub_21D2E:loc_21DD1j
cmp	bl, 0		; Compare Two Operands
jz	short loc_21DED	; Jump if Zero (ZF=1)
mov	[si-1],	ah

loc_21DED:		; CODE XREF: sub_21D2E+BAj
xor	bl, bl		; Logical Exclusive OR
mov	bh, 1

loc_21DF1:		; CODE XREF: sub_21D2E+B5j
dec	si		; Decrement by 1

loc_21DF2:		; Add
add	si, dx
cmp	si, di		; Compare Two Operands

loc_21DF6:		; Jump if Sign (SF=1)
js	short loc_21DFD
sub	si, di		; Integer Subtraction

loc_21DFA:		; Increment by 1
inc	si
xor	bx, bx		; Logical Exclusive OR

loc_21DFD:		; CODE XREF: sub_21D2E:loc_21DF6j
loop	loc_21DCA	; Loop while CX	!= 0
pop	di
pop	si
pop	ds
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_21D2E



; Attributes: bp-based frame

proc sub_21E08 far

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= dword ptr  6

push	bp

loc_21E09:
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di

loc_21E10:		; Logical Exclusive OR
xor	ax, ax
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_4]
imul	[bp+var_2]	; Signed Multiply
mov	[bp+var_6], ax
push	ds
push	si
push	di
mov	cx, [bp+var_6]
mov	dx, [bp+var_2]

loc_21E43:
mov	ax, [word ptr bp+argOffset+2]
mov	ah, al
mov	bx, [word ptr bp+argOffset]

loc_21E4B:		; Increment by 1
inc	bx
mov	ds, bx
mov	bx, 0
mov	di, 0
mov	si, 0

loc_21E57:		; CODE XREF: sub_21E08:loc_21E87j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jz	short loc_21E72	; Jump if Zero (ZF=1)

loc_21E5C:		; Compare Two Operands
cmp	al, ah
jz	short loc_21E72	; Jump if Zero (ZF=1)
cmp	al, 0DFh ; ''  ; Compare Two Operands
ja	short loc_21E72	; Jump if Above	(CF=0 &	ZF=0)
cmp	bh, 0		; Compare Two Operands
jz	short loc_21E6C	; Jump if Zero (ZF=1)
mov	[si-2],	ah

loc_21E6C:		; CODE XREF: sub_21E08+5Fj
xor	bh, bh		; Logical Exclusive OR
mov	bl, 1
jmp	short loc_21E7E	; Jump

loc_21E72:		; CODE XREF: sub_21E08+52j
			; sub_21E08+56j
			; sub_21E08+5Aj
cmp	bl, 0		; Compare Two Operands

loc_21E75:		; Jump if Zero (ZF=1)
jz	short loc_21E7A
mov	[si-1],	ah

loc_21E7A:		; CODE XREF: sub_21E08:loc_21E75j
xor	bl, bl		; Logical Exclusive OR
mov	bh, 1

loc_21E7E:		; CODE XREF: sub_21E08+68j
inc	di		; Increment by 1
cmp	di, dx		; Compare Two Operands
js	short loc_21E87	; Jump if Sign (SF=1)
xor	di, di		; Logical Exclusive OR
xor	bx, bx		; Logical Exclusive OR

loc_21E87:		; CODE XREF: sub_21E08+79j
loop	loc_21E57	; Loop while CX	!= 0
pop	di
pop	si
pop	ds
push	ds
push	si
push	di

loc_21E8F:
mov	cx, [bp+var_6]
mov	di, cx
mov	dx, [bp+var_2]

loc_21E97:
mov	ax, [word ptr bp+argOffset+2]
mov	ah, al

loc_21E9C:
mov	bx, [word ptr bp+argOffset]

loc_21E9F:		; Increment by 1
inc	bx

loc_21EA0:
mov	ds, bx
mov	bx, 0

loc_21EA5:
mov	si, 0

loc_21EA8:		; CODE XREF: sub_21E08:loc_21EDFj
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jz	short loc_21EC7	; Jump if Zero (ZF=1)
cmp	al, ah		; Compare Two Operands

loc_21EAF:		; Jump if Zero (ZF=1)
jz	short loc_21EC7
cmp	al, 0DFh ; ''  ; Compare Two Operands
ja	short loc_21EC7	; Jump if Above	(CF=0 &	ZF=0)
cmp	bh, 0		; Compare Two Operands

loc_21EB8:		; Jump if Zero (ZF=1)
jz	short loc_21EC1

loc_21EBA:		; Integer Subtraction
sub	si, dx
mov	[si-1],	ah
add	si, dx		; Add

loc_21EC1:		; CODE XREF: sub_21E08:loc_21EB8j
xor	bh, bh		; Logical Exclusive OR

loc_21EC3:
mov	bl, 1

loc_21EC5:		; Jump
jmp	short loc_21ED3

loc_21EC7:		; CODE XREF: sub_21E08+A3j
			; sub_21E08:loc_21EAFj
			; sub_21E08+ABj
cmp	bl, 0		; Compare Two Operands

loc_21ECA:		; Jump if Zero (ZF=1)
jz	short loc_21ECF

loc_21ECC:
mov	[si-1],	ah

loc_21ECF:		; CODE XREF: sub_21E08:loc_21ECAj
xor	bl, bl		; Logical Exclusive OR

loc_21ED1:
mov	bh, 1

loc_21ED3:		; CODE XREF: sub_21E08:loc_21EC5j
dec	si		; Decrement by 1
add	si, dx		; Add
cmp	si, di		; Compare Two Operands
js	short loc_21EDF	; Jump if Sign (SF=1)
sub	si, di		; Integer Subtraction
inc	si		; Increment by 1
xor	bx, bx		; Logical Exclusive OR

loc_21EDF:		; CODE XREF: sub_21E08+D0j
loop	loc_21EA8	; Loop while CX	!= 0
pop	di
pop	si
pop	ds
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_21E08



; Attributes: bp-based frame

proc sub_21EEA far

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= dword ptr  6
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di

loc_21EF2:		; Logical Exclusive OR
xor	ax, ax
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_21F09:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx
mov	[bp+var_6], ax
mov	ax, [bp+var_2]
imul	[bp+var_6]	; Signed Multiply
mov	[bp+var_4], ax
push	es
push	si
push	di
mov	cx, [bp+var_4]
mov	ax, [word ptr bp+argOffset+2]
mov	ah, al
mov	si, [bp+arg_4]
mov	bx, [word ptr bp+argOffset]
inc	bx		; Increment by 1

loc_21F2E:
mov	es, bx

loc_21F30:		; Logical Exclusive OR
xor	bx, bx
xor	dx, dx		; Logical Exclusive OR
xor	di, di		; Logical Exclusive OR

loc_21F36:		; CODE XREF: sub_21EEA+64j
mov	al, [es:di]
cmp	al, ah		; Compare Two Operands

loc_21F3B:		; Jump if Not Zero (ZF=0)
jnz	short loc_21F42
mov	al, [bx+si]

loc_21F3F:
mov	[es:di], al

loc_21F42:		; CODE XREF: sub_21EEA:loc_21F3Bj
inc	di		; Increment by 1
add	bx, dx		; Add
db 81h,0E3h,7,0	; <BAD>and     bx, 7 ; Logical AND
inc	dx		; Increment by 1
db 81h,0E2h,7,0	; <BAD>and     dx, 7 ; Logical AND
loop	loc_21F36	; Loop while CX	!= 0
pop	di
pop	si
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_21EEA



; Attributes: bp-based frame

proc sub_21F59 far

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= dword ptr  6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= byte ptr	 10h

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
imul	[bp+var_4]	; Signed Multiply

loc_21F88:
mov	[bp+var_6], ax
push	[word ptr bp+argOffset]

loc_21F8E:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[bp+var_8], dx
mov	[bp+var_A], ax
mov	ax, [word ptr bp+argOffset+2]
cmp	ax, [bp+var_4]	; Compare Two Operands
jge	short loc_21FD7	; Jump if Greater or Equal (SF=OF)
cmp	[word ptr bp+argOffset+2], 0 ; Compare Two Operands
jle	short loc_21FD7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	di, [bp+arg_4]
jmp	short loc_21FCD	; Jump

loc_21FAD:		; CODE XREF: sub_21F59:loc_21FD5j
cmp	di, [bp+var_2]	; Compare Two Operands

loc_21FB0:		; Jump if Greater or Equal (SF=OF)
jge	short loc_21FCC
or	di, di		; Logical Inclusive OR
jle	short loc_21FCC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word ptr bp+argOffset+2]
imul	[bp+arg_8]	; Signed Multiply
add	ax, di		; Add
mov	es, [bp+var_8]
add	ax, [bp+var_A]	; Add

loc_21FC4:
mov	dl, [bp+arg_A]

loc_21FC7:
mov	bx, ax
mov	[es:bx], dl

loc_21FCC:		; CODE XREF: sub_21F59:loc_21FB0j
			; sub_21F59+5Bj
inc	di		; Increment by 1

loc_21FCD:		; CODE XREF: sub_21F59+52j
mov	ax, [bp+arg_4]
add	ax, [bp+arg_8]	; Add
cmp	ax, di		; Compare Two Operands

loc_21FD5:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_21FAD

loc_21FD7:		; CODE XREF: sub_21F59+47j
			; sub_21F59+4Dj
mov	ax, [word ptr bp+argOffset+2]
add	ax, [bp+arg_6]	; Add
dec	ax		; Decrement by 1

loc_21FDE:		; Compare Two Operands
cmp	ax, [bp+var_4]
jge	short loc_2201F	; Jump if Greater or Equal (SF=OF)
mov	ax, [word ptr bp+argOffset+2]
add	ax, [bp+arg_6]	; Add
dec	ax		; Decrement by 1

loc_21FEA:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_2201F
mov	di, [bp+arg_4]
jmp	short loc_22015	; Jump

loc_21FF1:		; CODE XREF: sub_21F59+C4j
cmp	di, [bp+var_2]	; Compare Two Operands

loc_21FF4:		; Jump if Greater or Equal (SF=OF)
jge	short loc_22014

loc_21FF6:		; Logical Inclusive OR
or	di, di

loc_21FF8:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_22014
mov	ax, [word ptr bp+argOffset+2]
add	ax, [bp+arg_6]	; Add
dec	ax		; Decrement by 1
imul	[bp+arg_8]	; Signed Multiply
add	ax, di		; Add
mov	es, [bp+var_8]
add	ax, [bp+var_A]	; Add
mov	dl, [bp+arg_A]
mov	bx, ax
mov	[es:bx], dl

loc_22014:		; CODE XREF: sub_21F59:loc_21FF4j
			; sub_21F59:loc_21FF8j
inc	di		; Increment by 1

loc_22015:		; CODE XREF: sub_21F59+96j
mov	ax, [bp+arg_4]

loc_22018:		; Add
add	ax, [bp+arg_8]
cmp	ax, di		; Compare Two Operands
jg	short loc_21FF1	; Jump if Greater (ZF=0	& SF=OF)

loc_2201F:		; CODE XREF: sub_21F59+88j
			; sub_21F59:loc_21FEAj
mov	ax, [bp+arg_4]

loc_22022:		; Compare Two Operands
cmp	ax, [bp+var_2]
jge	short loc_2205C	; Jump if Greater or Equal (SF=OF)

loc_22027:		; Compare Two Operands
cmp	[bp+arg_4], 0
jle	short loc_2205C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_2202D:
mov	si, [word ptr bp+argOffset+2]
jmp	short loc_22052	; Jump

loc_22032:		; CODE XREF: sub_21F59+101j
cmp	si, [bp+var_4]	; Compare Two Operands
jge	short loc_22051	; Jump if Greater or Equal (SF=OF)
or	si, si		; Logical Inclusive OR
jle	short loc_22051	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
imul	[bp+arg_8]	; Signed Multiply

loc_22040:		; Add
add	ax, [bp+arg_4]

loc_22043:
mov	es, [bp+var_8]
add	ax, [bp+var_A]	; Add
mov	dl, [bp+arg_A]
mov	bx, ax
mov	[es:bx], dl

loc_22051:		; CODE XREF: sub_21F59+DCj
			; sub_21F59+E0j
inc	si		; Increment by 1

loc_22052:		; CODE XREF: sub_21F59+D7j
mov	ax, [word ptr bp+argOffset+2]
add	ax, [bp+arg_6]	; Add
cmp	ax, si		; Compare Two Operands
jg	short loc_22032	; Jump if Greater (ZF=0	& SF=OF)

loc_2205C:		; CODE XREF: sub_21F59+CCj
			; sub_21F59+D2j
mov	ax, [bp+arg_4]
add	ax, [bp+arg_8]	; Add
dec	ax		; Decrement by 1
cmp	ax, [bp+var_2]	; Compare Two Operands
jge	short loc_220A4	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+arg_4]
add	ax, [bp+arg_8]	; Add
dec	ax		; Decrement by 1

loc_2206F:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_220A4
mov	si, [word ptr bp+argOffset+2]
jmp	short loc_2209A	; Jump

loc_22076:		; CODE XREF: sub_21F59+149j
cmp	si, [bp+var_4]	; Compare Two Operands
jge	short loc_22099	; Jump if Greater or Equal (SF=OF)

loc_2207B:		; Logical Inclusive OR
or	si, si

loc_2207D:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_22099

loc_2207F:
mov	ax, si
imul	[bp+arg_8]	; Signed Multiply
mov	bx, [bp+arg_4]
add	bx, [bp+arg_8]	; Add
add	bx, ax		; Add
mov	es, [bp+var_8]
add	bx, [bp+var_A]	; Add
mov	al, [bp+arg_A]
mov	[es:bx-1], al

loc_22099:		; CODE XREF: sub_21F59+120j
			; sub_21F59:loc_2207Dj
inc	si		; Increment by 1

loc_2209A:		; CODE XREF: sub_21F59+11Bj
mov	ax, [word ptr bp+argOffset+2]
add	ax, [bp+arg_6]	; Add
cmp	ax, si		; Compare Two Operands
jg	short loc_22076	; Jump if Greater (ZF=0	& SF=OF)

loc_220A4:		; CODE XREF: sub_21F59+10Dj
			; sub_21F59:loc_2206Fj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_21F59



; Attributes: bp-based frame

proc sub_220AA far	; CODE XREF: idk_OVR_LoadLbxHelp+179P
			; idk_OVR_LoadLbxHelp+405P

var_14=	dword ptr -14h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
argOffset= dword ptr  6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 14h		; Integer Subtraction

loc_220B0:
push	si
push	di		; arg2_SI
mov	si, [word ptr bp+argOffset+2]
mov	di, [bp+arg_4]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset

loc_220CF:		; Call Procedure
call	ST_Read_2B_From_Buffer_At_Offset
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_2]

loc_220DC:		; Signed Multiply
imul	[bp+var_4]
mov	[bp+var_A], ax
push	[word ptr bp+argOffset]

loc_220E5:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr bp+var_14+2],	dx
mov	[word ptr bp+var_14], ax

loc_220F1:
mov	[word ptr si], 3E8h
mov	[word ptr di], 3E8h
mov	[bp+var_8], 0
mov	[bp+var_6], 0

loc_22103:
mov	[bp+var_10], 10h

loc_22108:
mov	[bp+var_C], 0
jmp	short loc_22167	; Jump

loc_2210F:		; CODE XREF: sub_220AA:loc_2216Dj
mov	[bp+var_E], 0
jmp	short loc_2215C	; Jump

loc_22116:		; CODE XREF: sub_220AA+B8j
les	bx, [bp+var_14]	; Load Full Pointer to ES:xx

loc_22119:		; Add
add	bx, [bp+var_10]
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
jz	short loc_22156	; Jump if Zero (ZF=1)
mov	ax, [si]
cmp	ax, [bp+var_C]	; Compare Two Operands
jle	short loc_2212E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]

loc_2212C:
mov	[si], ax

loc_2212E:		; CODE XREF: sub_220AA+7Dj
mov	ax, [di]
cmp	ax, [bp+var_E]	; Compare Two Operands
jle	short loc_2213A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_E]
mov	[di], ax

loc_2213A:		; CODE XREF: sub_220AA+89j
mov	ax, [bp+var_8]
cmp	ax, [bp+var_C]	; Compare Two Operands
jge	short loc_22148	; Jump if Greater or Equal (SF=OF)

loc_22142:
mov	ax, [bp+var_C]
mov	[bp+var_8], ax

loc_22148:		; CODE XREF: sub_220AA+96j
mov	ax, [bp+var_6]
cmp	ax, [bp+var_E]	; Compare Two Operands

loc_2214E:		; Jump if Greater or Equal (SF=OF)
jge	short loc_22156
mov	ax, [bp+var_E]
mov	[bp+var_6], ax

loc_22156:		; CODE XREF: sub_220AA+76j
			; sub_220AA:loc_2214Ej
inc	[bp+var_10]	; Increment by 1

loc_22159:		; Increment by 1
inc	[bp+var_E]

loc_2215C:		; CODE XREF: sub_220AA+6Aj
mov	ax, [bp+var_E]
cmp	ax, [bp+var_2]	; Compare Two Operands
jl	short loc_22116	; Jump if Less (SF!=OF)

loc_22164:		; Increment by 1
inc	[bp+var_C]

loc_22167:		; CODE XREF: sub_220AA+63j
mov	ax, [bp+var_C]

loc_2216A:		; Compare Two Operands
cmp	ax, [bp+var_4]

loc_2216D:		; Jump if Less (SF!=OF)
jl	short loc_2210F

loc_2216F:
mov	ax, [bp+var_6]

loc_22172:		; Integer Subtraction
sub	ax, [di]

loc_22174:		; Increment by 1
inc	ax

loc_22175:
mov	bx, [bp+arg_8]

loc_22178:
mov	[bx], ax

loc_2217A:
mov	ax, [bp+var_8]

loc_2217D:		; Integer Subtraction
sub	ax, [si]

loc_2217F:		; Increment by 1
inc	ax

loc_22180:
mov	bx, [bp+arg_6]

loc_22183:
mov	[bx], ax

loc_22185:
pop	di

loc_22186:
pop	si

loc_22187:
mov	sp, bp

loc_22189:
pop	bp

locret_2218A:		; Return Far from Procedure
retf
endp sub_220AA

ends seg028


; Segment type:	Pure code
segment	seg029 byte public 'CODE' use16
assume cs:seg029
;org 0Ch
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
word_2218C dw 0		; DATA XREF: idk_VGA_ScIndexMapMask_s22194+37w
			; idk_VGA_ScIndexMapMask_s22194:loc_22233r
			; idk_VGA_ScIndexMapMask_s22194+145r
			; sub_223C9:loc_22406w
			; sub_223C9:loc_22498r
			; sub_223C9+1A9r
algn_2218E:
align 4
word_22190 dw 0		; DATA XREF: idk_VGA_ScIndexMapMask_s22194+47w
			; idk_VGA_ScIndexMapMask_s22194:loc_22259r
			; idk_VGA_ScIndexMapMask_s22194+126r
			; idk_VGA_ScIndexMapMask_s22194+13Ar
			; idk_VGA_ScIndexMapMask_s22194+173r
			; idk_VGA_ScIndexMapMask_s22194+198r
			; idk_VGA_ScIndexMapMask_s22194+1A7r
			; idk_VGA_ScIndexMapMask_s22194:loc_22343r
			; sub_223C9+4Dw
			; sub_223C9+C7r
			; sub_223C9:loc_224BEr
			; sub_223C9+16Dr
			; sub_223C9+1D8r
			; sub_223C9:loc_225C6r
			; sub_223C9:loc_225D5r
			; sub_223C9:loc_225DDr
word_22192 dw 0		; DATA XREF: idk_VGA_ScIndexMapMask_s22194+3Fw
			; idk_VGA_ScIndexMapMask_s22194+FFw
			; idk_VGA_ScIndexMapMask_s22194+20Ew
			; sub_223C9+45w
			; sub_223C9+134w


; Attributes: bp-based frame

proc idk_VGA_ScIndexMapMask_s22194 far
			; CODE XREF: idk_VidLib_s1F743+173P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds


mov	dx, SC_INDEX
mov	al, MAP_MASK
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3


mov	ax, [bp+arg_2]
mov	bx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
mov	di, bx
and	ax, 11b		; Logical AND
mov	si, offset unk_36086
add	si, ax		; Add
lodsb			; Load String
mov	ah, al
mov	bx, [bp+arg_A]
mov	[cs:word_2218C], bx
mov	bx, [bp+arg_4]
mov	[cs:word_22192], bx
mov	bx, [bp+arg_6]
mov	[cs:word_22190], bx
mov	cx, [bp+arg_8]
mov	dx, [bp+arg_E]
mov	si, [bp+arg_C]
mov	ds, dx
cmp	cx, 0		; Compare Two Operands
jz	short loc_22208	; Jump if Zero (ZF=1)

loc_221F0:
mov	dx, ax

MAYBE_2D_LOOP:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+6Aj
			; idk_VGA_ScIndexMapMask_s22194+70j
lodsw			; Load String
cmp	al, 0FFh	; Compare Two Operands
jz	short loc_22203	; Jump if Zero (ZF=1)

loc_221F7:		; Exchange Register/Memory with	Register
xchg	al, ah
and	ax, 7FFFh	; Logical AND
add	si, ax		; Add
loop	MAYBE_2D_LOOP	; Loop while CX	!= 0

loc_22200:		; Jump
jmp	short loc_22206
db 90h

loc_22203:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+61j
dec	si		; Decrement by 1
loop	MAYBE_2D_LOOP	; Loop while CX	!= 0

loc_22206:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194:loc_22200j
mov	ax, dx

loc_22208:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+5Aj
			; idk_VGA_ScIndexMapMask_s22194:loc_222A4j
			; idk_VGA_ScIndexMapMask_s22194:loc_223B3j
push	di
cmp	si, 0FC00h	; Compare Two Operands
jb	short loc_2221B	; Jump if Below	(CF=1)

loc_2220F:
mov	ds, cx
add	cx, 0FC0h	; Add
mov	cx, ds
sub	si, 0FC00h	; Integer Subtraction

loc_2221B:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+79j
mov	dx, SC_DATA
mov	al, ah
out	dx, al		; EGA port: sequencer data register
lodsb			; Load String
cmp	al, 0FFh	; Compare Two Operands
jz	short loc_22292	; Jump if Zero (ZF=1)

loc_22226:
mov	dh, al
lodsb			; Load String
mov	dl, al
cmp	dh, 0		; Compare Two Operands
jns	short loc_22233	; Jump if Not Sign (SF=0)
jmp	loc_222D5	; Jump

loc_22233:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+9Aj
mov	bx, [cs:word_2218C]
xor	ch, ch		; Logical Exclusive OR

loc_2223A:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+C0j
cmp	bx, 0		; Compare Two Operands
jz	short loc_22259	; Jump if Zero (ZF=1)

loc_2223F:
mov	cl, [si+1]
sub	bx, cx		; Integer Subtraction
jbe	short loc_222B6	; Jump if Below	or Equal (CF=1 | ZF=1)
lodsb			; Load String

loc_22247:
mov	cl, al

loc_22249:		; Integer Subtraction
sub	bx, cx
jb	short loc_222C1	; Jump if Below	(CF=1)

loc_2224D:		; Increment by 1
inc	si
add	si, cx		; Add
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction
jnz	short loc_2223A	; Jump if Not Zero (ZF=0)

loc_22256:		; Jump
jmp	short loc_22292
db 90h

loc_22259:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+A9j
mov	bx, [cs:word_22190]

loc_2225E:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+FCj
			; idk_VGA_ScIndexMapMask_s22194+11Ej
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR

loc_22263:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194:loc_222BFj
sub	bx, cx		; Integer Subtraction

loc_22265:
mov	al, cl

loc_22267:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left

loc_2226B:		; Add
add	cl, al

loc_2226D:		; Add with Carry
adc	ch, 0

loc_22270:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_22276:		; Shift	Logical	Left
shl	cx, 1

loc_22278:		; Add
add	di, cx

loc_2227A:		; Load String
lodsb

loc_2227B:
mov	cl, al

loc_2227D:		; Logical Exclusive OR
xor	ch, ch

loc_2227F:		; Increment by 1
inc	si

loc_22280:		; Decrement by 1
dec	dx
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_22284:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+F7j
			; idk_VGA_ScIndexMapMask_s22194+13Fj
dec	bx		; Decrement by 1
js	short loc_222AD	; Jump if Sign (SF=1)
movsb			; Move Byte(s) from String to String

loc_22288:		; Add
add	di, 4Fh	; 'O'
loop	loc_22284	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_2225E	; Jump if Not Sign (SF=0)

loc_22292:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+90j
			; idk_VGA_ScIndexMapMask_s22194:loc_22256j
			; idk_VGA_ScIndexMapMask_s22194+120j
			; idk_VGA_ScIndexMapMask_s22194+16Fj
			; idk_VGA_ScIndexMapMask_s22194+191j
			; idk_VGA_ScIndexMapMask_s22194:loc_22381j
			; idk_VGA_ScIndexMapMask_s22194:loc_223C6j
pop	di
dec	[cs:word_22192]	; Decrement by 1
jz	short loc_222A7	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_222A4	; Jump if Sign (SF=1)
mov	ah, 1
inc	di		; Increment by 1

loc_222A4:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+10Bj
jmp	loc_22208	; Jump

loc_222A7:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+104j
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_222AD:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+F1j
add	si, cx		; Add
cmp	dx, 1		; Compare Two Operands
jns	short loc_2225E	; Jump if Not Sign (SF=0)
jmp	short loc_22292	; Jump

loc_222B6:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+B0j
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_22190]

loc_222BF:		; Jump
jmp	short loc_22263

loc_222C1:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+B7j
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction
add	si, bx		; Add
add	si, cx		; Add
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_22190]
jmp	short loc_22284	; Jump

loc_222D5:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+9Cj
and	dx, 7FFFh	; Logical AND
mov	bx, [cs:word_2218C]
xor	ch, ch		; Logical Exclusive OR

loc_222E0:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+16Dj
			; idk_VGA_ScIndexMapMask_s22194+18Fj
cmp	bx, 0		; Compare Two Operands
jz	short loc_22343	; Jump if Zero (ZF=1)

loc_222E5:
mov	cl, [si+1]
sub	bx, cx		; Integer Subtraction
js	short loc_22328	; Jump if Sign (SF=1)

loc_222EC:		; Load String
lodsb
mov	cl, al
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_222F4:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+168j
			; idk_VGA_ScIndexMapMask_s22194+18Aj
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands
jnb	short loc_22311	; Jump if Not Below (CF=0)
dec	bx		; Decrement by 1
js	short loc_22305	; Jump if Sign (SF=1)
loop	loc_222F4	; Loop while CX	!= 0

loc_222FE:		; Compare Two Operands
cmp	dx, 1
jns	short loc_222E0	; Jump if Not Sign (SF=0)
jmp	short loc_22292	; Jump

loc_22305:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+166j
add	cx, bx		; Add
mov	bx, [cs:word_22190]
dec	bx		; Decrement by 1
inc	cx		; Increment by 1
jmp	short loc_22376	; Jump
byte_22310 db 90h

loc_22311:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+163j
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
inc	si		; Increment by 1
sub	bl, al		; Integer Subtraction
sbb	bh, 0		; Integer Subtraction with Borrow
js	short loc_22334	; Jump if Sign (SF=1)
dec	cx		; Decrement by 1
loop	loc_222F4	; Loop while CX	!= 0

loc_22320:		; Compare Two Operands
cmp	dx, 1
jns	short loc_222E0	; Jump if Not Sign (SF=0)
jmp	loc_22292	; Jump

loc_22328:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+156j
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_22190]
jmp	short loc_2234D	; Jump
align 2

loc_22334:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+187j
dec	si		; Decrement by 1
lodsb			; Load String
push	cx
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_22190]
jmp	short loc_2238F	; Jump
db 90h

loc_22343:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+14Fj
mov	bx, [cs:word_22190]

loc_22348:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194:loc_2237Fj
			; idk_VGA_ScIndexMapMask_s22194:loc_2239Fj
			; idk_VGA_ScIndexMapMask_s22194+230j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR

loc_2234D:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+19Dj
sub	bx, cx		; Integer Subtraction
mov	al, cl
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	di, cx		; Add
lodsb			; Load String
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_2236E:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+1E6j
			; idk_VGA_ScIndexMapMask_s22194+206j
dec	bx		; Decrement by 1
js	short loc_223BF	; Jump if Sign (SF=1)
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands
jnb	short loc_22384	; Jump if Not Below (CF=0)

loc_22376:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+17Aj
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_2236E	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_2237F:		; Jump if Not Sign (SF=0)
jns	short loc_22348

loc_22381:		; Jump
jmp	loc_22292

loc_22384:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+1E0j
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
push	cx
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
lodsb			; Load String
inc	bx		; Increment by 1

loc_2238F:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+1ACj
			; idk_VGA_ScIndexMapMask_s22194+202j
dec	bx		; Decrement by 1
js	short loc_223BC	; Jump if Sign (SF=1)
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_2238F	; Loop while CX	!= 0
pop	cx
dec	cx		; Decrement by 1
loop	loc_2236E	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_2239F:		; Jump if Not Sign (SF=0)
jns	short loc_22348
pop	di
dec	[cs:word_22192]	; Decrement by 1
jz	short loc_223B6	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_223B3	; Jump if Sign (SF=1)

loc_223B0:
mov	ah, 1
inc	di		; Increment by 1

loc_223B3:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+21Aj
jmp	loc_22208	; Jump

loc_223B6:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+213j
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_223BC:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+1FCj
pop	cx
dec	cx		; Decrement by 1
dec	cx		; Decrement by 1

loc_223BF:		; CODE XREF: idk_VGA_ScIndexMapMask_s22194+1DBj
add	si, cx		; Add
cmp	dx, 1		; Compare Two Operands
jns	short loc_22348	; Jump if Not Sign (SF=0)

loc_223C6:		; Jump
jmp	loc_22292
endp idk_VGA_ScIndexMapMask_s22194



; Attributes: bp-based frame

proc sub_223C9 far	; CODE XREF: idk_VidLib_s1F743+18EP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds

loc_223D0:
mov	ax, [bp+arg_2]
mov	bx, ax

loc_223D5:		; Shift	Logical	Left
shl	ax, 1
shl	ax, 1		; Shift	Logical	Left

loc_223D9:		; Add
add	ax, bx
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
mov	di, bx
and	ax, 3		; Logical AND
mov	bl, al
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
mov	si, 4376h
add	si, ax		; Add

loc_223FE:		; Load String
lodsb
mov	ah, al
or	ah, bl		; Logical Inclusive OR
mov	bx, [bp+arg_A]

loc_22406:
mov	[cs:word_2218C], bx
mov	bx, [bp+arg_4]
mov	[cs:word_22192], bx
mov	bx, [bp+arg_6]
mov	[cs:word_22190], bx
mov	cx, [bp+arg_8]

loc_2241E:
mov	dx, [bp+arg_E]
mov	si, [bp+arg_C]
mov	ds, dx

loc_22426:		; Compare Two Operands
cmp	cx, 0
jz	short loc_22443	; Jump if Zero (ZF=1)
mov	dx, ax

loc_2242D:		; CODE XREF: sub_223C9+70j
			; sub_223C9+76j
lodsw			; Load String

loc_2242E:		; Compare Two Operands
cmp	al, 0FFh

loc_22430:		; Jump if Zero (ZF=1)
jz	short loc_2243E
xchg	al, ah		; Exchange Register/Memory with	Register

loc_22434:		; Logical AND
and	ax, 7FFFh
add	si, ax		; Add
loop	loc_2242D	; Loop while CX	!= 0
jmp	short loc_22441	; Jump
align 2

loc_2243E:		; CODE XREF: sub_223C9:loc_22430j
dec	si		; Decrement by 1
loop	loc_2242D	; Loop while CX	!= 0

loc_22441:		; CODE XREF: sub_223C9+72j
mov	ax, dx

loc_22443:		; CODE XREF: sub_223C9+60j
			; sub_223C9+154j
push	di
mov	dx, 3CEh
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, ah
shr	al, 1		; Shift	Logical	Right

loc_2244F:		; Shift	Logical	Right
shr	al, 1
shr	al, 1		; Shift	Logical	Right
shr	al, 1		; Shift	Logical	Right
out	dx, al		; EGA port: graphics controller	data register

loc_22456:
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_2245C:		; Increment by 1
inc	dx
mov	al, ah

loc_2245F:		; Logical AND
and	al, 0Fh
out	dx, al		; EGA port: sequencer data register

loc_22462:		; Compare Two Operands
cmp	si, 0FC00h
jb	short loc_22474	; Jump if Below	(CF=1)

loc_22468:
mov	ds, cx

loc_2246A:		; Add
add	cx, 0FC0h
mov	cx, ds

loc_22470:		; Integer Subtraction
sub	si, 0FC00h

loc_22474:		; CODE XREF: sub_223C9+9Dj
mov	dx, 3C5h
mov	al, ah
out	dx, al		; EGA port: sequencer data register
lodsb			; Load String
cmp	al, 0FFh	; Compare Two Operands
jz	short loc_224FC	; Jump if Zero (ZF=1)

loc_2247F:
mov	dh, al
lodsb			; Load String

loc_22482:
mov	dl, al
cmp	dh, 0		; Compare Two Operands
jns	short loc_22498	; Jump if Not Sign (SF=0)

loc_22489:		; Jump
jmp	loc_2256E

loc_2248C:		; CODE XREF: sub_223C9+E0j
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_22190]
jmp	short loc_224C8	; Jump
align 2

loc_22498:		; CODE XREF: sub_223C9+BEj
mov	bx, [cs:word_2218C]

loc_2249D:		; Logical Exclusive OR
xor	ch, ch

loc_2249F:		; CODE XREF: sub_223C9+F0j
cmp	bx, 0		; Compare Two Operands

loc_224A2:		; Jump if Zero (ZF=1)
jz	short loc_224BE
mov	cl, [si+1]
sub	bx, cx		; Integer Subtraction
jbe	short loc_2248C	; Jump if Below	or Equal (CF=1 | ZF=1)
lodsb			; Load String
mov	cl, al

loc_224AE:		; Integer Subtraction
sub	bx, cx

loc_224B0:		; Jump if Below	(CF=1)
jb	short loc_22529
inc	si		; Increment by 1
add	si, cx		; Add
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction
jnz	short loc_2249F	; Jump if Not Zero (ZF=0)
jmp	short loc_224FC	; Jump
align 2

loc_224BE:		; CODE XREF: sub_223C9:loc_224A2j
mov	bx, [cs:word_22190]

loc_224C3:		; CODE XREF: sub_223C9+131j
			; sub_223C9+15Cj
mov	cl, [si+1]

loc_224C6:		; Logical Exclusive OR
xor	ch, ch

loc_224C8:		; CODE XREF: sub_223C9+CCj
sub	bx, cx		; Integer Subtraction
mov	al, cl
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_224D0:		; Add
add	cl, al
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	di, cx		; Add
lodsb			; Load String
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1
dec	dx		; Decrement by 1

loc_224E6:		; Decrement by 1
dec	dx
sub	dx, cx		; Integer Subtraction

loc_224E9:		; CODE XREF: sub_223C9+12Cj
			; sub_223C9:loc_2253Bj
dec	bx		; Decrement by 1
js	short loc_22520	; Jump if Sign (SF=1)
lodsb			; Load String
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_22543	; Jump if Not Below (CF=0)
stosb			; Store	String

loc_224F2:		; CODE XREF: sub_223C9+1A3j
add	di, 4Fh	; 'O'   ; Add
loop	loc_224E9	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_224C3	; Jump if Not Sign (SF=0)

loc_224FC:		; CODE XREF: sub_223C9+B4j
			; sub_223C9+F2j
			; sub_223C9+15Ej
			; sub_223C9+1D3j
			; sub_223C9+1F6j
			; sub_223C9+256j
			; sub_223C9+27Aj
			; sub_223C9+289j
pop	di
dec	[cs:word_22192]	; Decrement by 1
jz	short loc_2253D	; Jump if Zero (ZF=1)
mov	cl, ah
and	cl, 0F0h	; Logical AND
add	cl, 10h		; Add

loc_2250C:		; Logical AND
and	ah, 0Fh
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_2251B	; Jump if Sign (SF=1)
mov	cl, 0
mov	ah, 1
inc	di		; Increment by 1

loc_2251B:		; CODE XREF: sub_223C9+14Bj
or	ah, cl		; Logical Inclusive OR
jmp	loc_22443	; Jump

loc_22520:		; CODE XREF: sub_223C9+121j
add	si, cx		; Add
cmp	dx, 1		; Compare Two Operands
jns	short loc_224C3	; Jump if Not Sign (SF=0)
jmp	short loc_224FC	; Jump

loc_22529:		; CODE XREF: sub_223C9:loc_224B0j
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction
add	si, bx		; Add
add	si, cx		; Add
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_22190]

loc_2253B:		; Jump
jmp	short loc_224E9

loc_2253D:		; CODE XREF: sub_223C9+139j
pop	ds
pop	es
pop	di

loc_22540:
pop	si
pop	bp
retf			; Return Far from Procedure

loc_22543:		; CODE XREF: sub_223C9+126j
sub	al, 0E8h ; ''  ; Integer Subtraction

loc_22545:
push	si
push	ds
mov	si, seg	dseg

loc_2254A:
mov	ds, si

loc_2254C:
mov	si, ax

loc_2254E:		; Logical AND
and	si, 0FFh
shl	si, 1		; Shift	Logical	Left

loc_22554:		; Shift	Logical	Left
shl	si, 1
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left

loc_2255A:		; Add
add	si, [idk_FontsLbx1_6144B]
mov	ds, si
mov	al, [es:di]
mov	si, ax

loc_22565:		; Logical AND
and	si, 0FFh
movsb			; Move Byte(s) from String to String
pop	ds
pop	si
jmp	short loc_224F2	; Jump

loc_2256E:		; CODE XREF: sub_223C9:loc_22489j
and	dx, 7FFFh	; Logical AND
mov	bx, [cs:word_2218C]
xor	ch, ch		; Logical Exclusive OR

loc_22579:		; CODE XREF: sub_223C9+1D1j
			; sub_223C9:loc_225BDj
cmp	bx, 0		; Compare Two Operands
jz	short loc_225DD	; Jump if Zero (ZF=1)
mov	cl, [si+1]
sub	bx, cx		; Integer Subtraction
js	short loc_225C2	; Jump if Sign (SF=1)
lodsb			; Load String
mov	cl, al
inc	si		; Increment by 1
dec	dx		; Decrement by 1

loc_2258A:		; Decrement by 1
dec	dx

loc_2258B:		; Integer Subtraction
sub	dx, cx

loc_2258D:		; CODE XREF: sub_223C9:loc_22595j
			; sub_223C9+1EFj
lodsb			; Load String

loc_2258E:		; Compare Two Operands
cmp	al, 0E0h ; ''

loc_22590:		; Jump if Not Below (CF=0)
jnb	short loc_225AB
dec	bx		; Decrement by 1
js	short loc_2259F	; Jump if Sign (SF=1)

loc_22595:		; Loop while CX	!= 0
loop	loc_2258D
cmp	dx, 1		; Compare Two Operands
jns	short loc_22579	; Jump if Not Sign (SF=0)
jmp	loc_224FC	; Jump

loc_2259F:		; CODE XREF: sub_223C9+1CAj
add	cx, bx		; Add
mov	bx, [cs:word_22190]
dec	bx		; Decrement by 1
inc	cx		; Increment by 1
jmp	short loc_22610	; Jump
db 90h

loc_225AB:		; CODE XREF: sub_223C9:loc_22590j
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
inc	si		; Increment by 1

loc_225B0:		; Integer Subtraction
sub	bl, al

loc_225B2:		; Integer Subtraction with Borrow
sbb	bh, 0

loc_225B5:		; Jump if Sign (SF=1)
js	short loc_225CE
dec	cx		; Decrement by 1
loop	loc_2258D	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_225BD:		; Jump if Not Sign (SF=0)
jns	short loc_22579
jmp	loc_224FC	; Jump

loc_225C2:		; CODE XREF: sub_223C9+1BAj
neg	bx		; Two's Complement Negation
mov	cx, bx

loc_225C6:
mov	bx, [cs:word_22190]
jmp	short loc_225E7	; Jump
align 2

loc_225CE:		; CODE XREF: sub_223C9:loc_225B5j
dec	si		; Decrement by 1
lodsb			; Load String

loc_225D0:
push	cx
neg	bx		; Two's Complement Negation
mov	cx, bx

loc_225D5:
mov	bx, [cs:word_22190]
jmp	short loc_2262D	; Jump
db 90h

loc_225DD:		; CODE XREF: sub_223C9+1B3j
mov	bx, [cs:word_22190]

loc_225E2:		; CODE XREF: sub_223C9+254j
			; sub_223C9+278j
			; sub_223C9+287j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR

loc_225E7:		; CODE XREF: sub_223C9+202j
sub	bx, cx		; Integer Subtraction
mov	al, cl

loc_225EB:		; Shift	Logical	Left
shl	cx, 1

loc_225ED:		; Shift	Logical	Left
shl	cx, 1
add	cl, al		; Add
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_225FC:		; Add
add	di, cx
lodsb			; Load String
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1

loc_22606:		; Integer Subtraction
sub	dx, cx

loc_22608:		; CODE XREF: sub_223C9+24Fj
			; sub_223C9+273j
dec	bx		; Decrement by 1
js	short loc_2264B	; Jump if Sign (SF=1)
lodsb			; Load String

loc_2260C:		; Compare Two Operands
cmp	al, 0E0h ; ''
jnb	short loc_22622	; Jump if Not Below (CF=0)

loc_22610:		; CODE XREF: sub_223C9+1DFj
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_22655	; Jump if Not Below (CF=0)
stosb			; Store	String

loc_22615:		; CODE XREF: sub_223C9:loc_2267Ej
add	di, 4Fh	; 'O'   ; Add
loop	loc_22608	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_225E2	; Jump if Not Sign (SF=0)
jmp	loc_224FC	; Jump

loc_22622:		; CODE XREF: sub_223C9+245j
and	al, 1Fh		; Logical AND

loc_22624:		; Increment by 1
inc	al
push	cx

loc_22627:
mov	cl, al

loc_22629:		; Logical Exclusive OR
xor	ch, ch
lodsb			; Load String
inc	bx		; Increment by 1

loc_2262D:		; CODE XREF: sub_223C9+211j
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_22680	; Jump if Not Below (CF=0)

loc_22631:		; CODE XREF: sub_223C9:loc_22638j
dec	bx		; Decrement by 1
js	short loc_22648	; Jump if Sign (SF=1)

loc_22634:		; Store	String
stosb
add	di, 4Fh	; 'O'   ; Add

loc_22638:		; Loop while CX	!= 0
loop	loc_22631

loc_2263A:		; CODE XREF: sub_223C9:loc_226B1j
pop	cx
dec	cx		; Decrement by 1
loop	loc_22608	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_225E2	; Jump if Not Sign (SF=0)
jmp	loc_224FC	; Jump

loc_22646:		; CODE XREF: sub_223C9:loc_2269Ej
pop	ds
pop	si

loc_22648:		; CODE XREF: sub_223C9+269j
pop	cx
dec	cx		; Decrement by 1

loc_2264A:		; Decrement by 1
dec	cx

loc_2264B:		; CODE XREF: sub_223C9+240j
add	si, cx		; Add
cmp	dx, 1		; Compare Two Operands
jns	short loc_225E2	; Jump if Not Sign (SF=0)
jmp	loc_224FC	; Jump

loc_22655:		; CODE XREF: sub_223C9+249j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds

loc_22659:
mov	si, seg	dseg
mov	ds, si

loc_2265E:
mov	si, ax

loc_22660:		; Logical AND
and	si, 0FFh
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left

loc_2266A:		; Shift	Logical	Left
shl	si, 1
add	si, [idk_FontsLbx1_6144B] ; Add
mov	ds, si

loc_22672:
mov	al, [es:di]
mov	si, ax
and	si, 0FFh	; Logical AND
movsb			; Move Byte(s) from String to String

loc_2267C:
pop	ds

loc_2267D:
pop	si

loc_2267E:		; Jump
jmp	short loc_22615

loc_22680:		; CODE XREF: sub_223C9+266j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds
mov	si, seg	dseg
mov	ds, si
mov	si, ax

loc_2268B:		; Logical AND
and	si, 0FFh
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left

loc_22693:		; Shift	Logical	Left
shl	si, 1

loc_22695:		; Shift	Logical	Left
shl	si, 1

loc_22697:		; Add
add	si, [idk_FontsLbx1_6144B]

loc_2269B:
mov	ds, si

loc_2269D:		; CODE XREF: sub_223C9:loc_226ADj
dec	bx		; Decrement by 1

loc_2269E:		; Jump if Sign (SF=1)
js	short loc_22646

loc_226A0:
mov	al, [es:di]

loc_226A3:
mov	si, ax

loc_226A5:		; Logical AND
and	si, 0FFh

loc_226A9:		; Move Byte(s) from String to String
movsb

loc_226AA:		; Add
add	di, 4Fh	; 'O'

loc_226AD:		; Loop while CX	!= 0
loop	loc_2269D

loc_226AF:
pop	ds

loc_226B0:
pop	si

loc_226B1:		; Jump
jmp	short loc_2263A
endp sub_223C9

ends seg029


; Segment type:	Pure code
segment	seg030 byte public 'CODE' use16
assume cs:seg030
;org 4
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
word_226B4 dw 0		; DATA XREF: sub_226C2+F7w
			; sub_226C2:loc_22824r
			; sub_226C2:loc_228CAr
			; sub_229E6+46w
			; sub_229E6:loc_22ABCr
			; sub_229E6:loc_22B96r
algn_226B6:
align 4
word_226B8 dw 0		; DATA XREF: sub_226C2:loc_227C9w
			; sub_226C2:loc_2284Ar
			; sub_226C2+1E9r
			; sub_226C2+1FDr
			; sub_226C2:loc_228F8r
			; sub_226C2:loc_2291Dr
			; sub_226C2:loc_2292Cr
			; sub_226C2:loc_22934r
			; sub_229E6+56w
			; sub_229E6+CEr
			; sub_229E6:loc_22AE2r
			; sub_229E6+174r
			; sub_229E6+1DFr
			; sub_229E6:loc_22BEAr
			; sub_229E6+213r
			; sub_229E6:loc_22C01r
word_226BA dw 0		; DATA XREF: sub_226C2+FFw
			; sub_226C2:loc_22884w
			; sub_226C2+2D1w
			; sub_229E6:loc_22A34w
			; sub_229E6+13Bw
word_226BC dw 0		; DATA XREF: sub_226C2:loc_22737w
			; sub_229BA+3r
			; sub_229BA+Bw
			; sub_229BA:loc_229DDw
word_226BE dw 0		; DATA XREF: sub_226C2:loc_22751w
			; sub_229BA+10r
word_226C0 dw 0		; DATA XREF: sub_226C2:loc_226D3w


; Attributes: bp-based frame

proc sub_226C2 far	; CODE XREF: idk_VidLib_s1F743+1ACP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp

loc_226C3:
mov	bp, sp

loc_226C5:
push	si

loc_226C6:
push	di

loc_226C7:
push	es

loc_226C8:
push	ds

loc_226C9:
mov	ax, [bp+arg_C]

loc_226CC:
mov	ds, ax

loc_226CE:
mov	es, ax

loc_226D0:
mov	ax, [LibMalloc_w31D10]

loc_226D3:
mov	[cs:word_226C0], ax

loc_226D7:
mov	si, 0Ah
lodsb			; Load String

loc_226DB:		; Logical Exclusive OR
xor	ah, ah

loc_226DD:
mov	dx, ax

loc_226DF:		; Load String
lodsb

loc_226E0:		; Logical Exclusive OR
xor	ah, ah

loc_226E2:
mov	bx, ax
lodsw			; Load String
mov	si, ax

loc_226E7:
mov	di, si
push	dx

loc_226EA:
push	bx

loc_226EB:		; Call Procedure
call	sub_163FC

loc_226F0:		; Add
add	sp, 4

loc_226F3:
mov	ax, seg	dseg

loc_226F6:
mov	ds, ax

loc_226F8:
mov	ax, [bp+arg_E]

loc_226FB:		; Shift	Logical	Left
shl	ax, 1

loc_226FD:		; Shift	Logical	Left
shl	ax, 1

loc_226FF:		; Add
add	si, ax

loc_22701:		; Add
add	si, 12h

loc_22704:
mov	ax, [EMM_PageFrameSegmentAddress]

loc_22707:
mov	ds, ax
lodsw			; Load String
mov	dx, ax

loc_2270C:		; Load String
lodsw
inc	dx		; Increment by 1

loc_2270E:		; Add with Carry
adc	ax, 0

loc_22711:		; Shift	Logical	Left
shl	dx, 1

loc_22713:		; Rotate Through Carry Left
rcl	ax, 1

loc_22715:		; Shift	Logical	Left
shl	dx, 1

loc_22717:		; Rotate Through Carry Left
rcl	ax, 1

loc_22719:		; Shift	Logical	Right
shr	dx, 1

loc_2271B:		; Shift	Logical	Right
shr	dx, 1

loc_2271D:		; Add
add	al, [es:0Bh]

loc_22722:		; Add with Carry
adc	ah, 0

loc_22725:		; Add
add	dx, [es:0Ch]

loc_2272A:		; Compare Two Operands
cmp	dx, 0C000h

loc_2272E:		; Jump if Below	(CF=1)
jb	short loc_22737

loc_22730:		; Logical AND
and	dx, 3FFFh
inc	ax		; Increment by 1
inc	ax		; Increment by 1
inc	ax		; Increment by 1

loc_22737:		; CODE XREF: sub_226C2:loc_2272Ej
mov	[cs:word_226BC], ax

loc_2273B:
mov	bx, 11h

loc_2273E:		; Add
add	bx, di

loc_22740:
mov	bl, [bx]

loc_22742:		; Logical Exclusive OR
xor	bh, bh
mov	di, bx

loc_22746:
mov	si, dx

loc_22748:
mov	bx, ax

loc_2274A:
mov	dx, [es:0Ah]

loc_2274F:		; Logical Exclusive OR
xor	dh, dh

loc_22751:
mov	[cs:word_226BE], dx
push	dx
push	bx

loc_22758:		; Call Procedure
call	sub_163FC

loc_2275D:		; Add
add	sp, 4
cmp	di, 0		; Compare Two Operands

loc_22763:		; Jump if Zero (ZF=1)
jz	short loc_22785

loc_22765:
push	[bp+arg_A]

loc_22768:
push	[bp+arg_8]

loc_2276B:
push	[bp+arg_6]

loc_2276E:
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]

loc_22777:
push	cs

loc_22778:		; Call Procedure
call	near ptr sub_229E6
nop			; No Operation

loc_2277C:		; Add
add	sp, 0Ch
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_22785:		; CODE XREF: sub_226C2:loc_22763j
mov	ax, seg	dseg
mov	ds, ax
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_22790:
mov	ax, [bp+arg_2]

loc_22793:
mov	bx, ax

loc_22795:		; Shift	Logical	Left
shl	ax, 1

loc_22797:		; Shift	Logical	Left
shl	ax, 1
add	ax, bx		; Add

loc_2279B:		; Add
add	ax, [g_ptrVideoRamBuffer]

loc_2279F:
mov	es, ax

loc_227A1:
mov	ax, [bp+arg_0]
mov	bx, ax

loc_227A6:		; Shift	Logical	Right
shr	bx, 1

loc_227A8:		; Shift	Logical	Right
shr	bx, 1

loc_227AA:
mov	di, bx

loc_227AC:		; Logical AND
and	ax, 3

loc_227AF:
mov	bx, 437Ah
add	bx, ax		; Add
mov	ah, [bx]
mov	bx, [bp+arg_A]
mov	[cs:word_226B4], bx
mov	bx, [bp+arg_4]
mov	[cs:word_226BA], bx
mov	bx, [bp+arg_6]

loc_227C9:
mov	[cs:word_226B8], bx
mov	cx, [bp+arg_8]
mov	bx, [EMM_PageFrameSegmentAddress]

loc_227D5:
mov	ds, bx

loc_227D7:		; Compare Two Operands
cmp	cx, 0
jz	short loc_22802	; Jump if Zero (ZF=1)
mov	dx, ax

loc_227DE:		; CODE XREF: sub_226C2:loc_227F0j
			; sub_226C2+136j
lodsw			; Load String
cmp	al, 0FFh	; Compare Two Operands
jz	short loc_227FD	; Jump if Zero (ZF=1)
xchg	al, ah		; Exchange Register/Memory with	Register
and	ax, 7FFFh	; Logical AND
add	si, ax		; Add

loc_227EA:		; CODE XREF: sub_226C2+13Cj
cmp	si, 0C000h	; Compare Two Operands

loc_227EE:		; Jump if Not Below (CF=0)
jnb	short loc_227F5

loc_227F0:		; Loop while CX	!= 0
loop	loc_227DE
jmp	short loc_22800	; Jump
db 90h

loc_227F5:		; CODE XREF: sub_226C2:loc_227EEj
call	sub_229BA	; Call Procedure
loop	loc_227DE	; Loop while CX	!= 0
jmp	short loc_22800	; Jump
byte_227FC db 90h

loc_227FD:		; CODE XREF: sub_226C2+11Fj
dec	si		; Decrement by 1
jmp	short loc_227EA	; Jump

loc_22800:		; CODE XREF: sub_226C2+130j
			; sub_226C2+138j
mov	ax, dx

loc_22802:		; CODE XREF: sub_226C2+118j
			; sub_226C2:loc_22895j
			; sub_226C2:loc_229A4j
push	di
cmp	si, 0C000h	; Compare Two Operands

loc_22807:		; Jump if Below	(CF=1)
jb	short loc_2280C
call	sub_229BA	; Call Procedure

loc_2280C:		; CODE XREF: sub_226C2:loc_22807j
mov	dx, 3C5h

loc_2280F:
mov	al, ah
out	dx, al		; EGA port: sequencer data register
lodsb			; Load String
cmp	al, 0FFh	; Compare Two Operands

loc_22815:		; Jump if Zero (ZF=1)
jz	short loc_22883
mov	dh, al
lodsb			; Load String
mov	dl, al
cmp	dh, 0		; Compare Two Operands
jns	short loc_22824	; Jump if Not Sign (SF=0)
jmp	loc_228C6	; Jump

loc_22824:		; CODE XREF: sub_226C2+15Dj
mov	bx, [cs:word_226B4]

loc_22829:		; Logical Exclusive OR
xor	ch, ch

loc_2282B:		; CODE XREF: sub_226C2+183j
cmp	bx, 0		; Compare Two Operands
jz	short loc_2284A	; Jump if Zero (ZF=1)

loc_22830:
mov	cl, [si+1]
sub	bx, cx		; Integer Subtraction

loc_22835:		; Jump if Below	or Equal (CF=1 | ZF=1)
jbe	short loc_228A7
lodsb			; Load String
mov	cl, al
sub	bx, cx		; Integer Subtraction

loc_2283C:		; Jump if Below	(CF=1)
jb	short loc_228B2
inc	si		; Increment by 1
add	si, cx		; Add
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1

loc_22843:		; Integer Subtraction
sub	dx, cx
jnz	short loc_2282B	; Jump if Not Zero (ZF=0)
jmp	short loc_22883	; Jump
align 2

loc_2284A:		; CODE XREF: sub_226C2+16Cj
mov	bx, [cs:word_226B8]

loc_2284F:		; CODE XREF: sub_226C2:loc_22881j
			; sub_226C2:loc_228A3j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR

loc_22854:		; CODE XREF: sub_226C2:loc_228B0j
sub	bx, cx		; Integer Subtraction
mov	al, cl
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add
adc	ch, 0		; Add with Carry

loc_22861:		; Shift	Logical	Left
shl	cx, 1

loc_22863:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	di, cx		; Add
lodsb			; Load String
mov	cl, al

loc_2286E:		; Logical Exclusive OR
xor	ch, ch
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_22875:		; CODE XREF: sub_226C2:loc_2287Cj
			; sub_226C2+202j
dec	bx		; Decrement by 1
js	short loc_2289E	; Jump if Sign (SF=1)
movsb			; Move Byte(s) from String to String

loc_22879:		; Add
add	di, 4Fh	; 'O'

loc_2287C:		; Loop while CX	!= 0
loop	loc_22875

loc_2287E:		; Compare Two Operands
cmp	dx, 1

loc_22881:		; Jump if Not Sign (SF=0)
jns	short loc_2284F

loc_22883:		; CODE XREF: sub_226C2:loc_22815j
			; sub_226C2+185j
			; sub_226C2+1E3j
			; sub_226C2+232j
			; sub_226C2:loc_22916j
			; sub_226C2+2B0j
			; sub_226C2+2F5j
pop	di

loc_22884:		; Decrement by 1
dec	[cs:word_226BA]
jz	short loc_22898	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_22895	; Jump if Sign (SF=1)
mov	ah, 1
inc	di		; Increment by 1

loc_22895:		; CODE XREF: sub_226C2+1CEj
jmp	loc_22802	; Jump

loc_22898:		; CODE XREF: sub_226C2+1C7j
pop	ds
pop	es
pop	di
pop	si

loc_2289C:
pop	bp
retf			; Return Far from Procedure

loc_2289E:		; CODE XREF: sub_226C2+1B4j
add	si, cx		; Add
cmp	dx, 1		; Compare Two Operands

loc_228A3:		; Jump if Not Sign (SF=0)
jns	short loc_2284F
jmp	short loc_22883	; Jump

loc_228A7:		; CODE XREF: sub_226C2:loc_22835j
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_226B8]

loc_228B0:		; Jump
jmp	short loc_22854

loc_228B2:		; CODE XREF: sub_226C2:loc_2283Cj
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction
add	si, bx		; Add
add	si, cx		; Add
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_226B8]
jmp	short loc_22875	; Jump

loc_228C6:		; CODE XREF: sub_226C2+15Fj
and	dx, 7FFFh	; Logical AND

loc_228CA:
mov	bx, [cs:word_226B4]

loc_228CF:		; Logical Exclusive OR
xor	ch, ch

loc_228D1:		; CODE XREF: sub_226C2:loc_228F2j
			; sub_226C2+252j
cmp	bx, 0		; Compare Two Operands
jz	short loc_22934	; Jump if Zero (ZF=1)
mov	cl, [si+1]
sub	bx, cx		; Integer Subtraction
js	short loc_22919	; Jump if Sign (SF=1)
lodsb			; Load String
mov	cl, al
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_228E5:		; CODE XREF: sub_226C2+22Bj
			; sub_226C2+24Dj
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands

loc_228E8:		; Jump if Not Below (CF=0)
jnb	short loc_22902
dec	bx		; Decrement by 1
js	short loc_228F6	; Jump if Sign (SF=1)
loop	loc_228E5	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_228F2:		; Jump if Not Sign (SF=0)
jns	short loc_228D1
jmp	short loc_22883	; Jump

loc_228F6:		; CODE XREF: sub_226C2+229j
add	cx, bx		; Add

loc_228F8:
mov	bx, [cs:word_226B8]
dec	bx		; Decrement by 1
inc	cx		; Increment by 1
jmp	short loc_22967	; Jump
align 2

loc_22902:		; CODE XREF: sub_226C2:loc_228E8j
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
inc	si		; Increment by 1
sub	bl, al		; Integer Subtraction
sbb	bh, 0		; Integer Subtraction with Borrow
js	short loc_22925	; Jump if Sign (SF=1)
dec	cx		; Decrement by 1
loop	loc_228E5	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_228D1	; Jump if Not Sign (SF=0)

loc_22916:		; Jump
jmp	loc_22883

loc_22919:		; CODE XREF: sub_226C2+219j
neg	bx		; Two's Complement Negation
mov	cx, bx

loc_2291D:
mov	bx, [cs:word_226B8]
jmp	short loc_2293E	; Jump
byte_22924 db 90h

loc_22925:		; CODE XREF: sub_226C2+24Aj
dec	si		; Decrement by 1
lodsb			; Load String
push	cx
neg	bx		; Two's Complement Negation
mov	cx, bx

loc_2292C:
mov	bx, [cs:word_226B8]
jmp	short loc_22980	; Jump
align 2

loc_22934:		; CODE XREF: sub_226C2+212j
mov	bx, [cs:word_226B8]

loc_22939:		; CODE XREF: sub_226C2:loc_22970j
			; sub_226C2+2CEj
			; sub_226C2+2F3j
mov	cl, [si+1]

loc_2293C:		; Logical Exclusive OR
xor	ch, ch

loc_2293E:		; CODE XREF: sub_226C2+260j
sub	bx, cx		; Integer Subtraction
mov	al, cl
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add
adc	ch, 0		; Add with Carry
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_2294F:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
add	di, cx		; Add
lodsb			; Load String
mov	cl, al
xor	ch, ch		; Logical Exclusive OR

loc_2295A:		; Increment by 1
inc	si
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_2295F:		; CODE XREF: sub_226C2:loc_2296Bj
			; sub_226C2+2C9j
dec	bx		; Decrement by 1
js	short loc_229B0	; Jump if Sign (SF=1)
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands
jnb	short loc_22975	; Jump if Not Below (CF=0)

loc_22967:		; CODE XREF: sub_226C2+23Dj
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add

loc_2296B:		; Loop while CX	!= 0
loop	loc_2295F

loc_2296D:		; Compare Two Operands
cmp	dx, 1

loc_22970:		; Jump if Not Sign (SF=0)
jns	short loc_22939
jmp	loc_22883	; Jump

loc_22975:		; CODE XREF: sub_226C2+2A3j
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
push	cx
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
lodsb			; Load String
inc	bx		; Increment by 1

loc_22980:		; CODE XREF: sub_226C2+26Fj
			; sub_226C2+2C5j
dec	bx		; Decrement by 1
js	short loc_229AD	; Jump if Sign (SF=1)
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_22980	; Loop while CX	!= 0
pop	cx
dec	cx		; Decrement by 1
loop	loc_2295F	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_22939	; Jump if Not Sign (SF=0)
pop	di
dec	[cs:word_226BA]	; Decrement by 1
jz	short loc_229A7	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_229A4	; Jump if Sign (SF=1)
mov	ah, 1
inc	di		; Increment by 1

loc_229A4:		; CODE XREF: sub_226C2+2DDj
jmp	loc_22802	; Jump

loc_229A7:		; CODE XREF: sub_226C2+2D6j
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_229AD:		; CODE XREF: sub_226C2+2BFj
pop	cx
dec	cx		; Decrement by 1
dec	cx		; Decrement by 1

loc_229B0:		; CODE XREF: sub_226C2+29Ej
add	si, cx		; Add

loc_229B2:		; Compare Two Operands
cmp	dx, 1
jns	short loc_22939	; Jump if Not Sign (SF=0)
jmp	loc_22883	; Jump
endp sub_226C2




proc sub_229BA near	; CODE XREF: sub_226C2:loc_227F5p
			; sub_226C2+147p
push	bx
push	ax
push	dx
mov	bx, [cs:word_226BC]
inc	bx		; Increment by 1
inc	bx		; Increment by 1
inc	bx		; Increment by 1
mov	[cs:word_226BC], bx
mov	dx, [cs:word_226BE]
push	dx
push	bx
call	sub_163FC	; Call Procedure
add	sp, 4		; Add
sub	si, 0C000h	; Integer Subtraction

loc_229DD:		; Increment by 1
inc	[cs:word_226BC]
pop	dx
pop	ax
pop	bx
retn			; Return Near from Procedure
endp sub_229BA



; Attributes: bp-based frame

proc sub_229E6 far	; CODE XREF: sub_226C2:loc_22778p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg

loc_229F0:
mov	ds, ax
mov	ax, [bp+arg_2]
mov	bx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
mov	di, bx

loc_22A0E:		; Logical AND
and	ax, 3
mov	bl, al
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
mov	cx, si
mov	si, 437Ah
add	si, ax		; Add
lodsb			; Load String
mov	ah, al
or	ah, bl		; Logical Inclusive OR
mov	si, cx
mov	bx, [bp+arg_A]
mov	[cs:word_226B4], bx
mov	bx, [bp+arg_4]

loc_22A34:
mov	[cs:word_226BA], bx
mov	bx, [bp+arg_6]
mov	[cs:word_226B8], bx
mov	cx, [bp+arg_8]
mov	bx, [EMM_PageFrameSegmentAddress]
mov	ds, bx
cmp	cx, 0		; Compare Two Operands
jz	short loc_22A67	; Jump if Zero (ZF=1)
mov	dx, ax

loc_22A51:		; CODE XREF: sub_229E6+77j
			; sub_229E6+7Dj
lodsw			; Load String
cmp	al, 0FFh	; Compare Two Operands
jz	short loc_22A62	; Jump if Zero (ZF=1)
xchg	al, ah		; Exchange Register/Memory with	Register
and	ax, 7FFFh	; Logical AND

loc_22A5B:		; Add
add	si, ax
loop	loc_22A51	; Loop while CX	!= 0
jmp	short loc_22A65	; Jump
align 2

loc_22A62:		; CODE XREF: sub_229E6+6Ej
dec	si		; Decrement by 1
loop	loc_22A51	; Loop while CX	!= 0

loc_22A65:		; CODE XREF: sub_229E6+79j
mov	ax, dx

loc_22A67:		; CODE XREF: sub_229E6+67j
			; sub_229E6:loc_22B41j
push	di
mov	dx, 3CEh
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_22A6F:
mov	al, ah
shr	al, 1		; Shift	Logical	Right

loc_22A73:		; Shift	Logical	Right
shr	al, 1

loc_22A75:		; Shift	Logical	Right
shr	al, 1
shr	al, 1		; Shift	Logical	Right
out	dx, al		; EGA port: graphics controller	data register
mov	dx, 3C4h

loc_22A7D:
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_22A80:		; Increment by 1
inc	dx

loc_22A81:
mov	al, ah
and	al, 0Fh		; Logical AND
out	dx, al		; EGA port: sequencer data register
cmp	si, 0FC00h	; Compare Two Operands

loc_22A8A:		; Jump if Below	(CF=1)
jb	short loc_22A98
mov	ds, cx
add	cx, 0FC0h	; Add
mov	cx, ds
sub	si, 0FC00h	; Integer Subtraction

loc_22A98:		; CODE XREF: sub_229E6:loc_22A8Aj
mov	dx, 3C5h
mov	al, ah
out	dx, al		; EGA port: sequencer data register
lodsb			; Load String
cmp	al, 0FFh	; Compare Two Operands

loc_22AA1:		; Jump if Zero (ZF=1)
jz	short loc_22B20
mov	dh, al
lodsb			; Load String
mov	dl, al
cmp	dh, 0		; Compare Two Operands
jns	short loc_22ABC	; Jump if Not Sign (SF=0)
jmp	loc_22B92	; Jump

loc_22AB0:		; CODE XREF: sub_229E6+E7j
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_226B8]
jmp	short loc_22AEC	; Jump
align 2

loc_22ABC:		; CODE XREF: sub_229E6+C5j
mov	bx, [cs:word_226B4]
xor	ch, ch		; Logical Exclusive OR

loc_22AC3:		; CODE XREF: sub_229E6+F7j
cmp	bx, 0		; Compare Two Operands
jz	short loc_22AE2	; Jump if Zero (ZF=1)
mov	cl, [si+1]
sub	bx, cx		; Integer Subtraction
jbe	short loc_22AB0	; Jump if Below	or Equal (CF=1 | ZF=1)
lodsb			; Load String
mov	cl, al
sub	bx, cx		; Integer Subtraction
jb	short loc_22B4D	; Jump if Below	(CF=1)
inc	si		; Increment by 1
add	si, cx		; Add
dec	dx		; Decrement by 1

loc_22ADA:		; Decrement by 1
dec	dx
sub	dx, cx		; Integer Subtraction
jnz	short loc_22AC3	; Jump if Not Zero (ZF=0)

loc_22ADF:		; Jump
jmp	short loc_22B20
align 2

loc_22AE2:		; CODE XREF: sub_229E6+E0j
mov	bx, [cs:word_226B8]

loc_22AE7:		; CODE XREF: sub_229E6:loc_22B1Ej
			; sub_229E6+163j
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR

loc_22AEC:		; CODE XREF: sub_229E6+D3j
sub	bx, cx		; Integer Subtraction

loc_22AEE:
mov	al, cl

loc_22AF0:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
add	cl, al		; Add

loc_22AF6:		; Add with Carry
adc	ch, 0
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_22AFD:		; Shift	Logical	Left
shl	cx, 1

loc_22AFF:		; Shift	Logical	Left
shl	cx, 1
add	di, cx		; Add
lodsb			; Load String
mov	cl, al

loc_22B06:		; Logical Exclusive OR
xor	ch, ch
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_22B0D:		; CODE XREF: sub_229E6+133j
			; sub_229E6+179j
dec	bx		; Decrement by 1
js	short loc_22B44	; Jump if Sign (SF=1)
lodsb			; Load String
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_22B67	; Jump if Not Below (CF=0)
stosb			; Store	String

loc_22B16:		; CODE XREF: sub_229E6+1AAj
add	di, 4Fh	; 'O'   ; Add
loop	loc_22B0D	; Loop while CX	!= 0

loc_22B1B:		; Compare Two Operands
cmp	dx, 1

loc_22B1E:		; Jump if Not Sign (SF=0)
jns	short loc_22AE7

loc_22B20:		; CODE XREF: sub_229E6:loc_22AA1j
			; sub_229E6:loc_22ADFj
			; sub_229E6+165j
			; sub_229E6+1DAj
			; sub_229E6+1FDj
			; sub_229E6:loc_22C43j
			; sub_229E6+281j
			; sub_229E6+290j
pop	di
dec	[cs:word_226BA]	; Decrement by 1

loc_22B26:		; Jump if Zero (ZF=1)
jz	short loc_22B61
mov	cl, ah
and	cl, 0F0h	; Logical AND
add	cl, 10h		; Add
and	ah, 0Fh		; Logical AND

loc_22B33:		; Shift	Logical	Left
shl	ah, 1
cmp	ah, 9		; Compare Two Operands

loc_22B38:		; Jump if Sign (SF=1)
js	short loc_22B3F
mov	cl, 0
mov	ah, 1
inc	di		; Increment by 1

loc_22B3F:		; CODE XREF: sub_229E6:loc_22B38j
or	ah, cl		; Logical Inclusive OR

loc_22B41:		; Jump
jmp	loc_22A67

loc_22B44:		; CODE XREF: sub_229E6+128j
add	si, cx		; Add
cmp	dx, 1		; Compare Two Operands
jns	short loc_22AE7	; Jump if Not Sign (SF=0)
jmp	short loc_22B20	; Jump

loc_22B4D:		; CODE XREF: sub_229E6+EEj
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_22B52:		; Add
add	si, bx
add	si, cx		; Add
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_226B8]
jmp	short loc_22B0D	; Jump

loc_22B61:		; CODE XREF: sub_229E6:loc_22B26j
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_22B67:		; CODE XREF: sub_229E6+12Dj
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si

loc_22B6A:
push	ds

loc_22B6B:
mov	si, seg	dseg
mov	ds, si

loc_22B70:
mov	si, ax

loc_22B72:		; Logical AND
and	si, 0FFh
shl	si, 1		; Shift	Logical	Left

loc_22B78:		; Shift	Logical	Left
shl	si, 1
shl	si, 1		; Shift	Logical	Left

loc_22B7C:		; Shift	Logical	Left
shl	si, 1

loc_22B7E:		; Add
add	si, [idk_FontsLbx1_6144B]
mov	ds, si
mov	al, [es:di]
mov	si, ax
and	si, 0FFh	; Logical AND
movsb			; Move Byte(s) from String to String
pop	ds

loc_22B8F:
pop	si
jmp	short loc_22B16	; Jump

loc_22B92:		; CODE XREF: sub_229E6+C7j
and	dx, 7FFFh	; Logical AND

loc_22B96:
mov	bx, [cs:word_226B4]
xor	ch, ch		; Logical Exclusive OR

loc_22B9D:		; CODE XREF: sub_229E6+1D8j
			; sub_229E6+1FBj
cmp	bx, 0		; Compare Two Operands

loc_22BA0:		; Jump if Zero (ZF=1)
jz	short loc_22C01
mov	cl, [si+1]
sub	bx, cx		; Integer Subtraction
js	short loc_22BE6	; Jump if Sign (SF=1)
lodsb			; Load String
mov	cl, al
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_22BB1:		; CODE XREF: sub_229E6+1D3j
			; sub_229E6+1F6j
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands
jnb	short loc_22BCF	; Jump if Not Below (CF=0)
dec	bx		; Decrement by 1
js	short loc_22BC3	; Jump if Sign (SF=1)
loop	loc_22BB1	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_22B9D	; Jump if Not Sign (SF=0)
jmp	loc_22B20	; Jump

loc_22BC3:		; CODE XREF: sub_229E6+1D1j
add	cx, bx		; Add
mov	bx, [cs:word_226B8]

loc_22BCA:		; Decrement by 1
dec	bx
inc	cx		; Increment by 1
jmp	short loc_22C34	; Jump
db 90h

loc_22BCF:		; CODE XREF: sub_229E6+1CEj
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
inc	si		; Increment by 1
sub	bl, al		; Integer Subtraction
sbb	bh, 0		; Integer Subtraction with Borrow

loc_22BD9:		; Jump if Sign (SF=1)
js	short loc_22BF2
dec	cx		; Decrement by 1
loop	loc_22BB1	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_22B9D	; Jump if Not Sign (SF=0)
jmp	loc_22B20	; Jump

loc_22BE6:		; CODE XREF: sub_229E6+1C1j
neg	bx		; Two's Complement Negation
mov	cx, bx

loc_22BEA:
mov	bx, [cs:word_226B8]
jmp	short loc_22C0B	; Jump
align 2

loc_22BF2:		; CODE XREF: sub_229E6:loc_22BD9j
dec	si		; Decrement by 1
lodsb			; Load String
push	cx
neg	bx		; Two's Complement Negation
mov	cx, bx
mov	bx, [cs:word_226B8]
jmp	short loc_22C51	; Jump
db 90h

loc_22C01:		; CODE XREF: sub_229E6:loc_22BA0j
mov	bx, [cs:word_226B8]

loc_22C06:		; CODE XREF: sub_229E6+25Bj
			; sub_229E6+27Fj
			; sub_229E6+28Ej
mov	cl, [si+1]
xor	ch, ch		; Logical Exclusive OR

loc_22C0B:		; CODE XREF: sub_229E6+209j
sub	bx, cx		; Integer Subtraction
mov	al, cl
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_22C13:		; Add
add	cl, al
adc	ch, 0		; Add with Carry

loc_22C18:		; Shift	Logical	Left
shl	cx, 1

loc_22C1A:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left

loc_22C1E:		; Shift	Logical	Left
shl	cx, 1

loc_22C20:		; Add
add	di, cx
lodsb			; Load String
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_22C2C:		; CODE XREF: sub_229E6+256j
			; sub_229E6+27Aj
dec	bx		; Decrement by 1
js	short loc_22C6F	; Jump if Sign (SF=1)
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands
jnb	short loc_22C46	; Jump if Not Below (CF=0)

loc_22C34:		; CODE XREF: sub_229E6+1E6j
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_22C79	; Jump if Not Below (CF=0)
stosb			; Store	String

loc_22C39:		; CODE XREF: sub_229E6+2BCj
add	di, 4Fh	; 'O'   ; Add
loop	loc_22C2C	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_22C06	; Jump if Not Sign (SF=0)

loc_22C43:		; Jump
jmp	loc_22B20

loc_22C46:		; CODE XREF: sub_229E6+24Cj
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
push	cx
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
lodsb			; Load String
inc	bx		; Increment by 1

loc_22C51:		; CODE XREF: sub_229E6+218j
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_22CA4	; Jump if Not Below (CF=0)

loc_22C55:		; CODE XREF: sub_229E6:loc_22C5Cj
dec	bx		; Decrement by 1
js	short loc_22C6C	; Jump if Sign (SF=1)

loc_22C58:		; Store	String
stosb
add	di, 4Fh	; 'O'   ; Add

loc_22C5C:		; Loop while CX	!= 0
loop	loc_22C55

loc_22C5E:		; CODE XREF: sub_229E6:loc_22CD5j
pop	cx
dec	cx		; Decrement by 1
loop	loc_22C2C	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands
jns	short loc_22C06	; Jump if Not Sign (SF=0)
jmp	loc_22B20	; Jump

loc_22C6A:		; CODE XREF: sub_229E6:loc_22CC2j
pop	ds
pop	si

loc_22C6C:		; CODE XREF: sub_229E6+270j
pop	cx
dec	cx		; Decrement by 1
dec	cx		; Decrement by 1

loc_22C6F:		; CODE XREF: sub_229E6+247j
add	si, cx		; Add
cmp	dx, 1		; Compare Two Operands
jns	short loc_22C06	; Jump if Not Sign (SF=0)
jmp	loc_22B20	; Jump

loc_22C79:		; CODE XREF: sub_229E6+250j
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds
mov	si, seg	dseg
mov	ds, si
mov	si, ax
and	si, 0FFh	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left

loc_22C8C:		; Shift	Logical	Left
shl	si, 1
shl	si, 1		; Shift	Logical	Left

loc_22C90:		; Add
add	si, [idk_FontsLbx1_6144B]
mov	ds, si
mov	al, [es:di]
mov	si, ax

loc_22C9B:		; Logical AND
and	si, 0FFh
movsb			; Move Byte(s) from String to String
pop	ds
pop	si
jmp	short loc_22C39	; Jump

loc_22CA4:		; CODE XREF: sub_229E6+26Dj
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds
mov	si, seg	dseg
mov	ds, si
mov	si, ax

loc_22CAF:		; Logical AND
and	si, 0FFh

loc_22CB3:		; Shift	Logical	Left
shl	si, 1

loc_22CB5:		; Shift	Logical	Left
shl	si, 1

loc_22CB7:		; Shift	Logical	Left
shl	si, 1

loc_22CB9:		; Shift	Logical	Left
shl	si, 1

loc_22CBB:		; Add
add	si, [idk_FontsLbx1_6144B]

loc_22CBF:
mov	ds, si

loc_22CC1:		; CODE XREF: sub_229E6:loc_22CD1j
dec	bx		; Decrement by 1

loc_22CC2:		; Jump if Sign (SF=1)
js	short loc_22C6A

loc_22CC4:
mov	al, [es:di]

loc_22CC7:
mov	si, ax

loc_22CC9:		; Logical AND
and	si, 0FFh

loc_22CCD:		; Move Byte(s) from String to String
movsb

loc_22CCE:		; Add
add	di, 4Fh	; 'O'

loc_22CD1:		; Loop while CX	!= 0
loop	loc_22CC1

loc_22CD3:
pop	ds

loc_22CD4:
pop	si

loc_22CD5:		; Jump
jmp	short loc_22C5E
endp sub_229E6

ends seg030


; Segment type:	Pure code
segment	seg031 byte public 'CODE' use16
assume cs:seg031
;org 8
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_22CD8 far	; CODE XREF: sub_1F8FD+5EP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_22CD9:
mov	bp, sp

loc_22CDB:
push	si

loc_22CDC:
push	di

loc_22CDD:
push	es

loc_22CDE:
push	ds

loc_22CDF:
mov	ax, [bp+arg_0]

loc_22CE2:
mov	bx, [bp+arg_2]

loc_22CE5:
mov	cx, [bp+arg_4]

loc_22CE8:
mov	ds, ax

loc_22CEA:
mov	es, bx

loc_22CEC:
mov	si, 0

loc_22CEF:
mov	di, 0

loc_22CF2:		; Move Byte(s) from String to String
movsw

loc_22CF3:		; Move Byte(s) from String to String
movsw

loc_22CF4:
mov	ax, 0DE0Ah
stosw			; Store	String

loc_22CF8:
mov	ax, cx
stosw			; Store	String

loc_22CFB:
mov	ax, 0

loc_22CFE:		; Store	String
stosw

loc_22CFF:
mov	di, 10h

loc_22D02:
mov	si, 0
lodsw			; Load String

loc_22D06:
mov	bx, ax
lodsw			; Load String

loc_22D09:		; Unsigned Multiplication of AL	or AX
mul	bx

loc_22D0B:
mov	cx, ax

loc_22D0D:		; Increment by 1
inc	cx

loc_22D0E:		; Shift	Logical	Right
shr	cx, 1

loc_22D10:		; Logical Exclusive OR
xor	ax, ax
rep stosw		; Store	String

loc_22D14:
pop	ds
pop	es

loc_22D16:
pop	di
pop	si

loc_22D18:
pop	bp
retf			; Return Far from Procedure
endp sub_22CD8

word_22D1A dw 0		; DATA XREF: sub_22D1C:loc_22D37w
			; sub_22D1C:loc_22D67w
			; sub_22D1C:loc_22D9Aw


; Attributes: bp-based frame

proc sub_22D1C far	; CODE XREF: sub_1F8FD+E0P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_22D1D:
mov	bp, sp

loc_22D1F:
push	si

loc_22D20:
push	di
push	es

loc_22D22:
push	ds
mov	ax, [bp+arg_4]

loc_22D26:
mov	es, ax

loc_22D28:
mov	di, 10h

loc_22D2B:
mov	si, [bp+arg_0]

loc_22D2E:
mov	bx, [bp+arg_2]

loc_22D31:
mov	ds, bx

loc_22D33:
mov	ax, [es:0]

loc_22D37:
mov	[cs:word_22D1A], ax

loc_22D3B:		; CODE XREF: sub_22D1C+50j
			; sub_22D1C:loc_22D9Fj
push	di

loc_22D3C:		; Load String
lodsb
cmp	al, 0FFh	; Compare Two Operands

loc_22D3F:		; Jump if Zero (ZF=1)
jz	short loc_22D61

loc_22D41:
mov	dh, al
lodsb			; Load String

loc_22D44:
mov	dl, al
cmp	dh, 0		; Compare Two Operands

loc_22D49:		; Jump if Sign (SF=1)
js	short loc_22D74

loc_22D4B:		; CODE XREF: sub_22D1C:loc_22D5Fj
mov	cl, [si+1]

loc_22D4E:		; Logical Exclusive OR
xor	ch, ch

loc_22D50:		; Add
add	di, cx
lodsb			; Load String
mov	cl, al
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1

loc_22D58:		; Integer Subtraction
sub	dx, cx

loc_22D5A:		; Move Byte(s) from String to String
rep movsb

loc_22D5C:		; Compare Two Operands
cmp	dx, 1

loc_22D5F:		; Jump if Not Sign (SF=0)
jns	short loc_22D4B

loc_22D61:		; CODE XREF: sub_22D1C:loc_22D3Fj
			; sub_22D1C+A2j
pop	di

loc_22D62:		; Add
add	di, [es:2]

loc_22D67:		; Decrement by 1
dec	[cs:word_22D1A]
jnz	short loc_22D3B	; Jump if Not Zero (ZF=0)

loc_22D6E:
pop	ds

loc_22D6F:
pop	es

loc_22D70:
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_22D74:		; CODE XREF: sub_22D1C:loc_22D49j
and	dx, 7FFFh	; Logical AND

loc_22D78:		; CODE XREF: sub_22D1C+76j
			; sub_22D1C:loc_22DBCj
mov	cl, [si+1]

loc_22D7B:		; Logical Exclusive OR
xor	ch, ch

loc_22D7D:		; Add
add	di, cx
lodsb			; Load String
mov	cl, al
inc	si		; Increment by 1
dec	dx		; Decrement by 1

loc_22D84:		; Decrement by 1
dec	dx

loc_22D85:		; Integer Subtraction
sub	dx, cx

loc_22D87:		; CODE XREF: sub_22D1C+71j
			; sub_22D1C:loc_22DB7j
lodsb			; Load String

loc_22D88:		; Compare Two Operands
cmp	al, 0E0h ; ''

loc_22D8A:		; Jump if Not Below (CF=0)
jnb	short loc_22DA7
stosb			; Store	String
loop	loc_22D87	; Loop while CX	!= 0

loc_22D8F:		; Compare Two Operands
cmp	dx, 1
jns	short loc_22D78	; Jump if Not Sign (SF=0)
pop	di

loc_22D95:		; Add
add	di, [es:2]

loc_22D9A:		; Decrement by 1
dec	[cs:word_22D1A]

loc_22D9F:		; Jump if Not Zero (ZF=0)
jnz	short loc_22D3B
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_22DA7:		; CODE XREF: sub_22D1C:loc_22D8Aj
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
mov	bx, cx
mov	cl, al

loc_22DAF:		; Logical Exclusive OR
xor	ch, ch
lodsb			; Load String

loc_22DB2:		; Store	String
rep stosb

loc_22DB4:
mov	cx, bx
dec	cx		; Decrement by 1

loc_22DB7:		; Loop while CX	!= 0
loop	loc_22D87

loc_22DB9:		; Compare Two Operands
cmp	dx, 1

loc_22DBC:		; Jump if Not Sign (SF=0)
jns	short loc_22D78
jmp	short loc_22D61	; Jump
endp sub_22D1C

word_22DC0 dw 0		; DATA XREF: sub_22DC6:loc_22E3Bw
			; sub_22EFA+2r
			; sub_22EFA+Aw
			; sub_22EFA:loc_22F17w
word_22DC2 dw 0		; DATA XREF: sub_22DC6+84w
word_22DC4 dw 0		; DATA XREF: sub_22DC6+11w
			; sub_22DC6:loc_22EA1w
			; sub_22DC6+10Ew


; Attributes: bp-based frame

proc sub_22DC6 far	; CODE XREF: sub_1F8FD+158P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_22DC7:
mov	bp, sp

loc_22DC9:
push	si

loc_22DCA:
push	di

loc_22DCB:
push	es
push	ds

loc_22DCD:
mov	ax, [bp+arg_0]

loc_22DD0:
mov	ds, ax
mov	es, ax

loc_22DD4:
mov	ax, [LibMalloc_w31D10]
mov	[cs:word_22DC4], ax
mov	si, 0Ah
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
mov	dx, ax
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
mov	bx, ax
lodsw			; Load String
mov	si, ax

loc_22DEB:
mov	di, si
push	dx
push	bx
call	sub_163FC	; Call Procedure

loc_22DF4:		; Add
add	sp, 4

loc_22DF7:
mov	ax, seg	dseg
mov	ds, ax

loc_22DFC:
mov	ax, [bp+arg_2]
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add

loc_22E05:		; Add
add	si, 12h
mov	ax, [EMM_PageFrameSegmentAddress]
mov	ds, ax
lodsw			; Load String

loc_22E0E:
mov	dx, ax

loc_22E10:		; Load String
lodsw
inc	dx		; Increment by 1
adc	ax, 0		; Add with Carry
shl	dx, 1		; Shift	Logical	Left
rcl	ax, 1		; Rotate Through Carry Left

loc_22E19:		; Shift	Logical	Left
shl	dx, 1

loc_22E1B:		; Rotate Through Carry Left
rcl	ax, 1
shr	dx, 1		; Shift	Logical	Right

loc_22E1F:		; Shift	Logical	Right
shr	dx, 1
add	al, [es:0Bh]	; Add
adc	ah, 0		; Add with Carry

loc_22E29:		; Add
add	dx, [es:0Ch]

loc_22E2E:		; Compare Two Operands
cmp	dx, 0C000h
jb	short loc_22E3B	; Jump if Below	(CF=1)

loc_22E34:		; Logical AND
and	dx, 3FFFh
inc	ax		; Increment by 1
inc	ax		; Increment by 1
inc	ax		; Increment by 1

loc_22E3B:		; CODE XREF: sub_22DC6+6Cj
mov	[cs:word_22DC0], ax

loc_22E3F:
mov	si, dx
mov	bx, ax
mov	dx, [es:0Ah]

loc_22E48:		; Logical Exclusive OR
xor	dh, dh
mov	[cs:word_22DC2], dx
push	dx

loc_22E50:
push	bx

loc_22E51:		; Call Procedure
call	sub_163FC

loc_22E56:		; Add
add	sp, 4
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg_4]
mov	es, ax

loc_22E63:
mov	di, 10h
mov	bx, [EMM_PageFrameSegmentAddress]
mov	ds, bx

loc_22E6C:		; CODE XREF: sub_22DC6:loc_22EA6j
			; sub_22DC6+113j
push	di

loc_22E6D:		; Compare Two Operands
cmp	si, 0C000h
jb	short loc_22E76	; Jump if Below	(CF=1)
call	sub_22EFA	; Call Procedure

loc_22E76:		; CODE XREF: sub_22DC6+ABj
lodsb			; Load String

loc_22E77:		; Compare Two Operands
cmp	al, 0FFh
jz	short loc_22E9B	; Jump if Zero (ZF=1)
mov	dh, al
lodsb			; Load String
mov	dl, al

loc_22E80:		; Compare Two Operands
cmp	dh, 0

loc_22E83:		; Jump if Sign (SF=1)
js	short loc_22EAE

loc_22E85:		; CODE XREF: sub_22DC6+D3j
mov	cl, [si+1]

loc_22E88:		; Logical Exclusive OR
xor	ch, ch

loc_22E8A:		; Add
add	di, cx

loc_22E8C:		; Load String
lodsb
mov	cl, al
inc	si		; Increment by 1

loc_22E90:		; Decrement by 1
dec	dx
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction
rep movsb		; Move Byte(s) from String to String
cmp	dx, 1		; Compare Two Operands
jns	short loc_22E85	; Jump if Not Sign (SF=0)

loc_22E9B:		; CODE XREF: sub_22DC6+B3j
			; sub_22DC6+132j
pop	di

loc_22E9C:		; Add
add	di, [es:2]

loc_22EA1:		; Decrement by 1
dec	[cs:word_22DC4]

loc_22EA6:		; Jump if Not Zero (ZF=0)
jnz	short loc_22E6C
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_22EAE:		; CODE XREF: sub_22DC6:loc_22E83j
and	dx, 7FFFh	; Logical AND

loc_22EB2:		; CODE XREF: sub_22DC6:loc_22ECCj
			; sub_22DC6:loc_22EF6j
mov	cl, [si+1]

loc_22EB5:		; Logical Exclusive OR
xor	ch, ch
add	di, cx		; Add
lodsb			; Load String
mov	cl, al
inc	si		; Increment by 1
dec	dx		; Decrement by 1
dec	dx		; Decrement by 1
sub	dx, cx		; Integer Subtraction

loc_22EC1:		; CODE XREF: sub_22DC6:loc_22EC7j
			; sub_22DC6+12Bj
lodsb			; Load String
cmp	al, 0E0h ; ''  ; Compare Two Operands
jnb	short loc_22EE1	; Jump if Not Below (CF=0)
stosb			; Store	String

loc_22EC7:		; Loop while CX	!= 0
loop	loc_22EC1
cmp	dx, 1		; Compare Two Operands

loc_22ECC:		; Jump if Not Sign (SF=0)
jns	short loc_22EB2
pop	di

loc_22ECF:		; Add
add	di, [es:2]
dec	[cs:word_22DC4]	; Decrement by 1
jnz	short loc_22E6C	; Jump if Not Zero (ZF=0)
pop	ds

loc_22EDC:
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_22EE1:		; CODE XREF: sub_22DC6+FEj
and	al, 1Fh		; Logical AND
inc	al		; Increment by 1
mov	bx, cx
mov	cl, al
xor	ch, ch		; Logical Exclusive OR
lodsb			; Load String
rep stosb		; Store	String
mov	cx, bx

loc_22EF0:		; Decrement by 1
dec	cx
loop	loc_22EC1	; Loop while CX	!= 0
cmp	dx, 1		; Compare Two Operands

loc_22EF6:		; Jump if Not Sign (SF=0)
jns	short loc_22EB2
jmp	short loc_22E9B	; Jump
endp sub_22DC6




proc sub_22EFA near	; CODE XREF: sub_22DC6+ADp
push	bx

loc_22EFB:
push	ax
mov	bx, [cs:word_22DC0]
add	bx, 3		; Add
mov	[cs:word_22DC0], bx
push	dx
push	bx

loc_22F0B:		; Call Procedure
call	sub_163FC

loc_22F10:		; Add
add	sp, 4

loc_22F13:		; Integer Subtraction
sub	si, 0C000h

loc_22F17:		; Increment by 1
inc	[cs:word_22DC0]
pop	ax
pop	bx
retn			; Return Near from Procedure
endp sub_22EFA

word_22F1F dw 0		; DATA XREF: sub_22F25:loc_22F68w
			; sub_22F25:loc_22F9Ar
			; sub_22FE1:loc_23000r
			; sub_2309C+16w
			; sub_2309C:loc_230C7r
			; sub_231D6+16w
			; sub_231D6:loc_23201r
word_22F21 dw 0		; DATA XREF: sub_2309C+1Dw
			; sub_2309C+3Ew
			; sub_231D6:loc_231F3w
			; sub_231D6+3Ew
			; sub_23243:loc_2329Bw
			; sub_23243+9Bw
			; sub_232ED+72w
			; sub_232ED:loc_233A6w
			; sub_234B7+23w
			; sub_234B7+63w
word_22F23 dw 0		; DATA XREF: sub_22F25:loc_22F70w
			; sub_22F25+85r
			; sub_22F25+A3r
			; sub_22FE1+33r
			; sub_22FE1:loc_2303Er
			; sub_22FE1+96r


; Attributes: bp-based frame

proc sub_22F25 far	; CODE XREF: sub_21014+2EP
			; idk_VidLib_s2104D:loc_2116CP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp

loc_22F28:
push	si
push	di
push	es
push	ds
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	ax, [bp+arg_2]
mov	bx, ax
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, bx		; Add
add	ax, [g_ptrVideoRamBuffer] ; Add
mov	es, ax
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right

loc_22F4A:		; Shift	Logical	Right
shr	bx, 1

loc_22F4C:
mov	di, bx

loc_22F4E:		; Logical AND
and	ax, 3

loc_22F51:
mov	bl, al
shl	bl, 1		; Shift	Logical	Left

loc_22F55:		; Shift	Logical	Left
shl	bl, 1
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
mov	si, 4380h

loc_22F5E:		; Add
add	si, ax
lodsb			; Load String
mov	ah, al
or	ah, bl		; Logical Inclusive OR
mov	cx, [bp+arg_A]

loc_22F68:
mov	[cs:word_22F1F], cx
mov	cx, [bp+arg_C]

loc_22F70:
mov	[cs:word_22F23], cx
mov	si, [bp+arg_4]
mov	bx, [bp+arg_8]
mov	cx, [bp+arg_6]
mov	ds, cx

loc_22F80:		; Compare Two Operands
cmp	[byte ptr LibMalloc_w31D18], 0
jz	short loc_22F90	; Jump if Zero (ZF=1)

loc_22F87:		; Call Procedure
call	sub_22FE1
pop	ds
pop	es
pop	di
pop	si

loc_22F8E:
pop	bp
retf			; Return Far from Procedure

loc_22F90:		; CODE XREF: sub_22F25+60j
and	ah, 0Fh		; Logical AND

loc_22F93:		; CODE XREF: sub_22F25+96j
			; sub_22F25:loc_22FD9j
push	di
mov	dx, 3C5h

loc_22F97:
mov	al, ah
out	dx, al		; EGA port: sequencer data register

loc_22F9A:
mov	cx, [cs:word_22F1F]

loc_22F9F:		; CODE XREF: sub_22F25+83j
			; sub_22F25:loc_22FC6j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jz	short loc_22FC3	; Jump if Zero (ZF=1)
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_22F9F	; Loop while CX	!= 0
add	si, [cs:word_22F23] ; Add
pop	di
shl	ah, 1		; Shift	Logical	Left

loc_22FB2:		; Compare Two Operands
cmp	ah, 9
js	short loc_22FBA	; Jump if Sign (SF=1)
mov	ah, 1
inc	di		; Increment by 1

loc_22FBA:		; CODE XREF: sub_22F25+90j
dec	bx		; Decrement by 1
jnz	short loc_22F93	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure

loc_22FC3:		; CODE XREF: sub_22F25+7Dj
add	di, 50h	; 'P'   ; Add

loc_22FC6:		; Loop while CX	!= 0
loop	loc_22F9F
add	si, [cs:word_22F23] ; Add
pop	di
shl	ah, 1		; Shift	Logical	Left

loc_22FD0:		; Compare Two Operands
cmp	ah, 9

loc_22FD3:		; Jump if Sign (SF=1)
js	short loc_22FD8

loc_22FD5:
mov	ah, 1
inc	di		; Increment by 1

loc_22FD8:		; CODE XREF: sub_22F25:loc_22FD3j
dec	bx		; Decrement by 1

loc_22FD9:		; Jump if Not Zero (ZF=0)
jnz	short loc_22F93
pop	ds
pop	es
pop	di

loc_22FDE:
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_22F25




proc sub_22FE1 near	; CODE XREF: sub_22F25:loc_22F87p
			; sub_22FE1+55j
			; sub_22FE1+B8j
push	di
mov	dx, 3CEh
mov	al, 4

loc_22FE7:		; EGA: graph 1 and 2 addr reg:
out	dx, al		; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_22FE9:
mov	al, ah
shr	al, 1		; Shift	Logical	Right
shr	al, 1		; Shift	Logical	Right

loc_22FEF:		; Shift	Logical	Right
shr	al, 1
shr	al, 1		; Shift	Logical	Right
out	dx, al		; EGA port: graphics controller	data register

loc_22FF4:
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, ah

loc_22FFD:		; Logical AND
and	al, 0Fh
out	dx, al		; EGA port: sequencer data register

loc_23000:
mov	cx, [cs:word_22F1F]

loc_23005:		; CODE XREF: sub_22FE1+31j
			; sub_22FE1:loc_2303Cj
			; sub_22FE1+94j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jz	short loc_23039	; Jump if Zero (ZF=1)
cmp	al, 0E8h ; ''  ; Compare Two Operands

loc_2300C:		; Jump if Not Below (CF=0)
jnb	short loc_23048

loc_2300E:		; Store	String
stosb

loc_2300F:		; Add
add	di, 4Fh	; 'O'
loop	loc_23005	; Loop while CX	!= 0
add	si, [cs:word_22F23] ; Add
pop	di
dec	bx		; Decrement by 1
jz	short locret_23038 ; Jump if Zero (ZF=1)

loc_2301D:		; CODE XREF: sub_22FE1+64j
mov	cl, ah
and	cl, 0F0h	; Logical AND
add	cl, 10h		; Add
and	ah, 0Fh		; Logical AND
shl	ah, 1		; Shift	Logical	Left

loc_2302A:		; Compare Two Operands
cmp	ah, 9
js	short loc_23034	; Jump if Sign (SF=1)

loc_2302F:
mov	cl, 0
mov	ah, 1
inc	di		; Increment by 1

loc_23034:		; CODE XREF: sub_22FE1+4Cj
or	ah, cl		; Logical Inclusive OR
jmp	short sub_22FE1	; Jump

locret_23038:		; CODE XREF: sub_22FE1+3Aj
			; sub_22FE1+9Dj
retn			; Return Near from Procedure

loc_23039:		; CODE XREF: sub_22FE1+27j
add	di, 50h	; 'P'   ; Add

loc_2303C:		; Loop while CX	!= 0
loop	loc_23005

loc_2303E:		; Add
add	si, [cs:word_22F23]
pop	di

loc_23044:		; Decrement by 1
dec	bx
jnz	short loc_2301D	; Jump if Not Zero (ZF=0)
retn			; Return Near from Procedure

loc_23048:		; CODE XREF: sub_22FE1:loc_2300Cj
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds

loc_2304C:
mov	si, seg	dseg
mov	ds, si

loc_23051:
mov	si, ax
and	si, 0FFh	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
add	si, [idk_FontsLbx1_6144B] ; Add
mov	ds, si
mov	al, [es:di]
mov	si, ax
and	si, 0FFh	; Logical AND
lodsb			; Load String
pop	ds
pop	si
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_23005	; Loop while CX	!= 0
add	si, [cs:word_22F23] ; Add
pop	di
dec	bx		; Decrement by 1
jz	short locret_23038 ; Jump if Zero (ZF=1)

loc_23080:
mov	cl, ah
and	cl, 0F0h	; Logical AND
add	cl, 10h		; Add

loc_23088:		; Logical AND
and	ah, 0Fh
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands

loc_23090:		; Jump if Sign (SF=1)
js	short loc_23097
mov	cl, 0

loc_23094:
mov	ah, 1
inc	di		; Increment by 1

loc_23097:		; CODE XREF: sub_22FE1:loc_23090j
or	ah, cl		; Logical Inclusive OR
jmp	sub_22FE1	; Jump
endp sub_22FE1



; Attributes: bp-based frame

proc sub_2309C far	; CODE XREF: sub_2117A+15AP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp

loc_2309D:
mov	bp, sp

loc_2309F:
push	si

loc_230A0:
push	di
push	es
push	ds
mov	di, [bp+arg_0]
mov	si, [bp+arg_4]

loc_230A9:
mov	bx, [bp+arg_8]
mov	dx, [bp+arg_A]

loc_230AF:
mov	ax, [bp+arg_E]
mov	[cs:word_22F1F], ax

loc_230B6:
mov	ax, [bp+arg_C]
mov	[cs:word_22F21], ax

loc_230BD:
mov	ax, [bp+arg_2]

loc_230C0:
mov	es, ax
mov	ax, [bp+arg_6]
mov	ds, ax

loc_230C7:		; CODE XREF: sub_2309C+43j
mov	cx, [cs:word_22F1F]

loc_230CC:		; CODE XREF: sub_2309C:loc_230D4j
lodsb			; Load String
inc	di		; Increment by 1
cmp	al, 0		; Compare Two Operands
jz	short loc_230D4	; Jump if Zero (ZF=1)
dec	di		; Decrement by 1
stosb			; Store	String

loc_230D4:		; CODE XREF: sub_2309C+34j
loop	loc_230CC	; Loop while CX	!= 0
add	di, bx		; Add
add	si, dx		; Add
dec	[cs:word_22F21]	; Decrement by 1
jnz	short loc_230C7	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_2309C



; Attributes: bp-based frame

proc sub_230E7 far

arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_230EA:
push	si
push	di
push	es
push	ds
mov	ax, [bp+arg_0]
mov	ds, ax
mov	es, ax
mov	bx, [LibMalloc_w31D10]
mov	cx, [LibMalloc_w31D12]
mov	ax, bx
dec	ax		; Decrement by 1
mul	cx		; Unsigned Multiplication of AL	or AX
add	ax, 10h		; Add
mov	si, ax
mov	di, 10h
shr	bx, 1		; Shift	Logical	Right
mov	dx, cx

loc_2310E:		; CODE XREF: sub_230E7+3Aj
mov	cx, dx

loc_23110:		; CODE XREF: sub_230E7+33j
lodsb			; Load String
mov	ah, [es:di]
stosb			; Store	String
dec	si		; Decrement by 1
mov	[es:si], ah
inc	si		; Increment by 1
loop	loc_23110	; Loop while CX	!= 0
sub	si, dx		; Integer Subtraction
sub	si, dx		; Integer Subtraction
dec	bx		; Decrement by 1
jnz	short loc_2310E	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_230E7



; Attributes: bp-based frame

proc sub_23129 far	; CODE XREF: sub_1D40D+14EP
			; sub_21711:loc_21814P

arg_0= word ptr	 6
arg_2= byte ptr	 8
arg_4= byte ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	bl, [bp+arg_2]
mov	bh, [bp+arg_4]
mov	ax, [bp+arg_0]
mov	ds, ax

loc_2313B:
mov	es, ax

loc_2313D:
mov	ax, [LibMalloc_w31D10]
mov	dx, [LibMalloc_w31D12]
mul	dx		; Unsigned Multiplication of AL	or AX

loc_23146:
mov	cx, ax
mov	si, 10h
mov	di, 10h

loc_2314E:		; CODE XREF: sub_23129:loc_23158j
lodsb			; Load String
inc	di		; Increment by 1
cmp	al, bl		; Compare Two Operands
jnz	short loc_23158	; Jump if Not Zero (ZF=0)
dec	di		; Decrement by 1
mov	al, bh
stosb			; Store	String

loc_23158:		; CODE XREF: sub_23129+29j
loop	loc_2314E	; Loop while CX	!= 0

loc_2315A:
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_23129



; Attributes: bp-based frame

proc sub_23160 far	; CODE XREF: sub_21711+1FP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, ds

loc_23169:
mov	es, ax
assume es:dseg
mov	di, [bp+arg_2]
mov	bx, di
mov	al, 0FFh
mov	cx, 256
rep stosb		; Store	String
mov	ax, [bp+arg_0]
mov	ds, ax
mov	si, 16

loc_2317F:
mov	ax, [LibMalloc_w31D10]
mov	dx, [LibMalloc_w31D12]
mul	dx		; Unsigned Multiplication of AL	or AX
mov	cx, ax
xor	ah, ah		; Logical Exclusive OR

loc_2318C:		; CODE XREF: sub_23160:loc_23198j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands

loc_2318F:		; Jump if Zero (ZF=1)
jz	short loc_23198
mov	di, bx
add	di, ax		; Add
xor	al, al		; Logical Exclusive OR
stosb			; Store	String

loc_23198:		; CODE XREF: sub_23160:loc_2318Fj
loop	loc_2318C	; Loop while CX	!= 0
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	si, 0
mov	cx, 256

loc_231AA:
mov	di, bx

loc_231AC:		; CODE XREF: sub_23160+62j
			; sub_23160:loc_231CEj
mov	al, [es:di]

loc_231AF:		; Compare Two Operands
cmp	al, 0FFh
jz	short loc_231CA	; Jump if Zero (ZF=1)
lodsb			; Load String
mov	ah, al
lodsb			; Load String
add	ah, al		; Add
lodsb			; Load String
shr	al, 1		; Shift	Logical	Right
add	ah, al		; Add

loc_231BE:
mov	[es:di], ah
inc	di		; Increment by 1
loop	loc_231AC	; Loop while CX	!= 0
pop	ds
pop	es
assume es:nothing
pop	di
pop	si

loc_231C8:
pop	bp
retf			; Return Far from Procedure

loc_231CA:		; CODE XREF: sub_23160+51j
inc	di		; Increment by 1

loc_231CB:		; Add
add	si, 3

loc_231CE:		; Loop while CX	!= 0
loop	loc_231AC
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_23160



; Attributes: bp-based frame

proc sub_231D6 far	; CODE XREF: sub_212E2:loc_2143CP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds

loc_231DD:
mov	di, [bp+arg_0]
mov	si, [bp+arg_4]
mov	bx, [bp+arg_8]
mov	dx, [bp+arg_A]
mov	ax, [bp+arg_E]
mov	[cs:word_22F1F], ax
mov	ax, [bp+arg_C]

loc_231F3:
mov	[cs:word_22F21], ax

loc_231F7:
mov	ax, [bp+arg_2]
mov	es, ax
mov	ax, [bp+arg_6]
mov	ds, ax

loc_23201:		; CODE XREF: sub_231D6+43j
mov	cx, [cs:word_22F1F]

loc_23206:		; CODE XREF: sub_231D6:loc_2320Ej
lodsb			; Load String
inc	di		; Increment by 1
cmp	al, 0		; Compare Two Operands
jnz	short loc_2320E	; Jump if Not Zero (ZF=0)
dec	di		; Decrement by 1
stosb			; Store	String

loc_2320E:		; CODE XREF: sub_231D6+34j
loop	loc_23206	; Loop while CX	!= 0
add	di, bx		; Add
add	si, dx		; Add
dec	[cs:word_22F21]	; Decrement by 1
jnz	short loc_23201	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
pop	bp

locret_23220:		; Return Far from Procedure
retf
endp sub_231D6



; Attributes: bp-based frame

proc sub_23221 far	; CODE XREF: sub_214B0+4FP
			; sub_214B0+A1P
			; sub_214B0+CFP
			; sub_214B0:loc_2159FP
			; sub_214B0+11AP
			; sub_215D8:loc_2162BP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_23222:
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	cx, [bp+arg_4]
mov	di, [bp+arg_0]

loc_2322E:
mov	ax, [bp+arg_2]
mov	es, ax
xor	al, al		; Logical Exclusive OR
rep stosb		; Store	String
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_23221

word_2323D dw 0		; DATA XREF: sub_23243+5Dw
			; sub_23243+82r
			; sub_23243+96w
			; sub_232ED:loc_23364w
			; sub_232ED+9Er
			; sub_232ED:loc_233A1w
word_2323F dw 0		; DATA XREF: sub_23243:loc_2326Bw
			; sub_23243:loc_232CAr
			; sub_232ED+38w
			; sub_232ED+A3r
word_23241 dw 0		; DATA XREF: sub_23243+30w
			; sub_23243+8Cr
			; sub_232ED:loc_2332Dw
			; sub_232ED+ADr


; Attributes: bp-based frame

proc sub_23243 far	; CODE XREF: sub_21829:loc_218F4P

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, [bp+arg_0]
mov	es, ax
mov	ax, [es:0]

loc_23256:
mov	bx, [bp+arg_2]
mul	bx		; Unsigned Multiplication of AL	or AX
mov	cx, 64h	; 'd'
div	cx		; Unsigned Divide

loc_23260:
mov	[es:0],	ax
mov	ax, 6400h

loc_23267:		; Logical Exclusive OR
xor	dx, dx
div	bx		; Unsigned Divide

loc_2326B:
mov	[cs:word_2323F], ax

loc_2326F:
mov	ax, [es:2]
mov	[cs:word_23241], ax
mov	bx, [bp+arg_4]
mul	bx		; Unsigned Multiplication of AL	or AX
mov	cx, 64h	; 'd'
div	cx		; Unsigned Divide
mov	[es:2],	ax
mov	ax, 6400h
mov	dx, 0
div	bx		; Unsigned Divide
mov	[bp+var_2], ax

loc_23290:
mov	si, 10h

loc_23293:
mov	di, 10h
mov	bx, [es:0]

loc_2329B:
mov	[cs:word_22F21], bx
mov	[cs:word_2323D], 0
mov	dx, [bp+var_2]
mov	ax, es

loc_232AC:
mov	ds, ax

loc_232AE:		; CODE XREF: sub_23243+A0j
push	si

loc_232AF:
mov	cx, [LibMalloc_w31D12]
mov	bx, 0

loc_232B6:		; CODE XREF: sub_23243+7Fj
movsb			; Move Byte(s) from String to String
dec	si		; Decrement by 1
add	bx, dx		; Add
mov	al, bh

loc_232BC:		; Logical Exclusive OR
xor	bh, bh
xor	ah, ah		; Logical Exclusive OR
add	si, ax		; Add
loop	loc_232B6	; Loop while CX	!= 0

loc_232C4:
pop	si
mov	cx, [cs:word_2323D]

loc_232CA:		; Add
add	cx, [cs:word_2323F]
mov	ax, [cs:word_23241]
mul	ch		; Unsigned Multiplication of AL	or AX
add	si, ax		; Add
xor	ch, ch		; Logical Exclusive OR
mov	[cs:word_2323D], cx
dec	[cs:word_22F21]	; Decrement by 1
jnz	short loc_232AE	; Jump if Not Zero (ZF=0)

loc_232E5:
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_23243



; Attributes: bp-based frame

proc sub_232ED far	; CODE XREF: sub_21829+98P

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp

loc_232F0:		; Integer Subtraction
sub	sp, 2
push	si
push	di
push	es
push	ds
mov	ax, [bp+arg_0]
mov	es, ax
mov	ax, [es:0]
mov	bx, [es:2]
mul	bx		; Unsigned Multiplication of AL	or AX

loc_23307:		; Add
add	ax, 0Fh
mov	si, ax
mov	ax, [es:0]
mov	bx, [bp+arg_2]
mul	bx		; Unsigned Multiplication of AL	or AX
mov	cx, 64h	; 'd'
div	cx		; Unsigned Divide
mov	[es:0],	ax
mov	ax, 6400h
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	[cs:word_2323F], ax

loc_23329:
mov	ax, [es:2]

loc_2332D:
mov	[cs:word_23241], ax
mov	bx, [bp+arg_4]
mul	bx		; Unsigned Multiplication of AL	or AX
mov	cx, 64h	; 'd'
div	cx		; Unsigned Divide
mov	[es:2],	ax
mov	ax, 6400h
mov	dx, 0
div	bx		; Unsigned Divide
mov	[bp+var_2], ax
mov	ax, [es:0]
mov	bx, [es:2]
mul	bx		; Unsigned Multiplication of AL	or AX
add	ax, 0Fh		; Add

loc_23358:
mov	di, ax
mov	bx, [es:0]
mov	[cs:word_22F21], bx

loc_23364:
mov	[cs:word_2323D], 0
mov	dx, [bp+var_2]
mov	ax, es
mov	ds, ax

loc_23372:		; CODE XREF: sub_232ED+BEj
push	si
mov	cx, [LibMalloc_w31D12]
mov	bx, 0

loc_2337A:		; CODE XREF: sub_232ED+9Bj
movsb			; Move Byte(s) from String to String
dec	di		; Decrement by 1

loc_2337C:		; Decrement by 1
dec	di
dec	si		; Decrement by 1

loc_2337E:		; Add
add	bx, dx

loc_23380:
mov	al, bh
xor	bh, bh		; Logical Exclusive OR
xor	ah, ah		; Logical Exclusive OR
sub	si, ax		; Integer Subtraction
loop	loc_2337A	; Loop while CX	!= 0
pop	si
mov	cx, [cs:word_2323D]
add	cx, [cs:word_2323F] ; Add

loc_23395:		; Compare Two Operands
cmp	ch, 0
jz	short loc_233A1	; Jump if Zero (ZF=1)
sub	si, [cs:word_23241] ; Integer Subtraction

loc_2339F:		; Logical Exclusive OR
xor	ch, ch

loc_233A1:		; CODE XREF: sub_232ED+ABj
mov	[cs:word_2323D], cx

loc_233A6:		; Decrement by 1
dec	[cs:word_22F21]
jnz	short loc_23372	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di

loc_233B0:
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_232ED

word_233B5 dw 0		; DATA XREF: sub_234B7+13w
			; sub_234B7:loc_234E5r
			; sub_234B7:loc_234EEw
byte_233B7 db 2Ah, 44h,	23h, 1,	46h, 19h, 4Fh, 3Bh
db 3Fh,	41h, 6,	2Eh, 52h, 1Ch, 3Eh, 5Ch
db 60h,	2Bh, 1Ch, 25h, 5Ch, 5, 3, 36h, 5Dh
db 53h,	16h, 11h, 13h, 60h, 30h, 1Bh, 48h
db 27h,	46h, 0Dh, 44h, 64h, 24h, 5Fh, 4
db 0Ch,	17h, 22h, 4Ah, 41h, 2Ah, 0Ch, 36h
db 45h,	30h, 2Dh, 3Fh, 3Ah, 26h, 3Ch, 18h
db 2Ah,	1Eh, 4Fh, 11h, 24h, 5Bh, 2Bh, 59h
db 7, 29h, 2Bh,	41h, 31h, 2Fh, 6, 5Bh, 1Eh
db 47h,	33h, 7,	2, 5Eh,	31h, 1Eh, 18h, 55h
db 37h,	39h, 29h, 43h, 4Dh, 20h, 9, 2Dh
db 28h,	1Bh, 18h, 26h, 27h, 13h, 53h, 1Eh
db 2Ah,	22h, 10h, 28h, 3Bh, 5, 1Fh, 4Eh
db 7, 4Ah, 57h,	16h, 2Eh, 19h, 49h, 47h
db 1Eh,	4Eh, 4Ah, 62h, 0Dh, 57h, 5Bh, 3Eh
db 25h,	38h, 44h, 38h, 4Bh, 20h, 35h, 2	dup(33h)
db 2Ah,	19h, 43h, 1Fh, 8, 5Ch, 8, 26h, 3Ah
db 58h,	36h, 54h, 2Eh, 2 dup(0Ah), 3Bh,	16h
db 59h,	17h, 2Fh, 7, 1Fh, 0Eh, 45h, 1, 5Ch
db 3Fh,	38h, 0Bh, 3Ch, 19h, 26h, 31h, 54h
db 60h,	2Ah, 3,	33h, 5Ch, 25h, 4Bh, 15h
db 61h,	16h, 31h, 64h, 45h, 55h, 52h, 23h
db 36h,	64h, 13h, 27h, 1, 59h, 1Ch, 44h
db 1Dh,	5Eh, 31h, 54h, 8, 16h, 0Bh, 12h
db 0Eh,	0Fh, 0Ah, 11h, 24h, 34h, 1, 32h
db 14h,	39h, 63h, 4, 19h, 9, 2Dh, 0Ah, 5Ah
db 3, 60h, 56h,	5Eh, 2Ch, 18h, 58h, 0Fh
db 4, 31h, 1, 3Bh, 13h,	51h, 61h, 63h, 52h
db 5Ah,	63h, 0Ah, 3Ah, 49h, 17h, 27h, 5Dh
db 27h,	50h, 5Bh, 3Ah, 3Bh, 5Ch, 10h, 59h
db 39h,	0Ch, 3,	23h, 49h, 38h, 1Dh, 2Fh


; Attributes: bp-based frame

proc sub_234B7 far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_234B8:
mov	bp, sp
push	si
push	di

loc_234BC:
push	es
push	ds

loc_234BE:
mov	ax, 3E8h
push	ax
push	cs
call	near ptr sub_236B9 ; Call Procedure
nop			; No Operation
add	sp, 2		; Add
mov	[cs:word_233B5], ax

loc_234CE:
mov	ax, [bp+arg_0]
mov	es, ax
mov	di, 10h
mov	ax, [es:0]
mov	[cs:word_22F21], ax
mov	dx, [bp+arg_2]
mov	ax, cs
mov	ds, ax
assume ds:seg031

loc_234E5:		; CODE XREF: sub_234B7+68j
mov	ax, [cs:word_233B5]
call	sub_18B69	; Call Procedure

loc_234EE:
mov	[cs:word_233B5], ax

loc_234F2:
mov	al, ah
xor	ah, ah		; Logical Exclusive OR
mov	bx, ax
mov	si, bx
add	si, 6E7h	; Add
mov	cx, [es:2]

loc_23503:		; CODE XREF: sub_234B7+61j
lodsb			; Load String
inc	di		; Increment by 1
cmp	al, dl		; Compare Two Operands
jz	short loc_2350F	; Jump if Zero (ZF=1)

loc_23509:		; Jump if Below	(CF=1)
jb	short loc_2350F
xor	al, al		; Logical Exclusive OR
dec	di		; Decrement by 1
stosb			; Store	String

loc_2350F:		; CODE XREF: sub_234B7+50j
			; sub_234B7:loc_23509j
inc	bx		; Increment by 1
xor	bh, bh		; Logical Exclusive OR
mov	si, bx
add	si, 6E7h	; Add
loop	loc_23503	; Loop while CX	!= 0
dec	[cs:word_22F21]	; Decrement by 1
jnz	short loc_234E5	; Jump if Not Zero (ZF=0)
pop	ds
assume ds:dseg
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_234B7



; Attributes: bp-based frame

proc sub_23527 far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	ds
push	di
push	si
push	es
push	ds
mov	dx, [bp+arg_2]
mov	si, 0
mov	ax, [idk_FontsLbx1_e_96]
mov	es, ax

loc_2353A:
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	di, 0

loc_23542:
mov	cx, 100h

loc_23545:		; Logical Exclusive OR
xor	ah, ah

loc_23547:		; CODE XREF: sub_23527+40j
xor	bx, bx		; Logical Exclusive OR
lodsb			; Load String

loc_2354A:		; Add
add	bx, ax
shr	al, 1		; Shift	Logical	Right

loc_2354E:		; Add
add	bx, ax
lodsb			; Load String

loc_23551:		; Add
add	bx, ax

loc_23553:		; Shift	Logical	Right
shr	al, 1
add	bx, ax		; Add
lodsb			; Load String

loc_23558:		; Add
add	bx, ax

loc_2355A:		; Shift	Logical	Right
shr	bx, 1
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right

loc_23560:		; Shift	Logical	Right
shr	bx, 1
add	bx, dx		; Add
mov	al, bl
stosb			; Store	String
loop	loc_23547	; Loop while CX	!= 0
pop	ds
mov	ax, [bp+arg_0]
mov	es, ax
mov	bx, [idk_FontsLbx1_e_96]
mov	ds, bx
mov	ax, [es:0]
mov	bx, [es:2]
mul	bx		; Unsigned Multiplication of AL	or AX

loc_23580:
mov	cx, ax
cmp	cx, 0		; Compare Two Operands
jz	short loc_235A3	; Jump if Zero (ZF=1)
xor	bh, bh		; Logical Exclusive OR
mov	di, 10h

loc_2358C:
mov	si, di

loc_2358E:		; CODE XREF: sub_23527+73j
			; sub_23527+7Aj
mov	bl, [es:si]
cmp	bl, 0		; Compare Two Operands
jz	short loc_2359F	; Jump if Zero (ZF=1)
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_2358E	; Loop while CX	!= 0
jmp	short loc_235A3	; Jump
db 90h

loc_2359F:		; CODE XREF: sub_23527+6Dj
inc	si		; Increment by 1
inc	di		; Increment by 1
loop	loc_2358E	; Loop while CX	!= 0

loc_235A3:		; CODE XREF: sub_23527+5Ej
			; sub_23527+75j
pop	es
pop	si
pop	di
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_23527



; Attributes: bp-based frame

proc sub_235A9 far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	ds
push	di
push	si
push	es
push	ds
mov	dx, [bp+arg_2]
mov	si, 0

loc_235B7:
mov	ax, [idk_FontsLbx1_e_96]
mov	es, ax
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	di, 0
mov	cx, 100h
xor	ah, ah		; Logical Exclusive OR

loc_235C9:		; CODE XREF: sub_235A9:loc_235EDj
xor	bx, bx		; Logical Exclusive OR
lodsb			; Load String
add	bx, ax		; Add
shr	al, 1		; Shift	Logical	Right
add	bx, ax		; Add

loc_235D2:		; Load String
lodsb
add	bx, ax		; Add
shr	al, 1		; Shift	Logical	Right
add	bx, ax		; Add
lodsb			; Load String

loc_235DA:		; Add
add	bx, ax
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
mov	dh, dl
sub	dh, bl		; Integer Subtraction
mov	al, dh
stosb			; Store	String

loc_235ED:		; Loop while CX	!= 0
loop	loc_235C9
pop	ds
mov	ax, [bp+arg_0]
mov	es, ax
mov	bx, [idk_FontsLbx1_e_96]
mov	ds, bx
mov	ax, [es:0]
mov	bx, [es:2]
mul	bx		; Unsigned Multiplication of AL	or AX
mov	cx, ax
cmp	cx, 0		; Compare Two Operands
jz	short loc_23629	; Jump if Zero (ZF=1)
xor	bh, bh		; Logical Exclusive OR
mov	di, 10h
mov	si, di

loc_23614:		; CODE XREF: sub_235A9+77j
			; sub_235A9+7Ej
mov	bl, [es:si]
cmp	bl, 0		; Compare Two Operands
jz	short loc_23625	; Jump if Zero (ZF=1)
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_23614	; Loop while CX	!= 0
jmp	short loc_23629	; Jump
db 90h

loc_23625:		; CODE XREF: sub_235A9+71j
inc	di		; Increment by 1
inc	si		; Increment by 1
loop	loc_23614	; Loop while CX	!= 0

loc_23629:		; CODE XREF: sub_235A9+62j
			; sub_235A9+79j
pop	es
pop	si
pop	di
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_235A9



; Attributes: bp-based frame

proc sub_2362F far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_23630:
mov	bp, sp
push	ds
push	di
push	si
push	es
push	ds
mov	dx, [bp+arg_2]
mov	si, 0
mov	ax, [idk_FontsLbx1_e_96]
mov	es, ax
mov	ax, [idk_FontsLbx1_1024B]
mov	ds, ax
mov	di, 0
mov	cx, 100h
xor	ah, ah		; Logical Exclusive OR

loc_2364F:		; CODE XREF: sub_2362F+44j
xor	bx, bx		; Logical Exclusive OR
lodsb			; Load String
add	bx, ax		; Add
shr	al, 1		; Shift	Logical	Right
add	bx, ax		; Add
lodsb			; Load String
add	bx, ax		; Add
shr	al, 1		; Shift	Logical	Right
add	bx, ax		; Add

loc_2365F:		; Load String
lodsb
add	bx, ax		; Add
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right

loc_2366C:
mov	dh, dl

loc_2366E:		; Integer Subtraction
sub	dh, bl
mov	al, dh
stosb			; Store	String
loop	loc_2364F	; Loop while CX	!= 0
pop	ds
mov	ax, [bp+arg_0]
mov	es, ax

loc_2367B:
mov	bx, [idk_FontsLbx1_e_96]
mov	ds, bx
mov	ax, [es:0]
mov	bx, [es:2]
mul	bx		; Unsigned Multiplication of AL	or AX
mov	cx, ax

loc_2368E:		; Compare Two Operands
cmp	cx, 0
jz	short loc_236AF	; Jump if Zero (ZF=1)

loc_23693:		; Logical Exclusive OR
xor	bh, bh
mov	di, 10h
mov	si, di

loc_2369A:		; CODE XREF: sub_2362F+77j
			; sub_2362F+7Ej
mov	bl, [es:si]
cmp	bl, 0		; Compare Two Operands
jz	short loc_236AB	; Jump if Zero (ZF=1)
mov	al, [bx]
stosb			; Store	String
inc	si		; Increment by 1
loop	loc_2369A	; Loop while CX	!= 0
jmp	short loc_236AF	; Jump
db 90h

loc_236AB:		; CODE XREF: sub_2362F+71j
inc	di		; Increment by 1

loc_236AC:		; Increment by 1
inc	si
loop	loc_2369A	; Loop while CX	!= 0

loc_236AF:		; CODE XREF: sub_2362F+62j
			; sub_2362F+79j
pop	es

loc_236B0:
pop	si
pop	di
pop	ds
pop	bp

locret_236B4:		; Return Far from Procedure
retf
endp sub_2362F

word_236B5 dw 2893h	; DATA XREF: sub_236B9+1Ar
			; sub_236B9:loc_23726w
word_236B7 dw 0Ah	; DATA XREF: sub_236B9:loc_236D8r
			; sub_236B9:loc_2372Bw


; Attributes: bp-based frame

proc sub_236B9 far	; CODE XREF: sub_234B7+Cp

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	ds
push	di
push	si
push	es
cmp	[bp+arg_0], 0	; Compare Two Operands

loc_236C7:		; Jump if Not Zero (ZF=0)
jnz	short loc_236CE
mov	[bp+arg_0], 1

loc_236CE:		; CODE XREF: sub_236B9:loc_236C7j
mov	[bp+var_2], 0
mov	si, [cs:word_236B5]

loc_236D8:
mov	di, [cs:word_236B7]

loc_236DD:
mov	cx, 9

loc_236E0:		; CODE XREF: sub_236B9+5Ej
mov	ax, si
mov	bx, si
mov	dx, di
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
xor	ax, bx		; Logical Exclusive OR
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
xor	ax, bx		; Logical Exclusive OR
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
xor	ax, bx		; Logical Exclusive OR
shr	dx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	dx, 1		; Shift	Logical	Right

loc_23702:		; Rotate Through Carry Right
rcr	bx, 1
xor	ax, bx		; Logical Exclusive OR
shr	dx, 1		; Shift	Logical	Right
xor	al, dh		; Logical Exclusive OR

loc_2370A:
mov	dx, ax
shr	dx, 1		; Shift	Logical	Right

loc_2370E:		; Rotate Through Carry Left
rcl	[bp+var_2], 1
shr	ax, 1		; Shift	Logical	Right
rcr	di, 1		; Rotate Through Carry Right
rcr	si, 1		; Rotate Through Carry Right
loop	loc_236E0	; Loop while CX	!= 0
cmp	si, 0		; Compare Two Operands
jnz	short loc_23726	; Jump if Not Zero (ZF=0)

loc_2371E:		; Compare Two Operands
cmp	di, 0
jnz	short loc_23726	; Jump if Not Zero (ZF=0)

loc_23723:
mov	si, 30BEh

loc_23726:		; CODE XREF: sub_236B9+63j
			; sub_236B9+68j
mov	[cs:word_236B5], si

loc_2372B:
mov	[cs:word_236B7], di
mov	ax, si

loc_23732:		; Logical AND
and	ax, 3FFh

loc_23735:		; CODE XREF: sub_236B9:loc_2373Dj
cmp	ax, [bp+arg_0]	; Compare Two Operands

loc_23738:		; Jump if Below	(CF=1)
jb	short loc_2373F

loc_2373A:		; Integer Subtraction
sub	ax, [bp+arg_0]

loc_2373D:		; Jump
jmp	short loc_23735

loc_2373F:		; CODE XREF: sub_236B9:loc_23738j
pop	es

loc_23740:
pop	si

loc_23741:
pop	di

loc_23742:
pop	ds

loc_23743:
mov	sp, bp

loc_23745:
pop	bp

locret_23746:		; Return Far from Procedure
retf
endp sub_236B9

ends seg031


; Segment type:	Pure code
segment	seg032 byte public 'CODE' use16
assume cs:seg032
;org 8
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
byte_23748 db 0, 4, 8, 0Dh, 11h, 16h, 1Ah, 1Fh,	23h
db 28h,	2Dh, 31h, 36h, 3Bh, 3Fh, 44h, 49h
db 4Eh,	53h, 58h, 5Dh, 62h, 67h, 6Ch, 71h
db 77h,	7Ch, 82h, 88h, 8Dh, 93h, 99h, 9Fh
db 0A6h, 0ACh, 0B3h, 0B9h, 0C0h, 0C8h, 0CFh
db 0D6h, 0DEh, 0E6h, 0EEh, 0F7h, 2 dup(0)
db 77h,	4, 0EFh, 8, 65h, 0Dh, 0DBh, 11h
db 4Fh,	16h, 0C2h, 1Ah,	32h, 1Fh, 0A0h,	23h
db 0Ch,	28h, 74h, 2Ch, 0D8h, 30h, 39h, 35h
db 96h,	39h, 0EEh, 3Dh,	2 dup(42h), 90h
db 46h,	0D8h, 4Ah, 1Bh,	4Fh, 58h, 53h, 8Eh
db 57h,	0BEh, 5Bh, 0E6h, 5Fh, 7, 64h, 1Fh
db 68h,	30h, 6Ch, 39h, 70h, 38h, 74h, 2Fh
db 78h,	1Ch, 7Ch, 0, 80h, 0D9h,	83h, 0A8h
db 87h,	6Dh, 8Bh, 27h, 8Fh, 0D5h, 92h, 79h
db 96h,	10h, 9Ah, 9Ch, 9Dh, 1Bh, 0A1h, 8Dh
db 0A4h, 0F3h, 0A7h, 4Ch, 0ABh,	97h, 0AEh
db 0D5h, 0B1h, 5, 0B5h,	26h, 0B8h, 3Ah,	0BBh
db 3Eh,	0BEh, 34h, 0C1h, 1Bh, 0C4h, 0F3h
db 0C6h, 0BBh, 0C9h, 73h, 0CCh,	1Bh, 0CFh
db 0B4h, 0D1h, 3Bh, 0D4h, 0B3h,	0D6h, 19h
db 0D9h, 6Fh, 0DBh, 0B3h, 0DDh,	0E7h, 0DFh
db 8, 0E2h, 19h, 0E4h, 17h, 0E6h, 3, 0E8h
db 0DEh, 0E9h, 0A6h, 0EBh, 5Bh,	0EDh, 0FFh
db 0EEh, 8Fh, 0F0h, 0Dh, 0F2h, 78h, 0F3h
db 0D0h, 0F4h, 15h, 0F6h, 46h, 0F7h, 65h
db 0F8h, 70h, 0F9h, 67h, 0FAh, 4Bh, 0FBh
db 1Ch,	0FCh, 0D9h, 0FCh, 82h, 0FDh, 17h
db 0FEh, 99h, 0FEh, 6, 0FFh, 60h, 0FFh,	0A6h
db 0FFh, 0D8h, 0FFh, 0F6h, 0FFh, 0, 1, 9
db 1, 12h, 1, 1Ch, 1, 26h, 1, 31h, 1, 3Ch
db 1, 47h, 1, 53h, 1, 60h, 1, 6Dh, 1, 7Bh
db 1, 8Ah, 1, 99h, 1, 0AAh, 1, 0BBh, 1,	0CDh
db 1, 0E1h, 1, 0F6h, 1,	0Ch, 2,	24h, 2,	3Eh
db 2, 5Bh, 2, 79h, 2, 9Ah, 2, 0BFh, 2, 0E7h
db 2, 13h, 3, 45h, 3, 7Ch, 3, 0BBh, 3, 2
db 4, 54h, 4, 0B4h, 4, 25h, 5, 0ABh, 5,	50h
db 6, 1Dh, 7, 25h, 8, 83h, 9, 6Eh, 0Bh,	4Dh
db 0Eh,	15h, 13h, 0A3h,	1Ch, 4Dh, 39h, 0F6h
db 0FFh, 0D8h, 0FFh, 0A6h, 0FFh, 60h, 0FFh
db 6, 0FFh, 98h, 0FEh, 17h, 0FEh, 82h, 0FDh
db 0D9h, 0FCh, 1Ch, 0FCh, 4Bh, 0FBh, 67h
db 0FAh, 70h, 0F9h, 65h, 0F8h, 46h, 0F7h
db 15h,	0F6h, 0D0h, 0F4h, 78h, 0F3h, 0Dh
db 0F2h, 8Fh, 0F0h, 0FFh, 0EEh,	5Bh, 0EDh
db 0A6h, 0EBh, 0DEh, 0E9h, 3, 0E8h, 17h
db 0E6h, 18h, 0E4h, 8, 0E2h, 0E7h, 0DFh
db 0B3h, 0DDh, 6Fh, 0DBh, 19h, 0D9h, 0B3h
db 0D6h, 3Bh, 0D4h, 0B3h, 0D1h,	1Bh, 0CFh
db 73h,	0CCh, 0BBh, 0C9h, 0F2h,	0C6h, 1Bh
db 0C4h, 34h, 0C1h, 3Eh, 0BEh, 39h, 0BBh
db 26h,	0B8h, 4, 0B5h, 0D5h, 0B1h, 97h,	0AEh
db 4Ch,	0ABh, 0F3h, 0A7h, 8Dh, 0A4h, 1Bh
db 0A1h, 9Bh, 9Dh, 10h,	9Ah, 78h, 96h, 0D5h
db 92h,	27h, 8Fh, 6Dh, 8Bh, 0A8h, 87h, 0D9h
db 83h,	0FFh, 7Fh, 1Ch,	7Ch, 2Fh, 78h, 38h
db 74h,	38h, 70h, 30h, 6Ch, 1Fh, 68h, 6
db 64h,	0E6h, 5Fh, 0BDh, 5Bh, 8Eh, 57h,	58h
db 53h,	1Bh, 4Fh, 0D8h,	4Ah, 8Fh, 46h, 41h
db 42h,	0EEh, 3Dh, 96h,	2 dup(39h), 35h
db 0D8h, 30h, 73h, 2Ch,	0Bh, 28h, 0A0h,	23h
db 32h,	1Fh, 0C2h, 1Ah,	4Fh, 16h, 0DBh,	11h
db 65h,	0Dh, 0EEh, 8, 77h, 4, 2	dup(0)


; Attributes: bp-based frame

proc sub_23937 far	; CODE XREF: sub_1D5DE:loc_1D64BP
			; sub_20C7A+53P

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	es
push	ds
push	si
push	di

loc_2393E:
mov	bx, [bp+arg_0]
mov	ax, [bp+arg_2]
cmp	bx, 0		; Compare Two Operands
js	short loc_23969	; Jump if Sign (SF=1)
cmp	ax, 0		; Compare Two Operands
jns	short loc_23960	; Jump if Not Sign (SF=0)
neg	ax		; Two's Complement Negation
call	sub_23990	; Call Procedure

loc_23953:
mov	bx, 168h

loc_23956:		; Integer Subtraction
sub	bx, ax
mov	ax, bx
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure

loc_23960:		; CODE XREF: sub_23937+15j
call	sub_23990	; Call Procedure
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure

loc_23969:		; CODE XREF: sub_23937+10j
cmp	ax, 0		; Compare Two Operands

loc_2396C:		; Jump if Not Sign (SF=0)
jns	short loc_2397E
neg	ax		; Two's Complement Negation

loc_23970:		; Two's Complement Negation
neg	bx
call	sub_23990	; Call Procedure
add	ax, 0B4h ; ''  ; Add
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure

loc_2397E:		; CODE XREF: sub_23937:loc_2396Cj
neg	bx		; Two's Complement Negation

loc_23980:		; Call Procedure
call	sub_23990
mov	bx, 0B4h ; ''

loc_23986:		; Integer Subtraction
sub	bx, ax
mov	ax, bx
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp sub_23937




proc sub_23990 near	; CODE XREF: sub_23937+19p
			; sub_23937:loc_23960p
			; sub_23937+3Bp
			; sub_23937:loc_23980p
push	es
push	ds
push	si
push	di
xor	dh, dh		; Logical Exclusive OR
mov	dl, ah
mov	ah, al
xor	al, al		; Logical Exclusive OR

loc_2399C:		; Compare Two Operands
cmp	bx, 0
jz	short loc_23A06	; Jump if Zero (ZF=1)
div	bx		; Unsigned Divide
mov	bx, ax
mov	ax, ds
mov	es, ax
assume es:dseg

loc_239A9:
mov	ax, cs
mov	ds, ax
assume ds:seg032
cmp	bh, 0		; Compare Two Operands
jnz	short loc_239EF	; Jump if Not Zero (ZF=0)
cmp	bl, 67h	; 'g'   ; Compare Two Operands
jb	short loc_239D3	; Jump if Below	(CF=1)
mov	si, 1Eh
mov	cx, 17h

loc_239BD:
mov	di, 16h

loc_239C0:		; CODE XREF: sub_23990+36j
lodsb			; Load String
cmp	bl, al		; Compare Two Operands
jb	short loc_239CB	; Jump if Below	(CF=1)
inc	di		; Increment by 1
loop	loc_239C0	; Loop while CX	!= 0
mov	di, 2Ch	; ','

loc_239CB:		; CODE XREF: sub_23990+33j
dec	di		; Decrement by 1
mov	ax, di
pop	di
pop	si
pop	ds
assume ds:dseg
pop	es
assume es:nothing
retn			; Return Near from Procedure

loc_239D3:		; CODE XREF: sub_23990+25j
mov	si, 8
mov	cx, 16h
mov	di, 0

loc_239DC:		; CODE XREF: sub_23990+52j
lodsb			; Load String
cmp	bl, al		; Compare Two Operands
jb	short loc_239E7	; Jump if Below	(CF=1)
inc	di		; Increment by 1
loop	loc_239DC	; Loop while CX	!= 0
mov	di, 16h

loc_239E7:		; CODE XREF: sub_23990+4Fj
dec	di		; Decrement by 1
mov	ax, di
pop	di
pop	si
pop	ds
pop	es
retn			; Return Near from Procedure

loc_239EF:		; CODE XREF: sub_23990+20j
cmp	bx, 25Bh	; Compare Two Operands
jb	short loc_23A19	; Jump if Below	(CF=1)

loc_239F5:
mov	si, 115h

loc_239F8:
mov	cx, 17h
mov	di, 0

loc_239FE:		; CODE XREF: sub_23990+74j
lodsw			; Load String

loc_239FF:		; Compare Two Operands
cmp	bx, ax
jb	short loc_23A0E	; Jump if Below	(CF=1)
inc	di		; Increment by 1
loop	loc_239FE	; Loop while CX	!= 0

loc_23A06:		; CODE XREF: sub_23990+Fj
mov	ax, 5Ah	; 'Z'
pop	di
pop	si
pop	ds
pop	es
retn			; Return Near from Procedure

loc_23A0E:		; CODE XREF: sub_23990+71j
dec	di		; Decrement by 1
mov	ax, di
add	ax, 43h	; 'C'   ; Add
pop	di
pop	si
pop	ds
pop	es
retn			; Return Near from Procedure

loc_23A19:		; CODE XREF: sub_23990+63j
mov	si, 0E9h ; ''

loc_23A1C:
mov	cx, 16h
mov	di, 0

loc_23A22:		; CODE XREF: sub_23990+98j
lodsw			; Load String
cmp	bx, ax		; Compare Two Operands
jb	short loc_23A32	; Jump if Below	(CF=1)
inc	di		; Increment by 1
loop	loc_23A22	; Loop while CX	!= 0

loc_23A2A:
mov	ax, 42h	; 'B'
pop	di
pop	si
pop	ds
pop	es
retn			; Return Near from Procedure

loc_23A32:		; CODE XREF: sub_23990+95j
dec	di		; Decrement by 1

loc_23A33:
mov	ax, di
add	ax, 2Dh	; '-'   ; Add
pop	di
pop	si
pop	ds
pop	es
retn			; Return Near from Procedure
endp sub_23990



; Attributes: bp-based frame

proc sub_23A3D far	; CODE XREF: sub_1D5DE:loc_1D662P
			; sub_1D5DE:loc_1D67FP
			; sub_20C7A:loc_20CEFP
			; sub_20C7A:loc_20D4AP
			; sub_20C7A:loc_20D7CP
			; sub_20DB5:loc_20E33P
			; sub_20DB5:loc_20E6BP
			; sub_20DB5:loc_20EACP
			; sub_20DB5:loc_20EE7P
			; sub_20DB5+173P
			; sub_20DB5+1AEP
			; sub_20DB5+1EFP
			; sub_20DB5+22AP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp

loc_23A40:
push	es
push	ds

loc_23A42:
push	si
push	di
mov	bx, [bp+arg_2]
mov	dx, 0

loc_23A4A:
mov	ax, [bp+arg_0]
cmp	ax, 5Bh	; '['   ; Compare Two Operands

loc_23A50:		; Jump if Sign (SF=1)
js	short loc_23A7C
cmp	ax, 0B5h ; ''  ; Compare Two Operands
js	short loc_23A6F	; Jump if Sign (SF=1)
cmp	ax, 10Fh	; Compare Two Operands
js	short loc_23A66	; Jump if Sign (SF=1)
mov	cx, 168h
sub	cx, ax		; Integer Subtraction
mov	ax, cx
jmp	short loc_23A7C	; Jump
align 2

loc_23A66:		; CODE XREF: sub_23A3D+1Dj
sub	ax, 0B4h ; ''  ; Integer Subtraction
mov	dx, 1
jmp	short loc_23A7C	; Jump
db 90h

loc_23A6F:		; CODE XREF: sub_23A3D+18j
mov	cx, 0B4h ; ''
sub	cx, ax		; Integer Subtraction
mov	ax, cx

loc_23A76:
mov	dx, 1
jmp	short loc_23A7C	; Jump
align 2

loc_23A7C:		; CODE XREF: sub_23A3D:loc_23A50j
			; sub_23A3D+26j
			; sub_23A3D+2Fj
			; sub_23A3D+3Cj
mov	cx, dx
mov	si, ax

loc_23A80:		; Compare Two Operands
cmp	si, 0
jz	short loc_23ABC	; Jump if Zero (ZF=1)
dec	si		; Decrement by 1
shl	si, 1		; Shift	Logical	Left
mov	ax, cs
mov	ds, ax
assume ds:seg032
add	si, 143h	; Add

loc_23A90:		; Load String
lodsw
cmp	bx, 0		; Compare Two Operands
js	short loc_23AA7	; Jump if Sign (SF=1)
mul	bx		; Unsigned Multiplication of AL	or AX
mov	ax, dx
cmp	cx, 0		; Compare Two Operands
jz	short loc_23AA1	; Jump if Zero (ZF=1)

loc_23A9F:		; Two's Complement Negation
neg	ax

loc_23AA1:		; CODE XREF: sub_23A3D+60j
			; sub_23A3D+75j
			; sub_23A3D+84j
pop	di
pop	si
pop	ds
assume ds:dseg
pop	es
pop	bp
retf			; Return Far from Procedure

loc_23AA7:		; CODE XREF: sub_23A3D+57j
neg	bx		; Two's Complement Negation
mul	bx		; Unsigned Multiplication of AL	or AX
mov	ax, dx

loc_23AAD:		; Two's Complement Negation
neg	ax
cmp	cx, 0		; Compare Two Operands
jz	short loc_23AA1	; Jump if Zero (ZF=1)
neg	ax		; Two's Complement Negation
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure

loc_23ABC:		; CODE XREF: sub_23A3D+46j
mov	ax, bx
cmp	cx, 0		; Compare Two Operands
jz	short loc_23AA1	; Jump if Zero (ZF=1)
neg	ax		; Two's Complement Negation
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp sub_23A3D



; Attributes: bp-based frame

proc sub_23ACB far	; CODE XREF: sub_1D5DE+C3P
			; sub_1D5DE:loc_1D6BEP
			; sub_20C7A+88P
			; sub_20C7A:loc_20D31P
			; sub_20C7A:loc_20D64P
			; sub_20DB5:loc_20E4FP
			; sub_20DB5+D0P
			; sub_20DB5+113P
			; sub_20DB5+14CP
			; sub_20DB5+18FP
			; sub_20DB5+1C8P
			; sub_20DB5+20BP
			; sub_20DB5+244P

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	es
push	ds
push	si
push	di

loc_23AD2:
mov	bx, [bp+arg_2]

loc_23AD5:
mov	dx, 0

loc_23AD8:
mov	ax, [bp+arg_0]
cmp	ax, 5Bh	; '['   ; Compare Two Operands

loc_23ADE:		; Jump if Sign (SF=1)
js	short loc_23B0A
cmp	ax, 0B5h ; ''  ; Compare Two Operands
js	short loc_23B00	; Jump if Sign (SF=1)
cmp	ax, 10Fh	; Compare Two Operands

loc_23AE8:		; Jump if Sign (SF=1)
js	short loc_23AF7
mov	cx, 168h
sub	cx, ax		; Integer Subtraction
mov	ax, cx
mov	dx, 1
jmp	short loc_23B0A	; Jump
db 90h

loc_23AF7:		; CODE XREF: sub_23ACB:loc_23AE8j
sub	ax, 0B4h ; ''  ; Integer Subtraction
mov	dx, 1
jmp	short loc_23B0A	; Jump
algn_23AFF:
align 2

loc_23B00:		; CODE XREF: sub_23ACB+18j
mov	cx, 0B4h ; ''

loc_23B03:		; Integer Subtraction
sub	cx, ax

loc_23B05:
mov	ax, cx
jmp	short loc_23B0A	; Jump
align 2

loc_23B0A:		; CODE XREF: sub_23ACB:loc_23ADEj
			; sub_23ACB+29j
			; sub_23ACB+32j
			; sub_23ACB+3Cj
mov	cx, dx
mov	si, ax

loc_23B0E:		; Compare Two Operands
cmp	si, 5Ah	; 'Z'
jz	short loc_23B49	; Jump if Zero (ZF=1)
shl	si, 1		; Shift	Logical	Left
mov	ax, cs
mov	ds, ax
assume ds:seg032

loc_23B19:		; Add
db 81h,0C6h,35h,0 ; <BAD>add	 si, 35h ; '5'

loc_23B1D:		; Load String
lodsw

loc_23B1E:		; Compare Two Operands
cmp	bx, 0
js	short loc_23B34	; Jump if Sign (SF=1)
mul	bx		; Unsigned Multiplication of AL	or AX
mov	ax, dx

loc_23B27:		; Compare Two Operands
cmp	cx, 0
jz	short loc_23B2E	; Jump if Zero (ZF=1)
neg	ax		; Two's Complement Negation

loc_23B2E:		; CODE XREF: sub_23ACB+5Fj
			; sub_23ACB+74j
			; sub_23ACB+84j
pop	di
pop	si
pop	ds
assume ds:dseg

loc_23B31:
pop	es
pop	bp
retf			; Return Far from Procedure

loc_23B34:		; CODE XREF: sub_23ACB+56j
neg	bx		; Two's Complement Negation
mul	bx		; Unsigned Multiplication of AL	or AX
mov	ax, dx
neg	ax		; Two's Complement Negation
cmp	cx, 0		; Compare Two Operands
jz	short loc_23B2E	; Jump if Zero (ZF=1)

loc_23B41:		; Two's Complement Negation
neg	ax
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure

loc_23B49:		; CODE XREF: sub_23ACB+46j
mov	ax, [bp+arg_2]
cmp	cx, 0		; Compare Two Operands
jz	short loc_23B2E	; Jump if Zero (ZF=1)
neg	ax		; Two's Complement Negation
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp sub_23ACB

word_23B59 dw 0		; DATA XREF: sub_23B75:loc_23BEDw
			; sub_23B75+114r
			; sub_23B75:loc_23C9Bw
			; sub_23CF1+7Ew
			; sub_23CF1:loc_23E5Fr
			; sub_23CF1:loc_23E71w
word_23B5B dw 0		; DATA XREF: sub_23B75+94w
			; sub_23B75:loc_23C18r
			; sub_23B75+12Br
			; sub_23B75+133w
			; sub_23CF1:loc_23D8Bw
			; sub_23CF1:loc_23DBBr
			; sub_23CF1:loc_23E76r
			; sub_23CF1+18Dw
word_23B5D dw 0		; DATA XREF: sub_23B75+7Fw
			; sub_23B75+13Br
			; sub_23B75:loc_23CC2w
			; sub_23CF1+85w
			; sub_23CF1:loc_23E86r
			; sub_23CF1:loc_23E98w
word_23B5F dw 0		; DATA XREF: sub_23B75+86w
			; sub_23B75+152r
			; sub_23B75:loc_23CD9w
			; sub_23CF1:loc_23D7Dw
			; sub_23CF1:loc_23E9Dr
			; sub_23CF1:loc_23EAFw
db 4 dup(0)
word_23B65 dw 0		; DATA XREF: sub_23B75+1Fw
			; sub_23B75:loc_23C62r
			; sub_23CF1:loc_23D10w
			; sub_23CF1:loc_23E09r
word_23B67 dw 0		; DATA XREF: sub_23B75:loc_23B9Bw
			; sub_23B75+F9r
			; sub_23CF1+26w
			; sub_23CF1+124r
word_23B69 dw 0		; DATA XREF: sub_23B75+2Dw
			; sub_23B75+DCr
			; sub_23CF1+2Dw
			; sub_23CF1+107r
word_23B6B dw 0		; DATA XREF: sub_23B75:loc_23BA9w
			; sub_23B75+E8r
			; sub_23CF1:loc_23D25w
			; sub_23CF1+113r
word_23B6D dw 0		; DATA XREF: sub_23B75:loc_23BB0w
			; sub_23B75:loc_23C4Cr
			; sub_23CF1+3Bw
			; sub_23CF1+102r
word_23B6F dw 0		; DATA XREF: sub_23B75:loc_23B7Fw
			; sub_23B75:loc_23C10r
			; sub_23B75:loc_23C75w
			; sub_23CF1+Aw
			; sub_23CF1+A1r
			; sub_23CF1:loc_23E4Bw
word_23B71 dw 0		; DATA XREF: sub_23B75:loc_23B86w
			; sub_23B75+C4r
			; sub_23CF1+11w
			; sub_23CF1+EBr
word_23B73 dw 0		; DATA XREF: sub_23B75+18w
			; sub_23B75+CBr
			; sub_23CF1+18w
			; sub_23CF1+F2r


; Attributes: bp-based frame

proc sub_23B75 far	; CODE XREF: idk_VidLib_s1FBBF+461P
			; idk_VidLib_s1FBBF:loc_20563P
			; idk_VidLib_s1FBBF+CE7P
			; idk_VidLib_s1FBBF+1034P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh
arg_1A=	word ptr  20h
arg_1C=	word ptr  22h
arg_1E=	word ptr  24h
arg_20=	word ptr  26h
arg_22=	word ptr  28h
arg_24=	word ptr  2Ah
arg_26=	word ptr  2Ch
arg_28=	word ptr  2Eh
arg_2A=	word ptr  30h
arg_2C=	word ptr  32h

push	bp
mov	bp, sp
push	es
push	ds
push	si
push	di
mov	ax, [bp+arg_28]

loc_23B7F:
mov	[cs:word_23B6F], ax
mov	ax, [bp+arg_2A]

loc_23B86:
mov	[cs:word_23B71], ax
mov	ax, [bp+arg_2C]
mov	[cs:word_23B73], ax
mov	ax, [bp+arg_20]
mov	[cs:word_23B65], ax
mov	ax, [bp+arg_22]

loc_23B9B:
mov	[cs:word_23B67], ax

loc_23B9F:
mov	ax, [bp+arg_24]
mov	[cs:word_23B69], ax
mov	ax, [bp+arg_26]

loc_23BA9:
mov	[cs:word_23B6B], ax

loc_23BAD:
mov	ax, [bp+arg_1E]

loc_23BB0:
mov	[cs:word_23B6D], ax
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	ax, [g_ptrVideoRamBuffer]

loc_23BBD:
mov	es, ax
mov	cx, [bp+arg_2]
mov	ax, cx

loc_23BC4:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
add	cx, ax		; Add
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_23BCE:		; Shift	Logical	Left
shl	cx, 1
shl	cx, 1		; Shift	Logical	Left
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right

loc_23BD9:		; Shift	Logical	Right
shr	bx, 1
add	bx, cx		; Add
mov	di, bx
and	ax, 3		; Logical AND
mov	si, 4386h
add	si, ax		; Add
lodsb			; Load String
mov	ah, al
mov	si, [bp+arg_10]

loc_23BED:
mov	[cs:word_23B59], 80h ; ''
mov	[cs:word_23B5D], 80h ; ''
mov	[cs:word_23B5F], 80h ; ''
mov	cx, [bp+arg_6]
mov	ch, cl

loc_23C07:		; Logical Exclusive OR
xor	cl, cl
mov	[cs:word_23B5B], cx

loc_23C0E:		; CODE XREF: sub_23B75:loc_23CE8j
push	di
push	si

loc_23C10:		; Compare Two Operands
cmp	[cs:word_23B6F], 0
jns	short loc_23C75	; Jump if Not Sign (SF=0)

loc_23C18:
mov	cx, [cs:word_23B5B]
mov	cl, ch
xor	ch, ch		; Logical Exclusive OR

loc_23C21:
mov	dx, 3C5h
mov	al, ah

loc_23C26:		; EGA port: sequencer data register
out	dx, al

loc_23C27:
mov	dx, [bp+arg_12]

loc_23C2A:
mov	ds, dx
mov	dx, 0
mov	bx, 0

loc_23C32:		; CODE XREF: sub_23B75:loc_23C73j
lodsb			; Load String
dec	si		; Decrement by 1
inc	di		; Increment by 1
cmp	al, 0		; Compare Two Operands
jz	short loc_23C49	; Jump if Zero (ZF=1)
cmp	di, [cs:word_23B71] ; Compare Two Operands
jb	short loc_23C49	; Jump if Below	(CF=1)
cmp	di, [cs:word_23B73] ; Compare Two Operands
jnb	short loc_23C49	; Jump if Not Below (CF=0)
dec	di		; Decrement by 1
stosb			; Store	String

loc_23C49:		; CODE XREF: sub_23B75+C2j
			; sub_23B75+C9j
			; sub_23B75+D0j
add	di, 4Fh	; 'O'   ; Add

loc_23C4C:		; Add
add	si, [cs:word_23B6D]
add	dx, [cs:word_23B69] ; Add
cmp	dh, 0		; Compare Two Operands
jz	short loc_23C62	; Jump if Zero (ZF=1)
xor	dh, dh		; Logical Exclusive OR
add	si, [cs:word_23B6B] ; Add

loc_23C62:		; CODE XREF: sub_23B75+E4j
add	bx, [cs:word_23B65] ; Add
cmp	bh, 0		; Compare Two Operands

loc_23C6A:		; Jump if Zero (ZF=1)
jz	short loc_23C73
xor	bh, bh		; Logical Exclusive OR
add	si, [cs:word_23B67] ; Add

loc_23C73:		; CODE XREF: sub_23B75:loc_23C6Aj
loop	loc_23C32	; Loop while CX	!= 0

loc_23C75:		; CODE XREF: sub_23B75+A1j
dec	[cs:word_23B6F]	; Decrement by 1
pop	si
pop	di
mov	cx, seg	dseg

loc_23C7F:
mov	ds, cx
dec	[bp+arg_4]	; Decrement by 1
jz	short loc_23CEB	; Jump if Zero (ZF=1)
add	di, [bp+arg_A]	; Add
mov	cx, [cs:word_23B59]
add	cx, [bp+arg_C]	; Add
cmp	ch, 0		; Compare Two Operands
jz	short loc_23C9B	; Jump if Zero (ZF=1)
xor	ch, ch		; Logical Exclusive OR
add	di, [bp+arg_E]	; Add

loc_23C9B:		; CODE XREF: sub_23B75+11Fj
mov	[cs:word_23B59], cx
mov	cx, [cs:word_23B5B]
add	cx, [bp+arg_8]	; Add
mov	[cs:word_23B5B], cx
add	si, [bp+arg_14]	; Add
mov	cx, [cs:word_23B5D]
add	cx, [bp+arg_1A]	; Add

loc_23CB8:		; Compare Two Operands
cmp	ch, 0

loc_23CBB:		; Jump if Zero (ZF=1)
jz	short loc_23CC2

loc_23CBD:		; Logical Exclusive OR
xor	ch, ch
add	si, [bp+arg_1C]	; Add

loc_23CC2:		; CODE XREF: sub_23B75:loc_23CBBj
mov	[cs:word_23B5D], cx
mov	cx, [cs:word_23B5F]
add	cx, [bp+arg_16]	; Add

loc_23CCF:		; Compare Two Operands
cmp	ch, 0
jz	short loc_23CD9	; Jump if Zero (ZF=1)
xor	ch, ch		; Logical Exclusive OR
add	si, [bp+arg_18]	; Add

loc_23CD9:		; CODE XREF: sub_23B75+15Dj
mov	[cs:word_23B5F], cx
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_23CE8	; Jump if Sign (SF=1)
mov	ah, 1
inc	di		; Increment by 1

loc_23CE8:		; CODE XREF: sub_23B75+16Ej
jmp	loc_23C0E	; Jump

loc_23CEB:		; CODE XREF: sub_23B75+10Fj
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
endp sub_23B75



; Attributes: bp-based frame

proc sub_23CF1 far	; CODE XREF: idk_VidLib_s1FBBF+4BAP
			; idk_VidLib_s1FBBF+9FDP
			; idk_VidLib_s1FBBF+D40P
			; idk_VidLib_s1FBBF:loc_20C4CP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh
arg_1A=	word ptr  20h
arg_1C=	word ptr  22h
arg_1E=	word ptr  24h
arg_20=	word ptr  26h
arg_22=	word ptr  28h
arg_24=	word ptr  2Ah
arg_26=	word ptr  2Ch
arg_28=	word ptr  2Eh
arg_2A=	word ptr  30h
arg_2C=	word ptr  32h

push	bp
mov	bp, sp
push	es
push	ds
push	si
push	di

loc_23CF8:
mov	ax, [bp+arg_28]
mov	[cs:word_23B6F], ax

loc_23CFF:
mov	ax, [bp+arg_2A]
mov	[cs:word_23B71], ax
mov	ax, [bp+arg_2C]
mov	[cs:word_23B73], ax
mov	ax, [bp+arg_20]

loc_23D10:
mov	[cs:word_23B65], ax
mov	ax, [bp+arg_22]
mov	[cs:word_23B67], ax

loc_23D1B:
mov	ax, [bp+arg_24]
mov	[cs:word_23B69], ax
mov	ax, [bp+arg_26]

loc_23D25:
mov	[cs:word_23B6B], ax
mov	ax, [bp+arg_1E]
mov	[cs:word_23B6D], ax
mov	ax, [g_ptrVideoRamBuffer]
mov	es, ax
mov	cx, [bp+arg_2]
mov	ax, cx
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left

loc_23D3E:		; Add
add	cx, ax
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
shl	cx, 1		; Shift	Logical	Left
mov	ax, [bp+arg_0]
mov	bx, ax
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
add	bx, cx		; Add
mov	di, bx
and	ax, 3		; Logical AND
mov	bl, al
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left
shl	bl, 1		; Shift	Logical	Left

loc_23D60:		; Shift	Logical	Left
shl	bl, 1

loc_23D62:
mov	si, offset unk_36096
add	si, ax		; Add
lodsb			; Load String
mov	ah, al

loc_23D6A:		; Logical Inclusive OR
or	ah, bl
mov	si, [bp+arg_10]
mov	[cs:word_23B59], 80h ; ''
mov	[cs:word_23B5D], 80h ; ''

loc_23D7D:
mov	[cs:word_23B5F], 80h ; ''
mov	cx, [bp+arg_6]
mov	ch, cl
xor	cl, cl		; Logical Exclusive OR

loc_23D8B:
mov	[cs:word_23B5B], cx

loc_23D90:		; CODE XREF: sub_23CF1:loc_23ECDj
push	di
push	si
cmp	[cs:word_23B6F], 0 ; Compare Two Operands
js	short loc_23D9D	; Jump if Sign (SF=1)
jmp	loc_23E4B	; Jump

loc_23D9D:		; CODE XREF: sub_23CF1+A7j
mov	dx, 3CEh

loc_23DA0:
mov	al, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	al, ah
shr	al, 1		; Shift	Logical	Right
shr	al, 1		; Shift	Logical	Right
shr	al, 1		; Shift	Logical	Right
shr	al, 1		; Shift	Logical	Right
out	dx, al		; EGA port: graphics controller	data register
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	al, ah
and	al, 0Fh		; Logical AND
out	dx, al		; EGA port: sequencer data register

loc_23DBB:
mov	cx, [cs:word_23B5B]
mov	cl, ch
xor	ch, ch		; Logical Exclusive OR
mov	dx, 3C5h
mov	al, ah

loc_23DC9:		; EGA port: sequencer data register
out	dx, al
mov	dx, [bp+arg_12]
mov	ds, dx
mov	dx, 0
mov	bx, 0

loc_23DD5:		; CODE XREF: sub_23CF1:loc_23E1Aj
lodsb			; Load String
dec	si		; Decrement by 1
inc	di		; Increment by 1
cmp	al, 0		; Compare Two Operands
jz	short loc_23DF0	; Jump if Zero (ZF=1)
cmp	di, [cs:word_23B71] ; Compare Two Operands
jb	short loc_23DF0	; Jump if Below	(CF=1)
cmp	di, [cs:word_23B73] ; Compare Two Operands
jnb	short loc_23DF0	; Jump if Not Below (CF=0)
dec	di		; Decrement by 1
cmp	al, 0E8h ; ''  ; Compare Two Operands
jnb	short loc_23E1F	; Jump if Not Below (CF=0)

loc_23DEF:		; Store	String
stosb

loc_23DF0:		; CODE XREF: sub_23CF1+E9j
			; sub_23CF1+F0j
			; sub_23CF1+F7j
			; sub_23CF1+158j
add	di, 4Fh	; 'O'   ; Add
add	si, [cs:word_23B6D] ; Add
add	dx, [cs:word_23B69] ; Add
cmp	dh, 0		; Compare Two Operands
jz	short loc_23E09	; Jump if Zero (ZF=1)
xor	dh, dh		; Logical Exclusive OR
add	si, [cs:word_23B6B] ; Add

loc_23E09:		; CODE XREF: sub_23CF1+10Fj
add	bx, [cs:word_23B65] ; Add
cmp	bh, 0		; Compare Two Operands
jz	short loc_23E1A	; Jump if Zero (ZF=1)
xor	bh, bh		; Logical Exclusive OR
add	si, [cs:word_23B67] ; Add

loc_23E1A:		; CODE XREF: sub_23CF1+120j
loop	loc_23DD5	; Loop while CX	!= 0
jmp	short loc_23E4B	; Jump
db 90h

loc_23E1F:		; CODE XREF: sub_23CF1+FCj
sub	al, 0E8h ; ''  ; Integer Subtraction
push	si
push	ds
mov	si, seg	dseg
mov	ds, si
mov	si, ax
and	si, 0FFh	; Logical AND
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
shl	si, 1		; Shift	Logical	Left
add	si, [idk_FontsLbx1_6144B] ; Add
mov	ds, si
mov	al, [es:di]
mov	si, ax

loc_23E41:		; Logical AND
and	si, 0FFh
lodsb			; Load String
pop	ds
pop	si
stosb			; Store	String
jmp	short loc_23DF0	; Jump

loc_23E4B:		; CODE XREF: sub_23CF1+A9j
			; sub_23CF1+12Bj
dec	[cs:word_23B6F]	; Decrement by 1

loc_23E50:
pop	si
pop	di
mov	cx, seg	dseg
mov	ds, cx

loc_23E57:		; Decrement by 1
dec	[bp+arg_4]
jz	short loc_23ED0	; Jump if Zero (ZF=1)
add	di, [bp+arg_A]	; Add

loc_23E5F:
mov	cx, [cs:word_23B59]
add	cx, [bp+arg_C]	; Add
cmp	ch, 0		; Compare Two Operands

loc_23E6A:		; Jump if Zero (ZF=1)
jz	short loc_23E71
xor	ch, ch		; Logical Exclusive OR

loc_23E6E:		; Add
add	di, [bp+arg_E]

loc_23E71:		; CODE XREF: sub_23CF1:loc_23E6Aj
mov	[cs:word_23B59], cx

loc_23E76:
mov	cx, [cs:word_23B5B]
add	cx, [bp+arg_8]	; Add
mov	[cs:word_23B5B], cx

loc_23E83:		; Add
add	si, [bp+arg_14]

loc_23E86:
mov	cx, [cs:word_23B5D]
add	cx, [bp+arg_1A]	; Add

loc_23E8E:		; Compare Two Operands
cmp	ch, 0

loc_23E91:		; Jump if Zero (ZF=1)
jz	short loc_23E98
xor	ch, ch		; Logical Exclusive OR
add	si, [bp+arg_1C]	; Add

loc_23E98:		; CODE XREF: sub_23CF1:loc_23E91j
mov	[cs:word_23B5D], cx

loc_23E9D:
mov	cx, [cs:word_23B5F]
add	cx, [bp+arg_16]	; Add
cmp	ch, 0		; Compare Two Operands
jz	short loc_23EAF	; Jump if Zero (ZF=1)
xor	ch, ch		; Logical Exclusive OR
add	si, [bp+arg_18]	; Add

loc_23EAF:		; CODE XREF: sub_23CF1+1B7j
mov	[cs:word_23B5F], cx

loc_23EB4:
mov	cl, ah

loc_23EB6:		; Logical AND
and	cl, 0F0h

loc_23EB9:		; Add
add	cl, 10h

loc_23EBC:		; Logical AND
and	ah, 0Fh
shl	ah, 1		; Shift	Logical	Left

loc_23EC1:		; Compare Two Operands
cmp	ah, 9

loc_23EC4:		; Jump if Sign (SF=1)
js	short loc_23ECB

loc_23EC6:
mov	cl, 0

loc_23EC8:
mov	ah, 1

loc_23ECA:		; Increment by 1
inc	di

loc_23ECB:		; CODE XREF: sub_23CF1:loc_23EC4j
or	ah, cl		; Logical Inclusive OR

loc_23ECD:		; Jump
jmp	loc_23D90

loc_23ED0:		; CODE XREF: sub_23CF1+169j
pop	di

loc_23ED1:
pop	si

loc_23ED2:
pop	ds

loc_23ED3:
pop	es

loc_23ED4:
pop	bp

locret_23ED5:		; Return Far from Procedure
retf
endp sub_23CF1

ends seg032


; Segment type:	Pure code
segment	seg033 byte public 'CODE' use16
assume cs:seg033
;org 6
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
byte_23ED6 db 0, 1Eh, 0A0h, 2 dup(0), 30h, 0A1h, 2 dup(0)
db 2Eh,	0A2h, 2	dup(0),	20h, 0A3h, 2 dup(0)
db 12h,	0A4h, 2	dup(0),	21h, 0A5h, 2 dup(0)
db 22h,	0A6h, 2	dup(0),	23h, 0A7h, 2 dup(0)
db 17h,	0A8h, 2	dup(0),	24h, 0A9h, 2 dup(0)
db 25h,	0AAh, 2	dup(0),	26h, 0ABh, 2 dup(0)
db 32h,	0ACh, 2	dup(0),	31h, 0ADh, 2 dup(0)
db 18h,	0AEh, 2	dup(0),	19h, 0AFh, 2 dup(0)
db 10h,	0B0h, 2	dup(0),	13h, 0B1h, 2 dup(0)
db 1Fh,	0B2h, 2	dup(0),	14h, 0B3h, 2 dup(0)
db 16h,	0B4h, 2	dup(0),	2Fh, 0B5h, 2 dup(0)
db 11h,	0B6h, 2	dup(0),	2Dh, 0B7h, 2 dup(0)
db 15h,	0B8h, 2	dup(0),	2Ch, 0B9h, 0


; Attributes: bp-based frame

proc wtf_s23F3E	far	; CODE XREF: _f010509_MainMenuScreen+390P
			; idk_Mouse_s2B8B1+5EP
			; sub_3CFC0+11AP
			; sub_3DBA6+152P
			; sub_3E1DE+1CDP
			; sub_3EBA0+ABP
			; sub_3F3C6+6DP
			; idk_Load_NEWGAME_LBX+3BP
			; sub_3F7D8:loc_3F866P
			; sub_3FBE0+F2P
			; sub_4067D+E8P
			; idk_BuildingWorlds+35P
			; sub_4D540:loc_4D57DP
			; sub_4D540:loc_4D596P
			; ST_LoadMusicSoundfxIntro+60P
			; idk_OVR_LoadLbxHelp:loc_55CB5P
			; sub_56450+14P
			; sub_56450:loc_565E6P

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_23F3F:
mov	bp, sp
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	cx, [bp+arg_0]
mov	[idk_Mouse_w360A8], cx
sub	ax, ax		; Integer Subtraction
mov	bx, [bp+arg_2]
mov	[idk_Mouse_w360C0], bx
dec	cx		; Decrement by 1
jz	short loc_23F74	; Jump if Zero (ZF=1)

loc_23F5A:
mov	dx, cx
mov	ax, 12

loc_23F5F:		; Unsigned Multiplication of AL	or AX
mul	dx

loc_23F61:		; Add
add	bx, ax

loc_23F63:		; CODE XREF: wtf_s23F3E+34j
sub	ax, ax		; Integer Subtraction
cmp	ax, [bx+4]	; Compare Two Operands
jnz	short loc_23F6F	; Jump if Not Zero (ZF=0)
cmp	ax, [bx+6]	; Compare Two Operands
jz	short loc_23F74	; Jump if Zero (ZF=1)

loc_23F6F:		; CODE XREF: wtf_s23F3E+2Aj
sub	bx, 12		; Integer Subtraction
loop	loc_23F63	; Loop while CX	!= 0

loc_23F74:		; CODE XREF: wtf_s23F3E+1Aj
			; wtf_s23F3E+2Fj
mov	ax, [bx+2]

loc_23F77:
mov	[idk_Mouse_w360AA], ax
mov	ax, [bx]
mov	[idk_Mouse_w3609A], ax
pop	ds

loc_23F80:
pop	bp
retf			; Return Far from Procedure
endp wtf_s23F3E



; Attributes: bp-based frame

proc idk_Mouse_s23F82 far
			; CODE XREF: sub_1E547:loc_1E5CCP
			; sub_1E547+94P
			; Mouse_InterruptCallback+86p
			; sub_24D35:loc_24D91p
			; sub_24DAE+79DP
			; rschKBD_s2669B+280P
			; sub_27913:loc_279D0P
			; sub_27A2B+20P
			; sub_27AFB+1FP
			; sub_27E4B+254P
			; sub_2B470+39BP
			; sub_2E303+1EP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_23F83:
mov	bp, sp

loc_23F85:
push	ds
push	es

loc_23F87:
mov	ax, seg	dseg

loc_23F8A:
mov	ds, ax
mov	es, ax
assume es:dseg

loc_23F8E:
mov	ax, [idk_Mouse_w3609A]
mov	[idk_Mouse_w3609C], ax

loc_23F94:
mov	bx, [idk_Mouse_w360C0]

loc_23F98:
mov	cx, [idk_Mouse_w360A8]
dec	cx		; Decrement by 1

loc_23F9D:		; Jump if Zero (ZF=1)
jz	short loc_23FCD

loc_23F9F:
mov	dx, cx
mov	ax, 12
mul	dx		; Unsigned Multiplication of AL	or AX

loc_23FA6:		; Add
add	bx, ax

loc_23FA8:		; CODE XREF: idk_Mouse_s23F82:loc_23FCBj
mov	ax, [bx+4]
cmp	[bp+arg_0], ax	; Compare Two Operands
jb	short loc_23FC8	; Jump if Below	(CF=1)

loc_23FB0:
mov	ax, [bx+6]

loc_23FB3:		; Compare Two Operands
cmp	[bp+arg_2], ax

loc_23FB6:		; Jump if Below	(CF=1)
jb	short loc_23FC8

loc_23FB8:
mov	ax, [bx+8]

loc_23FBB:		; Compare Two Operands
cmp	ax, [bp+arg_0]

loc_23FBE:		; Jump if Below	(CF=1)
jb	short loc_23FC8

loc_23FC0:
mov	ax, [bx+0Ah]
cmp	ax, [bp+arg_2]	; Compare Two Operands

loc_23FC6:		; Jump if Not Below (CF=0)
jnb	short loc_23FCD

loc_23FC8:		; CODE XREF: idk_Mouse_s23F82+2Cj
			; idk_Mouse_s23F82:loc_23FB6j
			; idk_Mouse_s23F82:loc_23FBEj
sub	bx, 12		; Integer Subtraction

loc_23FCB:		; Loop while CX	!= 0
loop	loc_23FA8

loc_23FCD:		; CODE XREF: idk_Mouse_s23F82:loc_23F9Dj
			; idk_Mouse_s23F82:loc_23FC6j
mov	ax, [bx+2]

loc_23FD0:
mov	[idk_Mouse_w360AA], ax

loc_23FD3:
mov	ax, [bx]

loc_23FD5:
mov	[idk_Mouse_w3609A], ax

loc_23FD8:
pop	es
assume es:nothing
pop	ds

loc_23FDA:
pop	bp
retf			; Return Far from Procedure
endp idk_Mouse_s23F82




proc sub_23FDC far	; CODE XREF: sub_1E525+4P
			; sub_26026+3DP
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idk_Mouse_w3609A]
pop	ds
retf			; Return Far from Procedure
endp sub_23FDC




proc idk_Get_Mouse_w360AA far
			; CODE XREF: sub_24DAE+2EP
			; sub_24DAE+7A4P
			; sub_24DAE+B54P
			; sub_26026+44P
			; rschKBD_s2669B+287P
			; sub_27913+C4P
			; sub_27A2B+27P
			; sub_27AFB+26P
			; sub_27E4B:loc_280A6P
			; sub_2B470+3A2P
push	ds

loc_23FE8:
mov	ax, seg	dseg

loc_23FEB:
mov	ds, ax

loc_23FED:
mov	ax, [idk_Mouse_w360AA]
pop	ds
retf			; Return Far from Procedure
endp idk_Get_Mouse_w360AA




proc _f330547_GetMouseButtonsStatus far
			; CODE XREF: _f020405_idk_CheckInputOrSleep_s13F7E:loc_13F99P
			; sub_24DAE+729P
			; sub_24DAE:loc_258A9P
			; sub_24DAE:loc_258E2P
			; sub_24DAE:loc_25B76P
			; sub_24DAE:loc_25B84P
			; sub_27C84:loc_27CABP
			; sub_27CC0+2EP
			; sub_27CC0:loc_27E22P
			; sub_28141:loc_2815CP
			; sub_28141+164P
			; sub_28141:loc_28541P
			; sub_28583:loc_2859EP
			; sub_28583+105P
			; sub_28583:loc_2890DP
push	es
push	ds

loc_23FF4:
mov	ax, seg	dseg

loc_23FF7:
mov	ds, ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_24015	; Jump if Zero (ZF=1)

IfMouseLeftHandedSwapButtonPressBits:
mov	ax, 3
mov	bx, 0
mov	cx, 0
mov	dx, 0
cli			; Clear	Interrupt Flag
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row

loc_2400F:		; Set Interrupt	Flag
sti

loc_24010:		; call	  swap2lowbits
and	bx, 11b
mov	ax, bx

loc_24015:		; CODE XREF: _f330547_GetMouseButtonsStatus+Cj
pop	ds

loc_24016:
pop	es
retf			; Return Far from Procedure
endp _f330547_GetMouseButtonsStatus




proc MOUSE_WaitForButtonStatus far
			; CODE XREF: MOUSE_SetupRangeRoutine+65p
			; DOS_MouseReset+11p
push	si
push	di
push	es
push	ds

LOOP:			; CODE XREF: MOUSE_WaitForButtonStatus+17j
mov	ax, 3
mov	bx, 0
mov	cx, 0
mov	dx, 0
cli			; Clear	Interrupt Flag
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row
sti			; Set Interrupt	Flag
and	bx, 11b		; Logical AND
jnz	short LOOP	; Jump if Not Zero (ZF=0)
mov	ax, bx
pop	ds
pop	es

loc_24035:
pop	di

loc_24036:
pop	si
retf			; Return Far from Procedure
endp MOUSE_WaitForButtonStatus



; Attributes: bp-based frame

proc MOUSE_SetupRangeRoutine far
			; CODE XREF: idk_Mouse_s2B8B1+65P
push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
push	es
push	ds
cli			; Clear	Interrupt Flag
mov	ax, 0
mov	bx, 0
mov	cx, 0
mov	dx, 0
int	33h		; - MS MOUSE - RESET DRIVER AND	READ STATUS
			; Return: AX = status
			; BX = number of buttons
cmp	ax, 0		; If (AX != 0) Then Set	(ZF = 1)
jnz	short CONTINUE	; Jump if Not Zero (ZF=0)

SKIP:			; Set Interrupt	Flag
sti
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

CONTINUE:		; CODE XREF: MOUSE_SetupRangeRoutine+1Cj
mov	ax, 3
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row
mov	[FLAG_MouseLeftHanded],	1
mov	[FLAG_Mouse_Skip], 0
mov	dx, [word_360BC]
mov	cx, [word_360BA]
mov	[idk_Mouse_w360A4], cx
mov	[idk_Mouse_w360A6], dx
mov	ax, 7
mov	bx, 0
mov	cx, 0
mov	dx, 638
int	33h		; - MS MOUSE - DEFINE HORIZONTAL CURSOR	RANGE
			; CX = minimum column, DX = maximum column
mov	ax, 8
mov	bx, 0
mov	cx, 0
mov	dx, 199
int	33h		; - MS MOUSE - DEFINE VERTICAL CURSOR RANGE
			; CX = minimum row, DX = maximum row
push	cs
call	near ptr MOUSE_WaitForButtonStatus ; Call Procedure

loc_240A0:
mov	ax, seg	seg033
mov	es, ax
assume es:seg033
mov	ax, 12
mov	cx, 1
mov	dx, offset Mouse_InterruptCallback
int	33h		; - MS MOUSE - DEFINE INTERRUPT	SUBROUTINE PARAMETERS
			; CX = call mask, ES:DX	-> FAR routine
mov	[FLAG_Set_FLAG_Mouse_Skip], 0
mov	[FLAG_Mouse_w360AC], 0
mov	[FLAG_Mouse_w360B4], 0
mov	ax, 0FFFFh
sti			; Set Interrupt	Flag
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
mov	sp, bp
pop	bp

locret_240CD:		; Return Far from Procedure
retf
endp MOUSE_SetupRangeRoutine




proc set_w360A2_1 far	; CODE XREF: idk_Mouse_s2B8B1:loc_2B8DFP
			; idk_Mouse_s2B8B1+74P
push	ds

loc_240CF:
mov	ax, seg	dseg
mov	ds, ax

loc_240D4:
mov	[w360A2], 1
pop	ds
retf			; Return Far from Procedure
endp set_w360A2_1




proc DOS_MouseReset far	; CODE XREF: _f050207_EXIT_CleanUp+8P
			; idk_CleanupPrintExit_s14391+1EP
			; ST_execl_WizardsExe:loc_143F8P
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+DP
push	si
push	di
push	es
push	ds

loc_240E0:
mov	ax, seg	dseg
mov	ds, ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_24119	; Jump if Zero (ZF=1)
push	cs
call	near ptr MOUSE_WaitForButtonStatus ; Call Procedure

loc_240F0:
mov	[FLAG_Set_FLAG_Mouse_Skip], 0
mov	[FLAG_Mouse_w360AC], 0
mov	[FLAG_Mouse_w360B4], 0
push	cs

loc_24103:		; Call Procedure
call	near ptr get__Mouse_w360A4
nop			; No Operation
mov	[word_360BA], ax
push	cs
call	near ptr get__Mouse_w360A6 ; Call Procedure
nop			; No Operation
mov	[word_360BC], ax
cli			; Clear	Interrupt Flag
mov	ax, 21h

loc_24116:		; - MS MOUSE - SOFTWARE	RESET
int	33h		; Return: AX = FFFFh if	mouse driver installed
			; AX = 0021h if	mouse driver not installed
			; BX = 2 if mouse driver is installed
sti			; Set Interrupt	Flag

loc_24119:		; CODE XREF: DOS_MouseReset+Ej
mov	[FLAG_MouseLeftHanded],	0
pop	ds
pop	es
pop	di
pop	si
retf			; Return Far from Procedure
endp DOS_MouseReset



; NOTE:	the mouse interupt subroutine is a callback, called with a far call.

proc MOUSE_ExchangeInterrupt far
			; CODE XREF: sub_24DAE:loc_254D2P
			; sub_27CC0:loc_27CE9P
			; sub_27CC0+156P
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_24154	; Jump if Zero (ZF=1)
cli			; Clear	Interrupt Flag

loc_24135:
mov	ax, seg	seg033
mov	es, ax
assume es:seg033
mov	ax, 14h
mov	cx, 1
mov	dx, 2BEh
int	33h		; - MS MOUSE - EXCHANGE	INTERRUPT SUBROUTINES
			; CX = call mask, ES:DX	-> FAR routine
			; Return: CX = call mask of previous interrupt routine
			; ES:DX	= FAR address of previous interrupt routine
mov	ax, 0FFFFh
mov	[FLAG_Set_FLAG_Mouse_Skip], 1

loc_2414E:
mov	ax, 3
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row
sti			; Set Interrupt	Flag

loc_24154:		; CODE XREF: MOUSE_ExchangeInterrupt+Ej
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
retf			; Return Far from Procedure
endp MOUSE_ExchangeInterrupt




proc hrmMsExchIntSub far
			; CODE XREF: sub_24DAE:loc_24E03P
			; sub_24DAE+12AP
			; sub_24DAE:loc_24FBBP
			; sub_24DAE:loc_25260P
			; sub_24DAE:loc_253C4P
			; sub_24DAE+A52P
			; sub_24DAE:loc_2588DP
			; sub_24DAE:loc_25C26P
			; sub_24DAE+E8FP
			; sub_24DAE:loc_25C5CP
			; sub_24DAE:loc_25CD8P
			; sub_27CC0:loc_27E01P
			; sub_27CC0+171P
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_24189	; Jump if Zero (ZF=1)
cli			; Clear	Interrupt Flag
mov	ax, seg	seg033
mov	es, ax
assume es:seg033
mov	ax, 14h
mov	cx, 101011b
mov	dx, offset Mouse_InterruptCallback
int	33h		; - MS MOUSE - EXCHANGE	INTERRUPT SUBROUTINES
			; CX = call mask, ES:DX	-> FAR routine
			; Return: CX = call mask of previous interrupt routine
			; ES:DX	= FAR address of previous interrupt routine
mov	ax, 0FFFFh
mov	[FLAG_Set_FLAG_Mouse_Skip], 1
mov	ax, 3
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row
sti			; Set Interrupt	Flag

loc_24189:		; CODE XREF: hrmMsExchIntSub+Ej
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
retf			; Return Far from Procedure
endp hrmMsExchIntSub



; Attributes: bp-based frame

proc Mouse_InterruptCallback far
			; DATA XREF: MOUSE_SetupRangeRoutine+73o
			; hrmMsExchIntSub+1Co

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
cli			; Clear	Interrupt Flag
pushf			; Push Flags Register onto the Stack
push	ds
push	ax
cld			; Clear	Direction Flag
mov	ax, 31D1h
mov	ds, ax
mov	ax, cx
shr	ax, 1		; Shift	Logical	Right
mov	[idk_Mouse_w360A4], ax
mov	[idk_Mouse_w360A6], dx
cmp	[FLAG_Mouse_Skip], 0 ; Compare Two Operands
jz	short loc_241B3	; Jump if Zero (ZF=1)
jmp	loc_24266	; Jump

loc_241B3:		; CODE XREF: Mouse_InterruptCallback+20j
push	si
push	di
push	es
push	bx
push	cx
push	dx
mov	[FLAG_Mouse_Skip], 1
push	bx
push	dx
shr	cx, 1		; Shift	Logical	Right
push	cx
push	cs
call	near ptr sub_2460E ; Call Procedure
nop			; No Operation
add	sp, 6		; Add

loc_241CC:		; Compare Two Operands
cmp	[FLAG_Set_FLAG_Mouse_Skip], 0
jnz	short loc_241D6	; Jump if Not Zero (ZF=0)
jmp	loc_2425A	; Jump

loc_241D6:		; CODE XREF: Mouse_InterruptCallback+43j
mov	[FLAG_Set_FLAG_Mouse_Skip], 0
mov	bx, dx
mov	dx, 1111000100b
mov	ax, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
in	al, dx		; EGA port: sequencer data register
mov	[bp+var_4], ax
mov	dx, 3CEh
in	al, dx		; EGA: graph 1 and 2 addr reg:
			;
mov	[bp+var_A], ax
mov	ax, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
in	al, dx		; EGA port: graphics controller	data register

loc_241F7:
mov	[bp+var_6], ax
mov	dx, 3CEh
mov	ax, 8
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1
in	al, dx		; EGA port: graphics controller	data register
mov	[bp+var_8], ax
mov	al, 0FFh
out	dx, al		; EGA port: graphics controller	data register
push	bx
push	cx
mov	ax, [idk_Mouse_w360A8]
cmp	ax, 2		; Compare Two Operands
jb	short loc_24217	; Jump if Below	(CF=1)
push	cs
call	near ptr idk_Mouse_s23F82 ; Call Procedure

loc_24217:		; CODE XREF: Mouse_InterruptCallback+83j
push	cs
call	near ptr idk_ChkMousDoEga ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_24648 ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_24A74 ; Call Procedure
nop			; No Operation
add	sp, 4		; Add
mov	dx, 3C4h
mov	ax, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	ax, [bp+var_4]
out	dx, al		; EGA port: sequencer data register
mov	dx, 3CEh
mov	ax, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	ax, [bp+var_6]
out	dx, al		; EGA port: graphics controller	data register
mov	dx, 3CEh
mov	ax, 8
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1
mov	ax, [bp+var_8]
out	dx, al		; EGA port: graphics controller	data register
mov	dx, 3CEh
mov	ax, [bp+var_A]
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; set/reset.
			; Data bits 0-3	select planes for write	mode 00
mov	[FLAG_Set_FLAG_Mouse_Skip], 1

loc_2425A:		; CODE XREF: Mouse_InterruptCallback+45j
pop	dx
pop	cx
pop	bx
pop	es
pop	di
pop	si
mov	[FLAG_Mouse_Skip], 0

loc_24266:		; CODE XREF: Mouse_InterruptCallback+22j
pop	ax
pop	ds
popf			; Pop Stack into Flags Register
sti			; Set Interrupt	Flag
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp Mouse_InterruptCallback



; FLAG_w360BE =	FLAG_w3609E, FLAG_w3609E = 0

proc Disable_Set_FLAG_Mouse_Skip far
			; CODE XREF: DOS_FindFirst+BP
			; NoXrefs_DosGetDtaFindFirst:loc_140E5P
			; _f040101_DosFindFile+BP
			; ST_ScreenDump:loc_1DB71P
			; sub_1E547+FP
			; sub_1E60D:loc_1E611P
			; _f331647_TestKeyPress+3p
			; sub_24DAE:IS_KeyCode_146P
			; sub_24DAE+BDEP
			; rschKBD_s2669B:loc_2687EP
			; sub_27CC0:loc_27D2EP
			; sub_27CC0:loc_27DAFP
			; sub_27E4B+229P
			; sub_28141+72P
			; sub_2B470:loc_2B7FEP
			; sub_2E00A:loc_2E042P
			; sub_2E303+5P
push	ds		; FLAG_w3609E =	FLAG_w3609E; FLAG_w3609E = 0;
push	bx


mov	bx, seg	dseg
mov	ds, bx		; DS = DSEG
mov	bx, [FLAG_Set_FLAG_Mouse_Skip]
mov	[temp_Set_FLAG_Mouse_Skip], bx
sub	bx, bx		; BX = 0
mov	[FLAG_Set_FLAG_Mouse_Skip], bx


pop	bx
pop	ds
retf			; Return Far from Procedure
endp Disable_Set_FLAG_Mouse_Skip



; This seems like to be	some /global/ error checking.
; All references are FLAG_w360BE & FLAG_w3609E.
; FLAG_w360BE has 2 references - set & swap.
; FLAG_w3609E has 10 references.
; NOTE(JWB)(2020-09-05): Also, may a lock flag.
; NOTE(JWB)(2020-12-19):
; ST_DOS_FindFile sets this to
; 0 on failure,	-1 on success
;

proc Restore_Set_FLAG_Mouse_Skip far
			; CODE XREF: DOS_FindFirst:loc_140B3P
			; DOS_FindFirst+59P
			; NoXrefs_DosGetDtaFindFirst+3FP
			; _f040101_DosFindFile+58P
			; _f040101_DosFindFile+72P
			; ST_ScreenDump+3F3P
			; sub_1E547:loc_1E600P
			; sub_1E60D+45P
			; _f331647_TestKeyPress+10p
			; _f331647_TestKeyPress+1Ap
			; sub_24DAE+B8P
			; sub_24DAE+C1DP
			; rschKBD_s2669B:loc_26970P
			; sub_27CC0+B6P
			; sub_27CC0+137P
			; sub_27E4B:loc_28105P
			; sub_28141+40EP
			; sub_2B470+416P
			; sub_2E00A:loc_2E195P
			; sub_2E303:loc_2E349P
push	ds
push	bx
mov	bx, seg	dseg	; make sure DS points to the Data Segment, as it should
mov	ds, bx
mov	bx, [temp_Set_FLAG_Mouse_Skip]
mov	[FLAG_Set_FLAG_Mouse_Skip], bx
pop	bx
pop	ds
retf			; Return Far from Procedure
endp Restore_Set_FLAG_Mouse_Skip




proc sub_24298 far
push	ds
mov	ax, 31D1h
mov	ds, ax
mov	ax, [FLAG_MouseLeftHanded]
cmp	ax, 0		; Compare Two Operands
jz	short loc_242A8	; Jump if Zero (ZF=1)
pop	ds
retf			; Return Far from Procedure

loc_242A8:		; CODE XREF: sub_24298+Cj
mov	ax, [w360A2]
pop	ds
retf			; Return Far from Procedure
endp sub_24298




proc _f331647_TestKeyPress far
			; CODE XREF: _f020405_idk_CheckInputOrSleep_s13F7E:loc_13F8CP
			; sub_24DAE+36P
			; sub_26026+62P
			; o_1_a_87_s_0_tpsig2_84P
			; sub_27C84:loc_27C94P
			; sub_27CC0:loc_27D06P
			; sub_27CC0:loc_27D87P
			; sub_28141:loc_282E2P
			; sub_28583:loc_286C5P
push	ds
push	es
push	cs
call	near ptr Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E =	0
mov	ah, 11h
int	16h		; KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model	339,XT2,XT286,PS)
			; Return: ZF clear if keystroke	available
			; AH = scan code \ meaningless if ZF = 1
			; AL = character /
			; ZF set if kbd	buffer empty

loc_242B7:		; Jump if Zero (ZF=1)
jz	short noKeyPress

yesKeyPress:
mov	ax, 1
push	cs
call	near ptr Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	es
pop	ds
retf			; Return Far from Procedure

noKeyPress:		; CODE XREF: _f331647_TestKeyPress:loc_242B7j
mov	ax, 0
push	cs
call	near ptr Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	es
pop	ds
retf			; Return Far from Procedure
endp _f331647_TestKeyPress



; https://sites.google.com/site/pcdosretro/scancodes
; Is there a specifc set of codes they used?
; What's Borland's position?

proc ST_GetKeyboardCode	far
			; CODE XREF: rschKBD_s2669B+BP
			; o_1_a_87_s_0_tpsig2_84+9P
			; sub_27C84:loc_27C8FP
			; sub_27CC0+4FP
			; sub_27CC0+D0P
			; sub_28141:loc_28303P
			; sub_28583:loc_286E6P
push	es
push	ds
mov	ah, 10h
int	16h		; KEYBOARD - GET ENHANCED KEYSTROKE (AT	model 339,XT2,XT286,PS)
			; Return: AH = scan code, AL = character
cmp	ax, 11Bh	; Escape
			;	01	 1B
			; 00000001 00011011
			;	 1	 27
			;
jnz	short loc_242DE	; Jump if Not Zero (ZF=0)
mov	ax, 27
pop	ds
pop	es
retf			; Return Far from Procedure

loc_242DE:		; CODE XREF: ST_GetKeyboardCode+9j
cmp	ax, 4BE0h	; Keypad 4 / Left Arrow
			;	4B	 E0
			; 01001011 11100000
			;	75	224
			;
jnz	short loc_242E9	; Jump if Not Zero (ZF=0)
mov	ax, 1
pop	ds
pop	es
retf			; Return Far from Procedure

loc_242E9:		; CODE XREF: ST_GetKeyboardCode+14j
cmp	ax, 4DE0h	; Keypad 6 / Right Arrow
jnz	short loc_242F4	; Jump if Not Zero (ZF=0)
mov	ax, 2
pop	ds
pop	es
retf			; Return Far from Procedure

loc_242F4:		; CODE XREF: ST_GetKeyboardCode+1Fj
cmp	ax, 48E0h	; Keypad 8 / Up	Arrow
jnz	short loc_242FF	; Jump if Not Zero (ZF=0)
mov	ax, 3
pop	ds
pop	es
retf			; Return Far from Procedure

loc_242FF:		; CODE XREF: ST_GetKeyboardCode+2Aj
cmp	ax, 50E0h	; Keypad 2 / Down Arrow
jnz	short loc_2430A	; Jump if Not Zero (ZF=0)
mov	ax, 4
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2430A:		; CODE XREF: ST_GetKeyboardCode+35j
cmp	ax, 49E0h	; Keypad 9 / Page Up
jnz	short loc_24315	; Jump if Not Zero (ZF=0)
mov	ax, 5
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24315:		; CODE XREF: ST_GetKeyboardCode+40j
cmp	ax, 51E0h	; Keypad 3 / Page Down
jnz	short loc_24320	; Jump if Not Zero (ZF=0)
mov	ax, 6
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24320:		; CODE XREF: ST_GetKeyboardCode+4Bj
cmp	ax, 47E0h	; Keypad 7 / Home
jnz	short loc_2432B	; Jump if Not Zero (ZF=0)
mov	ax, 7
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2432B:		; CODE XREF: ST_GetKeyboardCode+56j
cmp	ax, 4FE0h	; Keypad 1 / End
jnz	short loc_24336	; Jump if Not Zero (ZF=0)
mov	ax, 8
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24336:		; CODE XREF: ST_GetKeyboardCode+61j
cmp	ax, 52E0h	; Keypad 0 / Insert
jnz	short loc_24341	; Jump if Not Zero (ZF=0)

loc_2433B:
mov	ax, 9

loc_2433E:
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24341:		; CODE XREF: ST_GetKeyboardCode+6Cj
cmp	ax, 53E0h	; Delete
			; Keypad . / Delete
jnz	short loc_2434C	; Jump if Not Zero (ZF=0)
mov	ax, 10
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2434C:		; CODE XREF: ST_GetKeyboardCode+77j
cmp	ax, 0E08h	; Backspace
			;	0E	 08
			; 00001110 00001000
			;	14	  8
			;
jnz	short loc_24357	; Jump if Not Zero (ZF=0)
mov	ax, 11
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24357:		; CODE XREF: ST_GetKeyboardCode+82j
cmp	ax, 1C0Dh	; Enter
jnz	short loc_24362	; Jump if Not Zero (ZF=0)
mov	ax, 12
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24362:		; CODE XREF: ST_GetKeyboardCode+8Dj
cmp	ax, 0F09h	; Tab
jnz	short loc_2436D	; Jump if Not Zero (ZF=0)
mov	ax, 13
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2436D:		; CODE XREF: ST_GetKeyboardCode+98j
cmp	ax, 3B00h	; F1 (Program Function Key 1)
jnz	short loc_24378	; Jump if Not Zero (ZF=0)
mov	ax, 14
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24378:		; CODE XREF: ST_GetKeyboardCode+A3j
cmp	ax, 3C00h	; F2 (Program Function Key 2)
jnz	short loc_24383	; Jump if Not Zero (ZF=0)
mov	ax, 15
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24383:		; CODE XREF: ST_GetKeyboardCode+AEj
cmp	ax, 3D00h	; F3 (Program Function Key 3)
jnz	short loc_2438E	; Jump if Not Zero (ZF=0)
mov	ax, 16
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2438E:		; CODE XREF: ST_GetKeyboardCode+B9j
cmp	ax, 3E00h	; F4 (Program Function Key 4)
jnz	short loc_24399	; Jump if Not Zero (ZF=0)
mov	ax, 17
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24399:		; CODE XREF: ST_GetKeyboardCode+C4j
cmp	ax, 3F00h	; F5 (Program Function Key 5)
jnz	short loc_243A4	; Jump if Not Zero (ZF=0)
mov	ax, 18
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243A4:		; CODE XREF: ST_GetKeyboardCode+CFj
cmp	ax, 4000h	; F6 (Program Function Key 6)
jnz	short loc_243AF	; Jump if Not Zero (ZF=0)
mov	ax, 19
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243AF:		; CODE XREF: ST_GetKeyboardCode+DAj
cmp	ax, 4100h	; F7 (Program Function Key 7)
jnz	short loc_243BA	; Jump if Not Zero (ZF=0)
mov	ax, 20
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243BA:		; CODE XREF: ST_GetKeyboardCode+E5j
cmp	ax, 4200h	; F8 (Program Function Key 8)
jnz	short loc_243C5	; Jump if Not Zero (ZF=0)
mov	ax, 21
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243C5:		; CODE XREF: ST_GetKeyboardCode+F0j
cmp	ax, 4300h	; F9 (Program Function Key 9)
jnz	short loc_243D0	; Jump if Not Zero (ZF=0)
mov	ax, 22
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243D0:		; CODE XREF: ST_GetKeyboardCode+FBj
cmp	ax, 4400h	; F10 (Program Function	Key 10)
jnz	short loc_243DB	; Jump if Not Zero (ZF=0)
mov	ax, 23
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243DB:		; CODE XREF: ST_GetKeyboardCode+106j
cmp	ah, 47h		; Home
jnz	short loc_243E6	; Jump if Not Zero (ZF=0)
mov	ax, 26
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243E6:		; CODE XREF: ST_GetKeyboardCode+111j
cmp	ah, 49h		; Page Up
jnz	short loc_243F1	; Jump if Not Zero (ZF=0)
mov	ax, 25
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243F1:		; CODE XREF: ST_GetKeyboardCode+11Cj
cmp	ah, 4Fh		; End
jnz	short loc_243FC	; Jump if Not Zero (ZF=0)
mov	ax, 28
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243FC:		; CODE XREF: ST_GetKeyboardCode+127j
cmp	ah, 51h		; Page Down
jnz	short loc_24407	; Jump if Not Zero (ZF=0)
mov	ax, 29
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24407:		; CODE XREF: ST_GetKeyboardCode+132j
cmp	ah, 48h		; Up Arrow
jnz	short loc_24412	; Jump if Not Zero (ZF=0)
mov	ax, 3
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24412:		; CODE XREF: ST_GetKeyboardCode+13Dj
cmp	ah, 50h		; Down Arrow
jnz	short loc_2441D	; Jump if Not Zero (ZF=0)
mov	ax, 4
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2441D:		; CODE XREF: ST_GetKeyboardCode+148j
cmp	ah, 4Bh		; Left Arrow
jnz	short loc_24428	; Jump if Not Zero (ZF=0)
mov	ax, 1
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24428:		; CODE XREF: ST_GetKeyboardCode+153j
cmp	ah, 4Dh		; Right	Arrow
jnz	short loc_24433	; Jump if Not Zero (ZF=0)
mov	ax, 2
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24433:		; CODE XREF: ST_GetKeyboardCode+15Ej
cmp	ah, 4Eh		; ? Alternate -	Plus ?
jnz	short loc_2443E	; Jump if Not Zero (ZF=0)
mov	ax, 43
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2443E:		; CODE XREF: ST_GetKeyboardCode+169j
cmp	ah, 4Ah		; ? Alternate -	Minus ?
jnz	short loc_24449	; Jump if Not Zero (ZF=0)
mov	ax, 45
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24449:		; CODE XREF: ST_GetKeyboardCode+174j
cmp	ah, 4Ch		; Numpad 5 / Center
jnz	short loc_24454	; Jump if Not Zero (ZF=0)
mov	ax, 30
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24454:		; CODE XREF: ST_GetKeyboardCode+17Fj
cmp	ax, 74E0h	; ? Control - Right Arrow ?
jnz	short loc_2445F	; Jump if Not Zero (ZF=0)
mov	ax, 128
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2445F:		; CODE XREF: ST_GetKeyboardCode+18Aj
cmp	ax, 73E0h	; ? Control - Left Arrow ?
jnz	short loc_2446A	; Jump if Not Zero (ZF=0)
mov	ax, 129
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2446A:		; CODE XREF: ST_GetKeyboardCode+195j
cmp	ax, 8DE0h	; ? Control - Up Arrow ?
jnz	short loc_24475	; Jump if Not Zero (ZF=0)
mov	ax, 130
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24475:		; CODE XREF: ST_GetKeyboardCode+1A0j
cmp	ax, 91E0h	; ? Control - Down Arrow ?
jnz	short loc_24480	; Jump if Not Zero (ZF=0)
mov	ax, 131
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24480:		; CODE XREF: ST_GetKeyboardCode+1ABj
cmp	ax, 7400h	; ? Control - Right Arrow ?
jnz	short loc_2448B	; Jump if Not Zero (ZF=0)
mov	ax, 128
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2448B:		; CODE XREF: ST_GetKeyboardCode+1B6j
cmp	ax, 7300h	; ? Control - Left Arrow ?
jnz	short loc_24496	; Jump if Not Zero (ZF=0)
mov	ax, 129
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24496:		; CODE XREF: ST_GetKeyboardCode+1C1j
cmp	ax, 8D00h	; ? Control - Up Arrow ?
jnz	short loc_244A1	; Jump if Not Zero (ZF=0)

loc_2449B:
mov	ax, 130
pop	ds
pop	es

locret_244A0:		; Return Far from Procedure
retf

loc_244A1:		; CODE XREF: ST_GetKeyboardCode+1CCj
cmp	ax, 9100h	; ? Control - Down Arrow ?

loc_244A4:		; Jump if Not Zero (ZF=0)
jnz	short loc_244AC
mov	ax, 131
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244AC:		; CODE XREF: ST_GetKeyboardCode:loc_244A4j
cmp	ax, 7700h	; ? Home ?
jnz	short loc_244B7	; Jump if Not Zero (ZF=0)
mov	ax, 132
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244B7:		; CODE XREF: ST_GetKeyboardCode+1E2j
cmp	ax, 8400h	; ? Control - Page Up ?
jnz	short loc_244C2	; Jump if Not Zero (ZF=0)
mov	ax, 133

loc_244BF:
pop	ds

loc_244C0:
pop	es
retf			; Return Far from Procedure

loc_244C2:		; CODE XREF: ST_GetKeyboardCode+1EDj
cmp	ax, 7500h	; ? Control - End ?
jnz	short loc_244CD	; Jump if Not Zero (ZF=0)
mov	ax, 134
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244CD:		; CODE XREF: ST_GetKeyboardCode+1F8j
cmp	ax, 7600h	; ? Control - Page Down	?
jnz	short loc_244D8	; Jump if Not Zero (ZF=0)
mov	ax, 135
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244D8:		; CODE XREF: ST_GetKeyboardCode+203j
cmp	ax, 92Ah	; ? Shift 8 / *	?
jnz	short loc_244E2	; Jump if Not Zero (ZF=0)
sub	ax, ax		; 0
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244E2:		; CODE XREF: ST_GetKeyboardCode+20Ej
cmp	ax, 0E00Dh	; ? Alternate -	Backspace ?
jnz	short loc_244ED	; Jump if Not Zero (ZF=0)
mov	ax, 12
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244ED:		; CODE XREF: ST_GetKeyboardCode+218j
cmp	ax, 1F13h	; ? Control - s	?
jnz	short loc_244F8	; Jump if Not Zero (ZF=0)
mov	ax, 144
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244F8:		; CODE XREF: ST_GetKeyboardCode+223j
cmp	ax, 8500h	; F11 (Program Function	Key 11)
			;	85	 00
			; 10000101 00000000
			;      133	  0
			;
jnz	short loc_24503	; Jump if Not Zero (ZF=0)
mov	ax, 145
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24503:		; CODE XREF: ST_GetKeyboardCode+22Ej
cmp	ax, 8600h	; F12 (Program Function	Key 12)
jnz	short loc_2450B	; Jump if Not Zero (ZF=0)
mov	ax, 146

loc_2450B:		; CODE XREF: ST_GetKeyboardCode+239j
mov	bx, 6
mov	dx, 106
add	dx, 4		; Add

loc_24514:		; CODE XREF: ST_GetKeyboardCode+255j
mov	cx, [cs:bx]	; WTF -	Why can	I not understand these?
			;
cmp	ax, cx		; CX - AX
jz	short loc_24524	; Jump if Zero (ZF=1)
add	bx, 4		; Add
cmp	bx, dx		; Meaning it's only going to try this
			; ((106	+ 4) - 6) / 4 =	26 times?
			;
jz	short loc_24529	; Jump if Zero (ZF=1)
jmp	short loc_24514	; Jump

loc_24524:		; CODE XREF: ST_GetKeyboardCode+24Cj
inc	bx		; Increment by 1
inc	bx		; Increment by 1
mov	ax, [cs:bx]

loc_24529:		; CODE XREF: ST_GetKeyboardCode+253j
pop	ds
pop	es
retf			; Return Far from Procedure
endp ST_GetKeyboardCode




proc get__Mouse_w360A4 far
			; CODE XREF: _f010509_MainMenuScreen+39DP
			; sub_1E547:loc_1E55BP
			; sub_1E547:loc_1E5BAP
			; DOS_MouseReset:loc_24103p
			; sub_24DAE+1EP
			; sub_24DAE+85P
			; sub_24DAE+98P
			; sub_24DAE+ABP
			; sub_24DAE:loc_258F2P
			; sub_25EA0+DP
			; sub_26026+9CP
			; sub_26026+AFP
			; sub_26026+C2P
			; sub_26026:loc_26680P
			; sub_27A2B+8P
			; sub_27AFB+7P
			; sub_27AFB:loc_27BE2P
			; sub_27CC0+83P
			; sub_27CC0+96P
			; sub_27CC0+A9P
			; sub_27CC0+104P
			; sub_27CC0+117P
			; sub_27CC0+12AP
			; sub_27E4B+91P
			; sub_2A235+48P
			; sub_2B470+375P
			; sub_2CF44:loc_2DD95P
			; sub_2E00A+75P
			; sub_2E00A+15BP
			; sub_2E303+AP
push	ds
mov	ax, seg	dseg

loc_24530:
mov	ds, ax
mov	ax, [idk_Mouse_w360A4]
pop	ds
retf			; Return Far from Procedure
endp get__Mouse_w360A4




proc get__Mouse_w360A6 far
			; CODE XREF: _f010509_MainMenuScreen+397P
			; sub_1E547:loc_1E563P
			; sub_1E547+6DP
			; DOS_MouseReset+2Fp
			; sub_24DAE+26P
			; sub_24DAE+7FP
			; sub_24DAE+92P
			; sub_24DAE+A5P
			; sub_24DAE+B4CP
			; sub_25EA0+15P
			; sub_26026+96P
			; sub_26026+A9P
			; sub_26026+BCP
			; sub_26026+662P
			; sub_27A2B+FP
			; sub_27AFB+FP
			; sub_27AFB+127P
			; sub_27CC0+7DP
			; sub_27CC0+90P
			; sub_27CC0+A3P
			; sub_27CC0+FEP
			; sub_27CC0+111P
			; sub_27CC0+124P
			; sub_27E4B+99P
			; sub_2A235+136P
			; sub_2B470+380P
			; sub_2CF44+E91P
			; sub_2E00A+7CP
			; sub_2E00A+162P
			; sub_2E303+11P
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idk_Mouse_w360A6]
pop	ds
retf			; Return Far from Procedure
endp get__Mouse_w360A6



; Attributes: bp-based frame

proc CALL_PositionMouseCursor far
			; CODE XREF: sub_1E547+9EP
			; sub_24D35:loc_24D85p
			; sub_24DAE+B1P
			; sub_24DAE:loc_259C4P
			; sub_26026+C8P
			; rschKBD_s2669B+2ABP
			; sub_27913:loc_279FBP
			; sub_27CC0+AFP
			; sub_27CC0+130P
			; sub_27E4B+2A2P
			; sub_2B470+3E9P
			; idk_Mouse_s2B8B1+4DP
			; idk_Mouse_s2B8B1+8DP
			; sub_2E00A+9EP
			; sub_2E00A+184P
			; sub_2E00A+1D0P

arg0_Column= word ptr  6
arg2_Row= word ptr  8

push	bp
mov	bp, sp
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg0_Column]
mov	[idk_Mouse_w360A4], ax
mov	ax, [bp+arg2_Row]
mov	[idk_Mouse_w360A6], ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_2456A	; Jump if Zero (ZF=1)
push	ax		; arg2_Row
push	[bp+arg0_Column] ; arg0_Column
push	cs
call	near ptr DOS_PositionMouseCursor ; Call	Procedure
nop			; No Operation
add	sp, 4		; Add

loc_2456A:		; CODE XREF: CALL_PositionMouseCursor+1Aj
pop	ds
pop	bp
retf			; Return Far from Procedure
endp CALL_PositionMouseCursor ;	sp-analysis failed



; Attributes: bp-based frame

; int __cdecl __far DOS_PositionMouseCursor(int	arg0_Column, int arg2_Row)
proc DOS_PositionMouseCursor far
			; CODE XREF: CALL_PositionMouseCursor+21p

arg0_Column= word ptr  6
arg2_Row= word ptr  8

push	bp
mov	bp, sp
push	ds
mov	cx, [bp+arg0_Column]
shl	cx, 1		; Shift	Logical	Left
mov	dx, [bp+arg2_Row]
mov	ax, 4
cli			; Clear	Interrupt Flag
int	33h		; DOS -	MS MOUSE - POSITION MOUSE CURSOR
			; CX = column, DX = row
sti			; Set Interrupt	Flag
pop	ds
pop	bp
retf			; Return Far from Procedure
endp DOS_PositionMouseCursor




proc idk_Get_Mouse_w360AE far
			; CODE XREF: sub_24DAE:MouseStatusIsRightButtonP
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idk_Mouse_w360AE]
pop	ds
retf			; Return Far from Procedure
endp idk_Get_Mouse_w360AE




proc idk_Get_Mouse_w360B0 far
			; CODE XREF: sub_24DAE:loc_2552FP
push	ds
mov	ax, seg	dseg
mov	ds, ax

loc_24594:
mov	ax, [idk_Mouse_w360B0]
pop	ds
retf			; Return Far from Procedure
endp idk_Get_Mouse_w360B0




proc idk_Get_Mouse_w360B2 far
			; CODE XREF: sub_24DAE:loc_254F2P
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idkMouse_w360B2]
pop	ds
retf			; Return Far from Procedure
endp idk_Get_Mouse_w360B2




proc get_w360AC_set0 far ; CODE	XREF: sub_24D35+4Cp
			; sub_24DAE:loc_254E3P
			; sub_24DAE:loc_2551AP
			; sub_24DAE:loc_258C7P
			; sub_24DAE:loc_25BB9P
			; sub_27C84+30P
			; sub_27CC0+37P
			; sub_27CC0:loc_27D7DP
			; sub_27CC0+176P
			; sub_28141+16DP
			; sub_28583+24P
			; sub_28583+10EP
			; sub_28583+39EP
			; sub_2A755+A7BP
			; sub_2B1F9+24EP
			; sub_2B9C4+9P
push	ds
mov	ax, seg	dseg

loc_245A8:
mov	ds, ax
mov	ax, [FLAG_Mouse_w360AC]
sub	bx, bx		; Integer Subtraction
mov	[FLAG_Mouse_w360AC], bx
pop	ds
retf			; Return Far from Procedure
endp get_w360AC_set0




; int __cdecl __far f332647_Get_w360B4_Set0()
proc _f332647_Get_w360B4_Set0 far
			; CODE XREF: _f020405_idk_CheckInputOrSleep_s13F7E+25P
			; sub_24DAE+771P
			; sub_24DAE+9D5P
			; sub_24DAE:loc_258CCP
			; sub_24DAE+E10P
			; sub_27C84+35P
			; sub_27CC0+17BP
			; sub_28583+29P
			; sub_28583:loc_28926P
			; sub_2A755+A80P
			; sub_2B1F9+253P
			; sub_2B9C4+EP
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [FLAG_Mouse_w360B4]
sub	bx, bx		; Integer Subtraction
mov	[FLAG_Mouse_w360B4], bx
pop	ds
retf			; Return Far from Procedure
endp _f332647_Get_w360B4_Set0



; Attributes: bp-based frame

proc sub_245C6 far	; CODE XREF: sub_24DAE:loc_259DCP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	[FLAG_Mouse_w360B4], 1
mov	ax, [bp+arg_0]
mov	[idk_Mouse_w360AE], ax
mov	ax, [bp+arg_2]
mov	[idk_Mouse_w360B0], ax
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_245C6



; Attributes: bp-based frame

proc sub_245E4 far	; CODE XREF: sub_24D35+43p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	[FLAG_Mouse_w360B4], 1
mov	[FLAG_Mouse_w360AC], 1
mov	ax, [bp+arg_0]
mov	[idk_Mouse_w360AE], ax
mov	ax, [bp+arg_2]
mov	[idk_Mouse_w360B0], ax
mov	ax, [bp+arg_4]
mov	[idkMouse_w360B2], ax
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_245E4



; Attributes: bp-based frame

proc sub_2460E far	; CODE XREF: Mouse_InterruptCallback+37p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_2460F:
mov	bp, sp
push	ds
push	ds

loc_24613:
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg_4]
and	ax, 11b		; Logical AND
cmp	ax, 0		; Compare Two Operands
jnz	short loc_24627	; Jump if Not Zero (ZF=0)
pop	ds
pop	ds
pop	bp
retf			; Return Far from Procedure

loc_24627:		; CODE XREF: sub_2460E+13j
mov	[idkMouse_w360B2], ax

loc_2462A:
mov	[FLAG_Mouse_w360AC], 1
mov	[FLAG_Mouse_w360B4], 1
mov	ax, [bp+arg_0]
mov	[idk_Mouse_w360AE], ax
mov	ax, [bp+arg_2]
mov	[idk_Mouse_w360B0], ax
sub	ax, ax		; Integer Subtraction

loc_24644:
pop	ds
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2460E



; Attributes: bp-based frame

proc sub_24648 far	; CODE XREF: _f010509_MainMenuScreen+3A3P
			; sub_1E547:loc_1E5D6P
			; Mouse_InterruptCallback+8Fp
			; sub_24D35:loc_24D99p
			; sub_24DAE+8BP
			; sub_24DAE+BFCP
			; sub_26026+21P
			; sub_26026+A2P
			; rschKBD_s2669B+2BFP
			; sub_27913+FCP
			; sub_27CC0+89P
			; sub_27CC0+10AP
			; sub_27E4B:loc_280CFP
			; sub_2B470+3CBP
			; sub_2E00A+88P
			; sub_2E00A+16EP
			; sub_2E00A+1BAP

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_43AC= word ptr  43B2h

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
cmp	[idk_Mouse_w3609A], 0 ;	Compare	Two Operands
jnz	short loc_24673	; Jump if Not Zero (ZF=0)
cmp	[word_360B8], 0	; Compare Two Operands
jz	short loc_2466D	; Jump if Zero (ZF=1)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_2466D:		; CODE XREF: sub_24648+1Bj
mov	[word_360B8], 1

loc_24673:		; CODE XREF: sub_24648+14j
mov	ax, ds
mov	es, ax
assume es:dseg
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
sub	al, al		; Integer Subtraction
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
mov	ds, ax
mov	si, [bp+arg_0]
shr	si, 1		; Shift	Logical	Right
shr	si, 1		; Shift	Logical	Right
mov	ax, si
mov	bx, 3
add	ax, bx		; Add
sub	ax, 50h	; 'P'   ; Integer Subtraction
js	short loc_2469C	; Jump if Sign (SF=1)
sub	bx, ax		; Integer Subtraction

loc_2469C:		; CODE XREF: sub_24648+50j
mov	ax, [bp+arg_2]

loc_2469F:
mov	cx, 50h	; 'P'
mul	cx		; Unsigned Multiplication of AL	or AX
add	si, ax		; Add
sub	di, di		; Integer Subtraction
mov	[es:di+43B2h], si
add	di, 2		; Add
mov	[es:di+43B2h], bx
add	di, 2		; Add
mov	[bp+var_6], bl

loc_246BB:
mov	ax, [bp+arg_2]
mov	bx, 10h
add	ax, bx		; Add
sub	ax, 0C8h ; ''  ; Integer Subtraction
js	short loc_246CA	; Jump if Sign (SF=1)
sub	bx, ax		; Integer Subtraction

loc_246CA:		; CODE XREF: sub_24648+7Ej
mov	[es:di+43B2h], bx

loc_246CF:		; Add
add	di, 2
mov	[bp+var_4], bx
mov	[bp+var_2], si
sub	bl, bl		; Integer Subtraction
mov	al, 4
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_246E1:		; CODE XREF: sub_24648+C9j
mov	al, bl
out	dx, al		; EGA port: graphics controller	data register
sub	bh, bh		; Integer Subtraction

loc_246E6:		; CODE XREF: sub_24648+BFj
mov	cx, [bp+var_4]

loc_246E9:		; CODE XREF: sub_24648+ADj
lodsw			; Load String
mov	[es:di+43B2h], ax
add	di, 2		; Add
add	si, 4Eh	; 'N'   ; Add
loop	loc_246E9	; Loop while CX	!= 0
mov	si, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_246E6	; Jump if Not Zero (ZF=0)
inc	bl		; Increment by 1
mov	si, [bp+var_2]
cmp	bl, 4		; Compare Two Operands
jnz	short loc_246E1	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_24648



; Attributes: bp-based frame

proc sub_2471B far	; CODE XREF: sub_2E303+27P

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds

loc_24725:
mov	ax, seg	dseg
mov	ds, ax
cmp	[idk_Mouse_w3609A], 0 ;	Compare	Two Operands
jnz	short loc_2474D	; Jump if Not Zero (ZF=0)
cmp	[idk_Mouse_w3609C], 0 ;	Compare	Two Operands
jnz	short loc_2474D	; Jump if Not Zero (ZF=0)
cmp	[word_360B8], 0	; Compare Two Operands
jz	short loc_24747	; Jump if Zero (ZF=1)
pop	ds

loc_24740:
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_24747:		; CODE XREF: sub_2471B+22j
mov	[word_360B8], 1

loc_2474D:		; CODE XREF: sub_2471B+14j
			; sub_2471B+1Bj
mov	ax, ds
mov	es, ax
assume es:dseg
mov	ax, 1
sub	ax, [idk_VGA_w35ED6] ; Integer Subtraction
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
mov	ds, ax
mov	si, [bp+arg_0]
shr	si, 1		; Shift	Logical	Right
shr	si, 1		; Shift	Logical	Right
mov	ax, si

loc_2476E:
mov	bx, 3
add	ax, bx		; Add
sub	ax, 50h	; 'P'   ; Integer Subtraction
js	short loc_2477A	; Jump if Sign (SF=1)
sub	bx, ax		; Integer Subtraction

loc_2477A:		; CODE XREF: sub_2471B+5Bj
mov	ax, [bp+arg_2]
mov	cx, 50h	; 'P'
mul	cx		; Unsigned Multiplication of AL	or AX
add	si, ax		; Add
sub	di, di		; Integer Subtraction
mov	[es:di+4862h], si
add	di, 2		; Add
mov	[es:di+4862h], bx
add	di, 2		; Add
mov	[bp+var_6], bl
mov	ax, [bp+arg_2]
mov	bx, 10h
add	ax, bx		; Add
sub	ax, 0C8h ; ''  ; Integer Subtraction
js	short loc_247A8	; Jump if Sign (SF=1)

loc_247A6:		; Integer Subtraction
sub	bx, ax

loc_247A8:		; CODE XREF: sub_2471B+89j
mov	[es:di+4862h], bx
add	di, 2		; Add
mov	[bp+var_4], bx
mov	[bp+var_2], si
sub	bl, bl		; Integer Subtraction
mov	al, 4
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_247BF:		; CODE XREF: sub_2471B+D4j
mov	al, bl
out	dx, al		; EGA port: graphics controller	data register
sub	bh, bh		; Integer Subtraction

loc_247C4:		; CODE XREF: sub_2471B+CAj
mov	cx, [bp+var_4]

loc_247C7:		; CODE XREF: sub_2471B+B8j
lodsw			; Load String
mov	[es:di+4862h], ax
add	di, 2		; Add

loc_247D0:		; Add
add	si, 4Eh	; 'N'
loop	loc_247C7	; Loop while CX	!= 0
mov	si, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_247C4	; Jump if Not Zero (ZF=0)
inc	bl		; Increment by 1
mov	si, [bp+var_2]

loc_247EC:		; Compare Two Operands
cmp	bl, 4
jnz	short loc_247BF	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2471B



; Attributes: bp-based frame

proc idk_VGA_s247F9 far	; CODE XREF: idk_Mouse_s2B8B1+AAP

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, ds
mov	es, ax
assume es:dseg
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
sub	al, al		; Integer Subtraction
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, VIDEO_RAM	; Add
mov	ds, ax
mov	si, [bp+arg_0]
shr	si, 1		; Shift	Logical	Right
shr	si, 1		; Shift	Logical	Right
mov	ax, si
mov	bx, 3
add	ax, bx		; Add
sub	ax, 80		; Integer Subtraction
js	short loc_24831	; Jump if Sign (SF=1)

loc_2482F:		; Integer Subtraction
sub	bx, ax

loc_24831:		; CODE XREF: idk_VGA_s247F9+34j
mov	ax, [bp+arg_2]
mov	cx, 80
mul	cx		; Unsigned Multiplication of AL	or AX
add	si, ax		; Add
sub	di, di		; Integer Subtraction
mov	[es:di+43B2h], si
add	di, 2		; Add
mov	[es:di+43B2h], bx
add	di, 2		; Add
mov	[bp+var_6], bl
mov	ax, [bp+arg_2]
mov	bx, 16
add	ax, bx		; Add
sub	ax, 200		; Integer Subtraction
js	short loc_2485F	; Jump if Sign (SF=1)
sub	bx, ax		; Integer Subtraction

loc_2485F:		; CODE XREF: idk_VGA_s247F9+62j
mov	[es:di+43B2h], bx
add	di, 2		; Add
mov	[bp+var_4], bx
mov	[bp+var_2], si
sub	bl, bl		; Integer Subtraction
mov	al, 4
mov	dx, GC_INDEX
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_24876:		; CODE XREF: idk_VGA_s247F9+ADj
mov	al, bl
out	dx, al		; EGA port: graphics controller	data register
sub	bh, bh		; Integer Subtraction

loc_2487B:		; CODE XREF: idk_VGA_s247F9+A3j
mov	cx, [bp+var_4]

loc_2487E:		; CODE XREF: idk_VGA_s247F9+91j
lodsw			; Load String
mov	[es:di+43B2h], ax
add	di, 2		; Add
add	si, 78		; Add
loop	loc_2487E	; Loop while CX	!= 0
mov	si, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_2487B	; Jump if Not Zero (ZF=0)
inc	bl		; Increment by 1
mov	si, [bp+var_2]
cmp	bl, 4		; Compare Two Operands
jnz	short loc_24876	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_VGA_s247F9




proc idk_Dseg_RepMovSw far
			; CODE XREF: sub_2E303:loc_2E344P
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	es, ax
assume es:dseg
mov	di, offset idk_Dseg_RepMovSw_DI
mov	si, offset idk_Dseg_RepMovSw_SI
mov	cx, offset idk_Dseg_RepMovSw_CX
rep movsw		; Move Byte(s) from String to String
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
retf			; Return Far from Procedure
endp idk_Dseg_RepMovSw



; Attributes: bp-based frame

proc idk_ChkMousDoEga far ; CODE XREF: sub_1E547+8AP
			; Mouse_InterruptCallback+8Ap
			; sub_24D35:loc_24D95p
			; sub_24DAE+75P
			; sub_24DAE:loc_25991P
			; sub_26026+14P
			; sub_26026+8CP
			; rschKBD_s2669B+2B2P
			; sub_27913+EFP
			; sub_27CC0+73P
			; sub_27CC0+F4P
			; sub_27E4B+277P
			; sub_28141:loc_2854AP
			; sub_2B470+3BEP
			; sub_2E00A+4DP
			; sub_2E00A:loc_2E0BBP
			; sub_2E00A:loc_2E19CP

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax

loc_248DA:		; Compare Two Operands
cmp	[idk_Mouse_w3609C], 0

loc_248DF:		; Jump if Not Zero (ZF=0)
jnz	short loc_248E9
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_248E9:		; CODE XREF: idk_ChkMousDoEga:loc_248DFj
sub	si, si		; Integer Subtraction
mov	di, [si+43B2h]
add	si, 2		; Add
mov	[bp+var_2], di
mov	ax, [si+43B2h]
add	si, 2		; Add
mov	[bp+var_6], al
mov	ax, [si+43B2h]
add	si, 2		; Add
mov	[bp+var_4], ax
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
sub	al, al		; Integer Subtraction
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
mov	es, ax
mov	bl, 1
mov	dx, 964
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1

loc_24922:		; CODE XREF: idk_ChkMousDoEga+86j
mov	al, bl
out	dx, al		; EGA port: sequencer data register
sub	bh, bh		; Integer Subtraction

loc_24927:		; CODE XREF: idk_ChkMousDoEga+7Cj
mov	cx, [bp+var_4]

loc_2492A:		; CODE XREF: idk_ChkMousDoEga+6Aj
mov	ax, [si+43B2h]
stosw			; Store	String
add	si, 2		; Add
add	di, 78		; Add
loop	loc_2492A	; Loop while CX	!= 0
mov	di, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	di, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_24927	; Jump if Not Zero (ZF=0)
shl	bl, 1		; Shift	Logical	Left
mov	di, [bp+var_2]
cmp	bl, 16		; Compare Two Operands
jnz	short loc_24922	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_ChkMousDoEga



; Attributes: bp-based frame

proc sub_2495B far	; CODE XREF: sub_1E547:loc_1E5AFP
			; sub_1E547+B4P
			; sub_2E303:loc_2E33FP

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp

loc_2495C:
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
cmp	[idk_Mouse_w3609C], 0 ;	Compare	Two Operands
jnz	short loc_24979	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_24979:		; CODE XREF: sub_2495B+14j
mov	ax, 1

loc_2497C:		; Integer Subtraction
sub	ax, [idk_VGA_w35ED6]
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left

loc_24988:		; Add
add	ax, VIDEO_RAM
mov	es, ax
sub	si, si		; Integer Subtraction
mov	di, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add
mov	[bp+var_2], di
mov	ax, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add
mov	[bp+var_6], al
mov	ax, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add
mov	[bp+var_4], ax
mov	bl, 1
mov	dx, 964
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1

loc_249B6:		; CODE XREF: sub_2495B+8Aj
mov	al, bl
out	dx, al		; EGA port: sequencer data register

loc_249B9:		; Integer Subtraction
sub	bh, bh

loc_249BB:		; CODE XREF: sub_2495B+80j
mov	cx, [bp+var_4]

loc_249BE:		; CODE XREF: sub_2495B+6Ej
mov	ax, [idk_Dseg_RepMovSw_DI+si]
stosw			; Store	String
add	si, 2		; Add
add	di, 78		; Add
loop	loc_249BE	; Loop while CX	!= 0
mov	di, [bp+var_2]
inc	bh		; Increment by 1

loc_249D0:		; Integer Subtraction
sub	ah, ah
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	di, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_249BB	; Jump if Not Zero (ZF=0)
shl	bl, 1		; Shift	Logical	Left
mov	di, [bp+var_2]

loc_249E2:		; Compare Two Operands
cmp	bl, 16
jnz	short loc_249B6	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2495B



; Attributes: bp-based frame

proc sub_249EF far

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

; FUNCTION CHUNK AT 0B3D SIZE 00000067 BYTES

push	bp

loc_249F0:
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds

loc_249F9:
mov	ax, seg	dseg
mov	ds, ax

loc_249FE:		; Compare Two Operands
cmp	[idk_Mouse_w3609C], 0
jnz	short loc_24A0D	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_249EF

; START	OF FUNCTION CHUNK FOR sub_249EF

loc_24A0D:		; CODE XREF: sub_249EF+14j
sub	si, si		; Integer Subtraction
mov	di, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add
mov	[bp+var_2], di
mov	ax, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add

loc_24A20:
mov	[bp+var_6], al
mov	ax, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add

loc_24A2A:
mov	[bp+var_4], ax
mov	ax, 0A800h
mov	es, ax
assume es:nothing
mov	bl, 1
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_24A3A:		; Increment by 1
inc	dx

loc_24A3B:		; CODE XREF: sub_249EF+7Bj
mov	al, bl
out	dx, al		; EGA port: sequencer data register

loc_24A3E:		; Integer Subtraction
sub	bh, bh

loc_24A40:		; CODE XREF: sub_249EF+71j
mov	cx, [bp+var_4]

loc_24A43:		; CODE XREF: sub_249EF+5Fj
mov	ax, [si+43B2h]
stosw			; Store	String
add	si, 2		; Add
add	di, 4Eh	; 'N'   ; Add
loop	loc_24A43	; Loop while CX	!= 0

loc_24A50:
mov	di, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	di, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_24A40	; Jump if Not Zero (ZF=0)
shl	bl, 1		; Shift	Logical	Left

loc_24A64:
mov	di, [bp+var_2]

loc_24A67:		; Compare Two Operands
cmp	bl, 10h
jnz	short loc_24A3B	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
assume es:nothing

loc_24A6E:
pop	di
pop	si

loc_24A70:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
; END OF FUNCTION CHUNK	FOR sub_249EF


;
; get__Mouse_w360A6()
; get__Mouse_w360A4()
;
; Attributes: bp-based frame

proc sub_24A74 far	; CODE XREF: sub_1E547:loc_1E5E0P
			; Mouse_InterruptCallback+94p
			; sub_24D35:loc_24D9Dp
			; sub_24DAE+9EP
			; sub_24DAE+C09P
			; sub_26026+30P
			; sub_26026+B5P
			; rschKBD_s2669B+2CEP
			; sub_27913+10BP
			; sub_27CC0+9CP
			; sub_27CC0+11DP
			; sub_27E4B+293P
			; sub_2B470+3DAP
			; sub_2E00A+93P
			; sub_2E00A+179P
			; sub_2E00A+1C5P

arg_Mouse_w360A4= word ptr  6
arg_Mouse_w360A6= word ptr  8

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	dx, [idk_Mouse_w3609A]
cmp	dx, 0		; Compare Two Operands
jz	short loc_24A94	; Jump if Zero (ZF=1)
mov	bx, [bp+arg_Mouse_w360A4]
mov	cx, [bp+arg_Mouse_w360A6]
push	cs
call	near ptr sub_24AC0 ; Call Procedure
nop			; No Operation

loc_24A94:		; CODE XREF: sub_24A74+13j
pop	ds
pop	es
pop	di
pop	si

loc_24A98:
pop	bp
retf			; Return Far from Procedure
endp sub_24A74



; Attributes: bp-based frame

proc sub_24A9A far	; CODE XREF: sub_2E303:loc_2E333P

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	dx, [idk_Mouse_w3609A]
cmp	dx, 0		; Compare Two Operands
jz	short loc_24ABA	; Jump if Zero (ZF=1)
mov	bx, [bp+arg_0]

loc_24AB2:
mov	cx, [bp+arg_2]
push	cs
call	near ptr sub_24B91 ; Call Procedure
nop			; No Operation

loc_24ABA:		; CODE XREF: sub_24A9A+13j
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_24A9A



; Attributes: bp-based frame

proc sub_24AC0 far	; CODE XREF: sub_24A74+1Cp

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	es
push	ds
push	si
push	di
mov	ax, seg	dseg
mov	ds, ax
cmp	dx, 0		; Compare Two Operands
jnz	short loc_24ADC	; Jump if Not Zero (ZF=0)
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_24ADC:		; CODE XREF: sub_24AC0+12j
dec	dx		; Decrement by 1
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	dx, [ptrFontsLbx2_@80] ; Add
mov	[bp+var_2], dx
mov	dx, cx
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	dx, cx		; Add
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, dx		; Add
add	ax, VIDEO_RAM	; Add
mov	es, ax
mov	ax, 200
sub	ax, cx		; Integer Subtraction
jbe	short loc_24B89	; Jump if Below	or Equal (CF=1 | ZF=1)
cmp	ax, 17		; Compare Two Operands
js	short loc_24B15	; Jump if Sign (SF=1)
mov	ax, 10h

loc_24B15:		; CODE XREF: sub_24AC0+50j
mov	[bp+var_4], ax
mov	ax, bx
mov	ah, 1
and	al, 3		; Logical AND

loc_24B1E:		; Jump if Zero (ZF=1)
jz	short loc_24B28
mov	cl, al
xor	ch, ch		; Logical Exclusive OR

loc_24B24:		; CODE XREF: sub_24AC0+66j
shl	ah, 1		; Shift	Logical	Left
loop	loc_24B24	; Loop while CX	!= 0

loc_24B28:		; CODE XREF: sub_24AC0:loc_24B1Ej
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	dx, bx
shr	dx, 1		; Shift	Logical	Right
shr	dx, 1		; Shift	Logical	Right
mov	cx, 320
sub	cx, bx		; Integer Subtraction
jbe	short loc_24B89	; Jump if Below	or Equal (CF=1 | ZF=1)
cmp	cx, 11h		; Compare Two Operands
js	short loc_24B43	; Jump if Sign (SF=1)
mov	cx, 16

loc_24B43:		; CODE XREF: sub_24AC0+7Ej
mov	bl, cl
mov	bh, [byte ptr bp+var_4]
mov	si, 0
mov	cx, [bp+var_2]
mov	ds, cx

loc_24B50:		; CODE XREF: sub_24AC0:loc_24B87j
mov	di, dx
mov	dx, SC_DATA
mov	al, ah
out	dx, al		; EGA port: sequencer data register
mov	dx, di
mov	cl, bh
xor	ch, ch		; Logical Exclusive OR

loc_24B5E:		; CODE XREF: sub_24AC0+A6j
			; sub_24AC0+AFj
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jnz	short loc_24B6B	; Jump if Not Zero (ZF=0)
add	di, 80		; Add
loop	loc_24B5E	; Loop while CX	!= 0
jmp	short loc_24B71	; Jump
db 90h

loc_24B6B:		; CODE XREF: sub_24AC0+A1j
stosb			; Store	String
add	di, 79		; Add
loop	loc_24B5E	; Loop while CX	!= 0

loc_24B71:		; CODE XREF: sub_24AC0+A8j
mov	cl, 16
sub	cl, bh		; Integer Subtraction
xor	ch, ch		; Logical Exclusive OR
add	si, cx		; Add
dec	bl		; Decrement by 1
jz	short loc_24B89	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_24B87	; Jump if Sign (SF=1)
inc	dx		; Increment by 1
mov	ah, 1

loc_24B87:		; CODE XREF: sub_24AC0+C2j
jmp	short loc_24B50	; Jump

loc_24B89:		; CODE XREF: sub_24AC0+4Bj
			; sub_24AC0+79j
			; sub_24AC0+BBj
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_24AC0



; Attributes: bp-based frame

proc sub_24B91 far	; CODE XREF: sub_24A9A+1Cp

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	es
push	ds
push	si
push	di
mov	ax, seg	dseg
mov	ds, ax
cmp	dx, 0		; Compare Two Operands
jnz	short loc_24BAD	; Jump if Not Zero (ZF=0)
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_24BAD:		; CODE XREF: sub_24B91+12j
dec	dx		; Decrement by 1

loc_24BAE:		; Shift	Logical	Left
shl	dx, 1

loc_24BB0:		; Shift	Logical	Left
shl	dx, 1
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	dx, [ptrFontsLbx2_@80] ; Add
mov	[bp+var_2], dx

loc_24BBD:
mov	dx, cx
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	dx, cx		; Add
mov	ax, 1
sub	ax, [idk_VGA_w35ED6] ; Integer Subtraction
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
add	ax, dx		; Add
mov	es, ax
mov	ax, 0C8h ; ''
sub	ax, cx		; Integer Subtraction
jbe	short loc_24C5E	; Jump if Below	or Equal (CF=1 | ZF=1)
cmp	ax, 11h		; Compare Two Operands
js	short loc_24BEA	; Jump if Sign (SF=1)
mov	ax, 10h

loc_24BEA:		; CODE XREF: sub_24B91+54j
mov	[bp+var_4], ax
mov	ax, bx
mov	ah, 1
and	al, 3		; Logical AND
jz	short loc_24BFD	; Jump if Zero (ZF=1)
mov	cl, al
xor	ch, ch		; Logical Exclusive OR

loc_24BF9:		; CODE XREF: sub_24B91+6Aj
shl	ah, 1		; Shift	Logical	Left
loop	loc_24BF9	; Loop while CX	!= 0

loc_24BFD:		; CODE XREF: sub_24B91+62j
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	dx, bx
shr	dx, 1		; Shift	Logical	Right

loc_24C07:		; Shift	Logical	Right
shr	dx, 1
mov	cx, 140h
sub	cx, bx		; Integer Subtraction
jbe	short loc_24C5E	; Jump if Below	or Equal (CF=1 | ZF=1)
cmp	cx, 11h		; Compare Two Operands
js	short loc_24C18	; Jump if Sign (SF=1)
mov	cx, 10h

loc_24C18:		; CODE XREF: sub_24B91+82j
mov	bl, cl
mov	bh, [byte ptr bp+var_4]
mov	si, 0
mov	cx, [bp+var_2]
mov	ds, cx

loc_24C25:		; CODE XREF: sub_24B91:loc_24C5Cj
mov	di, dx
mov	dx, 3C5h
mov	al, ah

loc_24C2C:		; EGA port: sequencer data register
out	dx, al
mov	dx, di

loc_24C2F:
mov	cl, bh
xor	ch, ch		; Logical Exclusive OR

loc_24C33:		; CODE XREF: sub_24B91:loc_24C3Bj
			; sub_24B91+B3j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jnz	short loc_24C40	; Jump if Not Zero (ZF=0)

loc_24C38:		; Add
add	di, 50h	; 'P'

loc_24C3B:		; Loop while CX	!= 0
loop	loc_24C33
jmp	short loc_24C46	; Jump
align 2

loc_24C40:		; CODE XREF: sub_24B91+A5j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_24C33	; Loop while CX	!= 0

loc_24C46:		; CODE XREF: sub_24B91+ACj
mov	cl, 10h
sub	cl, bh		; Integer Subtraction
xor	ch, ch		; Logical Exclusive OR

loc_24C4C:		; Add
add	si, cx
dec	bl		; Decrement by 1
jz	short loc_24C5E	; Jump if Zero (ZF=1)

loc_24C52:		; Shift	Logical	Left
shl	ah, 1
cmp	ah, 9		; Compare Two Operands
js	short loc_24C5C	; Jump if Sign (SF=1)
inc	dx		; Increment by 1
mov	ah, 1

loc_24C5C:		; CODE XREF: sub_24B91+C6j
jmp	short loc_24C25	; Jump

loc_24C5E:		; CODE XREF: sub_24B91+4Fj
			; sub_24B91+7Dj
			; sub_24B91+BFj
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp

loc_24C64:
pop	bp
retf			; Return Far from Procedure
endp sub_24B91




proc sub_24C66 far	; CODE XREF: sub_25D32+AP
mov	ax, [word_36A28]
mov	es, ax
mov	ax, 0FFFFh
mov	di, 0
mov	cx, [word_36A2A]
shl	cx, 1		; Shift	Logical	Left

loc_24C77:		; CODE XREF: sub_24C66+12j
stosw			; Store	String
loop	loc_24C77	; Loop while CX	!= 0
mov	ax, 0
mov	[word_36A22], ax
mov	[word_36A24], ax
retf			; Return Far from Procedure
endp sub_24C66




proc set_w36A24_0 far	; CODE XREF: sub_25D4E+AP
mov	[word_36A24], 0
retf			; Return Far from Procedure
endp set_w36A24_0




proc set_w36A26_1 far	; CODE XREF: sub_25D32+FP
			; sub_25D4E+FP
mov	[word_36A26], 1
retf			; Return Far from Procedure
endp set_w36A26_1




proc sub_24C92 far	; CODE XREF: sub_24CE7+1Bp
			; sub_24D35+15p
			; sub_25D6A+9P
mov	ax, [word_36A28]
mov	es, ax
mov	ax, 0FFFFh
mov	di, [word_36A22]
shr	di, 1		; Shift	Logical	Right
mov	bx, [word_36A2A]
cmp	di, bx		; Compare Two Operands
jz	short loc_24CA9	; Jump if Zero (ZF=1)
stosw			; Store	String

loc_24CA9:		; CODE XREF: sub_24C92+14j
mov	[word_36A26], 0
retf			; Return Far from Procedure
endp sub_24C92




proc sub_24CB0 far	; CODE XREF: sub_25DAB+41P
push	es
push	ds
push	si
push	di
mov	[word_36A22], 0
mov	ax, [word_36A28]
mov	es, ax
mov	ax, 0FFFFh
xor	di, di		; Logical Exclusive OR
mov	bx, [word_36A2A]
shl	bx, 1		; Shift	Logical	Left
jmp	short loc_24CCF	; Jump
nop			; No Operation

loc_24CCD:		; CODE XREF: sub_24CB0+26j
inc	di		; Increment by 1
inc	di		; Increment by 1

loc_24CCF:		; CODE XREF: sub_24CB0+1Aj
cmp	[es:di], ax	; Compare Two Operands
jz	short loc_24CD8	; Jump if Zero (ZF=1)
cmp	di, bx		; Compare Two Operands
jnz	short loc_24CCD	; Jump if Not Zero (ZF=0)

loc_24CD8:		; CODE XREF: sub_24CB0+22j
mov	[word_36A22], di
mov	ax, di
pop	di
pop	si
pop	ds
pop	es
retf			; Return Far from Procedure
mov	ax, [word_36A26]
retf			; Return Far from Procedure
endp sub_24CB0



; Attributes: bp-based frame

proc sub_24CE7 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

; FUNCTION CHUNK AT 0E3B SIZE 0000002A BYTES

push	bp
mov	bp, sp
push	ds
push	es
push	si
push	di
mov	ax, [word_36A28]
mov	es, ax
mov	si, [word_36A22]
mov	cx, [word_36A2A]
shl	cx, 1		; Shift	Logical	Left
cmp	si, cx		; Compare Two Operands
jnz	short loc_24D0B	; Jump if Not Zero (ZF=0)
push	cs
call	near ptr sub_24C92 ; Call Procedure
pop	di
pop	si
pop	es
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_24CE7

; START	OF FUNCTION CHUNK FOR sub_24CE7

loc_24D0B:		; CODE XREF: sub_24CE7+18j
mov	di, si
shr	di, 1		; Shift	Logical	Right
add	di, cx		; Add
mov	ax, [bp+arg_0]

loc_24D14:
mov	[es:si], ax
mov	ax, [bp+arg_2]
xor	ah, ah		; Logical Exclusive OR
mov	[es:di], al
mov	ax, [bp+arg_4]
add	di, [word_36A2A] ; Add

loc_24D26:
mov	[es:di], al
inc	si		; Increment by 1
inc	si		; Increment by 1
mov	[word_36A22], si
pop	di
pop	si
pop	es
pop	ds
pop	bp
retf			; Return Far from Procedure
; END OF FUNCTION CHUNK	FOR sub_24CE7



proc sub_24D35 far
push	ds
push	es
push	si
push	di

loc_24D39:
mov	ax, [word_36A28]
mov	es, ax
mov	si, [word_36A24]
mov	ax, [word_36A22]
cmp	ax, si		; Compare Two Operands

loc_24D47:		; Jump if Not Zero (ZF=0)
jnz	short loc_24D52

loc_24D49:		; CODE XREF: sub_24D35+31j
push	cs
call	near ptr sub_24C92 ; Call Procedure
pop	di
pop	si
pop	es
pop	ds
retf			; Return Far from Procedure

loc_24D52:		; CODE XREF: sub_24D35:loc_24D47j
mov	cx, [word_36A2A]
shl	cx, 1		; Shift	Logical	Left
mov	di, si
shr	di, 1		; Shift	Logical	Right
add	di, cx		; Add
xor	bx, bx		; Logical Exclusive OR

loc_24D60:
mov	ax, [es:si]
cmp	ax, 0FFFFh	; Compare Two Operands
jz	short loc_24D49	; Jump if Zero (ZF=1)
mov	bl, [es:di]
xor	cx, cx		; Logical Exclusive OR

loc_24D6D:		; Add
add	di, [word_36A2A]
mov	cl, [es:di]
push	cx
push	bx

loc_24D76:
push	ax
push	cs
call	near ptr sub_245E4 ; Call Procedure
cmp	cl, 0		; Compare Two Operands
jnz	short loc_24D84	; Jump if Not Zero (ZF=0)
push	cs
call	near ptr get_w360AC_set0 ; Call	Procedure

loc_24D84:		; CODE XREF: sub_24D35+49j
push	cs

loc_24D85:		; Call Procedure
call	near ptr CALL_PositionMouseCursor

loc_24D88:
mov	ax, [idk_Mouse_w360A8]

loc_24D8B:		; Compare Two Operands
cmp	ax, 2

loc_24D8E:		; Jump if Below	(CF=1)
jb	short loc_24D94
push	cs

loc_24D91:		; Call Procedure
call	near ptr idk_Mouse_s23F82

loc_24D94:		; CODE XREF: sub_24D35:loc_24D8Ej
push	cs

loc_24D95:		; Call Procedure
call	near ptr idk_ChkMousDoEga

loc_24D98:
push	cs

loc_24D99:		; Call Procedure
call	near ptr sub_24648

loc_24D9C:
push	cs

loc_24D9D:		; Call Procedure
call	near ptr sub_24A74

loc_24DA0:		; Add
add	sp, 6

loc_24DA3:		; Increment by 1
inc	si

loc_24DA4:		; Increment by 1
inc	si

loc_24DA5:
mov	[word_36A24], si

loc_24DA9:
pop	di

loc_24DAA:
pop	si

loc_24DAB:
pop	es

loc_24DAC:
pop	ds

locret_24DAD:		; Return Far from Procedure
retf
endp sub_24D35

ends seg033


; Segment type:	Pure code
segment	seg034 byte public 'CODE' use16
assume cs:seg034
;org 0Eh
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_24DAE far	; CODE XREF: sub_2B97A+33p

varLKeyCode1= byte ptr -15h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
varMouseButtonStatus= word ptr -6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 16h		; Integer Subtraction
push	si		; argSrc
push	di		; src
mov	[bp+var_14], 0
mov	[w36A32], 0FFFFh
mov	[bp+varMouseButtonStatus], 0
mov	[word_36A4A], 0
call	get__Mouse_w360A4 ; Call Procedure
mov	[bp+var_2], ax
call	get__Mouse_w360A6 ; Call Procedure
mov	[bp+var_4], ax
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax
call	_f331647_TestKeyPress ;	Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short NOT_KeyPress ; Jump if Not Zero (ZF=0)

loc_24DED:		; Jump
jmp	loc_254D2

NOT_KeyPress:		; CODE XREF: sub_24DAE+3Dj
lea	ax, [bp+var_14]	; int
push	ax		; int
nop			; No Operation
push	cs
call	near ptr rschKBD_s2669B	; Call Procedure
pop	cx
mov	[bp+varLKeyCode1], al
cmp	[bp+varLKeyCode1], 0 ; Compare Two Operands
jnz	short CheckIfDebugMode ; Jump if Not Zero (ZF=0)

loc_24E03:		; CODE XREF: sub_24DAE+16Aj
			; sub_24DAE:loc_254CFj
			; sub_24DAE+73Ej
call	hrmMsExchIntSub	; Call Procedure

loc_24E08:		; CODE XREF: sub_24DAE+316j
			; sub_24DAE+B23j
			; sub_24DAE+E83j
			; sub_24DAE:loc_25CF6j
xor	ax, ax		; Logical Exclusive OR

loc_24E0A:		; CODE XREF: sub_24DAE+623j
			; sub_24DAE+EA9j
			; sub_24DAE+ECBj
			; sub_24DAE+F4Ej
			; sub_24DAE+F56j
jmp	loc_25D07	; Jump

CheckIfDebugMode:	; CODE XREF: sub_24DAE+53j
cmp	[bp+varLKeyCode1], 145 ; Compare Two Operands
jnz	short NOT_KeyCode_145 ;	Jump if	Not Zero (ZF=0)

IS_KeyCode_145:		; Call Procedure
call	IfDebugExitWithMemDiag

NOT_KeyCode_145:	; CODE XREF: sub_24DAE+63j
cmp	[bp+varLKeyCode1], 146 ; Compare Two Operands
jnz	short NOT_KeyCode_146 ;	Jump if	Not Zero (ZF=0)

IS_KeyCode_146:		; FLAG_w360BE =	FLAG_w3609E, FLAG_w3609E = 0
call	Disable_Set_FLAG_Mouse_Skip
call	idk_ChkMousDoEga ; Call	Procedure
call	ST_ScreenDump	; Call Procedure
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24648	; Call Procedure
pop	cx
pop	cx
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24A74	; Call Procedure
pop	cx
pop	cx
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE

NOT_KeyCode_146:	; CODE XREF: sub_24DAE+6Ej
cmp	[bp+varLKeyCode1], 27 ;	#define	ESC 27
			;
			; an escape code of 27 meaning that it is a mutli-value	code
			;
			; if (kbhit())	  {
			;	    c =	getchar();	    // ESC to quit program
			;
			;	    if(	c==27 )	{
			;		if(kbhit()) {  // another character in the buffer, must	be a function/arrow key
			;		    c =	getchar();
			;
			;		    // work out	which function key and take appropriate	action.
			;		}
			;		else {
			;		     printf("\n\n ESC pressed -	program	terminated by user \n");
			;
jnz	short loc_24E7B	; Jump if Not Zero (ZF=0)
cmp	[idk_CfgMom_w36A54], 0 ; Compare Two Operands
jnz	short loc_24E7B	; Jump if Not Zero (ZF=0)
jmp	SET_AX_FFFF	; Jump

loc_24E7B:		; CODE XREF: sub_24DAE+C1j
			; sub_24DAE+C8j
cmp	[bp+varLKeyCode1], 96 ;	#define	NMPD_0 96

loc_24E7F:		; Jump if Not Zero (ZF=0)
jnz	short loc_24E9F

loc_24E81:		; Call Procedure
call	fncCheckDebugMode

loc_24E86:		; Logical Inclusive OR
or	ax, ax

loc_24E88:		; Jump if Not Zero (ZF=0)
jnz	short loc_24E9F

loc_24E8A:		; Compare Two Operands
cmp	[word_36A6C], 0

loc_24E8F:		; Jump if Not Zero (ZF=0)
jnz	short loc_24E99

loc_24E91:
mov	[word_36A6C], 1

loc_24E97:		; Jump
jmp	short loc_24E9F

loc_24E99:		; CODE XREF: sub_24DAE:loc_24E8Fj
mov	[word_36A6C], 0

loc_24E9F:		; CODE XREF: sub_24DAE:loc_24E7Fj
			; sub_24DAE:loc_24E88j
			; sub_24DAE:loc_24E97j
cmp	[bp+varLKeyCode1], 126 ; ~    126    7E
			; #define K_ALT7	126 | XF
			;
jnz	short loc_24EC3	; Jump if Not Zero (ZF=0)
call	fncCheckDebugMode ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_24EC3	; Jump if Not Zero (ZF=0)

FlipFLAG_w36A6E:	; Compare Two Operands
cmp	[FLAG_w36A6E], 0
jnz	short loc_24EBD	; Jump if Not Zero (ZF=0)

loc_24EB5:
mov	[FLAG_w36A6E], 1
jmp	short loc_24EC3	; Jump

loc_24EBD:		; CODE XREF: sub_24DAE+105j
mov	[FLAG_w36A6E], 0

loc_24EC3:		; CODE XREF: sub_24DAE+F5j
			; sub_24DAE+FEj
			; sub_24DAE+10Dj
mov	ax, [bp+var_14]

loc_24EC6:
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_24ECF:		; Add
add	bx, ax
cmp	[word ptr es:bx+8], 8 ;	Compare	Two Operands
jnz	short loc_24EE0	; Jump if Not Zero (ZF=0)
call	hrmMsExchIntSub	; Call Procedure
jmp	SET_AX_var14	; Jump

loc_24EE0:		; CODE XREF: sub_24DAE+128j
cmp	[bp+var_14], 0	; Compare Two Operands
jnz	short loc_24EE9	; Jump if Not Zero (ZF=0)

loc_24EE6:		; Jump
jmp	loc_2507A

loc_24EE9:		; CODE XREF: sub_24DAE+136j
mov	ax, [bp+var_14]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_24EF7:
mov	al, [es:bx+24h]

loc_24EFB:		; Compare Two Operands
cmp	al, [bp+varLKeyCode1]

loc_24EFE:		; Jump if Zero (ZF=1)
jz	short loc_24F03

loc_24F00:		; Jump
jmp	loc_2507A

loc_24F03:		; CODE XREF: sub_24DAE:loc_24EFEj
mov	ax, [bp+var_14]

loc_24F06:
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_24F11:		; Compare Two Operands
cmp	[word ptr es:bx+8], 6
jnz	short loc_24F1B	; Jump if Not Zero (ZF=0)
jmp	loc_24E03	; Jump

loc_24F1B:		; CODE XREF: sub_24DAE+168j
cmp	[bp+var_14], 0	; Compare Two Operands

loc_24F1F:		; Jump if Not Zero (ZF=0)
jnz	short loc_24F24
jmp	loc_25069	; Jump

loc_24F24:		; CODE XREF: sub_24DAE:loc_24F1Fj
mov	ax, [bp+var_14]
mov	dx, 38

loc_24F2A:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, [bp+var_14]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction

loc_24F4C:		; Shift	Arithmetic Right
sar	ax, 1
push	ax

loc_24F4F:
mov	ax, [bp+var_14]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]

loc_24F60:
pop	dx
add	ax, dx		; Add
mov	[bp+var_2], ax
mov	ax, [bp+var_14]
mov	dx, 38
imul	dx		; Signed Multiply

loc_24F6E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_24F72:		; Add
add	bx, ax

loc_24F74:
mov	ax, [es:bx+6]
push	ax
mov	ax, [bp+var_14]
mov	dx, 38
imul	dx		; Signed Multiply

loc_24F81:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_24F85:		; Add
add	bx, ax
pop	ax

loc_24F88:		; Integer Subtraction
sub	ax, [es:bx+2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax

loc_24F92:
mov	ax, [bp+var_14]
mov	dx, 38

loc_24F98:		; Signed Multiply
imul	dx

loc_24F9A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_24F9E:		; Add
add	bx, ax

loc_24FA0:
mov	ax, [es:bx+2]
pop	dx

loc_24FA5:		; Add
add	ax, dx
mov	[bp+var_4], ax
push	[bp+var_4]
push	[bp+var_2]

loc_24FB0:
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_2E00A ; Call Procedure
add	sp, 6		; Add

loc_24FBB:		; Call Procedure
call	hrmMsExchIntSub

loc_24FC0:
mov	ax, [bp+var_14]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_24FCE:
mov	ax, [es:bx+8]
cmp	ax, 1		; Compare Two Operands
jz	short loc_25020	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_24FE4	; Jump if Zero (ZF=1)
cmp	ax, 9		; Compare Two Operands
jz	short loc_2501D	; Jump if Zero (ZF=1)

loc_24FE1:		; Jump
jmp	loc_25067

loc_24FE4:		; CODE XREF: sub_24DAE+22Cj
mov	ax, [bp+var_14]

loc_24FE7:
mov	dx, 26h	; '&'

loc_24FEA:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_25013	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_2501B	; Jump

loc_25013:		; CODE XREF: sub_24DAE+24Bj
nop			; No Operation
push	cs
call	near ptr sub_2E27D ; Call Procedure
jmp	aSET_w36A32_FFFF ; Jump

loc_2501B:		; CODE XREF: sub_24DAE+263j
jmp	short loc_25069	; Jump

loc_2501D:		; CODE XREF: sub_24DAE+231j
jmp	loc_25C61	; Jump

loc_25020:		; CODE XREF: sub_24DAE+227j
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2504F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_25065	; Jump

loc_2504F:		; CODE XREF: sub_24DAE+287j
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2505D:
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 0

loc_25065:		; CODE XREF: sub_24DAE+29Fj
jmp	short loc_25069	; Jump

loc_25067:		; CODE XREF: sub_24DAE:loc_24FE1j
jmp	short $+2	; Jump

loc_25069:		; CODE XREF: sub_24DAE+173j
			; sub_24DAE:loc_2501Bj
			; sub_24DAE:loc_25065j
nop			; No Operation
push	cs
call	near ptr sub_2E27D ; Call Procedure
mov	[w36A32], 0FFFFh
jmp	SET_AX_var14	; Jump
jmp	loc_254D2	; Jump

loc_2507A:		; CODE XREF: sub_24DAE:loc_24EE6j
			; sub_24DAE:loc_24F00j
cmp	[bp+varLKeyCode1], 0Ch ; Compare Two Operands
jz	short loc_25083	; Jump if Zero (ZF=1)
jmp	loc_2537F	; Jump

loc_25083:		; CODE XREF: sub_24DAE+2D0j
cmp	[word_36A6A], 0	; Compare Two Operands
jz	short loc_250B9	; Jump if Zero (ZF=1)
mov	si, [word_36A70]
mov	ax, 0A870h
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2509F:		; argDest
push	[word ptr es:bx+16h]
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
cmp	[word_36A56], 0	; Compare Two Operands
jnz	short loc_250B6	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_2E27D ; Call Procedure

loc_250B6:		; CODE XREF: sub_24DAE+301j
jmp	SET_w36A32_FFFF	; Jump

loc_250B9:		; CODE XREF: sub_24DAE+2DAj
nop			; No Operation
push	cs

loc_250BB:		; Call Procedure
call	near ptr sub_27A2B
mov	si, ax
or	si, si		; Logical Inclusive OR
jnz	short loc_250C7	; Jump if Not Zero (ZF=0)
jmp	loc_24E08	; Jump

loc_250C7:		; CODE XREF: sub_24DAE+314j
or	si, si		; Logical Inclusive OR
jg	short loc_250CE	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_25222	; Jump

loc_250CE:		; CODE XREF: sub_24DAE+31Bj
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jz	short loc_250E5	; Jump if Zero (ZF=1)

loc_250E2:		; Jump
jmp	loc_251AB

loc_250E5:		; CODE XREF: sub_24DAE+332j
cmp	[word_36A6A], 0	; Compare Two Operands
jnz	short loc_25121	; Jump if Not Zero (ZF=0)

loc_250EC:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_250F9:
push	[word ptr es:bx+16h]
mov	ax, 0A870h
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	[word_36A66], 0
mov	[word_36A68], 0
mov	[word_36A6A], 1
mov	[word_36A70], si
jmp	loc_251A9	; Jump

loc_25121:		; CODE XREF: sub_24DAE+33Cj
cmp	[word_36A70], si ; Compare Two Operands
jz	short loc_25155	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply

loc_2512E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, offset idk2_b3C580
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	[word_36A66], 0
mov	[word_36A68], 0
mov	[word_36A70], si
jmp	short loc_251A9	; Jump

loc_25155:		; CODE XREF: sub_24DAE+377j
xor	di, di		; Logical Exclusive OR
jmp	short loc_2515A	; Jump

loc_25159:		; CODE XREF: sub_24DAE+3C4j
inc	di		; Increment by 1

loc_2515A:		; CODE XREF: sub_24DAE+3A9j
cmp	[byte ptr di-5790h], 0 ; Compare Two Operands
jz	short loc_25174	; Jump if Zero (ZF=1)
mov	ax, si

loc_25163:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2516C:		; Add
add	bx, ax

loc_2516E:		; Compare Two Operands
cmp	[es:bx+20h], di
jg	short loc_25159	; Jump if Greater (ZF=0	& SF=OF)

loc_25174:		; CODE XREF: sub_24DAE+3B1j
cmp	[byte ptr di-5791h], 5Fh ; '_' ; Compare Two Operands

loc_25179:		; Jump if Not Zero (ZF=0)
jnz	short loc_2517C
dec	di		; Decrement by 1

loc_2517C:		; CODE XREF: sub_24DAE:loc_25179j
mov	[byte ptr di-5790h], 0
mov	[word_36A66], 0
mov	[word_36A70], 0FFFFh
mov	ax, 0A870h
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_251A9:		; CODE XREF: sub_24DAE+370j
			; sub_24DAE+3A5j
jmp	short loc_25222	; Jump

loc_251AB:		; CODE XREF: sub_24DAE:loc_250E2j
cmp	[word_36A6A], 0	; Compare Two Operands
jz	short loc_25222	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 11 ; Compare Two Operands
jz	short loc_25222	; Jump if Zero (ZF=1)
xor	di, di		; Logical Exclusive OR
jmp	short loc_251CB	; Jump

loc_251CA:		; CODE XREF: sub_24DAE+436j
inc	di		; Increment by 1

loc_251CB:		; CODE XREF: sub_24DAE+41Aj
cmp	[byte ptr di-5790h], 0 ; Compare Two Operands
jz	short loc_251E6	; Jump if Zero (ZF=1)
mov	ax, [word_36A70]
mov	dx, 26h	; '&'

loc_251D8:		; Signed Multiply
imul	dx

loc_251DA:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_251E0:		; Compare Two Operands
cmp	[es:bx+20h], di
jg	short loc_251CA	; Jump if Greater (ZF=0	& SF=OF)

loc_251E6:		; CODE XREF: sub_24DAE+422j
cmp	[byte ptr di-5791h], 5Fh ; '_' ; Compare Two Operands
jnz	short loc_251EE	; Jump if Not Zero (ZF=0)
dec	di		; Decrement by 1

loc_251EE:		; CODE XREF: sub_24DAE+43Dj
mov	[byte ptr di-5790h], 0
mov	ax, offset idk2_b3C580
push	ax
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; argDest

loc_25209:		; argDest,argSrc
call	_strcpy

loc_2520E:
pop	cx
pop	cx
mov	[word_36A66], 0
mov	[word_36A6A], 0

loc_2521C:
mov	[word_36A70], 0FFFFh

loc_25222:		; CODE XREF: sub_24DAE+31Dj
			; sub_24DAE:loc_251A9j
			; sub_24DAE+402j
			; sub_24DAE+416j
or	si, si		; Logical Inclusive OR
jnz	short loc_25229	; Jump if Not Zero (ZF=0)
jmp	loc_2531A	; Jump

loc_25229:		; CODE XREF: sub_24DAE+476j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 6 ;	Compare	Two Operands
jz	short loc_25260	; Jump if Zero (ZF=1)

loc_2523D:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jz	short loc_25260	; Jump if Zero (ZF=1)
push	[bp+var_4]
push	[bp+var_2]
push	si
nop			; No Operation
push	cs
call	near ptr sub_2E00A ; Call Procedure
add	sp, 6		; Add

loc_25260:		; CODE XREF: sub_24DAE+48Dj
			; sub_24DAE+4A1j
call	hrmMsExchIntSub	; Call Procedure
mov	ax, si

loc_25267:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+8]
cmp	ax, 1		; Compare Two Operands
jz	short loc_252C5	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_25288	; Jump if Zero (ZF=1)
cmp	ax, 9		; Compare Two Operands
jz	short loc_252BA	; Jump if Zero (ZF=1)
jmp	loc_25309	; Jump

loc_25288:		; CODE XREF: sub_24DAE+4D0j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_252B5	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_252B8	; Jump

loc_252B5:		; CODE XREF: sub_24DAE+4EEj
jmp	aSET_w36A32_FFFF ; Jump

loc_252B8:		; CODE XREF: sub_24DAE+505j
jmp	short loc_2530B	; Jump

loc_252BA:		; CODE XREF: sub_24DAE+4D5j
mov	[w36A32], 0FFFFh
mov	ax, si
jmp	loc_25C6A	; Jump

loc_252C5:		; CODE XREF: sub_24DAE+4CBj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_252D0:		; Add
add	bx, ax
mov	bx, [es:bx+1Ah]

loc_252D6:		; Compare Two Operands
cmp	[word ptr bx], 0
jnz	short loc_252F2	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_25307	; Jump

loc_252F2:		; CODE XREF: sub_24DAE+52Bj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_252FF:
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 0

loc_25307:		; CODE XREF: sub_24DAE+542j
jmp	short loc_2530B	; Jump

loc_25309:		; CODE XREF: sub_24DAE+4D7j
jmp	short $+2	; Jump

loc_2530B:		; CODE XREF: sub_24DAE:loc_252B8j
			; sub_24DAE:loc_25307j
cmp	[word_36A56], 0	; Compare Two Operands
jnz	short loc_25317	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_2E27D ; Call Procedure

loc_25317:		; CODE XREF: sub_24DAE+562j
jmp	SET_w36A32_FFFF	; Jump

loc_2531A:		; CODE XREF: sub_24DAE+478j
cmp	[word_36A3A], 0	; Compare Two Operands
jz	short loc_2537F	; Jump if Zero (ZF=1)
mov	si, 1
jmp	short loc_25379	; Jump

loc_25326:		; CODE XREF: sub_24DAE+5CFj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_25331:		; Add
add	bx, ax
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jnz	short loc_25378	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_2533C:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_25345:		; Add
add	bx, ax
mov	bx, [es:bx+1Ah]
mov	ax, [bx]

loc_2534D:
push	ax
mov	ax, si

loc_25350:
mov	dx, 26h	; '&'

loc_25353:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cmp	ax, [es:bx+18h]	; Compare Two Operands

loc_25360:		; Jump if Not Zero (ZF=0)
jnz	short loc_25378
mov	ax, si

loc_25364:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_25378	; Jump if Zero (ZF=1)
jmp	short SET_w36A32_FFFF ;	Jump

loc_25378:		; CODE XREF: sub_24DAE+58Aj
			; sub_24DAE:loc_25360j
			; sub_24DAE+5C6j
inc	si		; Increment by 1

loc_25379:		; CODE XREF: sub_24DAE+576j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jl	short loc_25326	; Jump if Less (SF!=OF)

loc_2537F:		; CODE XREF: sub_24DAE+2D2j
			; sub_24DAE+571j
cmp	[bp+varLKeyCode1], 2Bh ; '+' ; Compare Two Operands

loc_25383:		; Jump if Zero (ZF=1)
jz	short loc_2538B
cmp	[bp+varLKeyCode1], 2Dh ; '-' ; Compare Two Operands
jnz	short loc_253D4	; Jump if Not Zero (ZF=0)

loc_2538B:		; CODE XREF: sub_24DAE:loc_25383j
nop			; No Operation
push	cs
call	near ptr sub_27A2B ; Call Procedure
mov	si, ax
or	si, si		; Logical Inclusive OR
jz	short loc_253D4	; Jump if Zero (ZF=1)

loc_25396:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 6 ;	Compare	Two Operands
jnz	short loc_253D4	; Jump if Not Zero (ZF=0)
cmp	[bp+varLKeyCode1], 2Bh ; '+' ; Compare Two Operands
jnz	short loc_253B7	; Jump if Not Zero (ZF=0)

loc_253B0:
push	si
nop			; No Operation
push	cs
call	near ptr sub_2A4B2 ; Call Procedure
pop	cx

loc_253B7:		; CODE XREF: sub_24DAE+600j
cmp	[bp+varLKeyCode1], 2Dh ; '-' ; Compare Two Operands
jnz	short loc_253C4	; Jump if Not Zero (ZF=0)
push	si
nop			; No Operation
push	cs
call	near ptr sub_2A5E4 ; Call Procedure
pop	cx

loc_253C4:		; CODE XREF: sub_24DAE+60Dj
call	hrmMsExchIntSub	; Call Procedure

SET_w36A32_FFFF:	; CODE XREF: sub_24DAE:loc_250B6j
			; sub_24DAE:loc_25317j
			; sub_24DAE+5C8j
mov	[w36A32], 0FFFFh
mov	ax, si
jmp	loc_24E0A	; Jump

loc_253D4:		; CODE XREF: sub_24DAE+5DBj
			; sub_24DAE+5E6j
			; sub_24DAE+5FAj
cmp	[word_36A6A], 0	; Compare Two Operands
jg	short loc_253DE	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_254C9	; Jump

loc_253DE:		; CODE XREF: sub_24DAE+62Bj
cmp	[bp+varLKeyCode1], 0Bh ; Compare Two Operands
jnz	short loc_253E7	; Jump if Not Zero (ZF=0)
jmp	loc_25490	; Jump

loc_253E7:		; CODE XREF: sub_24DAE+634j
mov	[bp+var_8], 0

loc_253EC:		; Compare Two Operands
cmp	[bp+varLKeyCode1], 40h ; '@'
jle	short loc_253F8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+varLKeyCode1], 5Dh ; ']' ; Compare Two Operands
jl	short loc_25410	; Jump if Less (SF!=OF)

loc_253F8:		; CODE XREF: sub_24DAE+642j
cmp	[bp+varLKeyCode1], 2Dh ; '-' ; Compare Two Operands
jle	short loc_25404	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+varLKeyCode1], 3Bh ; ';' ; Compare Two Operands
jl	short loc_25410	; Jump if Less (SF!=OF)

loc_25404:		; CODE XREF: sub_24DAE+64Ej
cmp	[bp+varLKeyCode1], 20h ; ' ' ; Compare Two Operands
jz	short loc_25410	; Jump if Zero (ZF=1)
cmp	[bp+varLKeyCode1], 2Dh ; '-' ; Compare Two Operands
jnz	short loc_25417	; Jump if Not Zero (ZF=0)

loc_25410:		; CODE XREF: sub_24DAE+648j
			; sub_24DAE+654j
			; sub_24DAE+65Aj
mov	[bp+var_8], 1
jmp	short loc_25428	; Jump

loc_25417:		; CODE XREF: sub_24DAE+660j
cmp	[bp+varLKeyCode1], 60h ; '`' ; Compare Two Operands
jle	short loc_25428	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+varLKeyCode1], 7Bh ; '{' ; Compare Two Operands
jge	short loc_25428	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_8], 1

loc_25428:		; CODE XREF: sub_24DAE+667j
			; sub_24DAE+66Dj
			; sub_24DAE+673j
cmp	[bp+var_8], 1	; Compare Two Operands
jnz	short loc_2548E	; Jump if Not Zero (ZF=0)
xor	si, si		; Logical Exclusive OR
jmp	short loc_25433	; Jump

loc_25432:		; CODE XREF: sub_24DAE+6A8j
inc	si		; Increment by 1

loc_25433:		; CODE XREF: sub_24DAE+682j
cmp	[byte ptr si-5790h], 5Fh ; '_' ; Compare Two Operands
jz	short loc_25458	; Jump if Zero (ZF=1)
cmp	[byte ptr si-5790h], 0 ; Compare Two Operands
jz	short loc_25458	; Jump if Zero (ZF=1)
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+20h]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jg	short loc_25432	; Jump if Greater (ZF=0	& SF=OF)

loc_25458:		; CODE XREF: sub_24DAE+68Aj
			; sub_24DAE+691j
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_25466:
mov	ax, [es:bx+20h]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jle	short loc_2547D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	al, [bp+varLKeyCode1]
mov	[si-5790h], al
mov	[byte ptr si-578Fh], 0
jmp	short loc_25482	; Jump

loc_2547D:		; CODE XREF: sub_24DAE+6BFj
mov	[byte ptr si-5790h], 0

loc_25482:		; CODE XREF: sub_24DAE+6CDj
mov	[word_36A68], 0
mov	[word_36A66], 0

loc_2548E:		; CODE XREF: sub_24DAE+67Ej
jmp	short loc_254C9	; Jump

loc_25490:		; CODE XREF: sub_24DAE+636j
xor	si, si		; Logical Exclusive OR
jmp	short loc_25495	; Jump

loc_25494:		; CODE XREF: sub_24DAE+70Aj
inc	si		; Increment by 1

loc_25495:		; CODE XREF: sub_24DAE+6E4j
cmp	[byte ptr si-5790h], 0 ; Compare Two Operands
jz	short loc_254BA	; Jump if Zero (ZF=1)

loc_2549C:		; Compare Two Operands
cmp	[byte ptr si-5790h], 5Fh ; '_'
jz	short loc_254BA	; Jump if Zero (ZF=1)
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+20h]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jg	short loc_25494	; Jump if Greater (ZF=0	& SF=OF)

loc_254BA:		; CODE XREF: sub_24DAE+6ECj
			; sub_24DAE+6F3j
or	si, si		; Logical Inclusive OR
jle	short loc_254C9	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[byte ptr si-5791h], 0
mov	[word_36A66], 0

loc_254C9:		; CODE XREF: sub_24DAE+62Dj
			; sub_24DAE:loc_2548Ej
			; sub_24DAE+70Ej
mov	[w36A32], 0FFFFh

loc_254CF:		; argSrc
jmp	loc_24E03

loc_254D2:		; CODE XREF: sub_24DAE:loc_24DEDj
			; sub_24DAE+2C9j
call	MOUSE_ExchangeInterrupt	; Call Procedure
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_254E3	; Jump if Zero (ZF=1)

loc_254E0:		; Jump
jmp	loc_258A9

loc_254E3:		; CODE XREF: sub_24DAE+730j
call	get_w360AC_set0	;
			; mov	  ax, seg dseg
			; mov	  ds, ax
			; mov	  ax, word_360AC
			; sub	  bx, bx
			; mov	  word_360AC, bx
			;
or	ax, ax		; Logical Inclusive OR
jnz	short loc_254F2	; Jump if Not Zero (ZF=0)
jmp	loc_24E03	; Jump
jmp	loc_258A6	; Jump

loc_254F2:		; CODE XREF: sub_24DAE+73Cj
call	idk_Get_Mouse_w360B2 ; Call Procedure
mov	[bp+varMouseButtonStatus], ax
cmp	[bp+varMouseButtonStatus], 2 ; [bp+varMouseButtonStatus]=2 (AKA	match Right-Click)
jnz	short MouseStatusIsRightButton ; Jump Not Zero / Jump Equal
cmp	[idk_Flag_Mouse_w36A78], 0 ; Compare Two Operands
jz	short loc_25513	; Jump if Zero (ZF=1)
nop			; No Operation
push	cs

loc_25509:		; Call Procedure
call	near ptr sub_25EA0
or	ax, ax		; Logical Inclusive OR
jnz	short loc_25513	; Jump if Not Zero (ZF=0)
jmp	loc_258C7	; Jump

loc_25513:		; CODE XREF: sub_24DAE+757j
			; sub_24DAE+760j
cmp	[idk_CfgMom_w36A54], 0 ; Compare Two Operands
jnz	short MouseStatusIsRightButton ; Jump if Not Zero (ZF=0)

loc_2551A:		; CODE XREF: sub_24DAE+B3Ej
call	get_w360AC_set0	; Call Procedure
call	_f332647_Get_w360B4_Set0 ; Call	Procedure
jmp	SET_AX_FFFF	; Jump

MouseStatusIsRightButton:
			; CODE XREF: sub_24DAE+750j
			; sub_24DAE+76Aj
call	idk_Get_Mouse_w360AE ; Call Procedure

loc_2552C:
mov	[bp+var_2], ax

loc_2552F:		; Call Procedure
call	idk_Get_Mouse_w360B0
mov	[bp+var_4], ax

loc_25537:
mov	[bp+var_14], 0

loc_2553C:
mov	[bp+var_12], 0FFFFh
mov	[bp+varLKeyCode1], 0
push	[bp+var_4]

loc_25548:
push	[bp+var_2]
call	idk_Mouse_s23F82 ; var_2, bp+var4
pop	cx
pop	cx
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax
mov	si, 1
jmp	loc_255E9	; Jump

loc_25560:		; CODE XREF: sub_24DAE+841j
mov	ax, si
mov	dx, 26h
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]

loc_25570:
mov	[bp+var_A], ax
mov	ax, si
mov	dx, 26h
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
mov	[bp+var_C], ax
mov	ax, si
mov	dx, 26h

loc_2558C:		; Signed Multiply
imul	dx

loc_2558E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+4]
mov	[bp+var_E], ax
mov	ax, si
mov	dx, 26h

loc_255A0:		; Signed Multiply
imul	dx

loc_255A2:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+6]
mov	[bp+var_10], ax
mov	ax, [bp+var_2]

loc_255B2:		; Add
add	ax, [idk_Mouse_w3C5A4]
cmp	ax, [bp+var_A]	; Compare Two Operands

loc_255B9:		; Jump if Less (SF!=OF)
jl	short loc_255E4
mov	ax, [bp+var_2]

loc_255BE:		; Add
add	ax, [idk_Mouse_w3C5A4]
cmp	ax, [bp+var_E]	; Compare Two Operands
jg	short loc_255E4	; Jump if Greater (ZF=0	& SF=OF)

loc_255C7:
mov	ax, [bp+var_4]
add	ax, [idk_Mouse_w3C5A4] ; Add

loc_255CE:		; Compare Two Operands
cmp	ax, [bp+var_C]
jl	short loc_255E4	; Jump if Less (SF!=OF)
mov	ax, [bp+var_4]
add	ax, [idk_Mouse_w3C5A4] ; Add
cmp	ax, [bp+var_10]	; Compare Two Operands
jg	short loc_255E4	; Jump if Greater (ZF=0	& SF=OF)
mov	[bp+var_14], si
jmp	short loc_255F2	; Jump

loc_255E4:		; CODE XREF: sub_24DAE:loc_255B9j
			; sub_24DAE+817j
			; sub_24DAE+823j
			; sub_24DAE+82Fj
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax

loc_255E9:		; CODE XREF: sub_24DAE+7AFj
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jge	short loc_255F2	; Jump if Greater or Equal (SF=OF)
jmp	loc_25560	; Jump

loc_255F2:		; CODE XREF: sub_24DAE+834j
			; sub_24DAE+83Fj
cmp	[bp+var_14], 0	; Compare Two Operands
jz	short loc_25629	; Jump if Zero (ZF=1)
mov	ax, [bp+var_14]
mov	dx, 26h
imul	dx		; Signed Multiply

loc_25600:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jz	short loc_25629	; Jump if Zero (ZF=1)
mov	ax, [bp+var_14]
mov	[word_36A4A], ax
push	[bp+var_4]
push	[bp+var_2]
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_2E00A ; Call Procedure
add	sp, 6		; Add
nop			; No Operation
push	cs
call	near ptr sub_2E27D ; Call Procedure

loc_25629:		; CODE XREF: sub_24DAE+848j
			; sub_24DAE+85Dj
cmp	[bp+var_14], 0	; Compare Two Operands
jnz	short loc_25632	; Jump if Not Zero (ZF=0)
jmp	loc_25777	; Jump

loc_25632:		; CODE XREF: sub_24DAE+87Fj
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jz	short loc_2564A	; Jump if Zero (ZF=1)
jmp	loc_2571A	; Jump

loc_2564A:		; CODE XREF: sub_24DAE+897j
cmp	[word_36A6A], 0	; Compare Two Operands
jnz	short loc_25689	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, 0A870h
push	ax		; argDest
call	_strcpy		; argDest,argSrc

loc_2566C:
pop	cx
pop	cx
mov	[word_36A66], 0
mov	[word_36A68], 0
mov	[word_36A6A], 1
mov	ax, [bp+var_14]
mov	[word_36A70], ax
jmp	loc_25718	; Jump

loc_25689:		; CODE XREF: sub_24DAE+8A1j
mov	ax, [word_36A70]
cmp	ax, [bp+var_14]	; Compare Two Operands
jz	short loc_256C2	; Jump if Zero (ZF=1)

loc_25691:
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_25699:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_2569F:
push	[word ptr es:bx+16h]

loc_256A3:
mov	ax, 0A870h
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_256AE:
mov	[word_36A66], 0
mov	[word_36A68], 0
mov	ax, [bp+var_14]

loc_256BD:
mov	[word_36A70], ax
jmp	short loc_25718	; Jump

loc_256C2:		; CODE XREF: sub_24DAE+8E1j
xor	di, di		; Logical Exclusive OR
jmp	short loc_256C7	; Jump

loc_256C6:		; CODE XREF: sub_24DAE+932j
inc	di		; Increment by 1

loc_256C7:		; CODE XREF: sub_24DAE+916j
cmp	[byte ptr di-5790h], 0 ; Compare Two Operands
jz	short loc_256E2	; Jump if Zero (ZF=1)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx+20h], di	; Compare Two Operands
jg	short loc_256C6	; Jump if Greater (ZF=0	& SF=OF)

loc_256E2:		; CODE XREF: sub_24DAE+91Ej
cmp	[byte ptr di-5791h], 5Fh ; '_' ; Compare Two Operands
jnz	short loc_256EA	; Jump if Not Zero (ZF=0)
dec	di		; Decrement by 1

loc_256EA:		; CODE XREF: sub_24DAE+939j
mov	[byte ptr di-5790h], 0
mov	[word_36A66], 0

loc_256F5:
mov	[word_36A70], 0FFFFh
mov	ax, 0A870h
push	ax

loc_256FF:
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_25707:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_2570B:		; Add
add	bx, ax

loc_2570D:		; argDest
push	[word ptr es:bx+16h]

loc_25711:		; argDest,argSrc
call	_strcpy
pop	cx
pop	cx

loc_25718:		; CODE XREF: sub_24DAE+8D8j
			; sub_24DAE+912j
jmp	short loc_25777	; Jump

loc_2571A:		; CODE XREF: sub_24DAE+899j
cmp	[word_36A6A], 0	; Compare Two Operands
jz	short loc_25777	; Jump if Zero (ZF=1)
xor	di, di		; Logical Exclusive OR
jmp	short loc_25726	; Jump

loc_25725:		; CODE XREF: sub_24DAE+991j
inc	di		; Increment by 1

loc_25726:		; CODE XREF: sub_24DAE+975j
cmp	[byte ptr di-5790h], 0 ; Compare Two Operands
jz	short loc_25741	; Jump if Zero (ZF=1)
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx+20h], di	; Compare Two Operands
jg	short loc_25725	; Jump if Greater (ZF=0	& SF=OF)

loc_25741:		; CODE XREF: sub_24DAE+97Dj
cmp	[byte ptr di-5791h], 5Fh ; '_' ; Compare Two Operands
jnz	short loc_25749	; Jump if Not Zero (ZF=0)
dec	di		; Decrement by 1

loc_25749:		; CODE XREF: sub_24DAE+998j
mov	[byte ptr di-5790h], 0
mov	ax, 0A870h
push	ax

loc_25752:
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_2576B:
mov	[word_36A6A], 0
mov	[word_36A70], 0FFFFh

loc_25777:		; CODE XREF: sub_24DAE+881j
			; sub_24DAE:loc_25718j
			; sub_24DAE+971j
mov	[w36A32], 0FFFFh
cmp	[bp+var_14], 0	; Compare Two Operands
jz	short loc_2579A	; Jump if Zero (ZF=1)
call	_f332647_Get_w360B4_Set0 ; Call	Procedure
mov	ax, [bp+var_2]

loc_2578B:
mov	[word_3C57E], ax
mov	ax, [bp+var_4]
mov	[word_3C57C], ax
mov	ax, [bp+varMouseButtonStatus]
mov	[word_3C57A], ax

loc_2579A:		; CODE XREF: sub_24DAE+9D3j
cmp	[bp+var_14], 0	; Compare Two Operands
jnz	short loc_257A3	; Jump if Not Zero (ZF=0)
jmp	loc_2588D	; Jump

loc_257A3:		; CODE XREF: sub_24DAE+9F0j
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_257AF:		; Add
add	bx, ax
mov	bx, [es:bx+8]
dec	bx		; Decrement by 1

loc_257B6:		; switch 9 cases
cmp	bx, 8
jbe	short loc_257BE	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_2588B	; default

loc_257BE:		; CODE XREF: sub_24DAE+A0Bj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_25D20+bx] ; switch jump

loc_257C5:		; DATA XREF: seg034:off_25D20o
mov	ax, [bp+var_14]	; case 0x1

loc_257C8:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_257F4	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_257F7	; Jump

loc_257F4:		; CODE XREF: sub_24DAE+A2Cj
jmp	loc_25C26	; Jump

loc_257F7:		; CODE XREF: sub_24DAE+A44j
jmp	loc_2588D	; Jump

loc_257FA:		; CODE XREF: sub_24DAE+A12j
			; DATA XREF: seg034:off_25D20o
cmp	[bp+varMouseButtonStatus], 2 ; case 0x8
jnz	short loc_2582E	; Jump if Not Zero (ZF=0)
call	hrmMsExchIntSub	; Call Procedure

loc_25805:
mov	[w36A32], 0FFFFh
cmp	[idk_CfgMom_w36A54], 0 ; Compare Two Operands
jz	short loc_25829	; Jump if Zero (ZF=1)

loc_25812:		; CODE XREF: sub_24DAE+EA1j
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
jmp	loc_25D02	; Jump
jmp	short loc_2582C	; Jump

loc_25829:		; CODE XREF: sub_24DAE+A62j
jmp	SET_AX_FFFF	; Jump

loc_2582C:		; CODE XREF: sub_24DAE+A79j
jmp	short loc_25831	; case 0x0

loc_2582E:		; CODE XREF: sub_24DAE+A50j
jmp	loc_25C5C	; Jump

loc_25831:		; CODE XREF: sub_24DAE+A12j
			; sub_24DAE:loc_2582Cj
			; DATA XREF: seg034:off_25D20o
mov	ax, [bp+var_14]	; case 0x0
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_25839:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_25860	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_25876	; Jump

loc_25860:		; CODE XREF: sub_24DAE+A98j
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 0

loc_25876:		; CODE XREF: sub_24DAE+AB0j
jmp	short loc_2588D	; Jump

loc_25878:		; CODE XREF: sub_24DAE+A12j
			; DATA XREF: seg034:off_25D20o
push	[bp+var_4]	; case 0x3
push	[bp+var_2]

loc_2587E:
push	[bp+var_14]

loc_25881:		; No Operation
nop
push	cs

loc_25883:		; Call Procedure
call	near ptr sub_2E00A
add	sp, 6		; Add
jmp	short loc_2588D	; Jump

loc_2588B:		; CODE XREF: sub_24DAE+A0Dj
			; sub_24DAE+A12j
			; DATA XREF: seg034:off_25D20o
jmp	short $+2	; default

loc_2588D:		; CODE XREF: sub_24DAE+9F2j
			; sub_24DAE:loc_257F7j
			; sub_24DAE:loc_25876j
			; sub_24DAE+ADBj
call	hrmMsExchIntSub	; Call Procedure
mov	[word_36A4A], 0
cmp	[bp+varMouseButtonStatus], 2 ; Compare Two Operands
jnz	short loc_258A3	; Jump if Not Zero (ZF=0)
jmp	loc_25CFF	; Jump
jmp	short loc_258A6	; Jump

loc_258A3:		; CODE XREF: sub_24DAE+AEEj
jmp	SET_AX_var14	; Jump

loc_258A6:		; CODE XREF: sub_24DAE+741j
			; sub_24DAE+AF3j
jmp	loc_25BAA	; Jump

loc_258A9:		; CODE XREF: sub_24DAE:loc_254E0j
call	_f330547_GetMouseButtonsStatus ; Call Procedure
mov	[bp+varMouseButtonStatus], ax
cmp	[bp+varMouseButtonStatus], 2 ; Compare Two Operands
jnz	short loc_258EF	; Jump if Not Zero (ZF=0)
cmp	[idk_Flag_Mouse_w36A78], 0 ; Compare Two Operands
jz	short loc_258D4	; Jump if Zero (ZF=1)
nop			; No Operation
push	cs
call	near ptr sub_25EA0 ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_258D4	; Jump if Not Zero (ZF=0)

loc_258C7:		; CODE XREF: sub_24DAE+762j
call	get_w360AC_set0	; Call Procedure

loc_258CC:		; Call Procedure
call	_f332647_Get_w360B4_Set0
jmp	loc_24E08	; Jump

loc_258D4:		; CODE XREF: sub_24DAE+B0Ej
			; sub_24DAE+B17j
cmp	[idk_CfgMom_w36A54], 0 ; Compare Two Operands
jnz	short loc_258EF	; Jump if Not Zero (ZF=0)
jmp	short loc_258E2	; Jump

loc_258DD:		; CODE XREF: sub_24DAE+B3Cj
nop			; No Operation
push	cs
call	near ptr sub_2E27D ; Call Procedure

loc_258E2:		; CODE XREF: sub_24DAE+B2Dj
call	_f330547_GetMouseButtonsStatus ; Call Procedure
cmp	ax, 2		; Compare Two Operands
jz	short loc_258DD	; Jump if Zero (ZF=1)
jmp	loc_2551A	; Jump

loc_258EF:		; CODE XREF: sub_24DAE+B07j
			; sub_24DAE+B2Bj
jmp	loc_25B84	; Jump

loc_258F2:		; CODE XREF: sub_24DAE+DDFj
call	get__Mouse_w360A4 ; Call Procedure
mov	[bp+var_2], ax
call	get__Mouse_w360A6 ; Call Procedure
mov	[bp+var_4], ax
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax
mov	[bp+var_14], 0

loc_2590F:
mov	[bp+var_12], 0FFFFh
mov	[bp+varLKeyCode1], 0
nop			; No Operation
push	cs

loc_2591A:		; Call Procedure
call	near ptr sub_27A2B
mov	[bp+var_14], ax
cmp	[bp+var_14], 0	; Compare Two Operands
jz	short loc_25929	; Jump if Zero (ZF=1)

loc_25926:		; Jump
jmp	loc_259E6

loc_25929:		; CODE XREF: sub_24DAE+B76j
db 83h,3Eh,22h,4Dh,0FFh	; <BAD>cmp     [w36A32], 0FFFFh	; Compare Two Operands
jnz	short loc_25933	; Jump if Not Zero (ZF=0)
jmp	loc_259D6	; Jump

loc_25933:		; CODE XREF: sub_24DAE+B80j
mov	ax, [w36A32]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2593B:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_25941:		; Compare Two Operands
cmp	[word ptr es:bx+8], 6
jnz	short loc_2594D	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_2E26D ; Call Procedure

loc_2594D:		; CODE XREF: sub_24DAE+B98j
mov	ax, [w36A32]

loc_25950:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 3 ;	Compare	Two Operands
jz	short loc_259D0	; Jump if Zero (ZF=1)
mov	ax, [w36A32]
mov	dx, 26h	; '&'

loc_25968:		; Signed Multiply
imul	dx

loc_2596A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jz	short loc_259D0	; Jump if Zero (ZF=1)
mov	ax, [w36A32]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2597F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jz	short loc_259D0	; Jump if Zero (ZF=1)
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0

loc_25991:		; Call Procedure
call	idk_ChkMousDoEga
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[w36A32]
nop			; No Operation

loc_2599E:
push	cs
call	near ptr sub_2CF44 ; Call Procedure
pop	cx
pop	cx
push	[bp+var_4]

loc_259A7:
push	[bp+var_2]
call	sub_24648	; Call Procedure
pop	cx
pop	cx
push	[bp+var_4]

loc_259B4:
push	[bp+var_2]
call	sub_24A74	; Call Procedure

loc_259BC:
pop	cx
pop	cx

loc_259BE:
push	[bp+var_4]
push	[bp+var_2]

loc_259C4:		; Call Procedure
call	CALL_PositionMouseCursor
pop	cx
pop	cx
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE

loc_259D0:		; CODE XREF: sub_24DAE+BB2j
			; sub_24DAE+BC7j
			; sub_24DAE+BDCj
mov	[w36A32], 0FFFFh

loc_259D6:		; CODE XREF: sub_24DAE+B82j
push	[bp+var_4]
push	[bp+var_2]

loc_259DC:		; Call Procedure
call	sub_245C6
pop	cx
pop	cx
jmp	loc_25B90	; Jump

loc_259E6:		; CODE XREF: sub_24DAE:loc_25926j
mov	ax, [bp+var_14]
cmp	ax, [w36A32]	; Compare Two Operands
jnz	short loc_259F2	; Jump if Not Zero (ZF=0)

loc_259EF:		; Jump
jmp	loc_25A78

loc_259F2:		; CODE XREF: sub_24DAE+C3Fj
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_25A00:		; Compare Two Operands
cmp	[word ptr es:bx+8], 4
jz	short loc_25A78	; Jump if Zero (ZF=1)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jz	short loc_25A78	; Jump if Zero (ZF=1)
db 83h,3Eh,22h,4Dh,0FFh	; <BAD>cmp     [w36A32], 0FFFFh	; Compare Two Operands
jz	short loc_25A4D	; Jump if Zero (ZF=1)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_25A2F:		; Add
add	bx, ax
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands
jnz	short loc_25A4D	; Jump if Not Zero (ZF=0)
mov	ax, [w36A32]
mov	dx, 26h	; '&'

loc_25A3E:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_25A44:		; Add
add	bx, ax
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands
jz	short loc_25A78	; Jump if Zero (ZF=1)

loc_25A4D:		; CODE XREF: sub_24DAE+C73j
			; sub_24DAE+C88j
mov	ax, [w36A32]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_25A5B:		; Compare Two Operands
cmp	[word ptr es:bx+8], 6

loc_25A60:		; Jump if Not Zero (ZF=0)
jnz	short loc_25A67
nop			; No Operation
push	cs
call	near ptr sub_2E26D ; Call Procedure

loc_25A67:		; CODE XREF: sub_24DAE:loc_25A60j
push	[bp+var_4]
push	[bp+var_2]
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_2E00A ; Call Procedure
add	sp, 6		; Add

loc_25A78:		; CODE XREF: sub_24DAE:loc_259EFj
			; sub_24DAE+C57j
			; sub_24DAE+C6Cj
			; sub_24DAE+C9Dj
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jnz	short loc_25B0A	; Jump if Not Zero (ZF=0)

loc_25A8D:		; Compare Two Operands
cmp	[word_36A6A], 0
jnz	short loc_25ACB	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_14]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+22]
mov	ax, offset idk2_b3C580
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	[word_36A66], 0
mov	[word_36A68], 0
mov	[word_36A6A], 1
mov	ax, [bp+var_14]
mov	[word_36A70], ax
jmp	short loc_25B08	; Jump

loc_25ACB:		; CODE XREF: sub_24DAE+CE4j
mov	ax, [word_36A70]
cmp	ax, [bp+var_14]	; Compare Two Operands
jz	short loc_25B08	; Jump if Zero (ZF=1)
mov	ax, [bp+var_14]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+22]
mov	ax, offset idk2_b3C580
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	[word_36A66], 0
mov	[word_36A68], 0
mov	[word_36A6A], 1
mov	ax, [bp+var_14]
mov	[word_36A70], ax

loc_25B08:		; CODE XREF: sub_24DAE+D1Bj
			; sub_24DAE+D23j
jmp	short loc_25B67	; Jump

loc_25B0A:		; CODE XREF: sub_24DAE+CDDj
cmp	[word_36A6A], 0	; Compare Two Operands
jz	short loc_25B67	; Jump if Zero (ZF=1)
xor	di, di		; Logical Exclusive OR
jmp	short loc_25B16	; Jump

loc_25B15:		; CODE XREF: sub_24DAE+D81j
inc	di		; Increment by 1

loc_25B16:		; CODE XREF: sub_24DAE+D65j
cmp	[byte ptr di-5790h], 0 ; Compare Two Operands
jz	short loc_25B31	; Jump if Zero (ZF=1)
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx+20h], di	; Compare Two Operands
jg	short loc_25B15	; Jump if Greater (ZF=0	& SF=OF)

loc_25B31:		; CODE XREF: sub_24DAE+D6Dj
cmp	[byte ptr di-5791h], 5Fh ; '_' ; Compare Two Operands
jnz	short loc_25B39	; Jump if Not Zero (ZF=0)
dec	di		; Decrement by 1

loc_25B39:		; CODE XREF: sub_24DAE+D88j
mov	[byte ptr di-5790h], 0

loc_25B3E:
mov	ax, offset idk2_b3C580
push	ax
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_25B4A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_25B4E:		; Add
add	bx, ax
push	[word ptr es:bx+16h] ; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	[word_36A6A], 0
mov	[word_36A70], 0FFFFh

loc_25B67:		; CODE XREF: sub_24DAE:loc_25B08j
			; sub_24DAE+D61j
mov	ax, [bp+var_14]

loc_25B6A:
mov	[word_36A4A], ax
cmp	[word_36A56], 0	; Compare Two Operands
jz	short loc_25B76	; Jump if Zero (ZF=1)
jmp	short loc_25B90	; Jump

loc_25B76:		; CODE XREF: sub_24DAE+DC4j
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_25B84	; Jump if Zero (ZF=1)
nop			; No Operation
push	cs
call	near ptr sub_2E2B7 ; Call Procedure

loc_25B84:		; CODE XREF: sub_24DAE:loc_258EFj
			; sub_24DAE+DCFj
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_25B90	; Jump if Zero (ZF=1)
jmp	loc_258F2	; Jump

loc_25B90:		; CODE XREF: sub_24DAE+C35j
			; sub_24DAE+DC6j
			; sub_24DAE+DDDj
mov	ax, [word_36A4A]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 6 ;	Compare	Two Operands
jnz	short loc_25BAA	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs

loc_25BA7:		; Call Procedure
call	near ptr sub_2E26D

loc_25BAA:		; CODE XREF: sub_24DAE:loc_258A6j
			; sub_24DAE+DF5j
mov	[word_36A4A], 0
cmp	[bp+var_14], 0	; Compare Two Operands
jnz	short loc_25BB9	; Jump if Not Zero (ZF=0)
jmp	loc_25CD8	; Jump

loc_25BB9:		; CODE XREF: sub_24DAE+E06j
call	get_w360AC_set0	; Call Procedure
call	_f332647_Get_w360B4_Set0 ; Call	Procedure
mov	ax, [bp+var_2]
mov	[word_3C57E], ax
mov	ax, [bp+var_4]
mov	[word_3C57C], ax
mov	ax, [bp+varMouseButtonStatus]
mov	[word_3C57A], ax
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_25BDD:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	bx, [es:bx+8]
dec	bx		; Decrement by 1
cmp	bx, 8		; switch 9 cases
jbe	short loc_25BF0	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_25CD6	; default

loc_25BF0:		; CODE XREF: sub_24DAE+E3Dj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_25D0E+bx] ; switch jump

loc_25BF7:		; DATA XREF: seg034:off_25D0Eo
mov	ax, [bp+var_14]	; case 0x1
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_25C26	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_25C34	; Jump

loc_25C26:		; CODE XREF: sub_24DAE:loc_257F4j
			; sub_24DAE+E5Ej
call	hrmMsExchIntSub	; Call Procedure

aSET_w36A32_FFFF:	; CODE XREF: sub_24DAE+26Aj
			; sub_24DAE:loc_252B5j
mov	[w36A32], 0FFFFh
jmp	loc_24E08	; Jump

loc_25C34:		; CODE XREF: sub_24DAE+E76j
jmp	loc_25CD8	; Jump

loc_25C37:		; CODE XREF: sub_24DAE+E44j
			; DATA XREF: seg034:off_25D0Eo
cmp	[bp+varMouseButtonStatus], 2 ; case 0x8
jnz	short loc_25C5C	; Jump if Not Zero (ZF=0)
call	hrmMsExchIntSub	; Call Procedure
mov	[w36A32], 0FFFFh
cmp	[idk_CfgMom_w36A54], 0 ; Compare Two Operands
jz	short SET_AX_FFFF ; Jump if Zero (ZF=1)
jmp	loc_25812	; Jump
jmp	short loc_25C5A	; Jump

SET_AX_FFFF:		; CODE XREF: sub_24DAE+CAj
			; sub_24DAE+776j
			; sub_24DAE:loc_25829j
			; sub_24DAE+E9Fj
mov	ax, 0FFFFh
jmp	loc_24E0A	; Jump

loc_25C5A:		; CODE XREF: sub_24DAE+EA4j
jmp	short loc_25C7C	; case 0x0

loc_25C5C:		; CODE XREF: sub_24DAE:loc_2582Ej
			; sub_24DAE+E8Dj
call	hrmMsExchIntSub	; Call Procedure

loc_25C61:		; CODE XREF: sub_24DAE:loc_2501Dj
mov	[w36A32], 0FFFFh
mov	ax, [bp+var_14]

loc_25C6A:		; CODE XREF: sub_24DAE+514j
mov	dx, 26h
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
jmp	loc_24E0A	; Jump

loc_25C7C:		; CODE XREF: sub_24DAE+E44j
			; sub_24DAE:loc_25C5Aj
			; DATA XREF: seg034:off_25D0Eo
mov	ax, [bp+var_14]	; case 0x0

loc_25C7F:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_25CAB	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_14]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1

loc_25CA9:		; Jump
jmp	short loc_25CC1

loc_25CAB:		; CODE XREF: sub_24DAE+EE3j
mov	ax, [bp+var_14]

loc_25CAE:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 0

loc_25CC1:		; CODE XREF: sub_24DAE:loc_25CA9j
jmp	short loc_25CD8	; Jump

loc_25CC3:		; CODE XREF: sub_24DAE+E44j
			; DATA XREF: seg034:off_25D0Eo
push	[bp+var_4]	; case 0x3
push	[bp+var_2]
push	[bp+var_14]
nop			; No Operation
push	cs

loc_25CCE:		; Call Procedure
call	near ptr sub_2E00A
add	sp, 6		; Add
jmp	short loc_25CD8	; Jump

loc_25CD6:		; CODE XREF: sub_24DAE+E3Fj
			; sub_24DAE+E44j
			; DATA XREF: seg034:off_25D0Eo
jmp	short $+2	; default

loc_25CD8:		; CODE XREF: sub_24DAE+E08j
			; sub_24DAE:loc_25C34j
			; sub_24DAE:loc_25CC1j
			; sub_24DAE+F26j
call	hrmMsExchIntSub	; Call Procedure
mov	[w36A32], 0FFFFh
mov	ax, [bp+varMouseButtonStatus]
or	ax, ax		; Logical Inclusive OR
jz	short loc_25CF6	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short SET_AX_var14 ; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_25CFF	; Jump if Zero (ZF=1)
jmp	short loc_25D07	; Jump

loc_25CF6:		; CODE XREF: sub_24DAE+F3Aj
jmp	loc_24E08	; Jump

SET_AX_var14:		; CODE XREF: sub_24DAE+12Fj
			; sub_24DAE+2C6j
			; sub_24DAE:loc_258A3j
			; sub_24DAE+F3Fj
mov	ax, [bp+var_14]
jmp	loc_24E0A	; Jump

loc_25CFF:		; CODE XREF: sub_24DAE+AF0j
			; sub_24DAE+F44j
mov	ax, [bp+var_14]

loc_25D02:		; CODE XREF: sub_24DAE+A76j
neg	ax		; Two's Complement Negation
jmp	loc_24E0A	; Jump

loc_25D07:		; CODE XREF: sub_24DAE:loc_24E0Aj
			; sub_24DAE+F46j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_24DAE ; sp-analysis failed

align 2
off_25D0E dw offset loc_25C7C
			; DATA XREF: sub_24DAE+E44r
dw offset loc_25BF7	; jump table for switch	statement
dw offset loc_25CD6
dw offset loc_25CC3
dw offset loc_25CD6
dw offset loc_25CD6
dw offset loc_25CD6
dw offset loc_25CD6
dw offset loc_25C37
off_25D20 dw offset loc_25831
			; DATA XREF: sub_24DAE+A12r
dw offset loc_257C5	; jump table for switch	statement
dw offset loc_2588B
dw offset loc_25878
dw offset loc_2588B
dw offset loc_2588B
dw offset loc_2588B
dw offset loc_2588B
dw offset loc_257FA


; Attributes: bp-based frame

proc sub_25D32 far
push	bp
mov	bp, sp
cmp	[word_36A76], 0	; Compare Two Operands
jz	short loc_25D4C	; Jump if Zero (ZF=1)
call	sub_24C66	; Call Procedure
call	set_w36A26_1	; Call Procedure
mov	[word_36A72], 1

loc_25D4C:		; CODE XREF: sub_25D32+8j
pop	bp
retf			; Return Far from Procedure
endp sub_25D32



; Attributes: bp-based frame

proc sub_25D4E far
push	bp
mov	bp, sp
cmp	[word_36A76], 0	; Compare Two Operands
jz	short loc_25D68	; Jump if Zero (ZF=1)
call	set_w36A24_0	; Call Procedure
call	set_w36A26_1	; Call Procedure
mov	[word_36A72], 0FFFFh

loc_25D68:		; CODE XREF: sub_25D4E+8j
pop	bp
retf			; Return Far from Procedure
endp sub_25D4E



; Attributes: bp-based frame

proc sub_25D6A far
push	bp

loc_25D6B:
mov	bp, sp
mov	[word_36A72], 0
call	sub_24C92	; Call Procedure
pop	bp
retf			; Return Far from Procedure
endp sub_25D6A



; Attributes: bp-based frame

proc sub_25D7A far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	si

loc_25D7E:
mov	si, [bp+arg_0]
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
mov	bx, 10h
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
inc	ax		; Increment by 1

loc_25D8E:
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[word_36A28], ax

loc_25D98:
mov	[word_36A76], 1

loc_25D9E:
mov	ax, [bp+arg_2]
mov	[word_36A74], ax

loc_25DA4:
mov	[word_36A2A], si
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_25D7A



; Attributes: bp-based frame

proc sub_25DAB far

var_2= word ptr	-2
asczFileName= dword ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
cmp	[word_36A76], 0	; Compare Two Operands
jz	short loc_25DFA	; Jump if Zero (ZF=1)
mov	ax, offset aRb_0 ; int
push	ax
push	[word ptr bp+asczFileName] ; asczFileName
call	DOS_OpenFileModeCheck ;	Call Procedure
pop	cx
pop	cx
mov	si, ax
push	si
mov	ax, 1
push	ax

loc_25DCE:
mov	ax, [word_36A2A]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
push	ax
push	[word_36A28]
xor	ax, ax		; Logical Exclusive OR
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
call	DOS_CloseFileHandle ; Call Procedure
pop	cx
call	sub_24CB0	; Call Procedure
mov	[bp+var_2], ax
mov	[word_36A72], 0

loc_25DFA:		; CODE XREF: sub_25DAB+Cj
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_25DAB ; sp-analysis failed



; Attributes: bp-based frame

proc sub_25DFF far

asczFileName= dword ptr	 6

push	bp
mov	bp, sp
push	si
cmp	[word_36A76], 0	; Compare Two Operands
jz	short loc_25E43	; Jump if Zero (ZF=1)
mov	ax, offset aWb	; int
push	ax
push	[word ptr bp+asczFileName] ; asczFileName
call	DOS_OpenFileModeCheck ;	Call Procedure
pop	cx
pop	cx
mov	si, ax
push	si
mov	ax, 1
push	ax
mov	ax, [word_36A2A]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
push	ax
push	[word_36A28]
xor	ax, ax		; Logical Exclusive OR
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
call	DOS_CloseFileHandle ; Call Procedure
pop	cx
mov	[word_36A72], 0

loc_25E43:		; CODE XREF: sub_25DFF+9j
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_25DFF ; sp-analysis failed



; Attributes: bp-based frame

proc SetFlag_1_CfgMom_w36A54 far
			; CODE XREF: _f010109_main+2D2P
			; _f010309_RUN+60P
			; sub_4067D+F4P
push	bp
mov	bp, sp
mov	[idk_CfgMom_w36A54], 1
pop	bp
retf			; Return Far from Procedure
endp SetFlag_1_CfgMom_w36A54



; Attributes: bp-based frame

proc SetFlag_0_CfgMom_w36A54 far
push	bp
mov	bp, sp

loc_25E54:
mov	[idk_CfgMom_w36A54], 0
pop	bp
retf			; Return Far from Procedure
endp SetFlag_0_CfgMom_w36A54



; Attributes: bp-based frame

proc SetFlag_1_w36A56 far
push	bp
mov	bp, sp
mov	[word_36A56], 1
pop	bp
retf			; Return Far from Procedure
endp SetFlag_1_w36A56



; Attributes: bp-based frame

proc SetFlag_0_w36A56 far
push	bp
mov	bp, sp
mov	[word_36A56], 0

loc_25E70:
pop	bp
retf			; Return Far from Procedure
endp SetFlag_0_w36A56



; Attributes: bp-based frame

proc idk_SetThreeFlagsOrValues_s25E72 far
			; CODE XREF: _f010509_MainMenuScreen+3E0P
			; LBX_HelpEntry_s13EEE:loc_13F18P
			; LBX_HelpEntry_s3D9F3+2AP
			; sub_3FBE0+268P
			; sub_4067D+6F6P
			; sub_421DA+2D4P
			; LBX_HelpEntry_s433B8+2AP
			; LBX_HelpEntry_s433EB+2AP
			; LBX_HelpEntry_s4341E+2AP
			; LBX_HelpEntry_s43451:loc_4347BP
			; LBX_HelpEntry_s43484+36P
			; LBX_HelpEntry_s434C3+2AP
			; LBX_HelpEntry_s434F6+2AP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
mov	ax, [bp+arg_0]
mov	[idk_Flag_w3C578], ax
mov	[idk_Flag_Mouse_w36A78], 1
mov	ax, [bp+arg_2]
mov	[idk_Flag_w36A7A], ax
pop	bp
retf			; Return Far from Procedure
endp idk_SetThreeFlagsOrValues_s25E72



; Attributes: bp-based frame

proc idk_SetThreeFlags_s25E89 far
			; CODE XREF: _f010309_RUN+70P
			; _f010309_RUN+7DP
			; _f010509_MainMenuScreen+4BFP
			; sub_3CFC0+39AP
			; sub_3DA30:loc_3DA5AP
			; sub_3DBA6+36EP
			; sub_3DBA6+388P
			; sub_3DBA6+3DBP
			; sub_3E1DE+324P
			; sub_3E1DE+367P
			; sub_3EBA0+1C4P
			; sub_3EBA0+1E9P
			; sub_3F3C6+182P
			; sub_3F7D8+218P
			; sub_3FBE0+23DP
			; sub_3FBE0+446P
			; sub_4067D+6CAP
			; sub_4067D+825P
			; sub_56450+9DP
			; sub_56450+128P
push	bp
mov	bp, sp
mov	[idk_Flag_Mouse_w36A78], 0
mov	[idk_Flag_w36A7A], 0
mov	[idk_Flag_w3C578], 0
pop	bp
retf			; Return Far from Procedure
endp idk_SetThreeFlags_s25E89



; Attributes: bp-based frame

proc sub_25EA0 far	; CODE XREF: sub_24DAE:loc_25509p
			; sub_24DAE+B12p

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
mov	[bp+var_2], 0
call	get__Mouse_w360A4 ; Call Procedure
mov	[bp+var_4], ax
call	get__Mouse_w360A6 ; Call Procedure
mov	[bp+var_6], ax
cmp	[idk_Flag_w36A7A], 0 ; Compare Two Operands
jnz	short loc_25ECA	; Jump if Not Zero (ZF=0)

loc_25EC4:		; CODE XREF: sub_25EA0:loc_25F5Aj
mov	ax, 1

loc_25EC7:		; CODE XREF: sub_25EA0+ADj
jmp	loc_25F5D	; Jump

loc_25ECA:		; CODE XREF: sub_25EA0+22j
xor	di, di		; Logical Exclusive OR
jmp	loc_25F51	; Jump

loc_25ECF:		; CODE XREF: sub_25EA0+B7j
mov	ax, di
mov	dx, 5
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_25EDC:
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
db 83h,3Fh,0FFh	; <BAD>cmp     [word ptr bx], 0FFFFh ; Compare Two Operands
jz	short loc_25F50	; Jump if Zero (ZF=1)
mov	ax, si
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]

loc_25EF0:		; Add
add	bx, ax
mov	ax, [bx]
cmp	ax, [bp+var_4]	; Compare Two Operands
jg	short loc_25F50	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, si

loc_25EFB:		; Add
add	ax, 3
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]

loc_25F04:		; Add
add	bx, ax

loc_25F06:
mov	ax, [bx]
cmp	ax, [bp+var_4]	; Compare Two Operands
jl	short loc_25F50	; Jump if Less (SF!=OF)
mov	ax, si
add	ax, 2		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]

loc_25F18:		; Add
add	bx, ax
mov	ax, [bx]
cmp	ax, [bp+var_6]	; Compare Two Operands

loc_25F1F:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_25F50
mov	ax, si
add	ax, 4		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_6]	; Compare Two Operands
jl	short loc_25F50	; Jump if Less (SF!=OF)
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
call	j_idk_OVR_LoadLbxHelp ;	Call Procedure
pop	cx
mov	di, [idk_Flag_w36A7A]
xor	ax, ax		; Logical Exclusive OR
jmp	loc_25EC7	; Jump

loc_25F50:		; CODE XREF: sub_25EA0+45j
			; sub_25EA0+57j
			; sub_25EA0+6Bj
			; sub_25EA0:loc_25F1Fj
			; sub_25EA0+93j
inc	di		; Increment by 1

loc_25F51:		; CODE XREF: sub_25EA0+2Cj
cmp	di, [idk_Flag_w36A7A] ;	Compare	Two Operands
jge	short loc_25F5A	; Jump if Greater or Equal (SF=OF)
jmp	loc_25ECF	; Jump

loc_25F5A:		; CODE XREF: sub_25EA0+B5j
jmp	loc_25EC4	; Jump

loc_25F5D:		; CODE XREF: sub_25EA0:loc_25EC7j
pop	di
pop	si

loc_25F5F:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_25EA0



; Attributes: bp-based frame

proc sub_25F63 far

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
mov	cx, [bp+arg_0]
or	cx, cx		; Logical Inclusive OR
jge	short loc_25F76	; Jump if Greater or Equal (SF=OF)
mov	ax, cx
neg	ax		; Two's Complement Negation
mov	cx, ax

loc_25F76:		; CODE XREF: sub_25F63+Bj
cmp	cx, [idk_Mouse_w3C5A8] ; Compare Two Operands
jl	short loc_25F80	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR

loc_25F7E:		; CODE XREF: sub_25F63+47j
jmp	short loc_25FAC	; Jump

loc_25F80:		; CODE XREF: sub_25F63+17j
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_25F8D:
mov	ax, [es:bx+4]
push	ax
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_25F99:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_25F9D:		; Add
add	bx, ax
pop	ax
sub	ax, [es:bx]	; Integer Subtraction

loc_25FA3:		; Increment by 1
inc	ax
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
jmp	short loc_25F7E	; Jump

loc_25FAC:		; CODE XREF: sub_25F63:loc_25F7Ej
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_25F63



; Attributes: bp-based frame

proc sub_25FB0 far

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
mov	cx, [bp+arg_0]

loc_25FB9:		; Logical Inclusive OR
or	cx, cx
jge	short loc_25FC3	; Jump if Greater or Equal (SF=OF)
mov	ax, cx
neg	ax		; Two's Complement Negation
mov	cx, ax

loc_25FC3:		; CODE XREF: sub_25FB0+Bj
cmp	cx, [idk_Mouse_w3C5A8] ; Compare Two Operands
jl	short loc_25FCD	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR

loc_25FCB:		; CODE XREF: sub_25FB0+48j
jmp	short loc_25FFA	; Jump

loc_25FCD:		; CODE XREF: sub_25FB0+17j
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_25FEC:
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
jmp	short loc_25FCB	; Jump

loc_25FFA:		; CODE XREF: sub_25FB0:loc_25FCBj
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_25FB0



; Attributes: bp-based frame

proc sub_25FFE far
push	bp

loc_25FFF:
mov	bp, sp
mov	ax, [word_3C57E]
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_25FFE



; Attributes: bp-based frame

proc sub_26008 far
push	bp

loc_26009:
mov	bp, sp
mov	ax, [word_3C57C]
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_26008



; Attributes: bp-based frame

proc sub_26012 far
push	bp
mov	bp, sp
mov	ax, [word_3C57A]
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_26012



; Attributes: bp-based frame

proc sub_2601C far	; CODE XREF: sub_3D378:loc_3D38DP
			; sub_3DF8C+2AP
			; sub_3E60E:loc_3E73FP
			; sub_3EDD1+32P
			; sub_40EC0+6DP
			; sub_424BB+2CP
push	bp

loc_2601D:
mov	bp, sp
mov	ax, [word_36A4A]
jmp	short $+2	; Jump

loc_26024:
pop	bp
retf			; Return Far from Procedure
endp sub_2601C



; Attributes: bp-based frame

proc sub_26026 far	; CODE XREF: sub_2B97A+39p

var_B= byte ptr	-0Bh
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp

loc_26029:		; Integer Subtraction
sub	sp, 0Ch
push	si		; argSrc
push	di		; src

loc_2602E:
mov	ax, [idk_MousePosX_w3C5A2]

loc_26031:
mov	[bp+var_4], ax
mov	ax, [idk_MousePosX_w3C5A0]
mov	[bp+var_6], ax
call	idk_ChkMousDoEga ; Call	Procedure

loc_2603F:
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24648	; Call Procedure
pop	cx
pop	cx
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24A74	; Call Procedure
pop	cx
pop	cx

loc_2605D:
push	[bp+var_6]

loc_26060:
push	[bp+var_4]
call	sub_23FDC	; Call Procedure
pop	cx
pop	cx
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax

loc_26072:
mov	[bp+var_2], 0
nop			; No Operation
push	cs
call	near ptr sub_27A2B ; Call Procedure
mov	[bp+var_2], ax
mov	[bp+var_8], 0

loc_26084:
mov	[bp+var_B], 0
call	_f331647_TestKeyPress ;	Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_26094	; Jump if Not Zero (ZF=0)
jmp	loc_26680	; Jump

loc_26094:		; CODE XREF: sub_26026+69j
lea	ax, [bp+var_8]	; int
push	ax		; int
nop			; No Operation
push	cs

loc_2609A:		; Call Procedure
call	near ptr rschKBD_s2669B
pop	cx
mov	[bp+var_B], al

loc_260A1:		; Compare Two Operands
cmp	[bp+var_B], 91h	; ''

loc_260A5:		; Jump if Not Zero (ZF=0)
jnz	short loc_260AC
call	IfDebugExitWithMemDiag ; Call Procedure

loc_260AC:		; CODE XREF: sub_26026:loc_260A5j
cmp	[bp+var_B], 92h	; '' ; Compare Two Operands
jnz	short loc_260F5	; Jump if Not Zero (ZF=0)
call	idk_ChkMousDoEga ; Call	Procedure

loc_260B7:		; Call Procedure
call	ST_ScreenDump
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24648	; Call Procedure
pop	cx
pop	cx


call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24A74	; Call Procedure
pop	cx
pop	cx


call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx

loc_260F5:		; CODE XREF: sub_26026+8Aj
cmp	[bp+var_B], 1Bh	; Compare Two Operands
jnz	short loc_26101	; Jump if Not Zero (ZF=0)
mov	ax, 0FFFFh

loc_260FE:		; CODE XREF: sub_26026+28Cj
			; sub_26026+454j
			; sub_26026+55Fj
			; sub_26026+66Cj
jmp	loc_26695	; Jump

loc_26101:		; CODE XREF: sub_26026+D3j
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
cmp	al, [bp+var_B]	; Compare Two Operands
jz	short loc_2611B	; Jump if Zero (ZF=1)
jmp	loc_262B8	; Jump

loc_2611B:		; CODE XREF: sub_26026+F0j
cmp	[bp+var_B], 0	; Compare Two Operands

loc_2611F:		; Jump if Not Zero (ZF=0)
jnz	short loc_26124
jmp	loc_26690	; Jump

loc_26124:		; CODE XREF: sub_26026:loc_2611Fj
cmp	[bp+var_8], 0	; Compare Two Operands
jnz	short loc_2612D	; Jump if Not Zero (ZF=0)

loc_2612A:		; Jump
jmp	loc_262A9

loc_2612D:		; CODE XREF: sub_26026+102j
mov	ax, [idk_MousePosX_w3C5A2]
mov	[bp+var_4], ax
mov	ax, [idk_MousePosX_w3C5A0]
mov	[bp+var_6], ax
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, [bp+var_8]

loc_2614F:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, [bp+var_8]

loc_2617E:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_261AF:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_261B5:
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
mov	[idk_MousePosX_w3C5A0],	ax
cmp	[idk_MousePosX_w3C5A2],	0 ; Compare Two	Operands
jl	short loc_261CE	; Jump if Less (SF!=OF)
cmp	[idk_MousePosX_w3C5A2],	13Fh ; Compare Two Operands
jle	short loc_261D4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_261CE:		; CODE XREF: sub_26026+19Ej
mov	ax, [bp+var_4]
mov	[idk_MousePosX_w3C5A2],	ax

loc_261D4:		; CODE XREF: sub_26026+1A6j
cmp	[idk_MousePosX_w3C5A0],	0 ; Compare Two	Operands
jl	short loc_261E3	; Jump if Less (SF!=OF)

loc_261DB:		; Compare Two Operands
cmp	[idk_MousePosX_w3C5A0],	0C7h ; ''
jle	short loc_261E9	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_261E3:		; CODE XREF: sub_26026+1B3j
mov	ax, [bp+var_6]
mov	[idk_MousePosX_w3C5A0],	ax

loc_261E9:		; CODE XREF: sub_26026+1BBj
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
push	[bp+var_8]
nop			; No Operation
push	cs
call	near ptr sub_2E00A ; Call Procedure
add	sp, 6		; Add

loc_261FC:
mov	ax, [bp+var_8]

loc_261FF:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2620A:
mov	ax, [es:bx+8]
cmp	ax, 1		; Compare Two Operands
jz	short loc_26260	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_26220	; Jump if Zero (ZF=1)
cmp	ax, 9		; Compare Two Operands

loc_2621B:		; Jump if Zero (ZF=1)
jz	short loc_2625A
jmp	loc_262A7	; Jump

loc_26220:		; CODE XREF: sub_26026+1F0j
mov	ax, [bp+var_8]

loc_26223:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2624F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_26258	; Jump

loc_2624F:		; CODE XREF: sub_26026+20Fj
			; sub_26026:loc_26464j
mov	[w36A32], 0FFFFh
jmp	loc_26690	; Jump

loc_26258:		; CODE XREF: sub_26026+227j
jmp	short loc_262A9	; Jump

loc_2625A:		; CODE XREF: sub_26026:loc_2621Bj
mov	ax, [bp+var_8]

loc_2625D:		; Jump
jmp	loc_2646B

loc_26260:		; CODE XREF: sub_26026+1EBj
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'

loc_26266:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2628F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_26283:		; Add
add	bx, ax
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 1
jmp	short loc_262A5	; Jump

loc_2628F:		; CODE XREF: sub_26026+24Fj
mov	ax, [bp+var_8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2629B:		; Add
add	bx, ax
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 0

loc_262A5:		; CODE XREF: sub_26026+267j
jmp	short loc_262A9	; Jump

loc_262A7:		; CODE XREF: sub_26026+1F7j
jmp	short $+2	; Jump

loc_262A9:		; CODE XREF: sub_26026:loc_2612Aj
			; sub_26026:loc_26258j
			; sub_26026:loc_262A5j
mov	[w36A32], 0FFFFh

loc_262AF:
mov	ax, [bp+var_8]
jmp	loc_260FE	; Jump
jmp	loc_26680	; Jump

loc_262B8:		; CODE XREF: sub_26026+F2j
cmp	[bp+var_B], 0Ch	; Compare Two Operands
jz	short loc_262C1	; Jump if Zero (ZF=1)
jmp	loc_2653E	; Jump

loc_262C1:		; CODE XREF: sub_26026+296j
mov	ax, [idk_MousePosX_w3C5A2]
mov	[bp+var_4], ax
mov	ax, [idk_MousePosX_w3C5A0]
mov	[bp+var_6], ax
nop			; No Operation
push	cs
call	near ptr sub_27A2B ; Call Procedure
mov	si, ax
or	si, si		; Logical Inclusive OR

loc_262D6:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_262DB
jmp	loc_263D4	; Jump

loc_262DB:		; CODE XREF: sub_26026:loc_262D6j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_262E2:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jnz	short loc_2635E	; Jump if Not Zero (ZF=0)

loc_262EF:		; Compare Two Operands
cmp	[word_36A6A], 0
jnz	short loc_2632A	; Jump if Not Zero (ZF=0)

loc_262F6:
mov	ax, si

loc_262F8:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26303:
push	[word ptr es:bx+16h]
mov	ax, 0A870h
push	ax		; argDest

loc_2630B:		; argDest,argSrc
call	_strcpy
pop	cx
pop	cx

loc_26312:
mov	[word_36A66], 0

loc_26318:
mov	[word_36A68], 0
mov	[word_36A6A], 1
mov	[word_36A70], si
jmp	short loc_2635C	; Jump

loc_2632A:		; CODE XREF: sub_26026+2CEj
cmp	[word_36A70], si ; Compare Two Operands
jz	short loc_2635C	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_26337:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_2633D:
push	[word ptr es:bx+16h]
mov	ax, 0A870h
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_2634C:
mov	[word_36A66], 0
mov	[word_36A68], 0
mov	[word_36A70], si

loc_2635C:		; CODE XREF: sub_26026+302j
			; sub_26026+308j
jmp	short loc_263D4	; Jump

loc_2635E:		; CODE XREF: sub_26026+2C7j
cmp	[word_36A6A], 0	; Compare Two Operands
jz	short loc_263D4	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26372:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Bh
jz	short loc_263D4	; Jump if Zero (ZF=1)

loc_26379:		; Logical Exclusive OR
xor	di, di
jmp	short loc_2637E	; Jump

loc_2637D:		; CODE XREF: sub_26026+370j
inc	di		; Increment by 1

loc_2637E:		; CODE XREF: sub_26026+355j
cmp	[byte ptr di-5790h], 0 ; Compare Two Operands
jz	short loc_26398	; Jump if Zero (ZF=1)
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx+20h], di	; Compare Two Operands
jg	short loc_2637D	; Jump if Greater (ZF=0	& SF=OF)

loc_26398:		; CODE XREF: sub_26026+35Dj
cmp	[byte ptr (word_3C57E+1)+di], 5Fh ; '_' ; Compare Two Operands
jnz	short loc_263A0	; Jump if Not Zero (ZF=0)
dec	di		; Decrement by 1

loc_263A0:		; CODE XREF: sub_26026+377j
mov	[idk2_b3C580+di], 0
mov	ax, offset idk2_b3C580
push	ax
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; argDest
call	_strcpy		; argDest,argSrc

loc_263C0:
pop	cx
pop	cx

loc_263C2:
mov	[word_36A66], 0
mov	[word_36A6A], 0

loc_263CE:
mov	[word_36A70], 0FFFFh

loc_263D4:		; CODE XREF: sub_26026+2B2j
			; sub_26026:loc_2635Cj
			; sub_26026+33Dj
			; sub_26026+351j
or	si, si		; Logical Inclusive OR

loc_263D6:		; Jump if Not Zero (ZF=0)
jnz	short loc_263DB
jmp	loc_264D3	; Jump

loc_263DB:		; CODE XREF: sub_26026:loc_263D6j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 6 ;	Compare	Two Operands
jz	short loc_26414	; Jump if Zero (ZF=1)

loc_263EF:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_263F6:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Bh	; Compare Two Operands
jz	short loc_26414	; Jump if Zero (ZF=1)
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
push	si
nop			; No Operation
push	cs
call	near ptr sub_2E00A ; Call Procedure
add	sp, 6		; Add

loc_26414:		; CODE XREF: sub_26026+3C7j
			; sub_26026+3DBj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2641B:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+8]
cmp	ax, 1		; Compare Two Operands

loc_26428:		; Jump if Zero (ZF=1)
jz	short loc_2647D

loc_2642A:		; Compare Two Operands
cmp	ax, 2
jz	short loc_26437	; Jump if Zero (ZF=1)
cmp	ax, 9		; Compare Two Operands
jz	short loc_26469	; Jump if Zero (ZF=1)

loc_26434:		; Jump
jmp	loc_264C2

loc_26437:		; CODE XREF: sub_26026+407j
mov	ax, si
mov	dx, 26h	; '&'

loc_2643C:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26444:
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_26464	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'

loc_26452:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]

loc_2645E:
mov	[word ptr bx], 1

loc_26462:		; Jump
jmp	short loc_26467

loc_26464:		; CODE XREF: sub_26026+425j
jmp	loc_2624F	; Jump

loc_26467:		; CODE XREF: sub_26026:loc_26462j
jmp	short loc_264C4	; Jump

loc_26469:		; CODE XREF: sub_26026+40Cj
mov	ax, si

loc_2646B:		; CODE XREF: sub_26026:loc_2625Dj
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
jmp	loc_260FE	; Jump

loc_2647D:		; CODE XREF: sub_26026:loc_26428j
mov	ax, [bp+var_8]

loc_26480:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_264AB	; Jump if Not Zero (ZF=0)

loc_26494:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]

loc_264A5:
mov	[word ptr bx], 1

loc_264A9:		; Jump
jmp	short loc_264C0

loc_264AB:		; CODE XREF: sub_26026+46Cj
mov	ax, si

loc_264AD:
mov	dx, 26h	; '&'

loc_264B0:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_264B8:
mov	bx, [es:bx+1Ah]

loc_264BC:
mov	[word ptr bx], 0

loc_264C0:		; CODE XREF: sub_26026:loc_264A9j
jmp	short loc_264C4	; Jump

loc_264C2:		; CODE XREF: sub_26026:loc_26434j
jmp	short $+2	; Jump

loc_264C4:		; CODE XREF: sub_26026:loc_26467j
			; sub_26026:loc_264C0j
cmp	[word_36A56], 0	; Compare Two Operands
jnz	short loc_264D0	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_2E27D ; Call Procedure

loc_264D0:		; CODE XREF: sub_26026+4A3j
jmp	loc_26583	; Jump

loc_264D3:		; CODE XREF: sub_26026+3B2j
cmp	[word_36A3A], 0	; Compare Two Operands

loc_264D8:		; Jump if Zero (ZF=1)
jz	short loc_2653E
mov	si, 1

loc_264DD:		; Jump
jmp	short loc_26538

loc_264DF:		; CODE XREF: sub_26026+516j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_264E6:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_264EC:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ah

loc_264F1:		; Jump if Not Zero (ZF=0)
jnz	short loc_26537
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	ax, [bx]

loc_26506:
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2650E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
cmp	ax, [es:bx+18h]	; Compare Two Operands
jnz	short loc_26537	; Jump if Not Zero (ZF=0)

loc_2651B:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_26526:		; Add
add	bx, ax
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_26537	; Jump if Zero (ZF=1)

loc_2652F:
mov	[w36A32], 0FFFFh
jmp	short loc_26583	; Jump

loc_26537:		; CODE XREF: sub_26026:loc_264F1j
			; sub_26026+4F3j
			; sub_26026+507j
inc	si		; Increment by 1

loc_26538:		; CODE XREF: sub_26026:loc_264DDj
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jl	short loc_264DF	; Jump if Less (SF!=OF)

loc_2653E:		; CODE XREF: sub_26026+298j
			; sub_26026:loc_264D8j
cmp	[bp+var_B], 2Bh	; '+' ; Compare Two Operands
jz	short loc_2654A	; Jump if Zero (ZF=1)
cmp	[bp+var_B], 2Dh	; '-' ; Compare Two Operands
jnz	short loc_2658B	; Jump if Not Zero (ZF=0)

loc_2654A:		; CODE XREF: sub_26026+51Cj
nop			; No Operation
push	cs
call	near ptr sub_27A2B ; Call Procedure
mov	si, ax

loc_26551:		; Logical Inclusive OR
or	si, si
jz	short loc_2658B	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 6 ;	Compare	Two Operands
jnz	short loc_26588	; Jump if Not Zero (ZF=0)
cmp	[bp+var_B], 2Bh	; '+' ; Compare Two Operands
jnz	short loc_26576	; Jump if Not Zero (ZF=0)
push	si
nop			; No Operation
push	cs

loc_26572:		; Call Procedure
call	near ptr sub_2A4B2
pop	cx

loc_26576:		; CODE XREF: sub_26026+547j
cmp	[bp+var_B], 2Dh	; '-' ; Compare Two Operands
jnz	short loc_26583	; Jump if Not Zero (ZF=0)
push	si
nop			; No Operation
push	cs

loc_2657F:		; Call Procedure
call	near ptr sub_2A5E4
pop	cx

loc_26583:		; CODE XREF: sub_26026:loc_264D0j
			; sub_26026+50Fj
			; sub_26026+554j
mov	ax, si
jmp	loc_260FE	; Jump

loc_26588:		; CODE XREF: sub_26026+541j
jmp	loc_26690	; Jump

loc_2658B:		; CODE XREF: sub_26026+522j
			; sub_26026+52Dj
cmp	[word_36A6A], 0	; Compare Two Operands
jg	short loc_26595	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_26680	; Jump

loc_26595:		; CODE XREF: sub_26026+56Aj
cmp	[bp+var_B], 0Bh	; Compare Two Operands
jnz	short loc_2659E	; Jump if Not Zero (ZF=0)
jmp	loc_26647	; Jump

loc_2659E:		; CODE XREF: sub_26026+573j
mov	[bp+var_A], 0
cmp	[bp+var_B], 40h	; '@' ; Compare Two Operands
jle	short loc_265AF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_B], 5Dh	; ']' ; Compare Two Operands

loc_265AD:		; Jump if Less (SF!=OF)
jl	short loc_265C7

loc_265AF:		; CODE XREF: sub_26026+581j
cmp	[bp+var_B], 2Dh	; '-' ; Compare Two Operands
jle	short loc_265BB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_265B5:		; Compare Two Operands
cmp	[bp+var_B], 3Bh	; ';'
jl	short loc_265C7	; Jump if Less (SF!=OF)

loc_265BB:		; CODE XREF: sub_26026+58Dj
cmp	[bp+var_B], 20h	; ' ' ; Compare Two Operands
jz	short loc_265C7	; Jump if Zero (ZF=1)
cmp	[bp+var_B], 2Dh	; '-' ; Compare Two Operands
jnz	short loc_265CE	; Jump if Not Zero (ZF=0)

loc_265C7:		; CODE XREF: sub_26026:loc_265ADj
			; sub_26026+593j
			; sub_26026+599j
mov	[bp+var_A], 1
jmp	short loc_265DF	; Jump

loc_265CE:		; CODE XREF: sub_26026+59Fj
cmp	[bp+var_B], 60h	; '`' ; Compare Two Operands
jle	short loc_265DF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_265D4:		; Compare Two Operands
cmp	[bp+var_B], 7Bh	; '{'
jge	short loc_265DF	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_A], 1

loc_265DF:		; CODE XREF: sub_26026+5A6j
			; sub_26026+5ACj
			; sub_26026+5B2j
cmp	[bp+var_A], 1	; Compare Two Operands
jnz	short loc_26645	; Jump if Not Zero (ZF=0)
xor	si, si		; Logical Exclusive OR
jmp	short loc_265EA	; Jump

loc_265E9:		; CODE XREF: sub_26026+5E7j
inc	si		; Increment by 1

loc_265EA:		; CODE XREF: sub_26026+5C1j
cmp	[byte ptr si-5790h], 5Fh ; '_' ; Compare Two Operands
jz	short loc_2660F	; Jump if Zero (ZF=1)
cmp	[byte ptr si-5790h], 0 ; Compare Two Operands
jz	short loc_2660F	; Jump if Zero (ZF=1)
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26606:
mov	ax, [es:bx+20h]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jg	short loc_265E9	; Jump if Greater (ZF=0	& SF=OF)

loc_2660F:		; CODE XREF: sub_26026+5C9j
			; sub_26026+5D0j
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+20h]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jle	short loc_26634	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	al, [bp+var_B]
mov	[si-5790h], al
mov	[byte ptr si-578Fh], 0
jmp	short loc_26639	; Jump

loc_26634:		; CODE XREF: sub_26026+5FEj
mov	[byte ptr si-5790h], 0

loc_26639:		; CODE XREF: sub_26026+60Cj
mov	[word_36A68], 0
mov	[word_36A66], 0

loc_26645:		; CODE XREF: sub_26026+5BDj
jmp	short loc_26680	; Jump

loc_26647:		; CODE XREF: sub_26026+575j
xor	si, si		; Logical Exclusive OR
jmp	short loc_2664C	; Jump

loc_2664B:		; CODE XREF: sub_26026+649j
inc	si		; Increment by 1

loc_2664C:		; CODE XREF: sub_26026+623j
cmp	[byte ptr si-5790h], 0 ; Compare Two Operands
jz	short loc_26671	; Jump if Zero (ZF=1)
cmp	[byte ptr si-5790h], 5Fh ; '_' ; Compare Two Operands
jz	short loc_26671	; Jump if Zero (ZF=1)

loc_2665A:
mov	ax, [word_36A70]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+20h]

loc_2666C:		; Decrement by 1
dec	ax

loc_2666D:		; Compare Two Operands
cmp	ax, si
jg	short loc_2664B	; Jump if Greater (ZF=0	& SF=OF)

loc_26671:		; CODE XREF: sub_26026+62Bj
			; sub_26026+632j
or	si, si		; Logical Inclusive OR
jle	short loc_26680	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[byte ptr si-5791h], 0
mov	[word_36A66], 0

loc_26680:		; CODE XREF: sub_26026+6Bj
			; sub_26026+28Fj
			; sub_26026+56Cj
			; sub_26026:loc_26645j
			; sub_26026+64Dj
call	get__Mouse_w360A4 ; Call Procedure
mov	[idk_MousePosX_w3C5A2],	ax
call	get__Mouse_w360A6 ; Call Procedure
mov	[idk_MousePosX_w3C5A0],	ax

loc_26690:		; CODE XREF: sub_26026+FBj
			; sub_26026+22Fj
			; sub_26026:loc_26588j
xor	ax, ax		; Logical Exclusive OR
jmp	loc_260FE	; Jump

loc_26695:		; CODE XREF: sub_26026:loc_260FEj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_26026 ; sp-analysis failed



; Attributes: bp-based frame

; int __fastcall __far rschKBD_s2669B(int, int,	int, int)
proc rschKBD_s2669B far	; CODE XREF: sub_24DAE+48p
			; sub_26026:loc_2609Ap

argDest= byte ptr -28h
var_A= word ptr	-0Ah
var_8= byte ptr	-8
varKeyboardCode= byte ptr -7
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 28h		; Integer Subtraction
push	si
push	di		; argSrc
mov	di, [bp+arg_0]
call	ST_GetKeyboardCode ; Call Procedure
mov	[bp+varKeyboardCode], al

loc_266AE:
mov	ax, [idk_Kbd_w36A2E]
cmp	ax, [idk_Mouse_w3C5A8] ; Compare Two Operands
jl	short loc_266BD	; Jump if Less (SF!=OF)
mov	[idk_Kbd_w36A2E], 0

loc_266BD:		; CODE XREF: rschKBD_s2669B+1Aj
mov	ax, [idk_Kbd_w36A2E]
inc	ax		; Increment by 1
mov	si, ax
mov	al, [bp+varKeyboardCode]

TEST_LT_a:
mov	[bp+var_8], al
cmp	[bp+varKeyboardCode], 96 ; If (KBD_character < "a") Then Set (ZF = 1)
jle	short NOT_LOWERCASE_LETTER ; Jump if Less or Equal (ZF=1 | SF!=OF)

TEST_GT_z:		; If (KBD_character > "z") Then	Set (ZF	= 1)
cmp	[bp+varKeyboardCode], 123
jge	short NOT_LOWERCASE_LETTER ; Jump if Greater or	Equal (SF=OF)

ToUpper:
mov	al, [bp+varKeyboardCode]
add	al, -32		; Convert to UpperCase
mov	[bp+varKeyboardCode], al

NOT_LOWERCASE_LETTER:	; CODE XREF: rschKBD_s2669B+32j
			; rschKBD_s2669B+38j
cmp	[FLAG_GotKey], 0 ; Compare Two Operands
jz	short loc_2671E	; Jump if Zero (ZF=1)

loc_266E4:
mov	si, [FLAG_GotKey]
mov	al, [bp+varKeyboardCode]

loc_266EB:		; Add
add	al, 161
mov	[bp+varKeyboardCode], al
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_266FD:
mov	al, [es:bx+24h]
cmp	al, [bp+varKeyboardCode] ; Compare Two Operands
jnz	short loc_26710	; Jump if Not Zero (ZF=0)

loc_26706:
mov	al, [bp+varKeyboardCode]
add	al, 95		; Add
mov	[bp+varKeyboardCode], al
jmp	short loc_2671C	; Jump

loc_26710:		; CODE XREF: rschKBD_s2669B+69j
mov	al, [bp+varKeyboardCode]
add	al, 95		; Add
mov	[bp+varKeyboardCode], al
mov	si, [idk_Mouse_w3C5A8]

loc_2671C:		; CODE XREF: rschKBD_s2669B+73j
jmp	short loc_26722	; Jump

loc_2671E:		; CODE XREF: rschKBD_s2669B+47j
mov	si, [idk_Mouse_w3C5A8]

loc_26722:		; CODE XREF: rschKBD_s2669B:loc_2671Cj
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jz	short loc_2672B	; Jump if Zero (ZF=1)

loc_26728:		; Jump
jmp	loc_2683B

loc_2672B:		; CODE XREF: rschKBD_s2669B+8Bj
mov	[FLAG_GotKey], 0
mov	ax, [idk_Kbd_w36A2E]
inc	ax		; Increment by 1
mov	si, ax

loc_26737:		; Jump
jmp	short loc_26783

loc_26739:		; CODE XREF: rschKBD_s2669B+116j
mov	ax, si

loc_2673B:
mov	dx, 38
imul	dx		; Signed Multiply

loc_26740:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_26746:		; Compare Two Operands
cmp	[word ptr es:bx+8], 8

loc_2674B:		; Jump if Not Zero (ZF=0)
jnz	short loc_26782
mov	al, [bp+varKeyboardCode]

loc_26750:		; Add
add	al, 161

loc_26752:
mov	[bp+varKeyboardCode], al
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
cmp	al, [bp+varKeyboardCode] ; Compare Two Operands
jnz	short loc_26777	; Jump if Not Zero (ZF=0)
mov	al, [bp+varKeyboardCode]

loc_2676E:		; Add
add	al, 95

loc_26770:
mov	[bp+varKeyboardCode], al
jmp	short loc_267B3	; Jump
jmp	short loc_26780	; Jump

loc_26777:		; CODE XREF: rschKBD_s2669B+CEj
mov	al, [bp+varKeyboardCode]
add	al, 95		; Add
mov	[bp+varKeyboardCode], al
inc	si		; Increment by 1

loc_26780:		; CODE XREF: rschKBD_s2669B+DAj
jmp	short loc_26783	; Jump

loc_26782:		; CODE XREF: rschKBD_s2669B:loc_2674Bj
inc	si		; Increment by 1

loc_26783:		; CODE XREF: rschKBD_s2669B:loc_26737j
			; rschKBD_s2669B:loc_26780j
mov	ax, si
mov	dx, 38

loc_26788:		; Signed Multiply
imul	dx

loc_2678A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_2678E:		; Add
add	bx, ax

loc_26790:
mov	al, [es:bx+24h]

loc_26794:		; Compare Two Operands
cmp	al, [bp+varKeyboardCode]
jnz	short loc_267AD	; Jump if Not Zero (ZF=0)

loc_26799:
mov	ax, si

loc_2679B:
mov	dx, 38

loc_2679E:		; Signed Multiply
imul	dx

loc_267A0:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 8 ;	Compare	Two Operands
jnz	short loc_267B3	; Jump if Not Zero (ZF=0)

loc_267AD:		; CODE XREF: rschKBD_s2669B+FCj
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jnz	short loc_26739	; Jump if Not Zero (ZF=0)

loc_267B3:		; CODE XREF: rschKBD_s2669B+D8j
			; rschKBD_s2669B+110j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jz	short loc_267BC	; Jump if Zero (ZF=1)

loc_267B9:		; Jump
db 0E9h,7Fh,0 ;	<BAD>jmp     loc_2683B

loc_267BC:		; CODE XREF: rschKBD_s2669B+11Cj
mov	si, 1
jmp	short loc_2680B	; Jump

loc_267C1:		; CODE XREF: rschKBD_s2669B+19Ej
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_267CE:		; Compare Two Operands
cmp	[word ptr es:bx+8], 8
jnz	short loc_2680A	; Jump if Not Zero (ZF=0)
mov	al, [bp+varKeyboardCode]

loc_267D8:		; Add
add	al, 161
mov	[bp+varKeyboardCode], al

loc_267DD:
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
cmp	al, [bp+varKeyboardCode] ; Compare Two Operands
jnz	short loc_267FF	; Jump if Not Zero (ZF=0)
mov	al, [bp+varKeyboardCode]
add	al, 95		; Add
mov	[bp+varKeyboardCode], al
jmp	short loc_2683B	; Jump

loc_267FD:		; Jump
jmp	short loc_26808

loc_267FF:		; CODE XREF: rschKBD_s2669B+156j
mov	al, [bp+varKeyboardCode]

loc_26802:		; Add
add	al, 95
mov	[bp+varKeyboardCode], al
inc	si		; Increment by 1

loc_26808:		; CODE XREF: rschKBD_s2669B:loc_267FDj
jmp	short loc_2680B	; Jump

loc_2680A:		; CODE XREF: rschKBD_s2669B+138j
inc	si		; Increment by 1

loc_2680B:		; CODE XREF: rschKBD_s2669B+124j
			; rschKBD_s2669B:loc_26808j
mov	ax, si

loc_2680D:
mov	dx, 38
imul	dx		; Signed Multiply

loc_26812:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	al, [es:bx+24h]

loc_2681C:		; Compare Two Operands
cmp	al, [bp+varKeyboardCode]
jnz	short loc_26835	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_26823:
mov	dx, 38

loc_26826:		; Signed Multiply
imul	dx

loc_26828:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 8 ;	Compare	Two Operands

loc_26833:		; Jump if Not Zero (ZF=0)
jnz	short loc_2683B

loc_26835:		; CODE XREF: rschKBD_s2669B+184j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jnz	short loc_267C1	; Jump if Not Zero (ZF=0)

loc_2683B:		; CODE XREF: rschKBD_s2669B:loc_26728j
			; rschKBD_s2669B:loc_267B9j
			; rschKBD_s2669B+160j
			; rschKBD_s2669B:loc_26833j
mov	[idk_Kbd_w36A2E], si
mov	[bp+var_6], 1
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jl	short loc_2684D	; Jump if Less (SF!=OF)

loc_2684A:		; Jump
jmp	loc_26A4C

loc_2684D:		; CODE XREF: rschKBD_s2669B+1ADj
mov	[di], si
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2685C:		; Compare Two Operands
cmp	[word ptr es:bx], 320

loc_26861:		; Jump if Less (SF!=OF)
jl	short loc_26866
jmp	loc_26975	; Jump

loc_26866:		; CODE XREF: rschKBD_s2669B:loc_26861j
mov	ax, si

loc_26868:
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26873:		; Compare Two Operands
cmp	[word ptr es:bx+2], 200
jl	short loc_2687E	; Jump if Less (SF!=OF)

loc_2687B:		; Jump
jmp	loc_26975

loc_2687E:		; CODE XREF: rschKBD_s2669B+1DEj
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
mov	ax, si
mov	dx, 38

loc_26888:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax

loc_26895:
mov	ax, si

loc_26897:
mov	dx, 38
imul	dx		; Signed Multiply

loc_2689C:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_268A0:		; Add
add	bx, ax
pop	ax

loc_268A3:		; Integer Subtraction
sub	ax, [es:bx]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si

loc_268AE:
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_268B9:
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply

loc_268C9:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_268CF:
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si

loc_268EE:
mov	dx, 38

loc_268F1:		; Signed Multiply
imul	dx

loc_268F3:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
mov	[idk_MousePosX_w3C5A0],	ax
cmp	[idk_MousePosX_w3C5A2],	320 ; Compare Two Operands
jge	short loc_26970	; Jump if Greater or Equal (SF=OF)
cmp	[idk_MousePosX_w3C5A0],	200 ; Compare Two Operands

loc_26911:		; Jump if Greater or Equal (SF=OF)
jge	short loc_26970

loc_26913:
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	idk_Mouse_s23F82 ; Call	Procedure
pop	cx
pop	cx
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax
mov	ax, [idk_MousePosX_w3C5A2]
sub	ax, [idk_Mouse_w3C5A4] ; Integer Subtraction
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, [idk_MousePosX_w3C5A0]
sub	ax, [idk_Mouse_w3C5A4] ; Integer Subtraction
mov	[idk_MousePosX_w3C5A0],	ax
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
call	idk_ChkMousDoEga ; Call	Procedure
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24648	; Call Procedure
pop	cx

loc_26960:
pop	cx
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24A74	; Call Procedure
pop	cx
pop	cx

loc_26970:		; CODE XREF: rschKBD_s2669B+26Ej
			; rschKBD_s2669B:loc_26911j
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE

loc_26975:		; CODE XREF: rschKBD_s2669B+1C8j
			; rschKBD_s2669B:loc_2687Bj
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26982:		; Compare Two Operands
cmp	[word ptr es:bx+8], 8
jz	short loc_2698C	; Jump if Zero (ZF=1)
jmp	loc_26A4A	; Jump

loc_2698C:		; CODE XREF: rschKBD_s2669B+2ECj
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply

loc_26993:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_26999:		; argSrc
push	[word ptr es:bx+16h]

loc_2699D:		; Load Effective Address
lea	ax, [bp+argDest]
push	ax		; argDest

loc_269A1:		; argDest,argSrc
call	_strcpy
pop	cx
pop	cx
mov	ax, si
mov	dx, 38

loc_269AD:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
inc	[word ptr es:bx+18h] ; Increment by 1
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
push	ax
mov	ax, si

loc_269CD:
mov	dx, 38

loc_269D0:		; Signed Multiply
imul	dx

loc_269D2:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
cmp	ax, [es:bx+1Ah]	; Compare Two Operands
jl	short loc_26A0E	; Jump if Less (SF!=OF)

loc_269DF:
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_269EA:		; Add
add	bx, ax
mov	[word ptr es:bx+18h], 0

loc_269F2:
mov	ax, si

loc_269F4:
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_269FF:
mov	al, [bp+argDest]
mov	[es:bx+24h], al

loc_26A06:
mov	[FLAG_GotKey], 0

loc_26A0C:		; Jump
jmp	short loc_26A45

loc_26A0E:		; CODE XREF: rschKBD_s2669B+342j
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply

loc_26A15:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	bx, [es:bx+18h]
lea	ax, [bp+argDest] ; Load	Effective Address
add	bx, ax		; Add
mov	al, [bx]
push	ax
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_26A35:
mov	[es:bx+24h], al
mov	[FLAG_GotKey], si
mov	[word ptr di], 0
mov	[bp+varKeyboardCode], 0

loc_26A45:		; CODE XREF: rschKBD_s2669B:loc_26A0Cj
mov	[bp+var_6], 0

loc_26A4A:		; CODE XREF: rschKBD_s2669B+2EEj
jmp	short loc_26AAA	; Jump

loc_26A4C:		; CODE XREF: rschKBD_s2669B:loc_2684Aj
mov	ax, [di]

loc_26A4E:
mov	[bp+var_2], ax
mov	al, [bp+varKeyboardCode]
cbw			; AL ->	AX (with sign)
mov	[bp+var_A], ax
mov	cx, 8		; switch 8 cases
mov	bx, offset word_26B47

loc_26A5E:		; CODE XREF: rschKBD_s2669B+3CEj
mov	ax, [cs:bx]

loc_26A61:		; Compare Two Operands
cmp	ax, [bp+var_A]
jz	short loc_26A6D	; Jump if Zero (ZF=1)
add	bx, 2		; Add
loop	loc_26A5E	; Loop while CX	!= 0
jmp	short loc_26AA3	; default

loc_26A6D:		; CODE XREF: rschKBD_s2669B+3C9j
jmp	[word ptr cs:bx+10h] ; switch jump

loc_26A71:		; DATA XREF: seg034:off_26B57o
mov	ax, 'L'         ; case 0x1

loc_26A74:		; CODE XREF: rschKBD_s2669B+3E8j
			; rschKBD_s2669B+3EDj
			; rschKBD_s2669B+3F2j
			; rschKBD_s2669B+3F7j
			; rschKBD_s2669B+3FCj
			; rschKBD_s2669B+401j
			; rschKBD_s2669B+406j
push	ax		; L R U	D W X Y	Z (Left,Right,Up,Down)?
nop			; No Operation
push	cs
call	near ptr sub_27E4B ; Call Procedure
pop	cx
mov	[bp+var_2], ax
jmp	short loc_26AA5	; Jump

loc_26A80:		; CODE XREF: rschKBD_s2669B:loc_26A6Dj
			; DATA XREF: seg034:off_26B57o
mov	ax, 'R'         ; case 0x2
jmp	short loc_26A74	; Jump

loc_26A85:		; CODE XREF: rschKBD_s2669B:loc_26A6Dj
			; DATA XREF: seg034:off_26B57o
mov	ax, 'U'         ; case 0x3
jmp	short loc_26A74	; Jump

loc_26A8A:		; CODE XREF: rschKBD_s2669B:loc_26A6Dj
			; DATA XREF: seg034:off_26B57o
mov	ax, 'D'         ; case 0x4
jmp	short loc_26A74	; Jump

loc_26A8F:		; CODE XREF: rschKBD_s2669B:loc_26A6Dj
			; DATA XREF: seg034:off_26B57o
mov	ax, 'W'         ; case 0x1A
jmp	short loc_26A74	; Jump

loc_26A94:		; CODE XREF: rschKBD_s2669B:loc_26A6Dj
			; DATA XREF: seg034:off_26B57o
mov	ax, 'X'         ; case 0x19
jmp	short loc_26A74	; Jump

loc_26A99:		; CODE XREF: rschKBD_s2669B:loc_26A6Dj
			; DATA XREF: seg034:off_26B57o
mov	ax, 'Y'         ; case 0x1C
jmp	short loc_26A74	; Jump

loc_26A9E:		; CODE XREF: rschKBD_s2669B:loc_26A6Dj
			; DATA XREF: seg034:off_26B57o
mov	ax, 'Z'         ; case 0x1D
jmp	short loc_26A74	; Jump

loc_26AA3:		; CODE XREF: rschKBD_s2669B+3D0j
jmp	short $+2	; default

loc_26AA5:		; CODE XREF: rschKBD_s2669B+3E3j
mov	ax, [bp+var_2]
mov	[di], ax

loc_26AAA:		; CODE XREF: rschKBD_s2669B:loc_26A4Aj
cmp	[bp+var_6], 0	; Compare Two Operands
jz	short loc_26B1E	; Jump if Zero (ZF=1)

loc_26AB0:
mov	[bp+var_4], 0
jmp	short loc_26B15	; Jump

loc_26AB7:		; CODE XREF: rschKBD_s2669B:loc_26B1Cj
mov	ax, [bp+var_4]

loc_26ABA:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_26AC3:		; Add
add	bx, ax
cmp	[word ptr es:bx+8], 8 ;	Compare	Two Operands
jnz	short loc_26B12	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_26AD8:		; Add
add	bx, ax
push	[word ptr es:bx+16h]
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, [bp+var_4]

loc_26AEC:
mov	dx, 26h	; '&'

loc_26AEF:		; Signed Multiply
imul	dx

loc_26AF1:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_26AF5:		; Add
add	bx, ax

loc_26AF7:
mov	[word ptr es:bx+18h], 0
mov	ax, [bp+var_4]
mov	dx, 26h	; '&'

loc_26B03:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [bp+argDest]
mov	[es:bx+24h], al

loc_26B12:		; CODE XREF: rschKBD_s2669B+42Fj
inc	[bp+var_4]	; Increment by 1

loc_26B15:		; CODE XREF: rschKBD_s2669B+41Aj
mov	ax, [bp+var_4]
cmp	ax, [idk_Mouse_w3C5A8] ; Compare Two Operands

loc_26B1C:		; Jump if Less (SF!=OF)
jl	short loc_26AB7

loc_26B1E:		; CODE XREF: rschKBD_s2669B+413j
mov	ax, [di]
mov	dx, 26h	; '&'

loc_26B23:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
cmp	al, [bp+varKeyboardCode] ; Compare Two Operands
jz	short loc_26B3A	; Jump if Zero (ZF=1)
mov	al, [bp+var_8]
mov	[bp+varKeyboardCode], al

loc_26B3A:		; CODE XREF: rschKBD_s2669B+497j
mov	al, [bp+varKeyboardCode]
cbw			; AL ->	AX (with sign)
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp rschKBD_s2669B

db 0
word_26B47 dw	   1,	  2,	 3,	4
			; DATA XREF: rschKBD_s2669B+3C0o
dw    19h,   1Ah,   1Ch,   1Dh ; value table for switch	statement
off_26B57 dw offset loc_26A71 ;	jump table for switch statement
dw offset loc_26A80
dw offset loc_26A85
dw offset loc_26A8A
dw offset loc_26A94
dw offset loc_26A8F
dw offset loc_26A99
dw offset loc_26A9E


; Attributes: bp-based frame

proc sub_26B67 far	; CODE XREF: sub_27E4B+192p

var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 14h		; Integer Subtraction
push	si
push	di
mov	di, 1F4h
mov	[bp+var_2], 1F4h

loc_26B77:
mov	[bp+var_A], 0
mov	[bp+var_C], 1F4h
mov	[bp+var_E], 3
mov	[bp+var_10], 0D40h

loc_26B8B:
mov	ax, [bp+arg_4]
mov	[bp+var_4], ax
mov	si, 1
mov	[bp+var_6], 0
jmp	short loc_26BF4	; Jump

loc_26B9B:		; CODE XREF: sub_26B67+91j
mov	ax, si
mov	dx, 26h	; '&'

loc_26BA0:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands

loc_26BAD:		; Jump if Greater or Equal (SF=OF)
jge	short loc_26BF3

loc_26BAF:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26BBC:		; Compare Two Operands
cmp	[byte ptr es:bx+24h], 0
jnz	short loc_26BF3	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands

loc_26BD5:		; Jump if Zero (ZF=1)
jz	short loc_26BDC
inc	[bp+var_6]	; Increment by 1
jmp	short loc_26BF3	; Jump

loc_26BDC:		; CODE XREF: sub_26B67:loc_26BD5j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_26BF3	; Jump if Zero (ZF=1)
inc	[bp+var_6]	; Increment by 1

loc_26BF3:		; CODE XREF: sub_26B67:loc_26BADj
			; sub_26B67+5Aj
			; sub_26B67+73j
			; sub_26B67+87j
inc	si		; Increment by 1

loc_26BF4:		; CODE XREF: sub_26B67+32j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jl	short loc_26B9B	; Jump if Less (SF!=OF)
cmp	[bp+var_6], 0	; Compare Two Operands
jnz	short loc_26C05	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR

loc_26C02:		; CODE XREF: sub_26B67:loc_2790Aj
jmp	loc_2790D	; Jump

loc_26C05:		; CODE XREF: sub_26B67+97j
cmp	[bp+arg_2], 0	; Compare Two Operands
jnz	short loc_26C0E	; Jump if Not Zero (ZF=0)
jmp	loc_27022	; Jump

loc_26C0E:		; CODE XREF: sub_26B67+A2j
cmp	[bp+arg_0], 0	; Compare Two Operands
jz	short loc_26C17	; Jump if Zero (ZF=1)
jmp	loc_27022	; Jump

loc_26C17:		; CODE XREF: sub_26B67+ABj
mov	si, 1
jmp	loc_26DCE	; Jump

loc_26C1D:		; CODE XREF: sub_26B67:loc_26DD4j
cmp	si, [bp+arg_4]	; Compare Two Operands
jnz	short loc_26C34	; Jump if Not Zero (ZF=0)
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands

loc_26C28:		; Jump if Not Zero (ZF=0)
jnz	short loc_26C2F
jmp	loc_26DD7	; Jump
jmp	short loc_26C34	; Jump

loc_26C2F:		; CODE XREF: sub_26B67:loc_26C28j
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax

loc_26C34:		; CODE XREF: sub_26B67+B9j
			; sub_26B67+C6j
mov	[bp+var_8], 0
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands
jge	short loc_26C95	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_26C54:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 0	; Compare Two Operands
jnz	short loc_26C95	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26C6E:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ah
jnz	short loc_26C90	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_26C7C:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_26C82:		; Compare Two Operands
cmp	[word ptr es:bx+12h], 0
jz	short loc_26C8E	; Jump if Zero (ZF=1)
mov	[bp+var_8], 1

loc_26C8E:		; CODE XREF: sub_26B67+120j
jmp	short loc_26C95	; Jump

loc_26C90:		; CODE XREF: sub_26B67+10Cj
mov	[bp+var_8], 1

loc_26C95:		; CODE XREF: sub_26B67+E4j
			; sub_26B67+F8j
			; sub_26B67:loc_26C8Ej
cmp	[bp+var_8], 0	; Compare Two Operands
jnz	short loc_26C9E	; Jump if Not Zero (ZF=0)
jmp	loc_26DCD	; Jump

loc_26C9E:		; CODE XREF: sub_26B67+132j
cmp	[bp+arg_2], 0	; Compare Two Operands
jge	short loc_26CE7	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_26CAF:		; Add
add	bx, ax
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax

loc_26CCE:
mov	ax, si

loc_26CD0:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
sub	ax, [es:bx+2]	; Integer Subtraction

loc_26CE2:
pop	dx
sub	ax, dx		; Integer Subtraction
jmp	short loc_26D26	; Jump

loc_26CE7:		; CODE XREF: sub_26B67+13Bj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_26D00:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_26D06:
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'

loc_26D16:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	ax, [es:bx+2]	; Add
sub	ax, [bp+arg_8]	; Integer Subtraction

loc_26D26:		; CODE XREF: sub_26B67+17Ej
mov	[bp+var_2], ax
mov	ax, si

loc_26D2B:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_26D30:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction

loc_26D4C:		; AX ->	DX:AX (with sign)
cwd
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax

loc_26D52:
mov	ax, si
mov	dx, 26h	; '&'

loc_26D57:		; Signed Multiply
imul	dx

loc_26D59:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax

loc_26D60:		; Add
add	ax, [es:bx]
sub	ax, [bp+arg_6]	; Integer Subtraction

loc_26D66:
mov	di, ax
mov	ax, si

loc_26D6A:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_26D73:		; Add
add	bx, ax
mov	ax, [es:bx]
cmp	ax, [bp+arg_6]	; Compare Two Operands
jg	short loc_26DA0	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_26D88:		; Add
add	bx, ax
mov	ax, [es:bx+4]
cmp	ax, [bp+arg_6]	; Compare Two Operands
jl	short loc_26DA0	; Jump if Less (SF!=OF)
db 83h,0FFh,0FAh ; <BAD>cmp	di, 0FFFAh ; Compare Two Operands
jl	short loc_26D9D	; Jump if Less (SF!=OF)
cmp	di, 6		; Compare Two Operands
jle	short loc_26DA0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_26D9D:		; CODE XREF: sub_26B67+22Fj
mov	di, 6

loc_26DA0:		; CODE XREF: sub_26B67+214j
			; sub_26B67+22Aj
			; sub_26B67+234j
db 83h,0FFh,0FAh ; <BAD>cmp	di, 0FFFAh ; Compare Two Operands
jle	short loc_26DCD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	di, 6		; Compare Two Operands
jge	short loc_26DCD	; Jump if Greater or Equal (SF=OF)

loc_26DAA:		; Compare Two Operands
cmp	[bp+var_2], 0

loc_26DAE:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_26DCD

loc_26DB0:
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)

loc_26DB4:		; Compare Two Operands
cmp	dx, [bp+var_E]
jg	short loc_26DCD	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_26DC0	; Jump if Less (SF!=OF)
cmp	ax, [bp+var_10]	; Compare Two Operands

loc_26DBE:		; Jump if Not Below (CF=0)
jnb	short loc_26DCD

loc_26DC0:		; CODE XREF: sub_26B67+252j
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
mov	[bp+var_E], dx
mov	[bp+var_10], ax
mov	[bp+var_4], si

loc_26DCD:		; CODE XREF: sub_26B67+134j
			; sub_26B67+23Cj
			; sub_26B67+241j
			; sub_26B67:loc_26DAEj
			; sub_26B67+250j
			; sub_26B67:loc_26DBEj
inc	si		; Increment by 1

loc_26DCE:		; CODE XREF: sub_26B67+B3j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jge	short loc_26DD7	; Jump if Greater or Equal (SF=OF)

loc_26DD4:		; Jump
jmp	loc_26C1D

loc_26DD7:		; CODE XREF: sub_26B67+C3j
			; sub_26B67+26Bj
mov	ax, [bp+var_4]
cmp	ax, [bp+arg_4]	; Compare Two Operands
jz	short loc_26DE2	; Jump if Zero (ZF=1)
jmp	loc_27022	; Jump

loc_26DE2:		; CODE XREF: sub_26B67+276j
mov	si, 1
jmp	loc_27019	; Jump

loc_26DE8:		; CODE XREF: sub_26B67:loc_2701Fj
cmp	si, [bp+arg_4]	; Compare Two Operands
jnz	short loc_26DFF	; Jump if Not Zero (ZF=0)
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jnz	short loc_26DFA	; Jump if Not Zero (ZF=0)
jmp	loc_27022	; Jump

loc_26DF8:		; Jump
jmp	short loc_26DFF

loc_26DFA:		; CODE XREF: sub_26B67+28Cj
mov	ax, si
inc	ax		; Increment by 1

loc_26DFD:
mov	si, ax

loc_26DFF:		; CODE XREF: sub_26B67+284j
			; sub_26B67:loc_26DF8j
mov	[bp+var_8], 0
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands

loc_26E16:		; Jump if Greater or Equal (SF=OF)
jge	short loc_26E60
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_26E25:		; Compare Two Operands
cmp	[byte ptr es:bx+24h], 0
jnz	short loc_26E60	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_26E2E:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jnz	short loc_26E5B	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_26E47:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_26E4D:		; Compare Two Operands
cmp	[word ptr es:bx+12h], 0
jz	short loc_26E59	; Jump if Zero (ZF=1)

loc_26E54:
mov	[bp+var_8], 1

loc_26E59:		; CODE XREF: sub_26B67+2EBj
jmp	short loc_26E60	; Jump

loc_26E5B:		; CODE XREF: sub_26B67+2D7j
mov	[bp+var_8], 1

loc_26E60:		; CODE XREF: sub_26B67:loc_26E16j
			; sub_26B67+2C3j
			; sub_26B67:loc_26E59j
cmp	[bp+var_8], 0	; Compare Two Operands

loc_26E64:		; Jump if Not Zero (ZF=0)
jnz	short loc_26E69
jmp	loc_27018	; Jump

loc_26E69:		; CODE XREF: sub_26B67:loc_26E64j
cmp	[bp+arg_2], 0	; Compare Two Operands

loc_26E6D:		; Jump if Greater or Equal (SF=OF)
jge	short loc_26EB2

loc_26E6F:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_26E88:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax

loc_26E8F:		; Integer Subtraction
sub	ax, [es:bx+2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si

loc_26E9B:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
sub	ax, [es:bx+2]	; Integer Subtraction
pop	dx

loc_26EAE:		; Integer Subtraction
sub	ax, dx

loc_26EB0:		; Jump
jmp	short loc_26EF1

loc_26EB2:		; CODE XREF: sub_26B67:loc_26E6Dj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	ax, [es:bx+2]	; Add
sub	ax, [bp+arg_8]	; Integer Subtraction

loc_26EF1:		; CODE XREF: sub_26B67:loc_26EB0j
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si

loc_26F08:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_26F0D:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax

loc_26F14:		; Integer Subtraction
sub	ax, [es:bx]
cwd			; AX ->	DX:AX (with sign)

loc_26F18:		; Integer Subtraction
sub	ax, dx

loc_26F1A:		; Shift	Arithmetic Right
sar	ax, 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_26F28:		; Add
add	bx, ax
pop	ax

loc_26F2B:		; Add
add	ax, [es:bx]
sub	ax, [bp+arg_6]	; Integer Subtraction

loc_26F31:
mov	di, ax

loc_26F33:
mov	ax, si
mov	dx, 26h	; '&'

loc_26F38:		; Signed Multiply
imul	dx

loc_26F3A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx]

loc_26F43:		; Compare Two Operands
cmp	ax, [bp+arg_6]
jg	short loc_26F6B	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
cmp	ax, [bp+arg_6]	; Compare Two Operands
jl	short loc_26F6B	; Jump if Less (SF!=OF)

loc_26F5E:		; Compare Two Operands
db 83h,0FFh,0FAh ; <BAD>cmp	di, 0FFFAh
jl	short loc_26F68	; Jump if Less (SF!=OF)
cmp	di, 6		; Compare Two Operands
jle	short loc_26F6B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_26F68:		; CODE XREF: sub_26B67+3FAj
mov	di, 6

loc_26F6B:		; CODE XREF: sub_26B67+3DFj
			; sub_26B67+3F5j
			; sub_26B67+3FFj
or	di, di		; Logical Inclusive OR
jge	short loc_26F75	; Jump if Greater or Equal (SF=OF)
mov	ax, di
neg	ax		; Two's Complement Negation

loc_26F73:
mov	di, ax

loc_26F75:		; CODE XREF: sub_26B67+406j
cmp	[bp+var_2], 0	; Compare Two Operands
jge	short loc_26F7E	; Jump if Greater or Equal (SF=OF)
mov	di, 1F4h

loc_26F7E:		; CODE XREF: sub_26B67+412j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_26F89	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 1

loc_26F89:		; CODE XREF: sub_26B67+41Bj
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	dx

loc_26F8E:
push	ax

loc_26F8F:
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR

loc_26F96:
mov	ax, 64h	; 'd'
pop	cx
pop	bx
call	LXMUL@		; Call Procedure

loc_26FA0:
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_A], dx
mov	[bp+var_C], ax
cmp	[bp+var_A], 0	; Compare Two Operands
jl	short loc_27018	; Jump if Less (SF!=OF)
jnz	short loc_26FBB	; Jump if Not Zero (ZF=0)
cmp	[bp+var_C], 0	; Compare Two Operands
jb	short loc_27018	; Jump if Below	(CF=1)

loc_26FBB:		; CODE XREF: sub_26B67+44Cj
cmp	[bp+var_A], 0	; Compare Two Operands
jg	short loc_27018	; Jump if Greater (ZF=0	& SF=OF)

loc_26FC1:		; Jump if Less (SF!=OF)
jl	short loc_26FC9
cmp	[bp+var_C], 2Ch	; ',' ; Compare Two Operands
jnb	short loc_27018	; Jump if Not Below (CF=0)

loc_26FC9:		; CODE XREF: sub_26B67:loc_26FC1j
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, di
push	dx

loc_26FD0:		; AX ->	DX:AX (with sign)
cwd
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	ax
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
pop	bx
pop	cx
add	cx, ax		; Add
adc	bx, dx		; Add with Carry
mov	[bp+var_12], bx
mov	[bp+var_14], cx
mov	ax, [bp+var_12]
mov	dx, [bp+var_14]
cmp	ax, [bp+var_E]	; Compare Two Operands
jg	short loc_27018	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_27009	; Jump if Less (SF!=OF)
cmp	dx, [bp+var_10]	; Compare Two Operands
jnb	short loc_27018	; Jump if Not Below (CF=0)

loc_27009:		; CODE XREF: sub_26B67+49Bj
mov	ax, [bp+var_12]
mov	dx, [bp+var_14]
mov	[bp+var_E], ax
mov	[bp+var_10], dx
mov	[bp+var_4], si

loc_27018:		; CODE XREF: sub_26B67+2FFj
			; sub_26B67+44Aj
			; sub_26B67+452j
			; sub_26B67+458j
			; sub_26B67+460j
			; sub_26B67+499j
			; sub_26B67+4A0j
inc	si		; Increment by 1

loc_27019:		; CODE XREF: sub_26B67+27Ej
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands

loc_2701D:		; Jump if Greater or Equal (SF=OF)
jge	short loc_27022

loc_2701F:		; Jump
jmp	loc_26DE8

loc_27022:		; CODE XREF: sub_26B67+A4j
			; sub_26B67+ADj
			; sub_26B67+278j
			; sub_26B67+28Ej
			; sub_26B67:loc_2701Dj
cmp	[bp+arg_0], 0	; Compare Two Operands

loc_27026:		; Jump if Not Zero (ZF=0)
jnz	short loc_2702B

loc_27028:		; Jump
jmp	loc_27447

loc_2702B:		; CODE XREF: sub_26B67:loc_27026j
cmp	[bp+arg_2], 0	; Compare Two Operands

loc_2702F:		; Jump if Zero (ZF=1)
jz	short loc_27034
jmp	loc_27447	; Jump

loc_27034:		; CODE XREF: sub_26B67:loc_2702Fj
mov	si, 1
jmp	loc_271EE	; Jump

loc_2703A:		; CODE XREF: sub_26B67+68Dj
cmp	si, [bp+arg_4]	; Compare Two Operands
jnz	short loc_27051	; Jump if Not Zero (ZF=0)
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jnz	short loc_2704C	; Jump if Not Zero (ZF=0)

loc_27047:		; Jump
jmp	loc_271F7
jmp	short loc_27051	; Jump

loc_2704C:		; CODE XREF: sub_26B67+4DEj
mov	ax, si
inc	ax		; Increment by 1

loc_2704F:
mov	si, ax

loc_27051:		; CODE XREF: sub_26B67+4D6j
			; sub_26B67+4E3j
mov	[bp+var_8], 0

loc_27056:
mov	ax, si

loc_27058:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27063:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ch
jge	short loc_270B2	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_27071:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 0	; Compare Two Operands
jnz	short loc_270B2	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_27080:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands

loc_27090:		; Jump if Not Zero (ZF=0)
jnz	short loc_270AD
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2709F:		; Compare Two Operands
cmp	[word ptr es:bx+12h], 0

loc_270A4:		; Jump if Zero (ZF=1)
jz	short loc_270AB
mov	[bp+var_8], 1

loc_270AB:		; CODE XREF: sub_26B67:loc_270A4j
jmp	short loc_270B2	; Jump

loc_270AD:		; CODE XREF: sub_26B67:loc_27090j
mov	[bp+var_8], 1

loc_270B2:		; CODE XREF: sub_26B67+501j
			; sub_26B67+515j
			; sub_26B67:loc_270ABj
cmp	[bp+var_8], 0	; Compare Two Operands
jnz	short loc_270BB	; Jump if Not Zero (ZF=0)
jmp	loc_271ED	; Jump

loc_270BB:		; CODE XREF: sub_26B67+54Fj
cmp	[bp+arg_0], 0	; Compare Two Operands
jge	short loc_27102	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_270CE:
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
sub	ax, [es:bx]	; Integer Subtraction
pop	dx
sub	ax, dx		; Integer Subtraction
jmp	short loc_27141	; Jump

loc_27102:		; CODE XREF: sub_26B67+558j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2711B:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+arg_6]	; Integer Subtraction

loc_27141:		; CODE XREF: sub_26B67+599j
mov	di, ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_27160:		; Add
add	bx, ax
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_2717B:		; Add
add	ax, [es:bx+2]
sub	ax, [bp+arg_8]	; Integer Subtraction
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
cmp	ax, [bp+arg_8]	; Compare Two Operands
jg	short loc_271C2	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_271A2:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+6]

loc_271AC:		; Compare Two Operands
cmp	ax, [bp+arg_8]
jl	short loc_271C2	; Jump if Less (SF!=OF)
db 83h,7Eh,0FEh,0FAh ; <BAD>cmp	    [bp+var_2],	0FFFAh ; Compare Two Operands
jl	short loc_271BD	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 6	; Compare Two Operands

loc_271BB:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_271C2

loc_271BD:		; CODE XREF: sub_26B67+64Ej
mov	[bp+var_2], 6

loc_271C2:		; CODE XREF: sub_26B67+632j
			; sub_26B67+648j
			; sub_26B67:loc_271BBj
db 83h,7Eh,0FEh,0FAh ; <BAD>cmp	    [bp+var_2],	0FFFAh ; Compare Two Operands
jle	short loc_271ED	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_271C8:		; Compare Two Operands
cmp	[bp+var_2], 6
jge	short loc_271ED	; Jump if Greater or Equal (SF=OF)
or	di, di		; Logical Inclusive OR
jle	short loc_271ED	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, di

loc_271D4:		; AX ->	DX:AX (with sign)
cwd
cmp	dx, [bp+var_E]	; Compare Two Operands
jg	short loc_271ED	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_271E1	; Jump if Less (SF!=OF)
cmp	ax, [bp+var_10]	; Compare Two Operands
jnb	short loc_271ED	; Jump if Not Below (CF=0)

loc_271E1:		; CODE XREF: sub_26B67+673j
mov	ax, di
cwd			; AX ->	DX:AX (with sign)

loc_271E4:
mov	[bp+var_E], dx
mov	[bp+var_10], ax
mov	[bp+var_4], si

loc_271ED:		; CODE XREF: sub_26B67+551j
			; sub_26B67+65Fj
			; sub_26B67+665j
			; sub_26B67+669j
			; sub_26B67+671j
			; sub_26B67+678j
inc	si		; Increment by 1

loc_271EE:		; CODE XREF: sub_26B67+4D0j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jge	short loc_271F7	; Jump if Greater or Equal (SF=OF)
jmp	loc_2703A	; Jump

loc_271F7:		; CODE XREF: sub_26B67:loc_27047j
			; sub_26B67+68Bj
mov	ax, [bp+var_4]
cmp	ax, [bp+arg_4]	; Compare Two Operands
jz	short loc_27202	; Jump if Zero (ZF=1)
jmp	loc_27447	; Jump

loc_27202:		; CODE XREF: sub_26B67+696j
mov	si, 1
jmp	loc_2743E	; Jump

loc_27208:		; CODE XREF: sub_26B67:loc_27444j
cmp	si, [bp+arg_4]	; Compare Two Operands

loc_2720B:		; Jump if Not Zero (ZF=0)
jnz	short loc_2721F
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jnz	short loc_2721A	; Jump if Not Zero (ZF=0)
jmp	loc_27447	; Jump
jmp	short loc_2721F	; Jump

loc_2721A:		; CODE XREF: sub_26B67+6ACj
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax

loc_2721F:		; CODE XREF: sub_26B67:loc_2720Bj
			; sub_26B67+6B1j
mov	[bp+var_8], 0
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27231:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ch
jge	short loc_27280	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2723F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_27245:		; Compare Two Operands
cmp	[byte ptr es:bx+24h], 0
jnz	short loc_27280	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27259:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ah
jnz	short loc_2727B	; Jump if Not Zero (ZF=0)

loc_27260:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2726D:		; Compare Two Operands
cmp	[word ptr es:bx+12h], 0
jz	short loc_27279	; Jump if Zero (ZF=1)
mov	[bp+var_8], 1

loc_27279:		; CODE XREF: sub_26B67+70Bj
jmp	short loc_27280	; Jump

loc_2727B:		; CODE XREF: sub_26B67+6F7j
mov	[bp+var_8], 1

loc_27280:		; CODE XREF: sub_26B67+6CFj
			; sub_26B67+6E3j
			; sub_26B67:loc_27279j
cmp	[bp+var_8], 0	; Compare Two Operands
jnz	short loc_27289	; Jump if Not Zero (ZF=0)
jmp	loc_2743D	; Jump

loc_27289:		; CODE XREF: sub_26B67+71Dj
cmp	[bp+arg_0], 0	; Compare Two Operands
jge	short loc_272D0	; Jump if Greater or Equal (SF=OF)

loc_2728F:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
sub	ax, [es:bx]	; Integer Subtraction
pop	dx
sub	ax, dx		; Integer Subtraction
jmp	short loc_2730F	; Jump

loc_272D0:		; CODE XREF: sub_26B67+726j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+arg_6]	; Integer Subtraction

loc_2730F:		; CODE XREF: sub_26B67+767j
mov	di, ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2732A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'

loc_27340:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_27349:		; Add
add	ax, [es:bx+2]
sub	ax, [bp+arg_8]	; Integer Subtraction
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27360:
mov	ax, [es:bx+2]
cmp	ax, [bp+arg_8]	; Compare Two Operands
jg	short loc_27390	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]

loc_2737A:		; Compare Two Operands
cmp	ax, [bp+arg_8]
jl	short loc_27390	; Jump if Less (SF!=OF)
db 83h,7Eh,0FEh,0FAh ; <BAD>cmp	    [bp+var_2],	0FFFAh ; Compare Two Operands
jl	short loc_2738B	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 6	; Compare Two Operands
jle	short loc_27390	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_2738B:		; CODE XREF: sub_26B67+81Cj
mov	[bp+var_2], 6

loc_27390:		; CODE XREF: sub_26B67+800j
			; sub_26B67+816j
			; sub_26B67+822j
cmp	[bp+var_2], 0	; Compare Two Operands
jge	short loc_2739E	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_2]
neg	ax		; Two's Complement Negation
mov	[bp+var_2], ax

loc_2739E:		; CODE XREF: sub_26B67+82Dj
or	di, di		; Logical Inclusive OR
jge	short loc_273A7	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_2], 1F4h

loc_273A7:		; CODE XREF: sub_26B67+839j
or	di, di		; Logical Inclusive OR
jnz	short loc_273AE	; Jump if Not Zero (ZF=0)
mov	di, 1

loc_273AE:		; CODE XREF: sub_26B67+842j
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR
mov	ax, 64h	; 'd'
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_A], dx
mov	[bp+var_C], ax
cmp	[bp+var_A], 0	; Compare Two Operands
jl	short loc_2743D	; Jump if Less (SF!=OF)
jnz	short loc_273E0	; Jump if Not Zero (ZF=0)

loc_273DA:		; Compare Two Operands
cmp	[bp+var_C], 0

loc_273DE:		; Jump if Below	(CF=1)
jb	short loc_2743D

loc_273E0:		; CODE XREF: sub_26B67+871j
cmp	[bp+var_A], 0	; Compare Two Operands
jg	short loc_2743D	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_273EE	; Jump if Less (SF!=OF)
cmp	[bp+var_C], 2Ch	; ',' ; Compare Two Operands
jnb	short loc_2743D	; Jump if Not Below (CF=0)

loc_273EE:		; CODE XREF: sub_26B67+87Fj
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, di
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	ax

loc_273FE:
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
push	ax

loc_27404:
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)

loc_27409:
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
pop	bx

loc_27411:
pop	cx
add	cx, ax		; Add

loc_27414:		; Add with Carry
adc	bx, dx
mov	[bp+var_12], bx
mov	[bp+var_14], cx
mov	ax, [bp+var_12]

loc_2741F:
mov	dx, [bp+var_14]
cmp	ax, [bp+var_E]	; Compare Two Operands
jg	short loc_2743D	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_2742E	; Jump if Less (SF!=OF)
cmp	dx, [bp+var_10]	; Compare Two Operands

loc_2742C:		; Jump if Not Below (CF=0)
jnb	short loc_2743D

loc_2742E:		; CODE XREF: sub_26B67+8C0j
mov	ax, [bp+var_12]
mov	dx, [bp+var_14]
mov	[bp+var_E], ax
mov	[bp+var_10], dx
mov	[bp+var_4], si

loc_2743D:		; CODE XREF: sub_26B67+71Fj
			; sub_26B67+86Fj
			; sub_26B67:loc_273DEj
			; sub_26B67+87Dj
			; sub_26B67+885j
			; sub_26B67+8BEj
			; sub_26B67:loc_2742Cj
inc	si		; Increment by 1

loc_2743E:		; CODE XREF: sub_26B67+69Ej
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands

loc_27442:		; Jump if Greater or Equal (SF=OF)
jge	short loc_27447

loc_27444:		; Jump
jmp	loc_27208

loc_27447:		; CODE XREF: sub_26B67:loc_27028j
			; sub_26B67+4CAj
			; sub_26B67+698j
			; sub_26B67+6AEj
			; sub_26B67:loc_27442j
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_27450	; Jump if Not Zero (ZF=0)

loc_2744D:		; Jump
jmp	loc_276A8

loc_27450:		; CODE XREF: sub_26B67+8E4j
cmp	[bp+arg_2], 0	; Compare Two Operands
jl	short loc_27459	; Jump if Less (SF!=OF)

loc_27456:		; Jump
jmp	loc_276A8

loc_27459:		; CODE XREF: sub_26B67+8EDj
mov	si, 1
jmp	loc_2769F	; Jump

loc_2745F:		; CODE XREF: sub_26B67+B3Ej
cmp	si, [bp+arg_4]	; Compare Two Operands

loc_27462:		; Jump if Not Zero (ZF=0)
jnz	short loc_27476

loc_27464:
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1

loc_27468:		; Compare Two Operands
cmp	ax, si

loc_2746A:		; Jump if Not Zero (ZF=0)
jnz	short loc_27471
jmp	loc_276A8	; Jump
jmp	short loc_27476	; Jump

loc_27471:		; CODE XREF: sub_26B67:loc_2746Aj
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax

loc_27476:		; CODE XREF: sub_26B67:loc_27462j
			; sub_26B67+908j
mov	[bp+var_8], 0
mov	ax, si
mov	dx, 26h	; '&'

loc_27480:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands
jge	short loc_274D7	; Jump if Greater or Equal (SF=OF)

loc_2748F:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 0	; Compare Two Operands
jnz	short loc_274D7	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_274AE:		; Add
add	bx, ax

loc_274B0:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ah
jnz	short loc_274D2	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_274B9:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_274D0	; Jump if Zero (ZF=1)
mov	[bp+var_8], 1

loc_274D0:		; CODE XREF: sub_26B67+962j
jmp	short loc_274D7	; Jump

loc_274D2:		; CODE XREF: sub_26B67+94Ej
mov	[bp+var_8], 1

loc_274D7:		; CODE XREF: sub_26B67+926j
			; sub_26B67+93Aj
			; sub_26B67:loc_274D0j
cmp	[bp+var_8], 0	; Compare Two Operands
jnz	short loc_274E0	; Jump if Not Zero (ZF=0)
jmp	loc_2769E	; Jump

loc_274E0:		; CODE XREF: sub_26B67+974j
cmp	[bp+arg_0], 0	; Compare Two Operands
jle	short loc_27527	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+arg_6]	; Integer Subtraction
jmp	short loc_27566	; Jump

loc_27527:		; CODE XREF: sub_26B67+97Dj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2752E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_27540:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction

loc_2754D:		; Shift	Arithmetic Right
sar	ax, 1
push	ax
mov	ax, si

loc_27552:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2755D:
mov	ax, [bp+arg_6]

loc_27560:		; Integer Subtraction
sub	ax, [es:bx]
pop	dx
sub	ax, dx		; Integer Subtraction

loc_27566:		; CODE XREF: sub_26B67+9BEj
mov	di, ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'

loc_2757F:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+arg_8]
sub	dx, ax		; Integer Subtraction
mov	ax, si
mov	bx, 26h	; '&'
push	dx
imul	bx		; Signed Multiply

loc_2759E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_275A4:
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction

loc_275A9:
mov	[bp+var_2], ax

loc_275AC:		; Logical Inclusive OR
or	di, di
jl	short loc_275B6	; Jump if Less (SF!=OF)

loc_275B0:		; Compare Two Operands
cmp	[bp+var_2], 0
jge	short loc_275C3	; Jump if Greater or Equal (SF=OF)

loc_275B6:		; CODE XREF: sub_26B67+A47j
mov	[bp+var_A], 0
mov	[bp+var_C], 1F4h
jmp	loc_2769E	; Jump

loc_275C3:		; CODE XREF: sub_26B67+A4Dj
cmp	di, [bp+var_2]	; Compare Two Operands
jl	short loc_275F2	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 0	; Compare Two Operands
jz	short loc_275F2	; Jump if Zero (ZF=1)
mov	ax, di

loc_275D0:		; AX ->	DX:AX (with sign)
cwd
push	dx
push	ax
mov	ax, [bp+var_2]

loc_275D6:		; AX ->	DX:AX (with sign)
cwd
push	ax

loc_275D8:
push	dx

loc_275D9:		; Logical Exclusive OR
xor	dx, dx
mov	ax, 64h	; 'd'
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_A], dx
mov	[bp+var_C], ax

loc_275F2:		; CODE XREF: sub_26B67+A5Fj
			; sub_26B67+A65j
cmp	[bp+var_2], di	; Compare Two Operands

loc_275F5:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_2761F
or	di, di		; Logical Inclusive OR

loc_275F9:		; Jump if Zero (ZF=1)
jz	short loc_2761F
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, di

loc_27603:		; AX ->	DX:AX (with sign)
cwd
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR
mov	ax, 64h	; 'd'
pop	cx
pop	bx

loc_2760D:		; Call Procedure
call	LXMUL@

loc_27612:
push	dx
push	ax

loc_27614:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E

loc_27619:
mov	[bp+var_A], dx

loc_2761C:
mov	[bp+var_C], ax

loc_2761F:		; CODE XREF: sub_26B67:loc_275F5j
			; sub_26B67:loc_275F9j
or	di, di		; Logical Inclusive OR
jz	short loc_27629	; Jump if Zero (ZF=1)
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_27633	; Jump if Not Zero (ZF=0)

loc_27629:		; CODE XREF: sub_26B67+ABAj
mov	[bp+var_A], 0
mov	[bp+var_C], 1F4h

loc_27633:		; CODE XREF: sub_26B67+AC0j
cmp	[bp+var_A], 0	; Compare Two Operands
jl	short loc_2769E	; Jump if Less (SF!=OF)
jnz	short loc_27641	; Jump if Not Zero (ZF=0)

loc_2763B:		; Compare Two Operands
cmp	[bp+var_C], 22h	; '"'
jb	short loc_2769E	; Jump if Below	(CF=1)

loc_27641:		; CODE XREF: sub_26B67+AD2j
cmp	[bp+var_A], 0	; Compare Two Operands

loc_27645:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_2769E
jnz	short loc_2764F	; Jump if Not Zero (ZF=0)
cmp	[bp+var_C], 69h	; 'i' ; Compare Two Operands
ja	short loc_2769E	; Jump if Above	(CF=0 &	ZF=0)

loc_2764F:		; CODE XREF: sub_26B67+AE0j
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, di
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	ax

loc_2765F:
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
push	ax

loc_27665:
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx

loc_2766C:		; Call Procedure
call	LXMUL@
pop	bx

loc_27672:
pop	cx
add	cx, ax		; Add
adc	bx, dx		; Add with Carry
mov	[bp+var_12], bx
mov	[bp+var_14], cx
mov	ax, [bp+var_12]
mov	dx, [bp+var_14]

loc_27683:		; Compare Two Operands
cmp	ax, [bp+var_E]
jg	short loc_2769E	; Jump if Greater (ZF=0	& SF=OF)

loc_27688:		; Jump if Less (SF!=OF)
jl	short loc_2768F
cmp	dx, [bp+var_10]	; Compare Two Operands

loc_2768D:		; Jump if Not Below (CF=0)
jnb	short loc_2769E

loc_2768F:		; CODE XREF: sub_26B67:loc_27688j
mov	ax, [bp+var_12]
mov	dx, [bp+var_14]
mov	[bp+var_E], ax

loc_27698:
mov	[bp+var_10], dx
mov	[bp+var_4], si

loc_2769E:		; CODE XREF: sub_26B67+976j
			; sub_26B67+A59j
			; sub_26B67+AD0j
			; sub_26B67+AD8j
			; sub_26B67:loc_27645j
			; sub_26B67+AE6j
			; sub_26B67+B1Fj
			; sub_26B67:loc_2768Dj
inc	si		; Increment by 1

loc_2769F:		; CODE XREF: sub_26B67+8F5j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jge	short loc_276A8	; Jump if Greater or Equal (SF=OF)
jmp	loc_2745F	; Jump

loc_276A8:		; CODE XREF: sub_26B67:loc_2744Dj
			; sub_26B67:loc_27456j
			; sub_26B67+905j
			; sub_26B67+B3Cj
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_276B1	; Jump if Not Zero (ZF=0)

loc_276AE:		; Jump
jmp	loc_27907

loc_276B1:		; CODE XREF: sub_26B67+B45j
cmp	[bp+arg_2], 0	; Compare Two Operands
jg	short loc_276BA	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_27907	; Jump

loc_276BA:		; CODE XREF: sub_26B67+B4Ej
mov	si, 1
jmp	loc_278FE	; Jump

loc_276C0:		; CODE XREF: sub_26B67+D9Dj
cmp	si, [bp+arg_4]	; Compare Two Operands
jnz	short loc_276D7	; Jump if Not Zero (ZF=0)
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jnz	short loc_276D2	; Jump if Not Zero (ZF=0)
jmp	loc_27907	; Jump
jmp	short loc_276D7	; Jump

loc_276D2:		; CODE XREF: sub_26B67+B64j
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax

loc_276D7:		; CODE XREF: sub_26B67+B5Cj
			; sub_26B67+B69j
mov	[bp+var_8], 0
mov	ax, si

loc_276DE:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_276E9:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ch
jge	short loc_27738	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 0	; Compare Two Operands
jnz	short loc_27738	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2770F:		; Add
add	bx, ax
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jnz	short loc_27733	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27725:		; Compare Two Operands
cmp	[word ptr es:bx+12h], 0
jz	short loc_27731	; Jump if Zero (ZF=1)
mov	[bp+var_8], 1

loc_27731:		; CODE XREF: sub_26B67+BC3j
jmp	short loc_27738	; Jump

loc_27733:		; CODE XREF: sub_26B67+BAFj
mov	[bp+var_8], 1

loc_27738:		; CODE XREF: sub_26B67+B87j
			; sub_26B67+B9Bj
			; sub_26B67:loc_27731j
cmp	[bp+var_8], 0	; Compare Two Operands
jnz	short loc_27741	; Jump if Not Zero (ZF=0)

loc_2773E:		; Jump
jmp	loc_278FD

loc_27741:		; CODE XREF: sub_26B67+BD5j
cmp	[bp+arg_0], 0	; Compare Two Operands
jle	short loc_27788	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si

loc_27749:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2774E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_27752:		; Add
add	bx, ax
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right

loc_2776F:
push	ax
mov	ax, si
mov	dx, 26h	; '&'

loc_27775:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+arg_6]	; Integer Subtraction
jmp	short loc_277C7	; Jump

loc_27788:		; CODE XREF: sub_26B67+BDEj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2778F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si

loc_2779C:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction

loc_277AE:		; Shift	Arithmetic Right
sar	ax, 1

loc_277B0:
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
sub	ax, [es:bx]	; Integer Subtraction
pop	dx
sub	ax, dx		; Integer Subtraction

loc_277C7:		; CODE XREF: sub_26B67+C1Fj
mov	di, ax
mov	ax, si

loc_277CB:
mov	dx, 26h	; '&'

loc_277CE:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax

loc_277DB:
mov	ax, si
mov	dx, 26h	; '&'

loc_277E0:		; Signed Multiply
imul	dx

loc_277E2:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)

loc_277EE:		; Integer Subtraction
sub	ax, dx
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	ax, [es:bx+2]	; Add
sub	ax, [bp+arg_8]	; Integer Subtraction
mov	[bp+var_2], ax
or	di, di		; Logical Inclusive OR
jl	short loc_27815	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 0	; Compare Two Operands
jge	short loc_27822	; Jump if Greater or Equal (SF=OF)

loc_27815:		; CODE XREF: sub_26B67+CA6j
mov	[bp+var_A], 0

loc_2781A:
mov	[bp+var_C], 1F4h

loc_2781F:		; Jump
jmp	loc_278FD

loc_27822:		; CODE XREF: sub_26B67+CACj
cmp	di, [bp+var_2]	; Compare Two Operands

loc_27825:		; Jump if Less (SF!=OF)
jl	short loc_27851
cmp	[bp+var_2], 0	; Compare Two Operands
jz	short loc_27851	; Jump if Zero (ZF=1)
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR
mov	ax, 64h	; 'd'
pop	cx
pop	bx
call	LXMUL@		; Call Procedure

loc_27844:
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_A], dx
mov	[bp+var_C], ax

loc_27851:		; CODE XREF: sub_26B67:loc_27825j
			; sub_26B67+CC4j
cmp	[bp+var_2], di	; Compare Two Operands
jle	short loc_2787E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
or	di, di		; Logical Inclusive OR

loc_27858:		; Jump if Zero (ZF=1)
jz	short loc_2787E

loc_2785A:
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR

loc_27867:
mov	ax, 64h	; 'd'
pop	cx
pop	bx

loc_2786C:		; Call Procedure
call	LXMUL@
push	dx
push	ax

loc_27873:		;   xor	    cx,	cx
call	LDIV@		;   jmp	    short loc_1064E
mov	[bp+var_A], dx

loc_2787B:
mov	[bp+var_C], ax

loc_2787E:		; CODE XREF: sub_26B67+CEDj
			; sub_26B67:loc_27858j
or	di, di		; Logical Inclusive OR
jz	short loc_27888	; Jump if Zero (ZF=1)
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_27892	; Jump if Not Zero (ZF=0)

loc_27888:		; CODE XREF: sub_26B67+D19j
mov	[bp+var_A], 0

loc_2788D:
mov	[bp+var_C], 1F4h

loc_27892:		; CODE XREF: sub_26B67+D1Fj
cmp	[bp+var_A], 0	; Compare Two Operands

loc_27896:		; Jump if Less (SF!=OF)
jl	short loc_278FD
jnz	short loc_278A0	; Jump if Not Zero (ZF=0)
cmp	[bp+var_C], 22h	; '"' ; Compare Two Operands
jb	short loc_278FD	; Jump if Below	(CF=1)

loc_278A0:		; CODE XREF: sub_26B67+D31j
cmp	[bp+var_A], 0	; Compare Two Operands
jg	short loc_278FD	; Jump if Greater (ZF=0	& SF=OF)
jnz	short loc_278AE	; Jump if Not Zero (ZF=0)
cmp	[bp+var_C], 69h	; 'i' ; Compare Two Operands

loc_278AC:		; Jump if Above	(CF=0 &	ZF=0)
ja	short loc_278FD

loc_278AE:		; CODE XREF: sub_26B67+D3Fj
mov	ax, di

loc_278B0:		; AX ->	DX:AX (with sign)
cwd
push	ax
mov	ax, di
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx

loc_278B7:
pop	bx

loc_278B8:		; Call Procedure
call	LXMUL@
push	ax
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
push	ax

loc_278C4:
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
pop	bx
pop	cx
add	cx, ax		; Add
adc	bx, dx		; Add with Carry
mov	[bp+var_12], bx
mov	[bp+var_14], cx

loc_278DC:
mov	ax, [bp+var_12]
mov	dx, [bp+var_14]
cmp	ax, [bp+var_E]	; Compare Two Operands
jg	short loc_278FD	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_278EE	; Jump if Less (SF!=OF)
cmp	dx, [bp+var_10]	; Compare Two Operands
jnb	short loc_278FD	; Jump if Not Below (CF=0)

loc_278EE:		; CODE XREF: sub_26B67+D80j
mov	ax, [bp+var_12]
mov	dx, [bp+var_14]
mov	[bp+var_E], ax
mov	[bp+var_10], dx

loc_278FA:
mov	[bp+var_4], si

loc_278FD:		; CODE XREF: sub_26B67:loc_2773Ej
			; sub_26B67:loc_2781Fj
			; sub_26B67:loc_27896j
			; sub_26B67+D37j
			; sub_26B67+D3Dj
			; sub_26B67:loc_278ACj
			; sub_26B67+D7Ej
			; sub_26B67+D85j
inc	si		; Increment by 1

loc_278FE:		; CODE XREF: sub_26B67+B56j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jge	short loc_27907	; Jump if Greater or Equal (SF=OF)
jmp	loc_276C0	; Jump

loc_27907:		; CODE XREF: sub_26B67:loc_276AEj
			; sub_26B67+B50j
			; sub_26B67+B66j
			; sub_26B67+D9Bj
mov	ax, [bp+var_4]

loc_2790A:		; Jump
jmp	loc_26C02

loc_2790D:		; CODE XREF: sub_26B67:loc_26C02j
pop	di
pop	si

loc_2790F:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_26B67



; Attributes: bp-based frame

proc sub_27913 far	; CODE XREF: _f010509_MainMenuScreen+3AEP

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_27928	; Jump if Zero (ZF=1)
jmp	loc_27A25	; Jump

loc_27928:		; CODE XREF: sub_27913+10j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'

loc_2793F:		; Signed Multiply
imul	dx

loc_27941:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2795C:		; Add
add	bx, ax
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
mov	di, ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27973:
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2797F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax

loc_27986:		; Integer Subtraction
sub	ax, [es:bx+2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax

loc_27990:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add

loc_279A4:
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jl	short loc_27A25	; Jump if Less (SF!=OF)

loc_279AD:		; Compare Two Operands
cmp	[bp+var_2], 0C8h ; ''
jge	short loc_27A25	; Jump if Greater or Equal (SF=OF)
or	di, di		; Logical Inclusive OR
jl	short loc_27A25	; Jump if Less (SF!=OF)

loc_279B8:		; Compare Two Operands
cmp	di, 140h
jge	short loc_27A25	; Jump if Greater or Equal (SF=OF)
mov	[idk_MousePosX_w3C5A2],	di
mov	ax, [bp+var_2]
mov	[idk_MousePosX_w3C5A0],	ax
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]

loc_279D0:		; Call Procedure
call	idk_Mouse_s23F82
pop	cx

loc_279D6:
pop	cx
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax
mov	ax, [idk_MousePosX_w3C5A2]
sub	ax, [idk_Mouse_w3C5A4] ; Integer Subtraction
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, [idk_MousePosX_w3C5A0]
sub	ax, [idk_Mouse_w3C5A4] ; Integer Subtraction
mov	[idk_MousePosX_w3C5A0],	ax
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]

loc_279FB:		; Call Procedure
call	CALL_PositionMouseCursor
pop	cx
pop	cx
call	idk_ChkMousDoEga ; Call	Procedure
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24648	; Call Procedure
pop	cx
pop	cx
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24A74	; Call Procedure
pop	cx
pop	cx

loc_27A25:		; CODE XREF: sub_27913+12j
			; sub_27913+98j
			; sub_27913+9Fj
			; sub_27913+A3j
			; sub_27913+A9j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_27913



; Attributes: bp-based frame

proc sub_27A2B far	; CODE XREF: sub_24DAE:loc_250BBp
			; sub_24DAE+5DFp
			; sub_24DAE:loc_2591Ap
			; sub_26026+53p
			; sub_26026+2A9p
			; sub_26026+526p
			; sub_27AFB+2Fp

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
call	get__Mouse_w360A4 ; Call Procedure
mov	di, ax
call	get__Mouse_w360A6 ; Call Procedure
mov	[bp+var_2], ax
mov	[bp+var_4], 0
push	[bp+var_2]
push	di
call	idk_Mouse_s23F82 ; Call	Procedure
pop	cx
pop	cx
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax
mov	si, 1
jmp	loc_27AE7	; Jump

loc_27A60:		; CODE XREF: sub_27A2B+C2j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
mov	[bp+var_6], ax
mov	ax, si
mov	dx, 26h	; '&'

loc_27A78:		; Signed Multiply
imul	dx

loc_27A7A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_27A80:
mov	ax, [es:bx+2]
mov	[bp+var_8], ax

loc_27A87:
mov	ax, si

loc_27A89:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_27A8E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+4]

loc_27A98:
mov	[bp+var_A], ax
mov	ax, si

loc_27A9D:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_27AA6:		; Add
add	bx, ax
mov	ax, [es:bx+6]
mov	[bp+var_C], ax

loc_27AAF:
mov	ax, di
add	ax, [idk_Mouse_w3C5A4] ; Add
cmp	ax, [bp+var_6]	; Compare Two Operands
jl	short loc_27AE2	; Jump if Less (SF!=OF)

loc_27ABA:
mov	ax, di
add	ax, [idk_Mouse_w3C5A4] ; Add
cmp	ax, [bp+var_A]	; Compare Two Operands
jg	short loc_27AE2	; Jump if Greater (ZF=0	& SF=OF)

loc_27AC5:
mov	ax, [bp+var_2]
add	ax, [idk_Mouse_w3C5A4] ; Add
cmp	ax, [bp+var_8]	; Compare Two Operands

loc_27ACF:		; Jump if Less (SF!=OF)
jl	short loc_27AE2
mov	ax, [bp+var_2]
add	ax, [idk_Mouse_w3C5A4] ; Add
cmp	ax, [bp+var_C]	; Compare Two Operands
jg	short loc_27AE2	; Jump if Greater (ZF=0	& SF=OF)
mov	[bp+var_4], si
jmp	short loc_27AF0	; Jump

loc_27AE2:		; CODE XREF: sub_27A2B+8Dj
			; sub_27A2B+98j
			; sub_27A2B:loc_27ACFj
			; sub_27A2B+B0j
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax

loc_27AE7:		; CODE XREF: sub_27A2B+32j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jge	short loc_27AF0	; Jump if Greater or Equal (SF=OF)
jmp	loc_27A60	; Jump

loc_27AF0:		; CODE XREF: sub_27A2B+B5j
			; sub_27A2B+C0j
mov	ax, [bp+var_4]
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_27A2B



; Attributes: bp-based frame

proc sub_27AFB far	; CODE XREF: _f010609_DrawMainMenuScreen+EP
			; sub_2A755+674p
			; sub_2B1F9+1F1p
			; sub_2B470+9p
			; sub_3EDD1+39P
			; sub_3EDD1+42P
			; sub_40037:loc_40193P
			; sub_4E031+5P

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
call	get__Mouse_w360A4 ; Call Procedure
mov	[bp+var_2], ax
call	get__Mouse_w360A6 ; Call Procedure
mov	[bp+var_4], ax
xor	si, si		; Logical Exclusive OR
push	[bp+var_4]
push	[bp+var_2]
call	idk_Mouse_s23F82 ; Call	Procedure
pop	cx
pop	cx
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax
push	cs
call	near ptr sub_27A2B ; Call Procedure
mov	si, ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27B3C:		; Compare Two Operands
cmp	[word ptr es:bx+8], 9
jnz	short loc_27B80	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
pop	ax
mov	[bx], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]

loc_27B7A:		; CODE XREF: sub_27AFB+AFj
			; sub_27AFB+16Aj
jmp	loc_27C68	; Jump
jmp	loc_27C68	; Jump

loc_27B80:		; CODE XREF: sub_27AFB+46j
mov	ax, si

loc_27B82:
mov	dx, 26h	; '&'

loc_27B85:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27B8D:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ah
jnz	short loc_27BAC	; Jump if Not Zero (ZF=0)

loc_27B94:
mov	ax, si
mov	dx, 26h	; '&'

loc_27B99:		; Signed Multiply
imul	dx

loc_27B9B:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_27B9F:		; Add
add	bx, ax

loc_27BA1:		; Compare Two Operands
cmp	[word ptr es:bx+12h], 0
jnz	short loc_27BAC	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_27B7A	; Jump

loc_27BAC:		; CODE XREF: sub_27AFB+97j
			; sub_27AFB+ABj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands
jz	short loc_27BC3	; Jump if Zero (ZF=1)

loc_27BC0:		; Jump
jmp	loc_27C63

loc_27BC3:		; CODE XREF: sub_27AFB+C3j
db 83h,3Eh,22h,4Dh,0FFh	; <BAD>cmp     [w36A32], 0FFFFh	; Compare Two Operands
jz	short loc_27BE2	; Jump if Zero (ZF=1)

loc_27BCA:
mov	ax, [w36A32]

loc_27BCD:
mov	dx, 26h	; '&'

loc_27BD0:		; Signed Multiply
imul	dx

loc_27BD2:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands
jnz	short loc_27BE2	; Jump if Not Zero (ZF=0)

loc_27BDF:		; Jump
jmp	loc_27C63

loc_27BE2:		; CODE XREF: sub_27AFB+CDj
			; sub_27AFB+E2j
call	get__Mouse_w360A4 ; Call Procedure
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_27BF3:		; Add
add	bx, ax
pop	ax

loc_27BF6:		; Integer Subtraction
sub	ax, [es:bx]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cwd			; AX ->	DX:AX (with sign)
idiv	[word ptr es:bx+18h] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ch]
pop	ax
mov	[bx], ax
call	get__Mouse_w360A6 ; Call Procedure
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_27C2F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cwd			; AX ->	DX:AX (with sign)

loc_27C4A:		; Signed Divide
idiv	[word ptr es:bx+1Ah]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Eh]
pop	ax
mov	[bx], ax

loc_27C63:		; CODE XREF: sub_27AFB:loc_27BC0j
			; sub_27AFB:loc_27BDFj
mov	ax, si
jmp	loc_27B7A	; Jump

loc_27C68:		; CODE XREF: sub_27AFB:loc_27B7Aj
			; sub_27AFB+82j
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_27AFB

push	bp
mov	bp, sp
jmp	short $+2	; Jump
; [00000012 BYTES: COLLAPSED FUNCTION o_1_a_87_s_0_tpsig2_84. PRESS KEYPAD "+" TO EXPAND]


; Attributes: bp-based frame

proc sub_27C84 far	; CODE XREF: sub_27CC0+9p
push	bp
mov	bp, sp
mov	[word_36A4A], 0
jmp	short loc_27C94	; Jump

loc_27C8F:		; CODE XREF: sub_27C84+17j
call	ST_GetKeyboardCode ; Call Procedure

loc_27C94:		; CODE XREF: sub_27C84+9j
call	_f331647_TestKeyPress ;	Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_27C8F	; Jump if Not Zero (ZF=0)
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_27CBE	; Jump if Zero (ZF=1)
jmp	short loc_27CAB	; Jump

gotMouseClick:		; CODE XREF: sub_27C84+2Ej
nop			; No Operation
push	cs

loc_27CA8:		; Call Procedure
call	near ptr sub_2E2B7

loc_27CAB:		; CODE XREF: sub_27C84+20j
call	_f330547_GetMouseButtonsStatus ; Call Procedure

loc_27CB0:		; Logical Inclusive OR
or	ax, ax
jnz	short gotMouseClick ; Jump Not Zero / Jump Equal
call	get_w360AC_set0	; Call Procedure
call	_f332647_Get_w360B4_Set0 ; Call	Procedure

loc_27CBE:		; CODE XREF: sub_27C84+1Ej
pop	bp
retf			; Return Far from Procedure
endp sub_27C84



; Attributes: bp-based frame

proc sub_27CC0 far	; CODE XREF: sub_4D8FA+EAP
			; sub_4E9F4:loc_4EBCBP
			; sub_4EF74:loc_4F15FP
			; idk_OVR_LoadLbxHelp+500P

var_1= byte ptr	-1

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction

loc_27CC6:
push	si
push	di
push	cs
call	near ptr sub_27C84 ; Call Procedure
xor	si, si		; Logical Exclusive OR
xor	di, di		; Logical Exclusive OR
mov	ax, [idk_Mouse_w3C5A8]
mov	[word_3C5A6], ax
mov	[idk_Mouse_w3C5A8], 1
jmp	loc_27E0B	; Jump

loc_27CDF:		; CODE XREF: sub_27CC0+14Fj
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jnz	short loc_27CE9	; Jump if Not Zero (ZF=0)
jmp	loc_27D87	; Jump

loc_27CE9:		; CODE XREF: sub_27CC0+24j
call	MOUSE_ExchangeInterrupt	; Call Procedure
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_27D00	; Jump if Not Zero (ZF=0)
call	get_w360AC_set0	; Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_27D06	; Jump if Zero (ZF=1)

loc_27D00:		; CODE XREF: sub_27CC0+35j
mov	di, 1
mov	si, 1

loc_27D06:		; CODE XREF: sub_27CC0+3Ej
call	_f331647_TestKeyPress ;	Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_27D85	; Jump if Zero (ZF=1)
call	ST_GetKeyboardCode ; Call Procedure
mov	[bp+var_1], al
mov	al, [bp+var_1]
cbw			; AL ->	AX (with sign)
cmp	ax, 0FF91h	; Compare Two Operands
jz	short loc_27D27	; Jump if Zero (ZF=1)
cmp	ax, 0FF92h	; Compare Two Operands
jz	short loc_27D2E	; Jump if Zero (ZF=1)
jmp	short loc_27D7D	; Jump

loc_27D27:		; CODE XREF: sub_27CC0+5Ej
call	IfDebugExitWithMemDiag ; Call Procedure
jmp	short loc_27D85	; Jump

loc_27D2E:		; CODE XREF: sub_27CC0+63j
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
call	idk_ChkMousDoEga ; Call	Procedure
call	ST_ScreenDump	; Call Procedure
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24648	; Call Procedure
pop	cx
pop	cx
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24A74	; Call Procedure
pop	cx
pop	cx
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
jmp	short loc_27D85	; Jump

loc_27D7D:		; CODE XREF: sub_27CC0+65j
call	get_w360AC_set0	; Call Procedure
mov	si, 1

loc_27D85:		; CODE XREF: sub_27CC0+4Dj
			; sub_27CC0+6Cj
			; sub_27CC0+BBj
jmp	short loc_27E01	; Jump

loc_27D87:		; CODE XREF: sub_27CC0+26j
call	_f331647_TestKeyPress ;	Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_27E01	; Jump if Zero (ZF=1)
call	ST_GetKeyboardCode ; Call Procedure
mov	[bp+var_1], al
mov	al, [bp+var_1]
cbw			; AL ->	AX (with sign)
cmp	ax, 0FF91h	; Compare Two Operands
jz	short loc_27DA8	; Jump if Zero (ZF=1)
cmp	ax, 0FF92h	; Compare Two Operands
jz	short loc_27DAF	; Jump if Zero (ZF=1)
jmp	short loc_27DFE	; Jump

loc_27DA8:		; CODE XREF: sub_27CC0+DFj
call	IfDebugExitWithMemDiag ; Call Procedure

loc_27DAD:		; Jump
jmp	short loc_27E01

loc_27DAF:		; CODE XREF: sub_27CC0+E4j
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
call	idk_ChkMousDoEga ; Call	Procedure
call	ST_ScreenDump	; Call Procedure
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24648	; Call Procedure
pop	cx
pop	cx
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	sub_24A74	; Call Procedure
pop	cx
pop	cx
call	get__Mouse_w360A6 ; Call Procedure
push	ax
call	get__Mouse_w360A4 ; Call Procedure
push	ax
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
jmp	short loc_27E01	; Jump

loc_27DFE:		; CODE XREF: sub_27CC0+E6j
mov	si, 1

loc_27E01:		; CODE XREF: sub_27CC0:loc_27D85j
			; sub_27CC0+CEj
			; sub_27CC0:loc_27DADj
			; sub_27CC0+13Cj
call	hrmMsExchIntSub	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_2E2B7 ; Call Procedure

loc_27E0B:		; CODE XREF: sub_27CC0+1Cj
or	si, si		; Logical Inclusive OR
jnz	short loc_27E12	; Jump if Not Zero (ZF=0)
jmp	loc_27CDF	; Jump

loc_27E12:		; CODE XREF: sub_27CC0+14Dj
or	di, di		; Logical Inclusive OR
jz	short loc_27E2B	; Jump if Zero (ZF=1)
call	MOUSE_ExchangeInterrupt	; Call Procedure
jmp	short loc_27E22	; Jump

loc_27E1D:		; CODE XREF: sub_27CC0+169j
nop			; No Operation
push	cs
call	near ptr sub_2E2B7 ; Call Procedure

loc_27E22:		; CODE XREF: sub_27CC0+15Bj
call	_f330547_GetMouseButtonsStatus ; Call Procedure

loc_27E27:		; Logical Inclusive OR
or	ax, ax
jnz	short loc_27E1D	; Jump if Not Zero (ZF=0)

loc_27E2B:		; CODE XREF: sub_27CC0+154j
mov	ax, [word_3C5A6]
mov	[idk_Mouse_w3C5A8], ax
call	hrmMsExchIntSub	; Call Procedure
call	get_w360AC_set0	; Call Procedure
call	_f332647_Get_w360B4_Set0 ; Call	Procedure

loc_27E40:
mov	ax, 0FFFFh
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_27CC0



; Attributes: bp-based frame

proc sub_27E4B far	; CODE XREF: rschKBD_s2669B+3DCp

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= byte ptr	 6

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
mov	al, [bp+arg_0]
cbw			; AL ->	AX (with sign)
sub	ax, 68		; Integer Subtraction
mov	bx, ax

loc_27E5C:		; switch 23 cases
cmp	bx, 22
ja	short loc_27EAF	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_28113+bx] ; switch jump

loc_27E68:		; DATA XREF: seg034:off_28113o
mov	[bp+var_8], -1	; case 0x8

loc_27E6D:		; CODE XREF: sub_27E4B+2Ej
			; sub_27E4B+69j
mov	[bp+var_A], 0
jmp	short loc_27EB6	; Jump

loc_27E74:		; CODE XREF: sub_27E4B+18j
			; DATA XREF: seg034:off_28113o
mov	[bp+var_8], 1	; case 0xE
jmp	short loc_27E6D	; Jump

loc_27E7B:		; CODE XREF: sub_27E4B+18j
			; DATA XREF: seg034:off_28113o
mov	[bp+var_8], 0	; case 0x11
jmp	short loc_27E95	; Jump

loc_27E82:		; CODE XREF: sub_27E4B+18j
			; DATA XREF: seg034:off_28113o
mov	[bp+var_8], 0	; case 0x0
jmp	short loc_27EA8	; Jump

loc_27E89:		; CODE XREF: sub_27E4B+18j
			; DATA XREF: seg034:off_28113o
mov	[bp+var_8], -1	; case 0x13
jmp	short loc_27E95	; Jump

loc_27E90:		; CODE XREF: sub_27E4B+18j
			; DATA XREF: seg034:off_28113o
mov	[bp+var_8], 1	; case 0x14

loc_27E95:		; CODE XREF: sub_27E4B+35j
			; sub_27E4B+43j
mov	[bp+var_A], -1
jmp	short loc_27EB6	; Jump

loc_27E9C:		; CODE XREF: sub_27E4B+18j
			; DATA XREF: seg034:off_28113o
mov	[bp+var_8], -1	; case 0x15
jmp	short loc_27EA8	; Jump

loc_27EA3:		; CODE XREF: sub_27E4B+18j
			; DATA XREF: seg034:off_28113o
mov	[bp+var_8], 1	; case 0x16

loc_27EA8:		; CODE XREF: sub_27E4B+3Cj
			; sub_27E4B+56j
mov	[bp+var_A], 1
jmp	short loc_27EB6	; Jump

loc_27EAF:		; CODE XREF: sub_27E4B+14j
			; sub_27E4B+18j
			; DATA XREF: seg034:off_28113o
mov	[bp+var_8], 0	; default
jmp	short loc_27E6D	; Jump

loc_27EB6:		; CODE XREF: sub_27E4B+27j
			; sub_27E4B+4Fj
			; sub_27E4B+62j
cmp	[word_36A3A], 0	; Compare Two Operands
jz	short loc_27ED5	; Jump if Zero (ZF=1)
cmp	[bp+var_A], 0	; Compare Two Operands
jz	short loc_27ED5	; Jump if Zero (ZF=1)
xor	si, si		; Logical Exclusive OR
push	[bp+var_A]
nop			; No Operation
push	cs

loc_27ECA:		; Call Procedure
call	near ptr sub_2B470
pop	cx

loc_27ECE:
mov	si, ax

loc_27ED0:		; CODE XREF: sub_27E4B:loc_2810Aj
mov	ax, si
jmp	loc_2810D	; Jump

loc_27ED5:		; CODE XREF: sub_27E4B+70j
			; sub_27E4B+76j
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_27EEB	; Jump if Zero (ZF=1)
call	get__Mouse_w360A4 ; Call Procedure
mov	[bp+var_2], ax
call	get__Mouse_w360A6 ; Call Procedure
jmp	short loc_27EF4	; Jump

loc_27EEB:		; CODE XREF: sub_27E4B+8Fj
mov	ax, [idk_MousePosX_w3C5A2]
mov	[bp+var_2], ax
mov	ax, [idk_MousePosX_w3C5A0]

loc_27EF4:		; CODE XREF: sub_27E4B+9Ej
mov	[bp+var_4], ax

loc_27EF7:
mov	[bp+var_6], 0
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
mov	di, ax
jmp	loc_27FB4	; Jump

loc_27F05:		; CODE XREF: sub_27E4B+16Dj
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ch	; Compare Two Operands
jl	short loc_27F1C	; Jump if Less (SF!=OF)
jmp	loc_27FB3	; Jump

loc_27F1C:		; CODE XREF: sub_27E4B+CCj
mov	ax, di

loc_27F1E:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27F29:
mov	ax, [bp+var_4]

loc_27F2C:		; Add
add	ax, [idk_Mouse_w3C5A4]

loc_27F30:		; Compare Two Operands
cmp	[es:bx+2], ax
jg	short loc_27FB3	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_4]
add	ax, [idk_Mouse_w3C5A4] ; Add
cmp	[es:bx+6], ax	; Compare Two Operands
jl	short loc_27FB3	; Jump if Less (SF!=OF)

loc_27F50:
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_27F5B:		; Add
add	bx, ax
mov	ax, [bp+var_2]

loc_27F60:		; Add
add	ax, [idk_Mouse_w3C5A4]

loc_27F64:		; Compare Two Operands
cmp	[es:bx], ax
jg	short loc_27FB3	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, di

loc_27F6B:
mov	dx, 26h	; '&'

loc_27F6E:		; Signed Multiply
imul	dx

loc_27F70:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_27F74:		; Add
add	bx, ax
mov	ax, [bp+var_2]

loc_27F79:		; Add
add	ax, [idk_Mouse_w3C5A4]

loc_27F7D:		; Compare Two Operands
cmp	[es:bx+4], ax
jl	short loc_27FB3	; Jump if Less (SF!=OF)
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands

loc_27F95:		; Jump if Zero (ZF=1)
jz	short loc_27F9C
mov	[bp+var_6], di
jmp	short loc_27FB3	; Jump

loc_27F9C:		; CODE XREF: sub_27E4B:loc_27F95j
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_27FA9:		; Compare Two Operands
cmp	[word ptr es:bx+12h], 0

loc_27FAE:		; Jump if Zero (ZF=1)
jz	short loc_27FB3

loc_27FB0:
mov	[bp+var_6], di

loc_27FB3:		; CODE XREF: sub_27E4B+CEj
			; sub_27E4B+E9j
			; sub_27E4B+103j
			; sub_27E4B+11Cj
			; sub_27E4B+136j
			; sub_27E4B+14Fj
			; sub_27E4B:loc_27FAEj
dec	di		; Decrement by 1

loc_27FB4:		; CODE XREF: sub_27E4B+B7j
or	di, di		; Logical Inclusive OR

loc_27FB6:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_27FBB
jmp	loc_27F05	; Jump

loc_27FBB:		; CODE XREF: sub_27E4B:loc_27FB6j
mov	si, [bp+var_6]

loc_27FBE:		; Compare Two Operands
cmp	[bp+var_8], 0
jnz	short loc_27FCD	; Jump if Not Zero (ZF=0)
cmp	[bp+var_A], 0	; Compare Two Operands
jnz	short loc_27FCD	; Jump if Not Zero (ZF=0)
jmp	loc_2810A	; Jump

loc_27FCD:		; CODE XREF: sub_27E4B+177j
			; sub_27E4B+17Dj
push	[bp+var_4]

loc_27FD0:
push	[bp+var_2]

loc_27FD3:
push	[bp+var_6]
push	[bp+var_A]
push	[bp+var_8]
push	cs
call	near ptr sub_26B67 ; Call Procedure
add	sp, 0Ah		; Add
mov	si, ax
cmp	si, [bp+var_6]	; Compare Two Operands
jnz	short loc_27FED	; Jump if Not Zero (ZF=0)
jmp	loc_2810A	; Jump

loc_27FED:		; CODE XREF: sub_27E4B+19Dj
or	si, si		; Logical Inclusive OR
jnz	short loc_27FF4	; Jump if Not Zero (ZF=0)
jmp	loc_2810A	; Jump

loc_27FF4:		; CODE XREF: sub_27E4B+1A4j
mov	ax, si

loc_27FF6:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_27FFB:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction

loc_2801A:		; Shift	Arithmetic Right
sar	ax, 1
push	ax
mov	ax, si

loc_2801F:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28024:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si

loc_28047:
mov	dx, 26h	; '&'

loc_2804A:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_28053:		; Integer Subtraction
sub	ax, [es:bx+2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2806A:
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
mov	[idk_MousePosX_w3C5A0],	ax
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
cmp	[idk_MousePosX_w3C5A2],	0 ; Compare Two	Operands
jle	short loc_280F6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[idk_MousePosX_w3C5A2],	140h ; Compare Two Operands
jge	short loc_280F6	; Jump if Greater or Equal (SF=OF)

loc_28088:		; Compare Two Operands
cmp	[idk_MousePosX_w3C5A0],	0
jle	short loc_280F6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[idk_MousePosX_w3C5A0],	0C8h ; '' ; Compare Two Operands
jge	short loc_280F6	; Jump if Greater or Equal (SF=OF)
push	[idk_MousePosX_w3C5A0]

loc_2809B:
push	[idk_MousePosX_w3C5A2]
call	idk_Mouse_s23F82 ; Call	Procedure
pop	cx
pop	cx

loc_280A6:		; Call Procedure
call	idk_Get_Mouse_w360AA
mov	[idk_Mouse_w3C5A4], ax

loc_280AE:
mov	ax, [idk_MousePosX_w3C5A2]

loc_280B1:		; Integer Subtraction
sub	ax, [idk_Mouse_w3C5A4]

loc_280B5:
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, [idk_MousePosX_w3C5A0]

loc_280BB:		; Integer Subtraction
sub	ax, [idk_Mouse_w3C5A4]
mov	[idk_MousePosX_w3C5A0],	ax
call	idk_ChkMousDoEga ; Call	Procedure
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]

loc_280CF:		; Call Procedure
call	sub_24648
pop	cx
pop	cx
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24A74	; Call Procedure
pop	cx
pop	cx
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
jmp	short loc_28105	; Jump

loc_280F6:		; CODE XREF: sub_27E4B+233j
			; sub_27E4B+23Bj
			; sub_27E4B+242j
			; sub_27E4B+24Aj
mov	si, [bp+var_6]
mov	ax, [bp+var_2]

loc_280FC:
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, [bp+var_4]
mov	[idk_MousePosX_w3C5A0],	ax

loc_28105:		; CODE XREF: sub_27E4B+2A9j
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE

loc_2810A:		; CODE XREF: sub_27E4B+17Fj
			; sub_27E4B+19Fj
			; sub_27E4B+1A6j
jmp	loc_27ED0	; Jump

loc_2810D:		; CODE XREF: sub_27E4B+87j
pop	di
pop	si

loc_2810F:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_27E4B

off_28113 dw offset loc_27E82
			; DATA XREF: sub_27E4B+18r
dw offset loc_27EAF	; jump table for switch	statement
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27E68
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27E74
dw offset loc_27EAF
dw offset loc_27EAF
dw offset loc_27E7B
dw offset loc_27EAF
dw offset loc_27E89
dw offset loc_27E90
dw offset loc_27E9C
dw offset loc_27EA3


; Attributes: bp-based frame

; int __fastcall __far sub_28141(int, int, int,	int)
proc sub_28141 far	; CODE XREF: sub_2CF44+109Ep

var_50=	byte ptr -50h
var_4F=	byte ptr -4Fh
argDest= byte ptr -4Eh
var_F= byte ptr	-0Fh
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 4Eh		; Integer Subtraction
push	si
push	di		; argSrc
mov	[bp+var_E], 4
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_28165	; Jump if Zero (ZF=1)
jmp	short loc_2815C	; Jump

loc_28157:		; CODE XREF: sub_28141+22j
nop			; No Operation
push	cs
call	near ptr sub_2E26D ; Call Procedure

loc_2815C:		; CODE XREF: sub_28141+14j
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_28157	; Jump if Not Zero (ZF=0)

loc_28165:		; CODE XREF: sub_28141+12j
mov	[word_36A64], 0
mov	[word_36A66], 0
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+20h]
mov	[bp+var_4], ax
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
mov	[bp+var_8], ax
mov	[bp+var_6], 0
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
xor	si, si		; Logical Exclusive OR
mov	[bp+var_F], 0
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h] ; int
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2820A:
push	[word ptr es:bx+16h]
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
jmp	short loc_2821C	; Jump

loc_2821B:		; CODE XREF: sub_28141:loc_28220j
inc	si		; Increment by 1

loc_2821C:		; CODE XREF: sub_28141+D8j
cmp	[bp+si+argDest], 0 ; Compare Two Operands

loc_28220:		; Jump if Not Zero (ZF=0)
jnz	short loc_2821B
jmp	short loc_2822A	; Jump

loc_28224:		; CODE XREF: sub_28141+FAj
sub	si, si		; Integer Subtraction

loc_28226:
mov	[bp+si+argDest], 0

loc_2822A:		; CODE XREF: sub_28141+E1j
lea	ax, [bp+argDest] ; Load	Effective Address

loc_2822D:
push	ax

loc_2822E:		; Call Procedure
call	sub_1AF46
pop	cx

loc_28234:		; Compare Two Operands
cmp	ax, [bp+var_8]
jle	short loc_2823D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
or	si, si		; Logical Inclusive OR
jg	short loc_28224	; Jump if Greater (ZF=0	& SF=OF)

loc_2823D:		; CODE XREF: sub_28141+F6j
mov	[word_36A64], si
mov	ax, [word_36A64]
cmp	ax, [bp+var_4]	; Compare Two Operands
jl	short loc_2824F	; Jump if Less (SF!=OF)
mov	ax, [bp+var_4]
mov	[word_36A64], ax

loc_2824F:		; CODE XREF: sub_28141+106j
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
mov	ax, [bp+arg_0]

loc_28256:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
mov	[bp+var_A], ax
lea	ax, [bp+argDest] ; int
push	ax		; int
push	[bp+arg_0]	; int
nop			; No Operation
push	cs
call	near ptr sub_28963 ; Call Procedure
pop	cx
pop	cx

loc_28282:
mov	[bp+var_C], 0
jmp	loc_28506	; Jump

loc_2828A:		; CODE XREF: sub_28141+3D1j
jmp	short loc_282E2	; Jump

loc_2828C:		; CODE XREF: sub_28141+1AEj
db 83h,3Eh,62h,4Dh,0FFh	; <BAD>cmp     [word_36A72], 0FFFFh ; Compare Two Operands
jnz	short loc_28296	; Jump if Not Zero (ZF=0)
dec	[bp+var_E]	; Decrement by 1

loc_28296:		; CODE XREF: sub_28141+150j
cmp	[bp+var_E], 0	; Compare Two Operands
jnz	short loc_2829E	; Jump if Not Zero (ZF=0)
jmp	short loc_282F1	; Jump

loc_2829E:		; CODE XREF: sub_28141+159j
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_282BE	; Jump if Zero (ZF=1)
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_282B7	; Jump if Not Zero (ZF=0)
call	get_w360AC_set0	; Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_282BE	; Jump if Zero (ZF=1)

loc_282B7:		; CODE XREF: sub_28141+16Bj
mov	[bp+var_C], 1
jmp	short loc_282F1	; Jump

loc_282BE:		; CODE XREF: sub_28141+162j
			; sub_28141+174j
inc	[word_36A66]	; Increment by 1
mov	ax, [bp+var_A]
shl	ax, 1		; Shift	Logical	Left
dec	ax		; Decrement by 1
cmp	ax, [word_36A66] ; Compare Two Operands
jge	short loc_282D4	; Jump if Greater or Equal (SF=OF)

loc_282CE:
mov	[word_36A66], 0

loc_282D4:		; CODE XREF: sub_28141+18Bj
lea	ax, [bp+argDest] ; int
push	ax		; int

loc_282D8:		; int
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_28963 ; Call Procedure
pop	cx
pop	cx

loc_282E2:		; CODE XREF: sub_28141:loc_2828Aj
call	_f331647_TestKeyPress ;	Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_282F1	; Jump if Not Zero (ZF=0)
cmp	[bp+var_C], 0	; Compare Two Operands
jz	short loc_2828C	; Jump if Zero (ZF=1)

loc_282F1:		; CODE XREF: sub_28141+15Bj
			; sub_28141+17Bj
			; sub_28141+1A8j
cmp	[bp+var_E], 0	; Compare Two Operands
jnz	short loc_282FA	; Jump if Not Zero (ZF=0)
jmp	loc_28515	; Jump

loc_282FA:		; CODE XREF: sub_28141+1B4j
cmp	[bp+var_C], 0	; Compare Two Operands
jz	short loc_28303	; Jump if Zero (ZF=1)

loc_28300:		; Jump
jmp	loc_28515

loc_28303:		; CODE XREF: sub_28141+1BDj
call	ST_GetKeyboardCode ; Call Procedure
mov	[bp+var_F], al
mov	al, [bp+var_F]
cbw			; AL ->	AX (with sign)
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 0Ah		; switch 11 cases
jbe	short loc_2831A	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_28413	; default

loc_2831A:		; CODE XREF: sub_28141+1D4j
shl	bx, 1		; Shift	Logical	Left

loc_2831C:		; switch jump
jmp	[cs:off_2856D+bx]

loc_28321:		; DATA XREF: seg034:off_2856Do
cmp	[bp+var_6], 0	; case 0xA
jnz	short loc_28340	; Jump if Not Zero (ZF=0)
mov	[bp+argDest], 0
xor	si, si		; Logical Exclusive OR
mov	[word_36A64], 0
mov	[word_36A66], 0
mov	[bp+var_6], 1
jmp	short loc_28386	; Jump

loc_28340:		; CODE XREF: sub_28141+1E4j
or	si, si		; Logical Inclusive OR
jle	short loc_28386	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[word_36A64], si ; Compare Two Operands
jl	short loc_2835F	; Jump if Less (SF!=OF)
mov	ax, si
dec	ax		; Decrement by 1
mov	si, ax

loc_2834F:
mov	[bp+si+argDest], 0
dec	[word_36A64]	; Decrement by 1
mov	[word_36A66], 0
jmp	short loc_28386	; Jump

loc_2835F:		; CODE XREF: sub_28141+207j
cmp	[word_36A64], 0	; Compare Two Operands

loc_28364:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_28386
mov	di, [word_36A64]
jmp	short loc_28373	; Jump

loc_2836C:		; CODE XREF: sub_28141+234j
mov	al, [bp+di+argDest]
mov	[bp+di+var_4F],	al
inc	di		; Increment by 1

loc_28373:		; CODE XREF: sub_28141+229j
cmp	di, si		; Compare Two Operands
jl	short loc_2836C	; Jump if Less (SF!=OF)
dec	si		; Decrement by 1

loc_28378:		; Decrement by 1
dec	[word_36A64]
mov	[word_36A66], 0
mov	[bp+si+argDest], 0

loc_28386:		; CODE XREF: sub_28141+1FDj
			; sub_28141+201j
			; sub_28141+21Cj
			; sub_28141:loc_28364j
jmp	loc_284F8	; Jump

loc_28389:		; CODE XREF: sub_28141:loc_2831Cj
			; DATA XREF: seg034:off_2856Do
or	si, si		; case 0x9
jle	short loc_283AF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[word_36A64], si ; Compare Two Operands
jge	short loc_283AF	; Jump if Greater or Equal (SF=OF)

loc_28393:
mov	di, [word_36A64]
jmp	short loc_283A0	; Jump

loc_28399:		; CODE XREF: sub_28141+261j
mov	al, [bp+di-4Dh]
mov	[bp+di+argDest], al
inc	di		; Increment by 1

loc_283A0:		; CODE XREF: sub_28141+256j
cmp	di, si		; Compare Two Operands
jl	short loc_28399	; Jump if Less (SF!=OF)
dec	si		; Decrement by 1
mov	[word_36A66], 0
mov	[bp+si+argDest], 0

loc_283AF:		; CODE XREF: sub_28141+24Aj
			; sub_28141+250j
jmp	loc_284F8	; Jump

loc_283B2:		; CODE XREF: sub_28141:loc_2831Cj
			; DATA XREF: seg034:off_2856Do
mov	[bp+var_6], 1	; case 0x0
cmp	[word_36A64], 0	; Compare Two Operands
jle	short loc_283C8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_283BE:		; Decrement by 1
dec	[word_36A64]
mov	[word_36A66], 0

loc_283C8:		; CODE XREF: sub_28141+27Bj
jmp	loc_284F8	; Jump

loc_283CB:		; CODE XREF: sub_28141:loc_2831Cj
			; DATA XREF: seg034:off_2856Do
mov	ax, [word_36A64] ; case	0x1
cmp	ax, [bp+var_4]	; Compare Two Operands
jge	short loc_28410	; Jump if Greater or Equal (SF=OF)
cmp	[word_36A64], si ; Compare Two Operands
jge	short loc_28410	; Jump if Greater or Equal (SF=OF)
inc	[word_36A64]	; Increment by 1
mov	[word_36A66], 0
cmp	[word_36A64], si ; Compare Two Operands
jl	short loc_28410	; Jump if Less (SF!=OF)
mov	[bp+si+argDest], 20h ; ' '
mov	[byte ptr bp+si-4Dh], 0
mov	ax, [word_36A64]
cmp	ax, [bp+var_4]	; Compare Two Operands
jge	short loc_28408	; Jump if Greater or Equal (SF=OF)
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
cmp	ax, [bp+var_8]	; Compare Two Operands
jle	short loc_2840C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_28408:		; CODE XREF: sub_28141+2B6j
dec	[word_36A64]	; Decrement by 1

loc_2840C:		; CODE XREF: sub_28141+2C5j
mov	[bp+si+argDest], 0

loc_28410:		; CODE XREF: sub_28141+290j
			; sub_28141+296j
			; sub_28141+2A6j
jmp	loc_284F8	; Jump

loc_28413:		; CODE XREF: sub_28141+1D6j
			; sub_28141:loc_2831Cj
			; DATA XREF: seg034:off_2856Do
mov	[bp+var_2], 0	; default
cmp	[bp+var_F], 1Bh	; Compare Two Operands
jnz	short loc_2842A	; Jump if Not Zero (ZF=0)
mov	[bp+var_C], 2
mov	[bp+var_2], 0
jmp	short loc_2845F	; Jump

loc_2842A:		; CODE XREF: sub_28141+2DBj
cmp	[bp+var_F], 40h	; '@' ; Compare Two Operands
jle	short loc_28436	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_F], 5Dh	; ']' ; Compare Two Operands
jl	short loc_2845A	; Jump if Less (SF!=OF)

loc_28436:		; CODE XREF: sub_28141+2EDj
cmp	[bp+var_F], 2Dh	; '-' ; Compare Two Operands
jle	short loc_28442	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_2843C:		; Compare Two Operands
cmp	[bp+var_F], 3Bh	; ';'
jl	short loc_2845A	; Jump if Less (SF!=OF)

loc_28442:		; CODE XREF: sub_28141+2F9j
cmp	[bp+var_F], 20h	; ' ' ; Compare Two Operands
jz	short loc_2845A	; Jump if Zero (ZF=1)
cmp	[bp+var_F], 2Dh	; '-' ; Compare Two Operands
jz	short loc_2845A	; Jump if Zero (ZF=1)

loc_2844E:		; Compare Two Operands
cmp	[bp+var_F], 60h	; '`'
jle	short loc_2845F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_F], 7Bh	; '{' ; Compare Two Operands
jge	short loc_2845F	; Jump if Greater or Equal (SF=OF)

loc_2845A:		; CODE XREF: sub_28141+2F3j
			; sub_28141+2FFj
			; sub_28141+305j
			; sub_28141+30Bj
mov	[bp+var_2], 1

loc_2845F:		; CODE XREF: sub_28141+2E7j
			; sub_28141+311j
			; sub_28141+317j
cmp	[bp+var_2], 1	; Compare Two Operands
jz	short loc_28468	; Jump if Zero (ZF=1)
jmp	loc_284F6	; Jump

loc_28468:		; CODE XREF: sub_28141+322j
mov	[bp+var_6], 1

loc_2846D:
mov	al, [bp+var_F]
mov	[bp+si+argDest], al
mov	[byte ptr bp+si-4Dh], 0
cmp	si, [bp+var_4]	; Compare Two Operands
jge	short loc_284F2	; Jump if Greater or Equal (SF=OF)
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
cmp	ax, [bp+var_8]	; Compare Two Operands
jg	short loc_284F2	; Jump if Greater (ZF=0	& SF=OF)
mov	[bp+si+argDest], 0
cmp	[word_36A64], si ; Compare Two Operands
jge	short loc_284BB	; Jump if Greater or Equal (SF=OF)
mov	di, si
jmp	short loc_284A0	; Jump

loc_28499:		; CODE XREF: sub_28141+363j
mov	al, [bp+di+var_4F]
mov	[bp+di+argDest], al
dec	di		; Decrement by 1

loc_284A0:		; CODE XREF: sub_28141+356j
cmp	di, [word_36A64] ; Compare Two Operands
jg	short loc_28499	; Jump if Greater (ZF=0	& SF=OF)
inc	si		; Increment by 1
lea	ax, [bp+argDest] ; Load	Effective Address
mov	bx, [word_36A64]

loc_284AE:		; Add
add	bx, ax

loc_284B0:
mov	al, [bp+var_F]
mov	[bx], al
inc	[word_36A64]	; Increment by 1
jmp	short loc_284E6	; Jump

loc_284BB:		; CODE XREF: sub_28141+352j
mov	al, [bp+var_F]

loc_284BE:
mov	[bp+si+argDest], al
mov	ax, si
inc	ax		; Increment by 1
mov	si, ax
mov	[bp+si+argDest], 20h ; ' '
mov	[byte ptr bp+si-4Dh], 0

loc_284CE:		; Compare Two Operands
cmp	si, [bp+var_4]
jge	short loc_284E6	; Jump if Greater or Equal (SF=OF)
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	sub_1AF46	; Call Procedure
pop	cx

loc_284DD:		; Compare Two Operands
cmp	ax, [bp+var_8]
jg	short loc_284E6	; Jump if Greater (ZF=0	& SF=OF)

loc_284E2:		; Increment by 1
inc	[word_36A64]

loc_284E6:		; CODE XREF: sub_28141+378j
			; sub_28141+390j
			; sub_28141+39Fj
mov	[bp+si+argDest], 0

loc_284EA:
mov	[word_36A66], 0
jmp	short loc_284F6	; Jump

loc_284F2:		; CODE XREF: sub_28141+339j
			; sub_28141+348j
mov	[bp+si+argDest], 0

loc_284F6:		; CODE XREF: sub_28141+324j
			; sub_28141+3AFj
jmp	short $+2	; Jump

loc_284F8:		; CODE XREF: sub_28141:loc_28386j
			; sub_28141:loc_283AFj
			; sub_28141:loc_283C8j
			; sub_28141:loc_28410j
lea	ax, [bp+argDest] ; int

loc_284FB:		; int
push	ax
push	[bp+arg_0]	; int
nop			; No Operation
push	cs
call	near ptr sub_28963 ; Call Procedure
pop	cx
pop	cx

loc_28506:		; CODE XREF: sub_28141+146j
cmp	[bp+var_F], 0Ch	; Compare Two Operands
jz	short loc_28515	; Jump if Zero (ZF=1)
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_28515	; Jump if Not Zero (ZF=0)
jmp	loc_2828A	; argSrc

loc_28515:		; CODE XREF: sub_28141+1B6j
			; sub_28141:loc_28300j
			; sub_28141+3C9j
			; sub_28141+3CFj
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'

loc_2851F:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; argDest
call	_strcpy		; argDest,argSrc
pop	cx

loc_28531:
pop	cx
cmp	[bp+var_C], 0	; Compare Two Operands
jz	short loc_2854A	; Jump if Zero (ZF=1)

loc_28538:		; Compare Two Operands
cmp	[hrmMouseInstalled], 0
jz	short loc_2854A	; Jump if Zero (ZF=1)
jmp	short $+2	; Jump

loc_28541:		; CODE XREF: sub_28141+407j
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_28541	; Jump if Not Zero (ZF=0)

loc_2854A:		; CODE XREF: sub_28141+3F5j
			; sub_28141+3FCj
call	idk_ChkMousDoEga ; Call	Procedure
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
mov	[w36A32], 0FFFFh
mov	[word_36A64], 0
mov	[word_36A66], 0
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_28141 ; sp-analysis failed

db 0
off_2856D dw offset loc_283B2
			; DATA XREF: sub_28141:loc_2831Cr
dw offset loc_283CB	; jump table for switch	statement
dw offset loc_28413
dw offset loc_28413
dw offset loc_28413
dw offset loc_28413
dw offset loc_28413
dw offset loc_28413
dw offset loc_28413
dw offset loc_28389
dw offset loc_28321


; Attributes: bp-based frame

; int __fastcall __far sub_28583(int, int, int,	int, int, int, int, int, int, int, int,	int, int)
proc sub_28583 far	; CODE XREF: idk_Load_NEWGAME_LBX+B3P

var_4E=	byte ptr -4Eh
var_4D=	byte ptr -4Dh
argDest= byte ptr -4Ch
var_D= byte ptr	-0Dh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h

push	bp
mov	bp, sp
sub	sp, 4Ch		; Integer Subtraction
push	si

loc_2858A:		; argSrc
push	di
mov	[bp+var_8], 4
nop			; No Operation
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_285B1	; Jump if Zero (ZF=1)
jmp	short $+2	; Jump

loc_2859E:		; CODE XREF: sub_28583+22j
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_2859E	; Jump if Not Zero (ZF=0)
call	get_w360AC_set0	; Call Procedure
call	_f332647_Get_w360B4_Set0 ; Call	Procedure

loc_285B1:		; CODE XREF: sub_28583+17j
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_2B9C4 ; Call Procedure
pop	cx
push	[bp+arg_12]
mov	ax, 4D70h
push	ax
push	[bp+arg_10]
push	[bp+arg_E]
push	[bp+arg_C]
push	[bp+arg_A]
push	[bp+arg_8]
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs

loc_285DF:		; Call Procedure
call	near ptr sub_28D4A
add	sp, 16h		; Add
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
mov	[w36A32], ax
mov	[word_36A64], 0

loc_285F4:
mov	[word_36A66], 0

loc_285FA:
mov	[word_36A68], 0
mov	[bp+var_4], 0
xor	si, si		; Logical Exclusive OR
mov	[bp+var_D], 0

loc_2860B:		; Call Procedure
call	sub_1BBF9
mov	[bp+var_6], ax

loc_28613:
push	[bp+arg_6]
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_28621:		; Jump
jmp	short loc_28624

loc_28623:		; CODE XREF: sub_28583:loc_28628j
inc	si		; Increment by 1

loc_28624:		; CODE XREF: sub_28583:loc_28621j
cmp	[bp+si+argDest], 0 ; Compare Two Operands

loc_28628:		; Jump if Not Zero (ZF=0)
jnz	short loc_28623
jmp	short loc_28632	; Jump

loc_2862C:		; CODE XREF: sub_28583+C0j
sub	si, si		; Integer Subtraction
mov	[bp+si+argDest], 0

loc_28632:		; CODE XREF: sub_28583+A7j
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax

loc_28636:		; Call Procedure
call	sub_1AF46
pop	cx
cmp	ax, [bp+arg_4]	; Compare Two Operands
jle	short loc_28645	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
or	si, si		; Logical Inclusive OR
jg	short loc_2862C	; Jump if Greater (ZF=0	& SF=OF)

loc_28645:		; CODE XREF: sub_28583+BCj
mov	[word_36A64], si
mov	ax, [word_36A64]
cmp	ax, [bp+arg_8]	; Compare Two Operands
jl	short loc_28657	; Jump if Less (SF!=OF)
mov	ax, [bp+arg_8]
mov	[word_36A64], ax

loc_28657:		; CODE XREF: sub_28583+CCj
lea	ax, [bp+argDest] ; int
push	ax		; int
push	[bp+var_C]	; int
nop			; No Operation
push	cs
call	near ptr sub_28963 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_A], 0
jmp	loc_288E1	; Jump

loc_2866D:		; CODE XREF: sub_28583+36Aj
jmp	short loc_286C5	; Jump

loc_2866F:		; CODE XREF: sub_28583+14Fj
db 83h,3Eh,62h,4Dh,0FFh	; <BAD>cmp     [word_36A72], 0FFFFh ; Compare Two Operands
jnz	short loc_28679	; Jump if Not Zero (ZF=0)
dec	[bp+var_8]	; Decrement by 1

loc_28679:		; CODE XREF: sub_28583+F1j
cmp	[bp+var_8], 0	; Compare Two Operands

loc_2867D:		; Jump if Not Zero (ZF=0)
jnz	short loc_28681

loc_2867F:		; Jump
jmp	short noKeyPress

loc_28681:		; CODE XREF: sub_28583:loc_2867Dj
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_286A1	; Jump if Zero (ZF=1)
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_2869A	; Jump if Not Zero (ZF=0)
call	get_w360AC_set0	; Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_286A1	; Jump if Zero (ZF=1)

loc_2869A:		; CODE XREF: sub_28583+10Cj
mov	[bp+var_A], 1
jmp	short noKeyPress ; Jump

loc_286A1:		; CODE XREF: sub_28583+103j
			; sub_28583+115j
inc	[word_36A66]	; Increment by 1
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
dec	ax		; Decrement by 1
cmp	ax, [word_36A66] ; Compare Two Operands

loc_286AF:		; Jump if Greater or Equal (SF=OF)
jge	short loc_286B7
mov	[word_36A66], 0

loc_286B7:		; CODE XREF: sub_28583:loc_286AFj
lea	ax, [bp+argDest] ; int
push	ax		; int
push	[bp+var_C]	; int
nop			; No Operation
push	cs

loc_286C0:		; Call Procedure
call	near ptr sub_28963
pop	cx
pop	cx

loc_286C5:		; CODE XREF: sub_28583:loc_2866Dj
call	_f331647_TestKeyPress ;	Call Procedure
or	ax, ax		; Logical Inclusive OR

loc_286CC:		; Jump Not Zero	/ Jump Equal
jnz	short noKeyPress

yesKeyPress2:		; Compare Two Operands
cmp	[bp+var_A], 0
jz	short loc_2866F	; Jump if Zero (ZF=1)

noKeyPress:		; CODE XREF: sub_28583:loc_2867Fj
			; sub_28583+11Cj
			; sub_28583:loc_286CCj
cmp	[bp+var_8], 0	; Compare Two Operands
jnz	short loc_286DD	; Jump if Not Zero (ZF=0)
jmp	loc_288F0	; Jump

loc_286DD:		; CODE XREF: sub_28583+155j
cmp	[bp+var_A], 0	; Compare Two Operands
jz	short loc_286E6	; Jump if Zero (ZF=1)
jmp	loc_288F0	; Jump

loc_286E6:		; CODE XREF: sub_28583+15Ej
call	ST_GetKeyboardCode ; Call Procedure
mov	[bp+var_D], al
mov	al, [bp+var_D]
cbw			; AL ->	AX (with sign)
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 0Ah		; switch 11 cases
jbe	short loc_286FD	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_287EE	; default

loc_286FD:		; CODE XREF: sub_28583+175j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_2894D+bx] ; switch jump

loc_28704:		; DATA XREF: seg034:off_2894Do
cmp	[bp+var_4], 0	; case 0xA
jnz	short loc_28723	; Jump if Not Zero (ZF=0)
mov	[bp+argDest], 0
xor	si, si		; Logical Exclusive OR
mov	[word_36A64], 0
mov	[word_36A66], 0

loc_2871C:
mov	[bp+var_4], 1
jmp	short loc_28769	; Jump

loc_28723:		; CODE XREF: sub_28583+185j
or	si, si		; Logical Inclusive OR
jle	short loc_28769	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[word_36A64], si ; Compare Two Operands
jl	short loc_28742	; Jump if Less (SF!=OF)
mov	ax, si
dec	ax		; Decrement by 1
mov	si, ax
mov	[bp+si+argDest], 0
dec	[word_36A64]	; Decrement by 1
mov	[word_36A66], 0
jmp	short loc_28769	; Jump

loc_28742:		; CODE XREF: sub_28583+1A8j
cmp	[word_36A64], 0	; Compare Two Operands
jle	short loc_28769	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	di, [word_36A64]
jmp	short loc_28756	; Jump

loc_2874F:		; CODE XREF: sub_28583+1D5j
mov	al, [bp+di+argDest]
mov	[bp+di+var_4D],	al
inc	di		; Increment by 1

loc_28756:		; CODE XREF: sub_28583+1CAj
cmp	di, si		; Compare Two Operands
jl	short loc_2874F	; Jump if Less (SF!=OF)
dec	si		; Decrement by 1
dec	[word_36A64]	; Decrement by 1
mov	[word_36A66], 0
mov	[bp+si+argDest], 0

loc_28769:		; CODE XREF: sub_28583+19Ej
			; sub_28583+1A2j
			; sub_28583+1BDj
			; sub_28583+1C4j
jmp	loc_288D3	; Jump

loc_2876C:		; CODE XREF: sub_28583+17Cj
			; DATA XREF: seg034:off_2894Do
or	si, si		; case 0x9
jle	short loc_28792	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[word_36A64], si ; Compare Two Operands
jge	short loc_28792	; Jump if Greater or Equal (SF=OF)
mov	di, [word_36A64]
jmp	short loc_28783	; Jump

loc_2877C:		; CODE XREF: sub_28583+202j
mov	al, [bp+di-4Bh]
mov	[bp+di+argDest], al
inc	di		; Increment by 1

loc_28783:		; CODE XREF: sub_28583+1F7j
cmp	di, si		; Compare Two Operands
jl	short loc_2877C	; Jump if Less (SF!=OF)
dec	si		; Decrement by 1
mov	[word_36A66], 0
mov	[bp+si+argDest], 0

loc_28792:		; CODE XREF: sub_28583+1EBj
			; sub_28583+1F1j
jmp	loc_288D3	; Jump

loc_28795:		; CODE XREF: sub_28583+17Cj
			; DATA XREF: seg034:off_2894Do
mov	[bp+var_4], 1	; case 0x0
cmp	[word_36A64], 0	; Compare Two Operands

loc_2879F:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_287AB
dec	[word_36A64]	; Decrement by 1
mov	[word_36A66], 0

loc_287AB:		; CODE XREF: sub_28583:loc_2879Fj
jmp	loc_288D3	; Jump

loc_287AE:		; CODE XREF: sub_28583+17Cj
			; DATA XREF: seg034:off_2894Do
mov	ax, [word_36A64] ; case	0x1
cmp	ax, [bp+arg_8]	; Compare Two Operands
jge	short loc_287EB	; Jump if Greater or Equal (SF=OF)
cmp	[word_36A64], si ; Compare Two Operands
jge	short loc_287EB	; Jump if Greater or Equal (SF=OF)
inc	[word_36A64]	; Increment by 1
mov	[word_36A66], 0
cmp	[word_36A64], si ; Compare Two Operands

loc_287CA:		; Jump if Not Zero (ZF=0)
jnz	short loc_287EB
mov	[bp+si+argDest], 20h ; ' '
mov	[byte ptr bp+si-4Bh], 0
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax

loc_287D8:		; Call Procedure
call	sub_1AF46
pop	cx
cmp	ax, [bp+arg_4]	; Compare Two Operands
jle	short loc_287E7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
dec	[word_36A64]	; Decrement by 1

loc_287E7:		; CODE XREF: sub_28583+25Ej
mov	[bp+si+argDest], 0

loc_287EB:		; CODE XREF: sub_28583+231j
			; sub_28583+237j
			; sub_28583:loc_287CAj
jmp	loc_288D3	; Jump

loc_287EE:		; CODE XREF: sub_28583+177j
			; sub_28583+17Cj
			; DATA XREF: seg034:off_2894Do
mov	[bp+var_2], 0	; default
cmp	[bp+var_D], 1Bh	; Compare Two Operands
jnz	short loc_28805	; Jump if Not Zero (ZF=0)
mov	[bp+var_A], 2
mov	[bp+var_2], 0
jmp	short loc_2883A	; Jump

loc_28805:		; CODE XREF: sub_28583+274j
cmp	[bp+var_D], 40h	; '@' ; Compare Two Operands
jle	short loc_28811	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_D], 5Dh	; ']' ; Compare Two Operands
jl	short loc_28835	; Jump if Less (SF!=OF)

loc_28811:		; CODE XREF: sub_28583+286j
cmp	[bp+var_D], 2Dh	; '-' ; Compare Two Operands
jle	short loc_2881D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_D], 3Bh	; ';' ; Compare Two Operands
jl	short loc_28835	; Jump if Less (SF!=OF)

loc_2881D:		; CODE XREF: sub_28583+292j
cmp	[bp+var_D], 20h	; ' ' ; Compare Two Operands
jz	short loc_28835	; Jump if Zero (ZF=1)
cmp	[bp+var_D], 2Dh	; '-' ; Compare Two Operands
jz	short loc_28835	; Jump if Zero (ZF=1)

loc_28829:		; Compare Two Operands
cmp	[bp+var_D], 60h	; '`'
jle	short loc_2883A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_D], 7Bh	; '{' ; Compare Two Operands
jge	short loc_2883A	; Jump if Greater or Equal (SF=OF)

loc_28835:		; CODE XREF: sub_28583+28Cj
			; sub_28583+298j
			; sub_28583+29Ej
			; sub_28583+2A4j
mov	[bp+var_2], 1

loc_2883A:		; CODE XREF: sub_28583+280j
			; sub_28583+2AAj
			; sub_28583+2B0j
cmp	[bp+var_2], 1	; Compare Two Operands
jz	short loc_28843	; Jump if Zero (ZF=1)
jmp	loc_288D1	; Jump

loc_28843:		; CODE XREF: sub_28583+2BBj
mov	[bp+var_4], 1
mov	al, [bp+var_D]
mov	[bp+si+argDest], al
mov	[byte ptr bp+si-4Bh], 0
cmp	si, [bp+arg_8]	; Compare Two Operands
jge	short loc_288CD	; Jump if Greater or Equal (SF=OF)
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
cmp	ax, [bp+arg_4]	; Compare Two Operands
jg	short loc_288CD	; Jump if Greater (ZF=0	& SF=OF)
mov	[bp+si+argDest], 0
cmp	[word_36A64], si ; Compare Two Operands
jge	short loc_28896	; Jump if Greater or Equal (SF=OF)
mov	di, si
jmp	short loc_2887B	; Jump

loc_28874:		; CODE XREF: sub_28583+2FCj
mov	al, [bp+di+var_4D]
mov	[bp+di+argDest], al
dec	di		; Decrement by 1

loc_2887B:		; CODE XREF: sub_28583+2EFj
cmp	di, [word_36A64] ; Compare Two Operands
jg	short loc_28874	; Jump if Greater (ZF=0	& SF=OF)
inc	si		; Increment by 1
lea	ax, [bp+argDest] ; Load	Effective Address
mov	bx, [word_36A64]
add	bx, ax		; Add
mov	al, [bp+var_D]
mov	[bx], al
inc	[word_36A64]	; Increment by 1
jmp	short loc_288C1	; Jump

loc_28896:		; CODE XREF: sub_28583+2EBj
mov	al, [bp+var_D]
mov	[bp+si+argDest], al
mov	ax, si
inc	ax		; Increment by 1

loc_2889F:
mov	si, ax
mov	[bp+si+argDest], 20h ; ' '
mov	[byte ptr bp+si-4Bh], 0
cmp	si, [bp+arg_8]	; Compare Two Operands
jge	short loc_288C1	; Jump if Greater or Equal (SF=OF)

loc_288AE:		; Load Effective Address
lea	ax, [bp+argDest]
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
cmp	ax, [bp+arg_4]	; Compare Two Operands
jg	short loc_288C1	; Jump if Greater (ZF=0	& SF=OF)
inc	[word_36A64]	; Increment by 1

loc_288C1:		; CODE XREF: sub_28583+311j
			; sub_28583+329j
			; sub_28583+338j
mov	[bp+si+argDest], 0
mov	[word_36A66], 0
jmp	short loc_288D1	; Jump

loc_288CD:		; CODE XREF: sub_28583+2D2j
			; sub_28583+2E1j
mov	[bp+si+argDest], 0

loc_288D1:		; CODE XREF: sub_28583+2BDj
			; sub_28583+348j
jmp	short $+2	; Jump

loc_288D3:		; CODE XREF: sub_28583:loc_28769j
			; sub_28583:loc_28792j
			; sub_28583:loc_287ABj
			; sub_28583:loc_287EBj
lea	ax, [bp+argDest] ; int
push	ax		; int

loc_288D7:		; int
push	[bp+var_C]
nop			; No Operation
push	cs
call	near ptr sub_28963 ; Call Procedure
pop	cx
pop	cx

loc_288E1:		; CODE XREF: sub_28583+E7j
cmp	[bp+var_D], 0Ch	; Compare Two Operands
jz	short loc_288F0	; Jump if Zero (ZF=1)
cmp	[bp+var_A], 0	; Compare Two Operands
jnz	short loc_288F0	; Jump if Not Zero (ZF=0)
jmp	loc_2866D	; argSrc

loc_288F0:		; CODE XREF: sub_28583+157j
			; sub_28583+160j
			; sub_28583+362j
			; sub_28583+368j
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
push	[bp+arg_6]	; argDest

loc_288F7:		; argDest,argSrc
call	_strcpy
pop	cx
pop	cx
cmp	[bp+var_A], 0	; Compare Two Operands
jz	short loc_28916	; Jump if Zero (ZF=1)
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_28916	; Jump if Zero (ZF=1)

loc_2890B:		; Jump
jmp	short $+2

loc_2890D:		; CODE XREF: sub_28583+391j
call	_f330547_GetMouseButtonsStatus ; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_2890D	; Jump if Not Zero (ZF=0)

loc_28916:		; CODE XREF: sub_28583+37Fj
			; sub_28583+386j
mov	[w36A32], 0FFFFh

loc_2891C:		; No Operation
nop
push	cs

loc_2891E:		;
call	near ptr setFlagsMaybeMouseEGA ; mov	 word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
call	get_w360AC_set0	; Call Procedure

loc_28926:		; Call Procedure
call	_f332647_Get_w360B4_Set0
mov	[word_36A64], 0
mov	[word_36A66], 0
cmp	[bp+var_A], 2	; Compare Two Operands

loc_2893B:		; Jump if Not Zero (ZF=0)
jnz	short loc_28942
mov	ax, 0FFFFh

loc_28940:		; CODE XREF: sub_28583+3C1j
jmp	short loc_28946	; Jump

loc_28942:		; CODE XREF: sub_28583:loc_2893Bj
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_28940	; Jump

loc_28946:		; CODE XREF: sub_28583:loc_28940j
pop	di
pop	si
mov	sp, bp
pop	bp

locret_2894B:		; Return Far from Procedure
retf
endp sub_28583 ; sp-analysis failed

byte_2894C db 0
off_2894D dw offset loc_28795
			; DATA XREF: sub_28583+17Cr
dw offset loc_287AE	; jump table for switch	statement
dw offset loc_287EE
dw offset loc_287EE
dw offset loc_287EE
dw offset loc_287EE
dw offset loc_287EE
dw offset loc_287EE
dw offset loc_287EE
dw offset loc_2876C
dw offset loc_28704


; Attributes: bp-based frame

; int __fastcall __far sub_28963(int, int, int,	int, int)
proc sub_28963 far	; CODE XREF: sub_28141+13Cp
			; sub_28141+19Cp
			; sub_28141+3C0p
			; sub_28583+DDp
			; sub_28583:loc_286C0p
			; sub_28583+359p

var_5E=	word ptr -5Eh
var_5C=	word ptr -5Ch
argDest= byte ptr -4Ch
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 5Ch		; Integer Subtraction
push	si
push	di		; argSrc
call	_f020105_bios_timeofday	; Call Procedure
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
call	sub_1BBF9	; Call Procedure
push	ax
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_28989:
push	[word ptr es:bx+22h]

loc_2898D:		; Load Effective Address
lea	ax, [bp+var_5C]
push	ax
call	sub_1CD80	; Call Procedure

loc_28996:		; Add
add	sp, 6

loc_28999:
push	[bp+arg_2]
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest

loc_289A0:		; argDest,argSrc
call	_strcpy
pop	cx
pop	cx
nop			; No Operation
push	cs
call	near ptr sub_2E26D ; Call Procedure
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_289CE:		; Integer Subtraction
sub	ax, [es:bx]
mov	[bp+var_E], ax

loc_289D4:
mov	si, [bp+arg_0]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h] ; int
mov	ax, si

loc_289EA:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_28A06:		; int
push	[word ptr es:bx+0Ch]
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
mov	[bp+var_A], ax
mov	ax, si
mov	dx, 26h	; '&'

loc_28A20:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ah], 0	; Compare Two Operands
jz	short loc_28A8D	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+1Ah]

loc_28A40:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+6]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_28A5E:
push	[word ptr es:bx+4]
mov	ax, si

loc_28A64:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28A69:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_28A6D:		; Add
add	bx, ax

loc_28A6F:
push	[word ptr es:bx+2]

loc_28A73:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28A7A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_28A7E:		; Add
add	bx, ax

loc_28A80:
mov	ax, [es:bx]
dec	ax		; Decrement by 1
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add

loc_28A8D:		; CODE XREF: sub_28963+CAj
mov	[byte ptr bp+var_2+1], 0
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_28A9C:		; Add
add	bx, ax

loc_28A9E:
mov	ax, [es:bx+1Eh]

loc_28AA2:		; Logical Inclusive OR
or	ax, ax
jz	short loc_28AB1	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jnz	short loc_28AAE	; Jump if Not Zero (ZF=0)

loc_28AAB:		; Jump
jmp	loc_28BED

loc_28AAE:		; CODE XREF: sub_28963+146j
jmp	loc_28CBF	; Jump

loc_28AB1:		; CODE XREF: sub_28963+141j
lea	ax, [bp+argDest] ; Load	Effective Address
mov	bx, [word_36A64]
add	bx, ax		; Add
mov	al, [bx]
mov	[byte ptr bp+var_2], al

loc_28ABF:		; Load Effective Address
lea	ax, [bp+argDest]

loc_28AC2:
mov	bx, [word_36A64]

loc_28AC6:		; Add
add	bx, ax
mov	[byte ptr bx], 0
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
push	ax
mov	ax, si

loc_28AD8:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
mov	[bp+var_8], ax
lea	ax, [bp+argDest] ; Load	Effective Address
mov	bx, [word_36A64]
add	bx, ax		; Add
mov	al, [byte ptr bp+var_2]
mov	[bx], al
cmp	[byte ptr bp+var_2], 0 ; Compare Two Operands
jnz	short loc_28B04	; Jump if Not Zero (ZF=0)
mov	[byte ptr bp+var_2], 20h ; ' '

loc_28B04:		; CODE XREF: sub_28963+19Bj
lea	ax, [bp+var_2]	; Load Effective Address
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
mov	[bp+var_6], ax
cmp	[word_36A66], 0	; Compare Two Operands
jle	short loc_28B7A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_28B18:
mov	ax, [word_36A66]

loc_28B1B:		; Compare Two Operands
cmp	ax, [bp+var_A]
jg	short loc_28B7A	; Jump if Greater (ZF=0	& SF=OF)

loc_28B20:
mov	di, [word_36A66]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_28B2F:		; Add
add	bx, ax
mov	ax, [es:bx+2]
add	ax, [bp+var_A]	; Add
mov	[bp+var_C], ax
mov	[bp+var_4], 0
jmp	short loc_28B74	; Jump

loc_28B42:		; CODE XREF: sub_28963+213j
lea	ax, [bp+var_5C]	; Load Effective Address
mov	bx, [bp+var_4]
add	bx, ax		; Add
mov	al, [bx]
mov	ah, 0
push	ax
mov	ax, [bp+var_C]
sub	ax, di		; Integer Subtraction
inc	ax		; Increment by 1
push	ax
mov	ax, [bp+var_8]
add	ax, [bp+var_6]	; Add
inc	ax		; Increment by 1
push	ax
mov	ax, [bp+var_C]
sub	ax, di		; Integer Subtraction
inc	ax		; Increment by 1
push	ax
push	[bp+var_8]
call	sub_187FA	; Call Procedure
add	sp, 0Ah		; Add
inc	[bp+var_4]	; Increment by 1
dec	di		; Decrement by 1

loc_28B74:		; CODE XREF: sub_28963+1DDj
or	di, di		; Logical Inclusive OR
jg	short loc_28B42	; Jump if Greater (ZF=0	& SF=OF)
jmp	short loc_28BEA	; Jump

loc_28B7A:		; CODE XREF: sub_28963+1B3j
			; sub_28963+1BBj
cmp	[word_36A66], 0	; Compare Two Operands
jz	short loc_28BEA	; Jump if Zero (ZF=1)
mov	ax, [word_36A66]
sub	ax, [bp+var_A]	; Integer Subtraction
mov	dx, [bp+var_A]
sub	dx, ax		; Integer Subtraction
mov	di, dx
mov	[bp+var_4], 0
jmp	short loc_28BE6	; Jump

loc_28B95:		; CODE XREF: sub_28963+285j
mov	bx, [bp+var_A]
sub	bx, [bp+var_4]	; Integer Subtraction
lea	ax, [bp+var_5E+1] ; Load Effective Address
add	bx, ax		; Add
mov	al, [bx]
mov	ah, 0
push	ax

loc_28BA5:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_28BB0:		; Add
add	bx, ax
mov	ax, [es:bx+2]
add	ax, di		; Add
dec	ax		; Decrement by 1
push	ax
mov	ax, [bp+var_8]
add	ax, [bp+var_6]	; Add

loc_28BC0:		; Increment by 1
inc	ax
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
add	ax, di		; Add
dec	ax		; Decrement by 1
push	ax
push	[bp+var_8]
call	sub_187FA	; Call Procedure
add	sp, 0Ah		; Add
inc	[bp+var_4]	; Increment by 1
dec	di		; Decrement by 1

loc_28BE6:		; CODE XREF: sub_28963+230j
or	di, di		; Logical Inclusive OR
jg	short loc_28B95	; Jump if Greater (ZF=0	& SF=OF)

loc_28BEA:		; CODE XREF: sub_28963+215j
			; sub_28963+21Cj
jmp	loc_28CC1	; Jump

loc_28BED:		; CODE XREF: sub_28963:loc_28AABj
lea	ax, [bp+argDest] ; Load	Effective Address
mov	bx, [word_36A64]
add	bx, ax		; Add
mov	al, [bx]
mov	[byte ptr bp+var_2], al
lea	ax, [bp+argDest] ; Load	Effective Address
mov	bx, [word_36A64]
add	bx, ax		; Add
mov	[byte ptr bx], 0
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
push	ax
mov	ax, si
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
mov	[bp+var_8], ax
lea	ax, [bp+argDest] ; Load	Effective Address
mov	bx, [word_36A64]
add	bx, ax		; Add
mov	al, [byte ptr bp+var_2]
mov	[bx], al
cmp	[byte ptr bp+var_2], 0 ; Compare Two Operands
jnz	short loc_28C40	; Jump if Not Zero (ZF=0)
mov	[byte ptr bp+var_2], 32

loc_28C40:		; CODE XREF: sub_28963+2D7j
lea	ax, [bp+var_2]	; Load Effective Address
push	ax
call	sub_1AF46	; Call Procedure
pop	cx
mov	[bp+var_6], ax
mov	ax, [word_36A66]
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	di, dx
or	di, di		; Logical Inclusive OR
jnz	short loc_28C6B	; Jump if Not Zero (ZF=0)

loc_28C5C:		; Compare Two Operands
cmp	[word_36A68], 0
jnz	short loc_28C6B	; Jump if Not Zero (ZF=0)
mov	[word_36A68], 1
jmp	short loc_28C7C	; Jump

loc_28C6B:		; CODE XREF: sub_28963+2F7j
			; sub_28963+2FEj
or	di, di		; Logical Inclusive OR
jnz	short loc_28C7C	; Jump if Not Zero (ZF=0)
cmp	[word_36A68], 1	; Compare Two Operands
jnz	short loc_28C7C	; Jump if Not Zero (ZF=0)

loc_28C76:
mov	[word_36A68], 0

loc_28C7C:		; CODE XREF: sub_28963+306j
			; sub_28963+30Aj
			; sub_28963+311j
mov	ax, si
mov	dx, 26h	; '&'

loc_28C81:		; Signed Multiply
imul	dx

loc_28C83:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_28C87:		; Add
add	bx, ax

loc_28C89:
mov	ax, [es:bx+2]
add	ax, [bp+var_A]	; Add

loc_28C90:
mov	[bp+var_C], ax
cmp	[word_36A68], 0	; Compare Two Operands
jz	short loc_28CBD	; Jump if Zero (ZF=1)
mov	al, [byte ptr bp+var_5C]
mov	ah, 0
push	ax
mov	ax, [bp+var_C]
inc	ax		; Increment by 1
push	ax

loc_28CA5:
mov	ax, [bp+var_8]
add	ax, [bp+var_6]	; Add
inc	ax		; Increment by 1
push	ax
mov	ax, [bp+var_C]

loc_28CB0:		; Increment by 1
inc	ax
push	ax
push	[bp+var_8]
call	sub_187FA	; Call Procedure
add	sp, 0Ah		; Add

loc_28CBD:		; CODE XREF: sub_28963+335j
jmp	short loc_28CC1	; Jump

loc_28CBF:		; CODE XREF: sub_28963:loc_28AAEj
jmp	short $+2	; Jump

loc_28CC1:		; CODE XREF: sub_28963:loc_28BEAj
			; sub_28963:loc_28CBDj
mov	ax, si

loc_28CC3:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_28CDF:		; int
push	[word ptr es:bx+0Eh]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_28CEE:		; Add
add	bx, ax
push	[word ptr es:bx+0Ch] ; int

loc_28CF4:		; Call Procedure
call	idk_PalFnt_s1AB64
add	sp, 6		; Add

loc_28CFC:		; Call Procedure
call	sub_19D2A
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax

loc_28D05:
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, [bp+arg_0]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28D1F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
call	idk_SetPalette_s1C4F4 ;	Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_2E303 ; Call Procedure
push	[idk_InitRoland_w36A3C]

loc_28D3E:		; Call Procedure
call	_f020305_idk_SleepWaitPause
pop	cx
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_28963



; Attributes: bp-based frame

proc sub_28D4A far	; CODE XREF: sub_28583:loc_285DFp

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah

push	bp

loc_28D4B:
mov	bp, sp
push	si
push	di
mov	di, [bp+arg_0]
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx], di
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28D6B:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	[es:bx+2], ax

loc_28D78:		; Call Procedure
call	sub_1A4D1
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_28D8D:
mov	[es:bx+0Ch], ax

loc_28D91:		; Call Procedure
call	sub_1A4E6
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28D9F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
mov	[es:bx+0Eh], ax

loc_28DAA:		; Call Procedure
call	sub_1A4FB
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+14h], ax

loc_28DC3:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_28DCF:		; Add
add	bx, ax
mov	ax, di
add	ax, [bp+arg_4]	; Add

loc_28DD6:
mov	[es:bx+4], ax
call	sub_1BBF9	; Call Procedure
mov	dx, [bp+arg_2]
add	dx, ax		; Add
mov	ax, [idk_Mouse_w3C5A8]
mov	bx, 26h	; '&'
push	dx
imul	bx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]

loc_28DFB:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_28E06:
mov	ax, [bp+arg_8]
mov	[es:bx+20h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	si, [bp+arg_12]
mov	al, [si]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_28E2A:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_28E30:		; Add
add	bx, ax
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_28E76	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]

loc_28E3C:
mov	dx, 26h	; '&'

loc_28E3F:		; Signed Multiply
imul	dx

loc_28E41:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_28E47:		; Compare Two Operands
cmp	[byte ptr es:bx+24h], 7Bh ; '{'
jge	short loc_28E76	; Jump if Greater or Equal (SF=OF)

loc_28E4E:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_28E54:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_28E5C:
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_28E6F:		; Add
add	bx, ax
pop	ax
mov	[es:bx+24h], al

loc_28E76:		; CODE XREF: sub_28D4A+EDj
			; sub_28D4A+102j
mov	ax, [idk_Mouse_w3C5A8]

loc_28E79:
mov	dx, 26h	; '&'

loc_28E7C:		; Signed Multiply
imul	dx

loc_28E7E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_28E84:
mov	ax, [bp+arg_14]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
mov	[es:bx+16h], ax

loc_28EA0:
mov	ax, [idk_Mouse_w3C5A8]

loc_28EA3:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28EA8:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_28EAE:
mov	ax, [bp+arg_A]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_C]

loc_28EC6:
mov	[es:bx+1Ch], ax
mov	ax, [idk_Mouse_w3C5A8]

loc_28ECD:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_E]
mov	[es:bx+1Eh], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_10]
mov	[es:bx+22h], ax
mov	ax, [idk_Mouse_w3C5A8]

loc_28EF7:
mov	dx, 26h	; '&'

loc_28EFA:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 4
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si

loc_28F17:
pop	bp
retf			; Return Far from Procedure
endp sub_28D4A



; Attributes: bp-based frame

proc sub_28F19 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h

push	bp

loc_28F1A:
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]

loc_28F24:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx], si
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_28F3B:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx+2], di
call	sub_1A4D1	; Call Procedure
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_28F59:		; Add
add	bx, ax
pop	ax
mov	[es:bx+0Ch], ax
call	sub_1A4E6	; Call Procedure
push	ax
mov	ax, [idk_Mouse_w3C5A8]

loc_28F69:
mov	dx, 26h	; '&'

loc_28F6C:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+0Eh], ax
call	sub_1A4FB	; Call Procedure
push	ax

loc_28F7F:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+14h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+arg_4]	; Add
mov	[es:bx+4], ax
call	sub_1BBF9	; Call Procedure
mov	dx, di

loc_28FB0:		; Add
add	dx, ax
mov	ax, [idk_Mouse_w3C5A8]
mov	bx, 26h	; '&'
push	dx
imul	bx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
mov	[es:bx+20h], ax
mov	ax, [idk_Mouse_w3C5A8]

loc_28FDE:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28FE3:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	[byte ptr es:bx+24h], 0
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_28FF6:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [bp+arg_E]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_29009:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2900F:		; Add
add	bx, ax
mov	ax, [bp+arg_6]
mov	[es:bx+16h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_C]
mov	[es:bx+18h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_A]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_10]
mov	[es:bx+22h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_29065:
mov	[word ptr es:bx+8], 0Bh
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_28F19



; Attributes: bp-based frame

proc sub_2907C far

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	cx, [bp+arg_0]
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
dec	ax		; Decrement by 1
push	ax
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2909C:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], ax
pop	bp
retf			; Return Far from Procedure
endp sub_2907C



; Attributes: bp-based frame

proc sub_290A9 far	; CODE XREF: sub_2A755+154p
			; sub_2A755+1EDp
			; sub_2A755+3AAp
			; sub_2A755+41Ep
			; sub_2A755+589p
			; sub_2A755+5FDp
			; sub_2A755+771p
			; sub_2A755+822p
			; sub_2A755+940p
			; sub_2A755+9BEp
			; sub_2B1F9+E6p
			; sub_2B1F9+159p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh
arg_1A=	word ptr  20h

push	bp
mov	bp, sp
push	si
push	di

loc_290AE:
mov	di, [bp+arg_0]
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx], di
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_290CA:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [bp+arg_2]
dec	ax		; Decrement by 1
mov	[es:bx+2], ax

loc_290D8:		; Call Procedure
call	sub_1A4D1
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_290ED:
mov	[es:bx+0Ch], ax
call	sub_1A4E6	; Call Procedure
push	ax

loc_290F7:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_290FD:		; Signed Multiply
imul	dx

loc_290FF:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax

loc_29106:
mov	[es:bx+0Eh], ax
call	sub_1A4FB	; Call Procedure
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+14h], ax
mov	ax, [idk_Mouse_w3C5A8]

loc_29126:
mov	dx, 26h	; '&'

loc_29129:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2912F:		; Add
add	bx, ax
mov	ax, di
add	ax, [bp+arg_4]	; Add
mov	[es:bx+4], ax

loc_2913A:		; Call Procedure
call	sub_1BBF9
mov	dx, [bp+arg_2]
add	dx, ax		; Add

loc_29144:		; Increment by 1
inc	dx

loc_29145:
mov	ax, [idk_Mouse_w3C5A8]
mov	bx, 26h	; '&'
push	dx
imul	bx		; Signed Multiply

loc_2914E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_29152:		; Add
add	bx, ax
pop	ax
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_29161:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [bp+arg_C]
mov	[es:bx+18h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2917C:
mov	si, [bp+arg_18]
mov	al, [si]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2918D:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]

loc_29191:		; Add
add	bx, ax
mov	ax, [bp+arg_8]

loc_29196:
mov	[es:bx+12h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_291A0:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_291EC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_291AF:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_291EC	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_291D0:		; Add
add	bx, ax
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_291E8:
mov	[es:bx+24h], al

loc_291EC:		; CODE XREF: sub_290A9+104j
			; sub_290A9+119j
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_1A]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
mov	[es:bx+16h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_A]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_E]
mov	[es:bx+10h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_10]
mov	[es:bx+1Ch], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_12]
mov	[es:bx+1Eh], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_14]
mov	[es:bx+20h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_16]
mov	[es:bx+22h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 0Ah
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax

loc_292AF:
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_290A9



; Attributes: bp-based frame

proc sub_292B9 far

argDest= byte ptr -1Eh
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 1Eh		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_0]
push	di
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
xor	si, si		; Logical Exclusive OR
jmp	short loc_292D5	; Jump

loc_292D4:		; CODE XREF: sub_292B9+25j
inc	si		; Increment by 1

loc_292D5:		; CODE XREF: sub_292B9+19j
cmp	[bp+si+argDest], 0 ; Compare Two Operands
jz	short loc_292E0	; Jump if Zero (ZF=1)
cmp	si, 1Eh		; Compare Two Operands
jl	short loc_292D4	; Jump if Less (SF!=OF)

loc_292E0:		; CODE XREF: sub_292B9+20j
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx], 1F4h
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+2], 1F4h
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+4], 1F4h
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+6], 1F4h
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2933D:
mov	[word ptr es:bx+8], 8
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+0Ah], 0FFFFh
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_29365:
mov	[es:bx+16h], di
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+18h], 0
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx+1Ah], si
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [bp+argDest]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_293F6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_293F6	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_293F6:		; CODE XREF: sub_292B9+FEj
			; sub_292B9+113j
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_292B9



; Attributes: bp-based frame

proc sub_29409 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	si
push	di
mov	di, [bp+arg_4]
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_0]
mov	[es:bx], ax
mov	ax, [idk_Mouse_w3C5A8]

loc_29428:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	[es:bx+2], ax
push	di
call	sub_1FB15	; Call Procedure
pop	cx
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2945F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
mov	[es:bx+4], ax
push	di

loc_2946B:		; Call Procedure
call	sub_1FB29
pop	cx
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx+20h], di
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 5
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	si, [bp+arg_6]
mov	al, [si]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_2953F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_2953F	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2951F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_2953F:		; CODE XREF: sub_29409+F7j
			; sub_29409+10Cj
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_29409



; Attributes: bp-based frame

proc sub_29550 far

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_0]
push	[bp+arg_4]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, di
add	dx, ax		; Add
mov	[bp+var_2], dx
push	[bp+arg_4]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [bp+arg_2]
add	dx, ax		; Add
mov	[bp+var_4], dx
mov	ax, [bp+var_2]

loc_2957F:		; Compare Two Operands
cmp	ax, [idk_ScrnPosX0_w35EC2]
jl	short loc_2958B	; Jump if Less (SF!=OF)
cmp	di, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jle	short loc_29591	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_2958B:		; CODE XREF: sub_29550+33j
			; sub_29550:loc_295A3j
mov	ax, 0D8F0h

loc_2958E:		; CODE XREF: sub_29550+1C7j
jmp	loc_2971A	; Jump

loc_29591:		; CODE XREF: sub_29550+39j
mov	ax, [bp+var_4]
cmp	ax, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jl	short loc_295A3	; Jump if Less (SF!=OF)
mov	ax, [bp+arg_2]
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jle	short loc_295A5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_295A3:		; CODE XREF: sub_29550+48j
jmp	short loc_2958B	; Jump

loc_295A5:		; CODE XREF: sub_29550+51j
cmp	di, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jl	short loc_295BE	; Jump if Less (SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx], di
jmp	short loc_295D2	; Jump

loc_295BE:		; CODE XREF: sub_29550+59j
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [idk_ScrnPosX0_w35EC2]

loc_295CF:
mov	[es:bx], ax

loc_295D2:		; CODE XREF: sub_29550+6Cj
mov	ax, [bp+var_2]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jg	short loc_295EE	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
jmp	short loc_295FF	; Jump

loc_295EE:		; CODE XREF: sub_29550+89j
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_295FF:		; CODE XREF: sub_29550+9Cj
mov	[es:bx+4], ax
mov	ax, [bp+arg_2]
cmp	ax, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jl	short loc_2961F	; Jump if Less (SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
jmp	short loc_29630	; Jump

loc_2961F:		; CODE XREF: sub_29550+BAj
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_29627:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [idk_ScrnPosY0_w35EC4]

loc_29630:		; CODE XREF: sub_29550+CDj
mov	[es:bx+2], ax
mov	ax, [bp+var_4]
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jg	short loc_29650	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_4]
jmp	short loc_29661	; Jump

loc_29650:		; CODE XREF: sub_29550+EBj
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [idk_ScrnPosY199_w35EC8]

loc_29661:		; CODE XREF: sub_29550+FEj
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_29680:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	[es:bx+20h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 5
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_296AF:		; Add
add	bx, ax
mov	si, [bp+arg_6]
mov	al, [si]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_296C6:		; Add
add	bx, ax
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_2970C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_296DD:		; Compare Two Operands
cmp	[byte ptr es:bx+24h], 7Bh ; '{'
jge	short loc_2970C	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_2970C:		; CODE XREF: sub_29550+17Dj
			; sub_29550+192j
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	loc_2958E	; Jump

loc_2971A:		; CODE XREF: sub_29550:loc_2958Ej
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_29550



; Attributes: bp-based frame

proc sub_29720 far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
mov	ax, [bp+arg_0]
mov	[word_36A34], ax
mov	ax, [bp+arg_2]
mov	[word_36A36], ax
pop	bp
retf			; Return Far from Procedure
endp sub_29720



; Attributes: bp-based frame

proc sub_29731 far	; CODE XREF: sub_298BB+16p
			; sub_298FA+16p
			; sub_2994E+16p
			; sub_299A2+16p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	si
push	di

loc_29736:
mov	di, [bp+arg_6]
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_0]
mov	[es:bx], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	[es:bx+2], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2976E:		; Add
add	bx, ax
mov	ax, [bp+arg_4]
mov	[es:bx+16h], ax
push	di
call	sub_1FB15	; Call Procedure
pop	cx
push	ax

loc_2977F:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
dec	ax		; Decrement by 1
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+4], ax
push	di
call	sub_1FB29	; Call Procedure
pop	cx
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
dec	ax		; Decrement by 1
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], ax
call	sub_1A4D1	; Call Procedure
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+0Ch], ax
call	sub_1A4E6	; Call Procedure
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_297FF:		; Signed Multiply
imul	dx

loc_29801:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
mov	[es:bx+0Eh], ax

loc_2980C:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_29814:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [bp+arg_A]

loc_2981D:
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx+20h], di
push	di
call	sub_21C86	; Call Procedure
pop	cx
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+1Ch], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	si, [bp+arg_8]
mov	al, [si]

loc_29861:
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_298B7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_298B7	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_298B7:		; CODE XREF: sub_29731+147j
			; sub_29731+15Cj
pop	di
pop	si
pop	bp

locret_298BA:		; Return Far from Procedure
retf
endp sub_29731



; Attributes: bp-based frame

proc sub_298BB far	; CODE XREF: sub_3E1DE+22DP
			; sub_3E1DE+250P
			; sub_4D5B0:loc_4D6A2P
			; sub_4D5B0+11DP
			; sub_4DB4D+410P
			; sub_4DB4D+46DP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	[bp+arg_A]
push	[bp+arg_8]
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]

loc_298D0:
push	cs
call	near ptr sub_29731 ; Call Procedure

loc_298D4:		; Add
add	sp, 0Ch
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_298DD:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 0
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_298BB



; Attributes: bp-based frame

proc sub_298FA far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
push	[bp+arg_C]
push	[bp+arg_A]
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_29731 ; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_2991C:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 1
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_298FA



; Attributes: bp-based frame

proc sub_2994E far	; CODE XREF: sub_2A755+233p
			; sub_2A755+256p
			; sub_2A755+461p
			; sub_2A755+484p
			; sub_2A755+640p
			; sub_2A755+663p
			; sub_2A755+865p
			; sub_2A755+888p
			; sub_2A755+A01p
			; sub_2A755+A24p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
push	[bp+arg_C]
push	[bp+arg_A]
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_29731 ; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_29978:
mov	[word ptr es:bx+8], 2

loc_2997E:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_2994E



; Attributes: bp-based frame

proc sub_299A2 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h

push	bp
mov	bp, sp
push	[bp+arg_E]
push	[bp+arg_C]
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_29731 ; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_299CC:
mov	[word ptr es:bx+8], 3
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_A]
mov	[es:bx+18h], ax
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_299A2



; Attributes: bp-based frame

proc idk_Mouse_s29A0B far
			; CODE XREF: _f010509_MainMenuScreen+197P
			; _f010509_MainMenuScreen+1FCP
			; _f010509_MainMenuScreen+255P
			; _f010509_MainMenuScreen+296P
			; _f010509_MainMenuScreen+2D7P
			; sub_1D1B5:loc_1D301P
			; sub_1D1B5:loc_1D367P
			; sub_1D1B5:loc_1D3CDP
			; sub_1D1B5+239P
			; sub_3CFC0:loc_3D10BP
			; sub_3CFC0:loc_3D14EP
			; sub_3CFC0+1C1P
			; sub_3CFC0+1E6P
			; sub_3CFC0:loc_3D1EDP
			; sub_3CFC0+25EP
			; sub_3DBA6:loc_3DD2DP
			; sub_3DBA6+1B2P
			; sub_3DBA6+293P
			; sub_3DBA6+2CDP
			; sub_3E1DE+273P
			; sub_3E1DE+296P
			; sub_3E1DE+2B9P
			; sub_3E1DE:loc_3E4BAP
			; sub_3EBA0+FDP
			; sub_3EBA0+13DP
			; sub_3F3C6+B8P
			; sub_3F3C6+101P
			; sub_3F7D8:loc_3F891P
			; sub_3F7D8:loc_3F8B4P
			; sub_3F7D8+FFP
			; sub_3F7D8+122P
			; sub_3F7D8+145P
			; sub_3FBE0+137P
			; sub_3FBE0+177P
			; sub_4067D+132P
			; sub_4067D+2B2P
			; sub_4067D+2E8P
			; sub_4067D+31EP
			; LBX_NewGame_s41A5F:loc_41C65P
			; sub_421DA+10FP
			; sub_421DA:loc_4239CP
			; sub_421DA+277P
			; sub_4D5B0+146P
			; sub_4D5B0+167P
			; sub_4DB4D+3A7P
			; sub_4DB4D+490P
			; sub_4DB4D+4B1P
			; ST_LoadMusicSoundfxIntro+82P
			; sub_56450+DAP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	si
push	di
mov	di, [bp+arg_8]
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_0]
mov	[es:bx], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	[es:bx+2], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	[es:bx+4], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 7
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_A]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [di]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_29AF5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_29AF5	; Jump if Greater or Equal (SF=OF)

loc_29ACD:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
add	al, 224		; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_29AF5:		; CODE XREF: idk_Mouse_s29A0B+ABj
			; idk_Mouse_s29A0B+C0j
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_Mouse_s29A0B



; Attributes: bp-based frame

proc sub_29B06 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
push	si
push	di
mov	cx, [bp+arg_0]
mov	di, [bp+arg_2]
mov	ax, [bp+arg_4]
cmp	ax, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jl	short loc_29B20	; Jump if Less (SF!=OF)
cmp	cx, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jle	short loc_29B26	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_29B20:		; CODE XREF: sub_29B06+12j
			; sub_29B06:loc_29B35j
mov	ax, 0D8F0h

loc_29B23:		; CODE XREF: sub_29B06:loc_29C92j
jmp	loc_29C95	; Jump

loc_29B26:		; CODE XREF: sub_29B06+18j
mov	ax, [bp+arg_6]
cmp	ax, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jl	short loc_29B35	; Jump if Less (SF!=OF)

loc_29B2F:		; Compare Two Operands
cmp	di, [idk_ScrnPosY199_w35EC8]
jle	short loc_29B37	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_29B35:		; CODE XREF: sub_29B06+27j
jmp	short loc_29B20	; Jump

loc_29B37:		; CODE XREF: sub_29B06+2Dj
cmp	cx, [idk_ScrnPosX0_w35EC2] ; Compare Two Operands
jl	short loc_29B50	; Jump if Less (SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]

loc_29B40:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_29B45:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	[es:bx], cx
jmp	short loc_29B64	; Jump

loc_29B50:		; CODE XREF: sub_29B06+35j
mov	ax, [idk_Mouse_w3C5A8]

loc_29B53:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_29B58:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [idk_ScrnPosX0_w35EC2]

loc_29B61:
mov	[es:bx], ax

loc_29B64:		; CODE XREF: sub_29B06+48j
mov	ax, [bp+arg_4]
cmp	ax, [idk_ScrnPosX319_w35EC6] ; Compare Two Operands
jg	short loc_29B80	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
jmp	short loc_29B91	; Jump

loc_29B80:		; CODE XREF: sub_29B06+65j
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [idk_ScrnPosX319_w35EC6]

loc_29B91:		; CODE XREF: sub_29B06+78j
mov	[es:bx+4], ax
cmp	di, [idk_ScrnPosY0_w35EC4] ; Compare Two Operands
jl	short loc_29BAF	; Jump if Less (SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx+2], di
jmp	short loc_29BC4	; Jump

loc_29BAF:		; CODE XREF: sub_29B06+93j
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [idk_ScrnPosY0_w35EC4]
mov	[es:bx+2], ax

loc_29BC4:		; CODE XREF: sub_29B06+A7j
mov	ax, [bp+arg_6]
cmp	ax, [idk_ScrnPosY199_w35EC8] ; Compare Two Operands
jg	short loc_29BE0	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
jmp	short loc_29BF1	; Jump

loc_29BE0:		; CODE XREF: sub_29B06+C5j
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [idk_ScrnPosY199_w35EC8]

loc_29BF1:		; CODE XREF: sub_29B06+D8j
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 7
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_A]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	si, [bp+arg_8]
mov	al, [si]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_29C87	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]

loc_29C4D:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_29C87	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_29C6D:
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_29C7A:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_29C87:		; CODE XREF: sub_29B06+142j
			; sub_29B06+157j
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1

loc_29C92:		; Jump
jmp	loc_29B23

loc_29C95:		; CODE XREF: sub_29B06:loc_29B23j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_29B06



; Attributes: bp-based frame

proc idk_Mouse_s29C99 far
			; CODE XREF: _f010509_MainMenuScreen+30FP
			; _f010509_MainMenuScreen+32FP
			; _f010509_MainMenuScreen+348P
			; _f010509_MainMenuScreen+35AP
			; _f010509_MainMenuScreen+36CP
			; _f010509_MainMenuScreen+37EP
			; sub_3CFC0+12AP
			; sub_3DBA6+162P
			; sub_3EBA0+156P
			; sub_3F3C6+11FP
			; sub_3F7D8+154P
			; sub_3FBE0+191P
			; sub_4067D+33BP
			; LBX_NewGame_s41A5F+1E5P
			; ST_LoadMusicSoundfxIntro+91P

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di
mov	di, [bp+arg_0]
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx], 500
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+2], 1F4h
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+4], 1F4h
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+6], 1F4h
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 7
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+0Ah], 0FFFFh
mov	ax, [idk_Mouse_w3C5A8]

loc_29D1B:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [di]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_29D32:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_29D7E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_29D7E	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
add	al, 224		; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 38
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_29D7E:		; CODE XREF: idk_Mouse_s29C99+A6j
			; idk_Mouse_s29C99+BBj
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_Mouse_s29C99



; Attributes: bp-based frame

proc sub_29D8F far	; CODE XREF: sub_1B341+2E1P

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h

push	bp
mov	bp, sp
push	si
push	di
mov	di, [bp+arg_E]
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
mov	[es:bx], ax
mov	ax, [idk_Mouse_w3C5A8]

loc_29DAE:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
mov	[es:bx+2], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_A]
mov	[es:bx+4], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_C]
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_10]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 9
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	[es:bx+18h], ax

loc_29E28:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_0]

loc_29E39:
mov	[es:bx+16h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [di]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_29EB8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]

loc_29E7E:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_29EB8	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_29E98:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_29EAB:		; Signed Multiply
imul	dx

loc_29EAD:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_29EB8:		; CODE XREF: sub_29D8F+EAj
			; sub_29D8F+FFj
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_29D8F



; Attributes: bp-based frame

proc sub_29EC9 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h

push	bp
mov	bp, sp
push	si
push	di
mov	cx, [bp+arg_0]
mov	si, [bp+arg_2]
mov	di, [bp+arg_4]
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx], cx
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[es:bx+2], si
mov	ax, di
imul	[bp+arg_8]	; Signed Multiply
mov	dx, cx
add	dx, ax		; Add
dec	dx		; Decrement by 1
mov	ax, [idk_Mouse_w3C5A8]
mov	bx, 26h	; '&'
push	dx
imul	bx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+4], ax
mov	ax, [bp+arg_6]
imul	[bp+arg_A]	; Signed Multiply
mov	dx, si
add	dx, ax		; Add
dec	dx		; Decrement by 1
mov	ax, [idk_Mouse_w3C5A8]
mov	bx, 26h	; '&'
push	dx
imul	bx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_10]
mov	[es:bx+0Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 0Ch
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_29F6C:		; Add
add	bx, ax
mov	[es:bx+18h], di
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_29F80:
mov	ax, [bp+arg_6]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+24h], 0

loc_29F9A:
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'

loc_29FA0:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_C]
mov	[es:bx+1Ch], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_E]
mov	[es:bx+1Eh], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_2A016	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_2A016	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_29FFA:		; Add
add	bx, ax
mov	al, [es:bx+24h]

loc_2A000:		; Add
add	al, 0E0h ; ''
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_2A016:		; CODE XREF: sub_29EC9+10Ej
			; sub_29EC9+123j
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_29EC9



; Attributes: bp-based frame

proc sub_2A027 far	; CODE XREF: sub_4067D+1A8P
			; sub_4067D+1DDP
			; sub_4067D+212P
			; sub_4067D+247P
			; sub_4067D+27CP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah

push	bp
mov	bp, sp
push	[bp+arg_14]
push	[bp+arg_12]
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_2A033:
push	[bp+arg_10]
push	[bp+arg_E]
push	[bp+arg_C]
push	[bp+arg_A]

loc_2A03F:
push	[bp+arg_8]
push	[bp+arg_6]
push	[bp+arg_4]

loc_2A048:
push	[bp+arg_2]

loc_2A04B:
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_2A058 ; Call Procedure
add	sp, 18h		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_2A027



; Attributes: bp-based frame

proc sub_2A058 far	; CODE XREF: sub_2A027+29p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch

push	bp
mov	bp, sp
push	si
push	di
mov	cx, [bp+arg_C]
mov	di, [bp+arg_E]

loc_2A063:		; Compare Two Operands
cmp	[bp+arg_12], 0
jnz	short loc_2A06E	; Jump if Not Zero (ZF=0)
mov	ax, ds
mov	[bp+arg_12], ax

loc_2A06E:		; CODE XREF: sub_2A058+Fj
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_0]

loc_2A07F:
mov	[es:bx], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	[es:bx+2], ax
mov	ax, [idk_Mouse_w3C5A8]

loc_2A09A:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2A09F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx]
add	ax, cx		; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+4], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]

loc_2A0D0:		; Add
add	ax, di
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_8]
mov	[es:bx+16h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_A]
mov	[es:bx+18h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	[es:bx+1Ch], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_6]
mov	[es:bx+1Eh], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_16]
mov	[es:bx+0Ah], ax
cmp	cx, di		; Compare Two Operands
jle	short loc_2A169	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+20h], 0
jmp	short loc_2A17D	; Jump

loc_2A169:		; CODE XREF: sub_2A058+F9j
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+20h], 1

loc_2A17D:		; CODE XREF: sub_2A058+10Fj
mov	ax, [idk_Mouse_w3C5A8]

loc_2A180:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+8], 6
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_12]
mov	[es:bx+1Ah], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_10]
mov	[es:bx+22h], ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	si, [bp+arg_14]
mov	al, [si]
mov	[es:bx+24h], al
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 60h ; '`' ; Compare Two Operands
jle	short loc_2A224	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 7Bh ; '{' ; Compare Two Operands
jge	short loc_2A224	; Jump if Greater or Equal (SF=OF)
mov	ax, [idk_Mouse_w3C5A8]

loc_2A1FF:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+24h]
add	al, 0E0h ; ''  ; Add
push	ax
mov	ax, [idk_Mouse_w3C5A8]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+24h], al

loc_2A224:		; CODE XREF: sub_2A058+18Dj
			; sub_2A058+1A2j
mov	ax, [idk_Mouse_w3C5A8]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_2A058



; Attributes: bp-based frame

proc sub_2A235 far	; CODE XREF: sub_2CF44+1068p

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+20h], 0	; Compare Two Operands
jz	short loc_2A257	; Jump if Zero (ZF=1)
jmp	loc_2A344	; Jump

loc_2A257:		; CODE XREF: sub_2A235+1Dj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
mov	[bp+var_2], ax
call	get__Mouse_w360A4 ; Call Procedure
add	ax, [idk_Mouse_w3C5A4] ; Add
mov	di, ax
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, si
mov	bx, 26h	; '&'
push	dx
imul	bx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Eh]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2A2BC:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+1Ch]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx

loc_2A2CA:		; Call Procedure
call	LXMUL@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_A], dx
mov	[bp+var_C], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx+4], di	; Compare Two Operands
jg	short loc_2A305	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Eh]
mov	[bp+var_4], ax
jmp	short loc_2A341	; Jump

loc_2A305:		; CODE XREF: sub_2A235+B8j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx], di	; Compare Two Operands
jl	short loc_2A32A	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Ch]
jmp	short loc_2A33E	; Jump

loc_2A32A:		; CODE XREF: sub_2A235+E0j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Ch]
add	ax, [bp+var_C]	; Add

loc_2A33E:		; CODE XREF: sub_2A235+F3j
mov	[bp+var_4], ax

loc_2A341:		; CODE XREF: sub_2A235+CEj
jmp	loc_2A420	; Jump

loc_2A344:		; CODE XREF: sub_2A235+1Fj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2A34F:		; Add
add	bx, ax

loc_2A351:
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
mov	[bp+var_2], ax
call	get__Mouse_w360A6 ; Call Procedure
add	ax, [idk_Mouse_w3C5A4] ; Add
mov	di, ax
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
sub	ax, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, si
mov	bx, 26h	; '&'
push	dx
imul	bx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Eh]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+1Ch]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_A], dx
mov	[bp+var_C], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx+6], di	; Compare Two Operands
jg	short loc_2A3F4	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Ch]

loc_2A3EF:
mov	[bp+var_4], ax
jmp	short loc_2A420	; Jump

loc_2A3F4:		; CODE XREF: sub_2A235+1A7j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx+2], di	; Compare Two Operands
jl	short loc_2A41A	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Eh]
jmp	short loc_2A41D	; Jump

loc_2A41A:		; CODE XREF: sub_2A235+1D0j
mov	ax, [bp+var_C]

loc_2A41D:		; CODE XREF: sub_2A235+1E3j
mov	[bp+var_4], ax

loc_2A420:		; CODE XREF: sub_2A235:loc_2A341j
			; sub_2A235+1BDj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_2A44A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
mov	[bp+var_4], ax

loc_2A44A:		; CODE XREF: sub_2A235+1FFj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
cmp	ax, [bp+var_4]	; Compare Two Operands
jge	short loc_2A474	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
mov	[bp+var_4], ax

loc_2A474:		; CODE XREF: sub_2A235+229j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Ah]
mov	[bp+var_6], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2A48F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+22h]
mov	[bp+var_8], ax
push	es
mov	ax, [bp+var_4]
mov	cx, [bp+var_6]
mov	bx, [bp+var_8]
mov	es, cx
mov	[es:bx], ax
pop	es
pop	di
pop	si
mov	sp, bp

loc_2A4B0:
pop	bp
retf			; Return Far from Procedure
endp sub_2A235



; Attributes: bp-based frame

proc sub_2A4B2 far	; CODE XREF: sub_24DAE+605p
			; sub_26026:loc_26572p

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2A4CA:
mov	ax, [es:bx+1Ah]

loc_2A4CE:
mov	[bp+var_6], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2A4D8:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+22h]

loc_2A4E2:
mov	[bp+var_8], ax
push	es
mov	cx, [bp+var_6]
mov	bx, [bp+var_8]
mov	es, cx
mov	ax, [es:bx]
mov	[bp+var_4], ax

loc_2A4F4:
pop	es
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Eh]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+1Ch]	; Integer Subtraction
mov	[bp+var_2], ax

loc_2A51C:
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2A52F:
mov	ax, [bp+var_4]
sub	ax, [es:bx+1Ch]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR
mov	ax, 64h	; 'd'
pop	cx
pop	bx

loc_2A540:		; Call Procedure
call	LXMUL@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	di, ax
add	di, 5		; Add
cmp	di, 64h	; 'd'   ; Compare Two Operands
jle	short loc_2A569	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si

loc_2A558:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
jmp	short loc_2A5A1	; Jump

loc_2A569:		; CODE XREF: sub_2A4B2+A2j
xor	ax, ax		; Logical Exclusive OR

loc_2A56B:
mov	dx, 64h	; 'd'
push	ax
push	dx
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure

loc_2A580:
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_A], dx
mov	[bp+var_C], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Ch]

loc_2A59E:		; Add
add	ax, [bp+var_C]

loc_2A5A1:		; CODE XREF: sub_2A4B2+B5j
mov	[bp+var_4], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
cmp	ax, [bp+var_4]	; Compare Two Operands
jge	short loc_2A5CE	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
mov	[bp+var_4], ax

loc_2A5CE:		; CODE XREF: sub_2A4B2+106j
push	es
mov	ax, [bp+var_4]
mov	cx, [bp+var_6]
mov	bx, [bp+var_8]
mov	es, cx
mov	[es:bx], ax
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2A4B2



; Attributes: bp-based frame

proc sub_2A5E4 far	; CODE XREF: sub_24DAE+612p
			; sub_26026:loc_2657Fp

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Ah]
mov	[bp+var_6], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+22h]
mov	[bp+var_8], ax
push	es
mov	cx, [bp+var_6]
mov	bx, [bp+var_8]
mov	es, cx
mov	ax, [es:bx]
mov	[bp+var_4], ax
pop	es

loc_2A627:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Eh]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+1Ch]	; Integer Subtraction
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_4]
sub	ax, [es:bx+1Ch]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR
mov	ax, 64h	; 'd'

loc_2A670:
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	di, ax
sub	di, 5		; Integer Subtraction
or	di, di		; Logical Inclusive OR
jge	short loc_2A69A	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
jmp	short loc_2A6D2	; Jump

loc_2A69A:		; CODE XREF: sub_2A5E4+A1j
xor	ax, ax		; Logical Exclusive OR
mov	dx, 64h	; 'd'
push	ax
push	dx
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_2]
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx

loc_2A6AC:		; Call Procedure
call	LXMUL@
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+var_A], dx
mov	[bp+var_C], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Ch]
add	ax, [bp+var_C]	; Add

loc_2A6D2:		; CODE XREF: sub_2A5E4+B4j
mov	[bp+var_4], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_2A6FF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
mov	[bp+var_4], ax

loc_2A6FF:		; CODE XREF: sub_2A5E4+105j
push	es
mov	ax, [bp+var_4]
mov	cx, [bp+var_6]
mov	bx, [bp+var_8]
mov	es, cx
mov	[es:bx], ax
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2A5E4



;
; mov	  word_3C5A8, 1
; mov	  word_36A32, 0FFFFh
; mov	  word_36A4A, 0
; mov	  word_36A6A, 0
; mov	  word_36A70, 0FFFFh
; Attributes: bp-based frame

proc setFlagsMaybeMouseEGA far
			; CODE XREF: _f010509_MainMenuScreen:loc_13958P
			; sub_1D1B5+F1P
			; sub_1D40D+8P
			; sub_28583+Fp
			; sub_28583:loc_2891Ep
			; sub_2A755+38p
			; sub_2A755+2D8p
			; sub_2A755+49Cp
			; sub_2A755+69Fp
			; sub_2A755+89Cp
			; sub_2A755+A66p
			; sub_2B1F9+1Cp
			; sub_2B1F9+23Fp
			; idk_Mouse_s2B8B1+C4p
			; sub_2E2F1+4p
			; sub_3CFC0:loc_3D0E1P
			; sub_3DBA6+159P
			; sub_3E1DE+1D4P
			; sub_3EBA0+B2P
			; sub_3F3C6+74P
			; idk_Load_NEWGAME_LBX+42P
			; sub_3F7D8+95P
			; sub_3FBE0+F9P
			; sub_4067D+EFP
			; LBX_NewGame_s41A5F:loc_41C3BP
			; idk_BuildingWorlds+7DP
			; sub_4D5B0:loc_4D67DP
			; sub_4D5B0:loc_4D782P
			; sub_4DB4D:loc_4DDD3P
			; sub_4F44D:yesEqualP
			; ST_LoadMusicSoundfxIntro+67P
			; sub_56450+1BP
			; sub_56450+BFP
			; sub_56450+114P
			; sub_56450+11EP
push	bp
mov	bp, sp
mov	[idk_Mouse_w3C5A8], 1
mov	[w36A32], 0FFFFh
mov	[word_36A4A], 0
mov	[word_36A6A], 0
mov	[word_36A70], 0FFFFh
pop	bp
retf			; Return Far from Procedure
endp setFlagsMaybeMouseEGA



; Attributes: bp-based frame

proc sub_2A738 far

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	dx, [bp+arg_0]
or	dx, dx		; Logical Inclusive OR
jle	short loc_2A74D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	dx, 0Fh		; Compare Two Operands
jge	short loc_2A74D	; Jump if Greater or Equal (SF=OF)
mov	[word_36A50], dx
jmp	short loc_2A753	; Jump

loc_2A74D:		; CODE XREF: sub_2A738+8j
			; sub_2A738+Dj
mov	[word_36A50], 0

loc_2A753:		; CODE XREF: sub_2A738+13j
pop	bp
retf			; Return Far from Procedure
endp sub_2A738



; Attributes: bp-based frame

proc sub_2A755 far

var_34=	byte ptr -34h
var_2E=	word ptr -2Eh
var_2C=	word ptr -2Ch
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh
arg_1A=	word ptr  20h
arg_1C=	word ptr  22h
arg_1E=	word ptr  24h
arg_20=	word ptr  26h
arg_22=	word ptr  28h
arg_24=	word ptr  2Ah
arg_26=	word ptr  2Ch
arg_28=	word ptr  2Eh

push	bp
mov	bp, sp
sub	sp, 34h		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_C]
mov	[word_36A3A], 1
mov	[word_36A4E], 1

loc_2A76C:
mov	[word_36A52], 0
call	sub_1A510	; Call Procedure
mov	[bp+var_22], ax
call	sub_1A4FB	; Call Procedure
mov	[bp+var_26], ax
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_2B9C4 ; Call Procedure
pop	cx
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, [bp+arg_0]
add	ax, [bp+arg_4]	; Add
mov	[bp+var_1A], ax
call	sub_1BBF9	; Call Procedure

loc_2A79E:
mov	[bp+var_8], ax

loc_2A7A1:		; Call Procedure
call	sub_1A542
mov	dx, [bp+var_8]
add	dx, ax		; Add
mov	[bp+var_6], dx

loc_2A7AE:
mov	[bp+var_2], 0
xor	si, si		; Logical Exclusive OR
mov	[bp+var_4], 0
mov	ax, [bp+arg_8]
mov	[bp+var_10], ax
mov	ax, [bp+arg_2]
add	ax, [bp+var_6]	; Add
mov	[bp+var_A], ax
mov	[bp+var_12], 0

loc_2A7CE:
mov	[bp+var_1C], 0
jmp	short loc_2A81E	; Jump

loc_2A7D5:		; CODE XREF: sub_2A755+CDj
mov	ax, 2
push	ax
push	[bp+var_10]
lea	ax, [bp+var_34]	; Load Effective Address
push	ax
call	sub_1CD80	; Call Procedure
add	sp, 6		; Add
cmp	[bp+var_34], 0	; Compare Two Operands

loc_2A7EC:		; Jump if Zero (ZF=1)
jz	short loc_2A813
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_2A810	; Jump if Not Zero (ZF=0)
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2A808	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2A810	; Jump if Not Zero (ZF=0)

loc_2A808:		; CODE XREF: sub_2A755+ABj
mov	[bp+var_12], si
mov	[bp+var_4], 1

loc_2A810:		; CODE XREF: sub_2A755+9Dj
			; sub_2A755+B1j
inc	si		; Increment by 1
jmp	short loc_2A818	; Jump

loc_2A813:		; CODE XREF: sub_2A755:loc_2A7ECj
mov	[bp+var_2], 1

loc_2A818:		; CODE XREF: sub_2A755+BCj
mov	ax, [bp+arg_A]
add	[bp+var_10], ax	; Add

loc_2A81E:		; CODE XREF: sub_2A755+7Ej
cmp	[bp+var_2], 0	; Compare Two Operands
jz	short loc_2A7D5	; Jump if Zero (ZF=1)
mov	[bp+var_4], si
xor	si, si		; Logical Exclusive OR

loc_2A829:		; Compare Two Operands
cmp	[word ptr di], 0
jl	short loc_2A837	; Jump if Less (SF!=OF)
mov	ax, [di]
cmp	ax, [bp+var_4]	; Compare Two Operands
jge	short loc_2A837	; Jump if Greater or Equal (SF=OF)
mov	si, [di]

loc_2A837:		; CODE XREF: sub_2A755+D7j
			; sub_2A755+DEj
mov	ax, si
add	ax, [bp+arg_10]	; Add
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_2A84F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
sub	ax, [bp+arg_10]	; Integer Subtraction
mov	si, ax
or	si, si		; Logical Inclusive OR
jge	short loc_2A84F	; Jump if Greater or Equal (SF=OF)
xor	si, si		; Logical Exclusive OR

loc_2A84F:		; CODE XREF: sub_2A755+EAj
			; sub_2A755+F6j
mov	[bp+var_C], si
mov	ax, si
imul	[bp+arg_A]	; Signed Multiply
mov	dx, [bp+arg_8]
add	dx, ax		; Add
mov	[bp+var_10], dx
mov	[bp+var_1C], 0
jmp	short loc_2A8BF	; Jump

loc_2A866:		; CODE XREF: sub_2A755+175j
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2A873	; Jump if Not Zero (ZF=0)
mov	[bp+var_24], 1
jmp	short loc_2A881	; Jump

loc_2A873:		; CODE XREF: sub_2A755+115j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
mov	ax, [bx]
mov	[bp+var_24], ax

loc_2A881:		; CODE XREF: sub_2A755+11Cj
push	[bp+arg_28]
mov	ax, 4D70h
push	ax
push	[bp+arg_26]
push	[bp+arg_24]
push	[bp+arg_22]
push	[bp+arg_20]
push	[bp+arg_1E]
push	si
push	di
push	[bp+var_24]
push	[bp+var_10]
push	[bp+arg_4]
push	[bp+var_A]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	ax, [bp+arg_A]
add	[bp+var_10], ax	; Add
inc	si		; Increment by 1
inc	[bp+var_1C]	; Increment by 1

loc_2A8BF:		; CODE XREF: sub_2A755+10Fj
cmp	si, [bp+var_4]	; Compare Two Operands
jge	short loc_2A8CC	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_1C]
cmp	ax, [bp+arg_10]	; Compare Two Operands
jl	short loc_2A866	; Jump if Less (SF!=OF)

loc_2A8CC:		; CODE XREF: sub_2A755+16Dj
mov	ax, [bp+var_1C]
mov	[bp+var_2A], ax
cmp	[word ptr di], 0 ; Compare Two Operands
jl	short loc_2A8DE	; Jump if Less (SF!=OF)
mov	ax, [di]
cmp	ax, [bp+var_4]	; Compare Two Operands
jl	short loc_2A8F7	; Jump if Less (SF!=OF)

loc_2A8DE:		; CODE XREF: sub_2A755+180j
cmp	[bp+var_12], 0	; Compare Two Operands
jle	short loc_2A8F3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_12]
cmp	ax, [bp+var_4]	; Compare Two Operands
jge	short loc_2A8F3	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_C]
mov	[di], ax
jmp	short loc_2A8F7	; Jump

loc_2A8F3:		; CODE XREF: sub_2A755+18Dj
			; sub_2A755+195j
mov	[word ptr di], 0FFFFh

loc_2A8F7:		; CODE XREF: sub_2A755+187j
			; sub_2A755+19Cj
push	[bp+var_22]
call	sub_1A4E6	; Call Procedure
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_18], 0
push	[idk_Value_w36A38]
mov	ax, 4D70h
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_2A924:		; Logical Exclusive OR
xor	ax, ax
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 1
push	ax
lea	ax, [bp+var_18]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
mov	[bp+var_E], ax

loc_2A94B:		; Compare Two Operands
cmp	[bp+var_C], 0
jnz	short loc_2A958	; Jump if Not Zero (ZF=0)

loc_2A951:
mov	[bp+var_2C], 1
jmp	short loc_2A95D	; Jump

loc_2A958:		; CODE XREF: sub_2A755+1FAj
mov	[bp+var_2C], 0

loc_2A95D:		; CODE XREF: sub_2A755+201j
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_2A969	; Jump if Less (SF!=OF)
mov	[bp+var_2E], 1
jmp	short loc_2A96E	; Jump

loc_2A969:		; CODE XREF: sub_2A755+20Bj
mov	[bp+var_2E], 0

loc_2A96E:		; CODE XREF: sub_2A755+212j
mov	ax, 0FFFFh
push	ax
mov	ax, 4D74h
push	ax
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
push	[bp+arg_16]
mov	ax, 4D70h

loc_2A980:
push	ax
push	[bp+arg_14]
push	[bp+arg_12]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_1E], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 4D76h
push	ax
lea	ax, [bp+var_2E]	; Load Effective Address
push	ax
push	[bp+arg_1C]
mov	ax, 4D70h
push	ax
push	[bp+arg_1A]
push	[bp+arg_18]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_20], ax
mov	[bp+var_2], 0

loc_2A9B9:
mov	[bp+var_14], 0
mov	[bp+var_12], 0
mov	ax, [di]
mov	[bp+var_28], ax

loc_2A9C8:		; Jump
jmp	loc_2B1B1

loc_2A9CB:		; CODE XREF: sub_2A755+A62j
call	_f020105_bios_timeofday	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_2B97A ; Call Procedure
mov	[bp+var_12], ax
cmp	[bp+var_12], 0	; Compare Two Operands
jl	short loc_2A9EC	; Jump if Less (SF!=OF)
cmp	[bp+var_12], 0	; Compare Two Operands
jle	short loc_2A9F1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_12]
cmp	ax, [bp+var_1E]	; Compare Two Operands
jge	short loc_2A9F1	; Jump if Greater or Equal (SF=OF)

loc_2A9EC:		; CODE XREF: sub_2A755+287j
mov	[bp+var_2], 1

loc_2A9F1:		; CODE XREF: sub_2A755+28Dj
			; sub_2A755+295j
cmp	[bp+var_12], 0	; Compare Two Operands
jle	short loc_2AA14	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_12]

loc_2A9FA:		; Compare Two Operands
cmp	ax, [bp+var_1E]
jge	short loc_2AA14	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_12]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2AA07:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2AA1C	; Jump if Zero (ZF=1)

loc_2AA14:		; CODE XREF: sub_2A755+2A0j
			; sub_2A755+2A8j
mov	ax, [bp+var_12]
cmp	ax, [bp+var_E]	; Compare Two Operands
jnz	short loc_2AA21	; Jump if Not Zero (ZF=0)

loc_2AA1C:		; CODE XREF: sub_2A755+2BDj
mov	[bp+var_2], 0

loc_2AA21:		; CODE XREF: sub_2A755+2C5j
mov	ax, [bp+var_12]

loc_2AA24:		; Compare Two Operands
cmp	ax, [bp+var_1E]
jz	short loc_2AA2C	; Jump if Zero (ZF=1)
jmp	loc_2ABE5	; Jump

loc_2AA2C:		; CODE XREF: sub_2A755+2D2j
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
push	[bp+var_26]	; int

loc_2AA33:		; Call Procedure
call	sub_1A4E6
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_C]

loc_2AA4A:		; Integer Subtraction
sub	ax, [bp+arg_10]
mov	si, ax
or	si, si		; Logical Inclusive OR
jge	short loc_2AA55	; Jump if Greater or Equal (SF=OF)
xor	si, si		; Logical Exclusive OR

loc_2AA55:		; CODE XREF: sub_2A755+2FCj
mov	[bp+var_C], si
mov	[word ptr di], 0FFFFh
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_2AA60:
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2AA70	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2AA77	; Jump if Not Zero (ZF=0)

loc_2AA70:		; CODE XREF: sub_2A755+313j
mov	ax, [bp+var_C]

loc_2AA73:
mov	[di], ax
jmp	short loc_2AA9C	; Jump

loc_2AA77:		; CODE XREF: sub_2A755+319j
jmp	short loc_2AA92	; Jump

loc_2AA79:		; CODE XREF: sub_2A755+345j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2AA8D	; Jump if Not Zero (ZF=0)

loc_2AA87:		; Compare Two Operands
cmp	[bp+arg_E], 0
jnz	short loc_2AA91	; Jump if Not Zero (ZF=0)

loc_2AA8D:		; CODE XREF: sub_2A755+330j
mov	[di], si
jmp	short loc_2AA9C	; Jump

loc_2AA91:		; CODE XREF: sub_2A755+336j
inc	si		; Increment by 1

loc_2AA92:		; CODE XREF: sub_2A755:loc_2AA77j
mov	ax, [bp+var_C]
add	ax, [bp+arg_10]	; Add
cmp	ax, si		; Compare Two Operands
jg	short loc_2AA79	; Jump if Greater (ZF=0	& SF=OF)

loc_2AA9C:		; CODE XREF: sub_2A755+320j
			; sub_2A755+33Aj
mov	si, [bp+var_C]
mov	ax, si
imul	[bp+arg_A]	; Signed Multiply

loc_2AAA4:
mov	dx, [bp+arg_8]
add	dx, ax		; Add
mov	[bp+var_10], dx

loc_2AAAC:
mov	[bp+var_1C], 0
mov	ax, [bp+arg_2]
add	ax, [bp+var_6]	; Add
mov	[bp+var_A], ax
jmp	short loc_2AB15	; Jump

loc_2AABC:		; CODE XREF: sub_2A755+3CBj
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2AAC9	; Jump if Not Zero (ZF=0)
mov	[bp+var_24], 1
jmp	short loc_2AAD7	; Jump

loc_2AAC9:		; CODE XREF: sub_2A755+36Bj
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]

loc_2AAD0:		; Add
add	bx, ax
mov	ax, [bx]
mov	[bp+var_24], ax

loc_2AAD7:		; CODE XREF: sub_2A755+372j
push	[bp+arg_28]
mov	ax, 4D70h
push	ax
push	[bp+arg_26]
push	[bp+arg_24]
push	[bp+arg_22]
push	[bp+arg_20]
push	[bp+arg_1E]
push	si
push	di
push	[bp+var_24]
push	[bp+var_10]
push	[bp+arg_4]
push	[bp+var_A]
push	[bp+arg_0]

loc_2AAFE:
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	ax, [bp+arg_A]
add	[bp+var_10], ax	; Add
inc	si		; Increment by 1
inc	[bp+var_1C]	; Increment by 1

loc_2AB15:		; CODE XREF: sub_2A755+365j
cmp	si, [bp+var_4]	; Compare Two Operands
jge	short loc_2AB22	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_1C]
cmp	ax, [bp+arg_10]	; Compare Two Operands
jl	short loc_2AABC	; Jump if Less (SF!=OF)

loc_2AB22:		; CODE XREF: sub_2A755+3C3j
mov	ax, [bp+var_1C]
mov	[bp+var_2A], ax
push	[bp+var_22]
call	sub_1A4E6	; Call Procedure
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_18], 0
push	[idk_Value_w36A38]
mov	ax, 4D70h
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 1
push	ax
lea	ax, [bp+var_18]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_2AB86	; Jump if Not Zero (ZF=0)
mov	[bp+var_2C], 1
jmp	short loc_2AB8B	; Jump

loc_2AB86:		; CODE XREF: sub_2A755+428j
mov	[bp+var_2C], 0

loc_2AB8B:		; CODE XREF: sub_2A755+42Fj
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_2AB97	; Jump if Less (SF!=OF)
mov	[bp+var_2E], 1
jmp	short loc_2AB9C	; Jump

loc_2AB97:		; CODE XREF: sub_2A755+439j
mov	[bp+var_2E], 0

loc_2AB9C:		; CODE XREF: sub_2A755+440j
mov	ax, 0FFFFh
push	ax
mov	ax, 4D74h
push	ax
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
push	[bp+arg_16]
mov	ax, 4D70h
push	ax
push	[bp+arg_14]
push	[bp+arg_12]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_1E], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 4D76h
push	ax
lea	ax, [bp+var_2E]	; Load Effective Address
push	ax
push	[bp+arg_1C]
mov	ax, 4D70h
push	ax
push	[bp+arg_1A]
push	[bp+arg_18]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_20], ax
jmp	loc_2ADC1	; Jump

loc_2ABE5:		; CODE XREF: sub_2A755+2D4j
mov	ax, [bp+var_12]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_2ABF0	; Jump if Zero (ZF=1)
jmp	loc_2ADC1	; Jump

loc_2ABF0:		; CODE XREF: sub_2A755+496j
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
push	[bp+var_26]	; int
call	sub_1A4E6	; Call Procedure
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_C]
add	ax, [bp+arg_10]	; Add
mov	si, ax
mov	ax, si
add	ax, [bp+arg_10]	; Add
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_2AC2B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
sub	ax, [bp+arg_10]	; Integer Subtraction
mov	si, ax
or	si, si		; Logical Inclusive OR
jge	short loc_2AC2B	; Jump if Greater or Equal (SF=OF)
xor	si, si		; Logical Exclusive OR

loc_2AC2B:		; CODE XREF: sub_2A755+4C6j
			; sub_2A755+4D2j
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_2AC33	; Jump if Less (SF!=OF)
mov	si, [bp+var_C]

loc_2AC33:		; CODE XREF: sub_2A755+4D9j
mov	[bp+var_C], si
mov	[word ptr di], 0FFFFh
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2AC4F	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2AC56	; Jump if Not Zero (ZF=0)

loc_2AC4F:		; CODE XREF: sub_2A755+4F2j
mov	ax, [bp+var_C]
mov	[di], ax
jmp	short loc_2AC7B	; Jump

loc_2AC56:		; CODE XREF: sub_2A755+4F8j
jmp	short loc_2AC71	; Jump

loc_2AC58:		; CODE XREF: sub_2A755+524j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2AC6C	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2AC70	; Jump if Not Zero (ZF=0)

loc_2AC6C:		; CODE XREF: sub_2A755+50Fj
mov	[di], si
jmp	short loc_2AC7B	; Jump

loc_2AC70:		; CODE XREF: sub_2A755+515j
inc	si		; Increment by 1

loc_2AC71:		; CODE XREF: sub_2A755:loc_2AC56j
mov	ax, [bp+var_C]
add	ax, [bp+arg_10]	; Add
cmp	ax, si		; Compare Two Operands
jg	short loc_2AC58	; Jump if Greater (ZF=0	& SF=OF)

loc_2AC7B:		; CODE XREF: sub_2A755+4FFj
			; sub_2A755+519j
mov	[bp+var_1C], 0
mov	si, [bp+var_C]
mov	ax, si
imul	[bp+arg_A]	; Signed Multiply
mov	dx, [bp+arg_8]
add	dx, ax		; Add
mov	[bp+var_10], dx
mov	ax, [bp+arg_2]
add	ax, [bp+var_6]	; Add
mov	[bp+var_A], ax
jmp	short loc_2ACF4	; Jump

loc_2AC9B:		; CODE XREF: sub_2A755+5AAj
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2ACA8	; Jump if Not Zero (ZF=0)
mov	[bp+var_24], 1
jmp	short loc_2ACB6	; Jump

loc_2ACA8:		; CODE XREF: sub_2A755+54Aj
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
mov	ax, [bx]
mov	[bp+var_24], ax

loc_2ACB6:		; CODE XREF: sub_2A755+551j
push	[bp+arg_28]
mov	ax, 4D70h
push	ax
push	[bp+arg_26]
push	[bp+arg_24]
push	[bp+arg_22]
push	[bp+arg_20]
push	[bp+arg_1E]
push	si
push	di

loc_2ACCE:
push	[bp+var_24]
push	[bp+var_10]
push	[bp+arg_4]
push	[bp+var_A]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	ax, [bp+arg_A]
add	[bp+var_10], ax	; Add
inc	si		; Increment by 1
inc	[bp+var_1C]	; Increment by 1

loc_2ACF4:		; CODE XREF: sub_2A755+544j
cmp	si, [bp+var_4]	; Compare Two Operands
jge	short loc_2AD01	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_1C]
cmp	ax, [bp+arg_10]	; Compare Two Operands
jl	short loc_2AC9B	; Jump if Less (SF!=OF)

loc_2AD01:		; CODE XREF: sub_2A755+5A2j
mov	ax, [bp+var_1C]
mov	[bp+var_2A], ax
push	[bp+var_22]
call	sub_1A4E6	; Call Procedure
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_18], 0
push	[idk_Value_w36A38]
mov	ax, 4D70h
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_2AD2E:		; Logical Exclusive OR
xor	ax, ax
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 1
push	ax
lea	ax, [bp+var_18]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_2AD65	; Jump if Not Zero (ZF=0)
mov	[bp+var_2C], 1
jmp	short loc_2AD6A	; Jump

loc_2AD65:		; CODE XREF: sub_2A755+607j
mov	[bp+var_2C], 0

loc_2AD6A:		; CODE XREF: sub_2A755+60Ej
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_2AD76	; Jump if Less (SF!=OF)
mov	[bp+var_2E], 1
jmp	short loc_2AD7B	; Jump

loc_2AD76:		; CODE XREF: sub_2A755+618j
mov	[bp+var_2E], 0

loc_2AD7B:		; CODE XREF: sub_2A755+61Fj
mov	ax, 0FFFFh
push	ax
mov	ax, 4D74h
push	ax
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
push	[bp+arg_16]
mov	ax, 4D70h
push	ax
push	[bp+arg_14]
push	[bp+arg_12]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_1E], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 4D76h
push	ax
lea	ax, [bp+var_2E]	; Load Effective Address
push	ax
push	[bp+arg_1C]
mov	ax, 4D70h
push	ax
push	[bp+arg_1A]
push	[bp+arg_18]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_20], ax

loc_2ADC1:		; CODE XREF: sub_2A755+48Dj
			; sub_2A755+498j
cmp	[idk_Flag_w36A4C], 0 ; Compare Two Operands
jz	short loc_2ADE9	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_27AFB ; Call Procedure
mov	[bp+var_16], ax
cmp	[bp+var_16], 0	; Compare Two Operands
jle	short loc_2ADE9	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_16]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
mov	[di], ax

loc_2ADE9:		; CODE XREF: sub_2A755+671j
			; sub_2A755+67Ej
cmp	[word_36A52], 1	; Compare Two Operands
jz	short loc_2ADF3	; Jump if Zero (ZF=1)
jmp	loc_2AFE6	; Jump

loc_2ADF3:		; CODE XREF: sub_2A755+699j
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
push	[bp+var_26]	; int
call	sub_1A4E6	; Call Procedure
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_C]
inc	ax		; Increment by 1
mov	si, ax
mov	ax, [bp+var_C]
add	ax, [bp+arg_10]	; Add
mov	[bp+var_2A], ax
jmp	short loc_2AE23	; Jump

loc_2AE1F:		; CODE XREF: sub_2A755+6E3j
			; sub_2A755+6E9j
inc	si		; Increment by 1
inc	[bp+var_2A]	; Increment by 1

loc_2AE23:		; CODE XREF: sub_2A755+6C8j
mov	ax, [bp+var_2A]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2AE3A	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2A]
cmp	ax, [bp+var_4]	; Compare Two Operands
jl	short loc_2AE1F	; Jump if Less (SF!=OF)

loc_2AE3A:		; CODE XREF: sub_2A755+6DBj
cmp	[bp+arg_E], 0	; Compare Two Operands
jz	short loc_2AE1F	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2A]
cmp	ax, [bp+var_4]	; Compare Two Operands
jl	short loc_2AE4B	; Jump if Less (SF!=OF)
mov	si, [bp+var_C]

loc_2AE4B:		; CODE XREF: sub_2A755+6F1j
mov	ax, si
add	ax, [bp+arg_10]	; Add
cmp	ax, [bp+var_4]	; Compare Two Operands

loc_2AE53:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_2AE63
mov	ax, [bp+var_4]
sub	ax, [bp+arg_10]	; Integer Subtraction
mov	si, ax
or	si, si		; Logical Inclusive OR
jge	short loc_2AE63	; Jump if Greater or Equal (SF=OF)
xor	si, si		; Logical Exclusive OR

loc_2AE63:		; CODE XREF: sub_2A755:loc_2AE53j
			; sub_2A755+70Aj
mov	[bp+var_C], si
mov	ax, si
imul	[bp+arg_A]	; Signed Multiply
mov	dx, [bp+arg_8]
add	dx, ax		; Add

loc_2AE70:
mov	[bp+var_10], dx
mov	[bp+var_1C], 0
mov	ax, [bp+arg_2]

loc_2AE7B:		; Add
add	ax, [bp+var_6]
mov	[bp+var_A], ax
jmp	short loc_2AEDC	; Jump

loc_2AE83:		; CODE XREF: sub_2A755+792j
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2AE90	; Jump if Not Zero (ZF=0)
mov	[bp+var_24], 1
jmp	short loc_2AE9E	; Jump

loc_2AE90:		; CODE XREF: sub_2A755+732j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
mov	ax, [bx]
mov	[bp+var_24], ax

loc_2AE9E:		; CODE XREF: sub_2A755+739j
push	[bp+arg_28]
mov	ax, 4D70h
push	ax
push	[bp+arg_26]
push	[bp+arg_24]
push	[bp+arg_22]

loc_2AEAE:
push	[bp+arg_20]
push	[bp+arg_1E]
push	si
push	di
push	[bp+var_24]
push	[bp+var_10]
push	[bp+arg_4]
push	[bp+var_A]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	ax, [bp+arg_A]
add	[bp+var_10], ax	; Add
inc	si		; Increment by 1
inc	[bp+var_1C]	; Increment by 1

loc_2AEDC:		; CODE XREF: sub_2A755+72Cj
cmp	si, [bp+var_4]	; Compare Two Operands
jge	short loc_2AEE9	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_1C]
cmp	ax, [bp+arg_10]	; Compare Two Operands
jl	short loc_2AE83	; Jump if Less (SF!=OF)

loc_2AEE9:		; CODE XREF: sub_2A755+78Aj
mov	ax, [bp+var_1C]
mov	[bp+var_2A], ax
mov	ax, si
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2AF04	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2AF2C	; Jump if Not Zero (ZF=0)

loc_2AF04:		; CODE XREF: sub_2A755+7A7j
mov	ax, [bp+var_2A]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
push	ax
mov	ax, [bp+var_2A]

loc_2AF1A:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
pop	ax
mov	[bx], ax

loc_2AF2C:		; CODE XREF: sub_2A755+7ADj
push	[bp+var_22]
call	sub_1A4E6	; Call Procedure
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int

loc_2AF3B:		; Call Procedure
call	idk_PalFnt_s1AB64
add	sp, 6		; Add
mov	[bp+var_18], 0
push	[idk_Value_w36A38]
mov	ax, 4D70h
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 1
push	ax
lea	ax, [bp+var_18]	; Load Effective Address

loc_2AF66:
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_2AF8A	; Jump if Not Zero (ZF=0)
mov	[bp+var_2C], 1
jmp	short loc_2AF8F	; Jump

loc_2AF8A:		; CODE XREF: sub_2A755+82Cj
mov	[bp+var_2C], 0

loc_2AF8F:		; CODE XREF: sub_2A755+833j
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_2AF9B	; Jump if Less (SF!=OF)
mov	[bp+var_2E], 1
jmp	short loc_2AFA0	; Jump

loc_2AF9B:		; CODE XREF: sub_2A755+83Dj
mov	[bp+var_2E], 0

loc_2AFA0:		; CODE XREF: sub_2A755+844j
mov	ax, 0FFFFh
push	ax
mov	ax, 4D74h
push	ax
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
push	[bp+arg_16]
mov	ax, 4D70h
push	ax
push	[bp+arg_14]
push	[bp+arg_12]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_1E], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 4D76h
push	ax
lea	ax, [bp+var_2E]	; Load Effective Address
push	ax
push	[bp+arg_1C]
mov	ax, 4D70h
push	ax
push	[bp+arg_1A]
push	[bp+arg_18]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_20], ax

loc_2AFE6:		; CODE XREF: sub_2A755+69Bj
db 83h,3Eh,42h,4Dh,0FFh	; <BAD>cmp     [word_36A52], 0FFFFh ; Compare Two Operands
jz	short loc_2AFF0	; Jump if Zero (ZF=1)
jmp	loc_2B182	; Jump

loc_2AFF0:		; CODE XREF: sub_2A755+896j
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
push	[bp+var_26]	; int
call	sub_1A4E6	; Call Procedure
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_C]
dec	ax		; Decrement by 1
mov	si, ax
or	si, si		; Logical Inclusive OR
jge	short loc_2B017	; Jump if Greater or Equal (SF=OF)
xor	si, si		; Logical Exclusive OR

loc_2B017:		; CODE XREF: sub_2A755+8BEj
jmp	short loc_2B01A	; Jump

loc_2B019:		; CODE XREF: sub_2A755+8D5j
			; sub_2A755+8DBj
dec	si		; Decrement by 1

loc_2B01A:		; CODE XREF: sub_2A755:loc_2B017j
mov	ax, si

loc_2B01C:		; Shift	Logical	Left
shl	ax, 1
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2B02C	; Jump if Not Zero (ZF=0)

loc_2B028:		; Logical Inclusive OR
or	si, si
jg	short loc_2B019	; Jump if Greater (ZF=0	& SF=OF)

loc_2B02C:		; CODE XREF: sub_2A755+8D1j
cmp	[bp+arg_E], 0	; Compare Two Operands
jz	short loc_2B019	; Jump if Zero (ZF=1)

loc_2B032:
mov	[bp+var_C], si
mov	ax, si
imul	[bp+arg_A]	; Signed Multiply
mov	dx, [bp+arg_8]
add	dx, ax		; Add
mov	[bp+var_10], dx

loc_2B042:
mov	[bp+var_1C], 0
mov	ax, [bp+arg_2]
add	ax, [bp+var_6]	; Add
mov	[bp+var_A], ax
jmp	short loc_2B0AB	; Jump

loc_2B052:		; CODE XREF: sub_2A755+961j
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2B05F	; Jump if Not Zero (ZF=0)
mov	[bp+var_24], 1
jmp	short loc_2B06D	; Jump

loc_2B05F:		; CODE XREF: sub_2A755+901j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
mov	ax, [bx]

loc_2B06A:
mov	[bp+var_24], ax

loc_2B06D:		; CODE XREF: sub_2A755+908j
push	[bp+arg_28]
mov	ax, 4D70h
push	ax
push	[bp+arg_26]
push	[bp+arg_24]
push	[bp+arg_22]
push	[bp+arg_20]

loc_2B080:
push	[bp+arg_1E]
push	si
push	di
push	[bp+var_24]
push	[bp+var_10]
push	[bp+arg_4]
push	[bp+var_A]
push	[bp+arg_0]

loc_2B094:
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
mov	ax, [bp+var_6]
add	[bp+var_A], ax	; Add
mov	ax, [bp+arg_A]
add	[bp+var_10], ax	; Add
inc	si		; Increment by 1

loc_2B0A8:		; Increment by 1
inc	[bp+var_1C]

loc_2B0AB:		; CODE XREF: sub_2A755+8FBj
cmp	si, [bp+var_4]	; Compare Two Operands
jge	short loc_2B0B8	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_1C]
cmp	ax, [bp+arg_10]	; Compare Two Operands
jl	short loc_2B052	; Jump if Less (SF!=OF)

loc_2B0B8:		; CODE XREF: sub_2A755+959j
mov	ax, [bp+var_1C]

loc_2B0BB:
mov	[bp+var_2A], ax
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
mov	ax, [es:bx+3Eh]
mov	[di], ax
push	[bp+var_22]
call	sub_1A4E6	; Call Procedure

loc_2B0D0:		; int
push	ax
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_18], 0
push	[idk_Value_w36A38]
mov	ax, 4D70h
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_2B0EF:		; Logical Exclusive OR
xor	ax, ax
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 1
push	ax
lea	ax, [bp+var_18]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_2B126	; Jump if Not Zero (ZF=0)
mov	[bp+var_2C], 1
jmp	short loc_2B12B	; Jump

loc_2B126:		; CODE XREF: sub_2A755+9C8j
mov	[bp+var_2C], 0

loc_2B12B:		; CODE XREF: sub_2A755+9CFj
cmp	si, [bp+var_4]	; Compare Two Operands
jl	short loc_2B137	; Jump if Less (SF!=OF)
mov	[bp+var_2E], 1
jmp	short loc_2B13C	; Jump

loc_2B137:		; CODE XREF: sub_2A755+9D9j
mov	[bp+var_2E], 0

loc_2B13C:		; CODE XREF: sub_2A755+9E0j
mov	ax, 0FFFFh
push	ax
mov	ax, 4D74h
push	ax
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
push	[bp+arg_16]
mov	ax, 4D70h
push	ax
push	[bp+arg_14]
push	[bp+arg_12]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_1E], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 4D76h
push	ax
lea	ax, [bp+var_2E]	; Load Effective Address
push	ax
push	[bp+arg_1C]
mov	ax, 4D70h
push	ax
push	[bp+arg_1A]
push	[bp+arg_18]
push	cs
call	near ptr sub_2994E ; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_20], ax

loc_2B182:		; CODE XREF: sub_2A755+898j
mov	[word_36A52], 0
nop			; No Operation
push	cs
call	near ptr sub_2E26D ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_2E303 ; Call Procedure
cmp	[bp+var_14], 0	; Compare Two Operands
jnz	short loc_2B1A7	; Jump if Not Zero (ZF=0)
call	sub_1E525	; Call Procedure
mov	[bp+var_14], 1

loc_2B1A7:		; CODE XREF: sub_2A755+A46j
push	[idk_InitRoland_w36A3C]
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_2B1B1:		; CODE XREF: sub_2A755:loc_2A9C8j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_2B1BA	; Jump if Not Zero (ZF=0)
jmp	loc_2A9CB	; Jump

loc_2B1BA:		; CODE XREF: sub_2A755+A60j
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	[word_36A3A], 0
mov	[idk_Flag_w36A4C], 1
mov	[word_36A4E], 0
call	get_w360AC_set0	; Call Procedure
call	_f332647_Get_w360B4_Set0 ; Call	Procedure
cmp	[bp+var_12], 0	; Compare Two Operands
jge	short loc_2B1EA	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_28]
mov	[di], ax
mov	ax, 0FFFFh

loc_2B1E8:		; CODE XREF: sub_2A755+A9Cj
jmp	short loc_2B1F3	; Jump

loc_2B1EA:		; CODE XREF: sub_2A755+A89j
mov	ax, [bp+var_12]
add	ax, [bp+var_C]	; Add
dec	ax		; Decrement by 1
jmp	short loc_2B1E8	; Jump

loc_2B1F3:		; CODE XREF: sub_2A755:loc_2B1E8j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2A755



; Attributes: bp-based frame

proc sub_2B1F9 far

var_20=	byte ptr -20h
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh
arg_1A=	word ptr  20h

push	bp
mov	bp, sp
sub	sp, 20h		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_C]
mov	[word_36A3A], 1
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_2B9C4 ; Call Procedure
pop	cx
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, [bp+arg_0]
add	ax, [bp+arg_4]	; Add
mov	[bp+var_E], ax
call	sub_1BBF9	; Call Procedure
mov	[bp+var_A], ax
call	sub_1A542	; Call Procedure
mov	dx, [bp+var_A]
add	dx, ax		; Add
mov	[bp+var_8], dx
mov	[bp+var_2], 0
mov	[bp+var_4], 0
mov	[bp+var_6], 0
mov	ax, [bp+arg_8]
mov	[bp+var_12], ax
mov	ax, [bp+arg_2]
mov	[bp+var_C], ax
mov	di, 0FFFFh
jmp	loc_2B2F5	; Jump

loc_2B257:		; CODE XREF: sub_2B1F9+102j
mov	ax, 2
push	ax
push	[bp+var_12]
lea	ax, [bp+var_20]	; Load Effective Address
push	ax
call	sub_1CD80	; Call Procedure
add	sp, 6		; Add
cmp	[bp+var_20], 0	; Compare Two Operands
jz	short loc_2B2EA	; Jump if Zero (ZF=1)
cmp	[bp+var_6], 0	; Compare Two Operands
jnz	short loc_2B293	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2B28B	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2B293	; Jump if Not Zero (ZF=0)

loc_2B28B:		; CODE XREF: sub_2B1F9+8Aj
mov	di, [bp+var_4]
mov	[bp+var_6], 1

loc_2B293:		; CODE XREF: sub_2B1F9+7Bj
			; sub_2B1F9+90j
mov	ax, [bp+var_8]
add	[bp+var_C], ax	; Add
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2B2A6	; Jump if Not Zero (ZF=0)
mov	[bp+var_1A], 1
jmp	short loc_2B2B5	; Jump

loc_2B2A6:		; CODE XREF: sub_2B1F9+A4j
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
mov	ax, [bx]
mov	[bp+var_1A], ax

loc_2B2B5:		; CODE XREF: sub_2B1F9+ABj
push	[bp+arg_1A]
mov	ax, 4D70h
push	ax
push	[bp+arg_18]
push	[bp+arg_16]
push	[bp+arg_14]
push	[bp+arg_12]
push	[bp+arg_10]
push	[bp+var_4]
push	si
push	[bp+var_1A]
push	[bp+var_12]
push	[bp+arg_4]
push	[bp+var_C]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
inc	[bp+var_4]	; Increment by 1
jmp	short loc_2B2EF	; Jump

loc_2B2EA:		; CODE XREF: sub_2B1F9+75j
mov	[bp+var_2], 1

loc_2B2EF:		; CODE XREF: sub_2B1F9+EFj
mov	ax, [bp+arg_A]
add	[bp+var_12], ax	; Add

loc_2B2F5:		; CODE XREF: sub_2B1F9+5Bj
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_2B2FE	; Jump if Not Zero (ZF=0)
jmp	loc_2B257	; Jump

loc_2B2FE:		; CODE XREF: sub_2B1F9+100j
mov	ax, [bp+var_4]
mov	[bp+var_6], ax
call	sub_1A510	; Call Procedure
push	ax		; int
call	sub_1A4E6	; Call Procedure
push	ax		; int
call	sub_1A4D1	; Call Procedure
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_18], 0
push	[idk_Value_w36A38]
mov	ax, 4D70h
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 1
push	ax
lea	ax, [bp+var_18]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
push	cs
call	near ptr sub_290A9 ; Call Procedure
add	sp, 1Ch		; Add
mov	[bp+var_10], ax
cmp	[word ptr si], 0 ; Compare Two Operands
jl	short loc_2B36B	; Jump if Less (SF!=OF)
mov	ax, [si]
cmp	ax, [bp+var_6]	; Compare Two Operands
jge	short loc_2B36B	; Jump if Greater or Equal (SF=OF)
cmp	[si], di	; Compare Two Operands
jge	short loc_2B38E	; Jump if Greater or Equal (SF=OF)

loc_2B36B:		; CODE XREF: sub_2B1F9+165j
			; sub_2B1F9+16Cj
or	di, di		; Logical Inclusive OR
jl	short loc_2B38A	; Jump if Less (SF!=OF)
cmp	di, [bp+var_6]	; Compare Two Operands
jge	short loc_2B38A	; Jump if Greater or Equal (SF=OF)
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
mov	[si], ax
jmp	short loc_2B38E	; Jump

loc_2B38A:		; CODE XREF: sub_2B1F9+174j
			; sub_2B1F9+179j
mov	[word ptr si], 0FFFFh

loc_2B38E:		; CODE XREF: sub_2B1F9+170j
			; sub_2B1F9+18Fj
mov	[bp+var_2], 0
mov	[bp+var_14], 0
xor	di, di		; Logical Exclusive OR
jmp	loc_2B42E	; Jump

loc_2B39D:		; CODE XREF: sub_2B1F9+23Bj
call	_f020105_bios_timeofday	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_2B97A ; Call Procedure
mov	di, ax
or	di, di		; Logical Inclusive OR
jz	short loc_2B3B2	; Jump if Zero (ZF=1)
mov	[bp+var_2], 1

loc_2B3B2:		; CODE XREF: sub_2B1F9+1B2j
or	di, di		; Logical Inclusive OR
jle	short loc_2B3CB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, di
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_2B3CB	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_E], 0	; Compare Two Operands
jnz	short loc_2B3D0	; Jump if Not Zero (ZF=0)

loc_2B3CB:		; CODE XREF: sub_2B1F9+1BBj
			; sub_2B1F9+1CAj
cmp	di, [bp+var_10]	; Compare Two Operands
jnz	short loc_2B3D5	; Jump if Not Zero (ZF=0)

loc_2B3D0:		; CODE XREF: sub_2B1F9+1D0j
mov	[bp+var_2], 0

loc_2B3D5:		; CODE XREF: sub_2B1F9+1D5j
cmp	[bp+var_2], 0	; Compare Two Operands

loc_2B3D9:		; Jump if Zero (ZF=1)
jz	short loc_2B3DD
jmp	short loc_2B437	; Jump

loc_2B3DD:		; CODE XREF: sub_2B1F9:loc_2B3D9j
nop			; No Operation
push	cs
call	near ptr sub_2E26D ; Call Procedure
cmp	[idk_Flag_w36A4C], 0 ; Compare Two Operands
jz	short loc_2B40A	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_27AFB ; Call Procedure
mov	[bp+var_16], ax
cmp	[bp+var_16], 0	; Compare Two Operands
jle	short loc_2B40A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_16]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2B3FE:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+18h]
mov	[si], ax

loc_2B40A:		; CODE XREF: sub_2B1F9+1EEj
			; sub_2B1F9+1FBj
call	idk_SetPalette_s1C4F4 ;	Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_2E303 ; Call Procedure
cmp	[bp+var_14], 0	; Compare Two Operands
jnz	short loc_2B424	; Jump if Not Zero (ZF=0)
call	sub_1E525	; Call Procedure
mov	[bp+var_14], 1

loc_2B424:		; CODE XREF: sub_2B1F9+21Fj
push	[idk_InitRoland_w36A3C]
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_2B42E:		; CODE XREF: sub_2B1F9+1A1j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_2B437	; Jump if Not Zero (ZF=0)
jmp	loc_2B39D	; Jump

loc_2B437:		; CODE XREF: sub_2B1F9+1E2j
			; sub_2B1F9+239j
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	[word_36A3A], 0
mov	[idk_Flag_w36A4C], 1
call	get_w360AC_set0	; Call Procedure
call	_f332647_Get_w360B4_Set0 ; Call	Procedure
or	di, di		; Logical Inclusive OR
jge	short loc_2B45A	; Jump if Greater or Equal (SF=OF)
mov	ax, 0FFFFh

loc_2B458:		; CODE XREF: sub_2B1F9+264j
jmp	short loc_2B45F	; Jump

loc_2B45A:		; CODE XREF: sub_2B1F9+25Aj
mov	ax, di
dec	ax		; Decrement by 1
jmp	short loc_2B458	; Jump

loc_2B45F:		; CODE XREF: sub_2B1F9:loc_2B458j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2B1F9



; Attributes: bp-based frame

proc idk_SetFlag_w36A4C_s2B465 far
push	bp
mov	bp, sp
mov	[idk_Flag_w36A4C], 0
pop	bp
retf			; Return Far from Procedure
endp idk_SetFlag_w36A4C_s2B465



; Attributes: bp-based frame

proc sub_2B470 far	; CODE XREF: sub_27E4B:loc_27ECAp

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_2B473:		; Integer Subtraction
sub	sp, 2
push	si
push	di
push	cs
call	near ptr sub_27AFB ; Call Procedure
mov	di, ax
mov	si, di
or	di, di		; Logical Inclusive OR
jnz	short loc_2B487	; Jump if Not Zero (ZF=0)
jmp	loc_2B5DE	; Jump

loc_2B487:		; CODE XREF: sub_2B470+12j
cmp	[bp+arg_0], 1	; Compare Two Operands
jz	short loc_2B490	; Jump if Zero (ZF=1)
jmp	loc_2B521	; Jump

loc_2B490:		; CODE XREF: sub_2B470+1Bj
jmp	short loc_2B4A8	; Jump

loc_2B492:		; CODE XREF: sub_2B470+53j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2B499:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands

loc_2B4A4:		; Jump if Zero (ZF=1)
jz	short loc_2B4A8
jmp	short loc_2B4C5	; Jump

loc_2B4A8:		; CODE XREF: sub_2B470:loc_2B490j
			; sub_2B470:loc_2B4A4j
inc	si		; Increment by 1
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jle	short loc_2B4C5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2B4BE:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ah
jz	short loc_2B492	; Jump if Zero (ZF=1)

loc_2B4C5:		; CODE XREF: sub_2B470+36j
			; sub_2B470+3Fj
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jle	short loc_2B4E1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si

loc_2B4CF:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jz	short loc_2B51E	; Jump if Zero (ZF=1)

loc_2B4E1:		; CODE XREF: sub_2B470+5Bj
cmp	[word_36A4E], 0	; Compare Two Operands
jnz	short loc_2B516	; Jump if Not Zero (ZF=0)
mov	si, 1
jmp	short loc_2B4EE	; Jump

loc_2B4ED:		; CODE XREF: sub_2B470+98j
inc	si		; Increment by 1

loc_2B4EE:		; CODE XREF: sub_2B470+7Bj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2B4F5:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jnz	short loc_2B50A	; Jump if Not Zero (ZF=0)
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jg	short loc_2B4ED	; Jump if Greater (ZF=0	& SF=OF)

loc_2B50A:		; CODE XREF: sub_2B470+90j
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jg	short loc_2B514	; Jump if Greater (ZF=0	& SF=OF)
mov	si, di

loc_2B514:		; CODE XREF: sub_2B470+A0j
jmp	short loc_2B51E	; Jump

loc_2B516:		; CODE XREF: sub_2B470+76j
mov	si, di
mov	[word_36A52], 1

loc_2B51E:		; CODE XREF: sub_2B470+6Fj
			; sub_2B470:loc_2B514j
jmp	loc_2B5DB	; Jump

loc_2B521:		; CODE XREF: sub_2B470+1Dj
cmp	[word_36A4E], 0	; Compare Two Operands
jz	short loc_2B539	; Jump if Zero (ZF=1)
cmp	si, 1		; Compare Two Operands
jnz	short loc_2B539	; Jump if Not Zero (ZF=0)
mov	[word_36A52], 0FFFFh
mov	si, 1
jmp	loc_2B5DB	; Jump

loc_2B539:		; CODE XREF: sub_2B470+B6j
			; sub_2B470+BBj
cmp	si, 1		; Compare Two Operands
jle	short loc_2B541	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
dec	si		; Decrement by 1
jmp	short loc_2B549	; Jump

loc_2B541:		; CODE XREF: sub_2B470+CCj
mov	ax, [idk_Mouse_w3C5A8]
add	ax, 0FFFEh	; Add
mov	si, ax

loc_2B549:		; CODE XREF: sub_2B470+CFj
jmp	short loc_2B54C	; Jump

loc_2B54B:		; CODE XREF: sub_2B470+F2j
dec	si		; Decrement by 1

loc_2B54C:		; CODE XREF: sub_2B470:loc_2B549j
mov	ax, si
mov	dx, 26h	; '&'

loc_2B551:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jz	short loc_2B564	; Jump if Zero (ZF=1)
or	si, si		; Logical Inclusive OR
jg	short loc_2B54B	; Jump if Greater (ZF=0	& SF=OF)

loc_2B564:		; CODE XREF: sub_2B470+EEj
jmp	short loc_2B57D	; Jump

loc_2B566:		; CODE XREF: sub_2B470+10Fj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2B57C	; Jump if Zero (ZF=1)
jmp	short loc_2B581	; Jump

loc_2B57C:		; CODE XREF: sub_2B470+108j
dec	si		; Decrement by 1

loc_2B57D:		; CODE XREF: sub_2B470:loc_2B564j
or	si, si		; Logical Inclusive OR
jg	short loc_2B566	; Jump if Greater (ZF=0	& SF=OF)

loc_2B581:		; CODE XREF: sub_2B470+10Aj
or	si, si		; Logical Inclusive OR
jg	short loc_2B5DB	; Jump if Greater (ZF=0	& SF=OF)

loc_2B585:		; Compare Two Operands
cmp	[word_36A4E], 0
jz	short loc_2B597	; Jump if Zero (ZF=1)
mov	[word_36A52], 0FFFFh
mov	si, 1
jmp	short loc_2B5DB	; Jump

loc_2B597:		; CODE XREF: sub_2B470+11Aj
mov	ax, [idk_Mouse_w3C5A8]
add	ax, 0FFFEh	; Add
mov	si, ax
jmp	short loc_2B5A2	; Jump

loc_2B5A1:		; CODE XREF: sub_2B470+148j
dec	si		; Decrement by 1

loc_2B5A2:		; CODE XREF: sub_2B470+12Fj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jz	short loc_2B5BA	; Jump if Zero (ZF=1)
or	si, si		; Logical Inclusive OR
jg	short loc_2B5A1	; Jump if Greater (ZF=0	& SF=OF)

loc_2B5BA:		; CODE XREF: sub_2B470+144j
jmp	short loc_2B5BD	; Jump

loc_2B5BC:		; CODE XREF: sub_2B470+163j
dec	si		; Decrement by 1

loc_2B5BD:		; CODE XREF: sub_2B470:loc_2B5BAj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jnz	short loc_2B5D5	; Jump if Not Zero (ZF=0)
or	si, si		; Logical Inclusive OR
jg	short loc_2B5BC	; Jump if Greater (ZF=0	& SF=OF)

loc_2B5D5:		; CODE XREF: sub_2B470+15Fj
or	si, si		; Logical Inclusive OR
jnz	short loc_2B5DB	; Jump if Not Zero (ZF=0)
mov	si, di

loc_2B5DB:		; CODE XREF: sub_2B470:loc_2B51Ej
			; sub_2B470+C6j
			; sub_2B470+113j
			; sub_2B470+125j
			; sub_2B470+167j
jmp	loc_2B750	; Jump

loc_2B5DE:		; CODE XREF: sub_2B470+14j
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
mov	bx, [es:bx+40h]
cmp	[word ptr bx], 0 ; Compare Two Operands
jge	short loc_2B5EE	; Jump if Greater or Equal (SF=OF)
jmp	loc_2B718	; Jump

loc_2B5EE:		; CODE XREF: sub_2B470+179j
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
mov	bx, [es:bx+40h]
mov	ax, [bx]
inc	ax		; Increment by 1
mov	di, ax
or	di, di		; Logical Inclusive OR
jl	short loc_2B607	; Jump if Less (SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jge	short loc_2B609	; Jump if Greater or Equal (SF=OF)

loc_2B607:		; CODE XREF: sub_2B470+18Dj
xor	di, di		; Logical Exclusive OR

loc_2B609:		; CODE XREF: sub_2B470+195j
mov	si, di
cmp	[bp+arg_0], 1	; Compare Two Operands

loc_2B60F:		; Jump if Zero (ZF=1)
jz	short loc_2B614
jmp	loc_2B6A8	; Jump

loc_2B614:		; CODE XREF: sub_2B470:loc_2B60Fj
jmp	short loc_2B62C	; Jump

loc_2B616:		; CODE XREF: sub_2B470+1D7j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2B62C	; Jump if Zero (ZF=1)
jmp	short loc_2B649	; Jump

loc_2B62C:		; CODE XREF: sub_2B470:loc_2B614j
			; sub_2B470+1B8j
inc	si		; Increment by 1
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jle	short loc_2B649	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jz	short loc_2B616	; Jump if Zero (ZF=1)

loc_2B649:		; CODE XREF: sub_2B470+1BAj
			; sub_2B470+1C3j
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands

loc_2B64D:		; Jump if Greater or Equal (SF=OF)
jge	short loc_2B663
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jz	short loc_2B672	; Jump if Zero (ZF=1)

loc_2B663:		; CODE XREF: sub_2B470:loc_2B64Dj
cmp	[word_36A4E], 0	; Compare Two Operands
jz	short loc_2B672	; Jump if Zero (ZF=1)
mov	[word_36A52], 1
jmp	short loc_2B6A6	; Jump

loc_2B672:		; CODE XREF: sub_2B470+1F1j
			; sub_2B470+1F8j
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jg	short loc_2B6A6	; Jump if Greater (ZF=0	& SF=OF)
mov	si, 1
jmp	short loc_2B680	; Jump

loc_2B67F:		; CODE XREF: sub_2B470+22Aj
inc	si		; Increment by 1

loc_2B680:		; CODE XREF: sub_2B470+20Dj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2B687:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jnz	short loc_2B69C	; Jump if Not Zero (ZF=0)
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jg	short loc_2B67F	; Jump if Greater (ZF=0	& SF=OF)

loc_2B69C:		; CODE XREF: sub_2B470+222j
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1

loc_2B6A0:		; Compare Two Operands
cmp	ax, si
jg	short loc_2B6A6	; Jump if Greater (ZF=0	& SF=OF)
mov	si, di

loc_2B6A6:		; CODE XREF: sub_2B470+200j
			; sub_2B470+208j
			; sub_2B470+232j
jmp	short loc_2B716	; Jump

loc_2B6A8:		; CODE XREF: sub_2B470+1A1j
cmp	si, 1		; Compare Two Operands
jnz	short loc_2B6BC	; Jump if Not Zero (ZF=0)
cmp	[word_36A4E], 0	; Compare Two Operands
jz	short loc_2B6BC	; Jump if Zero (ZF=1)

loc_2B6B4:
mov	[word_36A52], 0FFFFh
jmp	short loc_2B716	; Jump

loc_2B6BC:		; CODE XREF: sub_2B470+23Bj
			; sub_2B470+242j
cmp	si, 1		; Compare Two Operands
jle	short loc_2B6C4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
dec	si		; Decrement by 1
jmp	short loc_2B6CC	; Jump

loc_2B6C4:		; CODE XREF: sub_2B470+24Fj
mov	ax, [idk_Mouse_w3C5A8]
add	ax, 0FFFEh	; Add
mov	si, ax

loc_2B6CC:		; CODE XREF: sub_2B470+252j
jmp	short loc_2B6E5	; Jump

loc_2B6CE:		; CODE XREF: sub_2B470+277j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2B6E4	; Jump if Zero (ZF=1)
jmp	short loc_2B6E9	; Jump

loc_2B6E4:		; CODE XREF: sub_2B470+270j
dec	si		; Decrement by 1

loc_2B6E5:		; CODE XREF: sub_2B470:loc_2B6CCj
or	si, si		; Logical Inclusive OR
jg	short loc_2B6CE	; Jump if Greater (ZF=0	& SF=OF)

loc_2B6E9:		; CODE XREF: sub_2B470+272j
or	si, si		; Logical Inclusive OR
jnz	short loc_2B716	; Jump if Not Zero (ZF=0)
mov	ax, [idk_Mouse_w3C5A8]
add	ax, 0FFFEh	; Add
mov	si, ax
jmp	short loc_2B6F8	; Jump

loc_2B6F7:		; CODE XREF: sub_2B470+29Ej
dec	si		; Decrement by 1

loc_2B6F8:		; CODE XREF: sub_2B470+285j
mov	ax, si

loc_2B6FA:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jnz	short loc_2B710	; Jump if Not Zero (ZF=0)
or	si, si		; Logical Inclusive OR
jg	short loc_2B6F7	; Jump if Greater (ZF=0	& SF=OF)

loc_2B710:		; CODE XREF: sub_2B470+29Aj
or	si, si		; Logical Inclusive OR
jnz	short loc_2B716	; Jump if Not Zero (ZF=0)
mov	si, di

loc_2B716:		; CODE XREF: sub_2B470:loc_2B6A6j
			; sub_2B470+24Aj
			; sub_2B470+27Bj
			; sub_2B470+2A2j
jmp	short loc_2B750	; Jump

loc_2B718:		; CODE XREF: sub_2B470+17Bj
mov	[bp+var_2], 1
jmp	short loc_2B73C	; Jump

loc_2B71F:		; CODE XREF: sub_2B470+2D3j
mov	ax, [bp+var_2]
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2B739	; Jump if Zero (ZF=1)
mov	si, [bp+var_2]
jmp	short loc_2B745	; Jump

loc_2B739:		; CODE XREF: sub_2B470+2C2j
inc	[bp+var_2]	; Increment by 1

loc_2B73C:		; CODE XREF: sub_2B470+2ADj
mov	ax, [bp+var_2]

loc_2B73F:		; Compare Two Operands
cmp	ax, [idk_Mouse_w3C5A8]
jl	short loc_2B71F	; Jump if Less (SF!=OF)

loc_2B745:		; CODE XREF: sub_2B470+2C7j
mov	ax, [bp+var_2]
cmp	ax, [idk_Mouse_w3C5A8] ; Compare Two Operands
jl	short loc_2B750	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR

loc_2B750:		; CODE XREF: sub_2B470:loc_2B5DBj
			; sub_2B470:loc_2B716j
			; sub_2B470+2DCj
or	si, si		; Logical Inclusive OR
jl	short loc_2B75C	; Jump if Less (SF!=OF)
mov	ax, [idk_Mouse_w3C5A8]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jge	short loc_2B75E	; Jump if Greater or Equal (SF=OF)

loc_2B75C:		; CODE XREF: sub_2B470+2E2j
xor	si, si		; Logical Exclusive OR

loc_2B75E:		; CODE XREF: sub_2B470+2EAj
or	si, si		; Logical Inclusive OR
jg	short loc_2B765	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_2B88B	; Jump

loc_2B765:		; CODE XREF: sub_2B470+2F0j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
mov	[idk_MousePosX_w3C5A0],	ax
call	get__Mouse_w360A4 ; Call Procedure
cmp	ax, [idk_MousePosX_w3C5A2] ; Compare Two Operands
jnz	short loc_2B7FE	; Jump if Not Zero (ZF=0)
call	get__Mouse_w360A6 ; Call Procedure
cmp	ax, [idk_MousePosX_w3C5A0] ; Compare Two Operands
jnz	short loc_2B7FE	; Jump if Not Zero (ZF=0)
jmp	loc_2B88B	; Jump

loc_2B7FE:		; CODE XREF: sub_2B470+37Ej
			; sub_2B470+389j
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	idk_Mouse_s23F82 ; Call	Procedure
pop	cx
pop	cx
call	idk_Get_Mouse_w360AA ; Call Procedure
mov	[idk_Mouse_w3C5A4], ax
mov	ax, [idk_MousePosX_w3C5A2]
sub	ax, [idk_Mouse_w3C5A4] ; Integer Subtraction
mov	[idk_MousePosX_w3C5A2],	ax
mov	ax, [idk_MousePosX_w3C5A0]
sub	ax, [idk_Mouse_w3C5A4] ; Integer Subtraction
mov	[idk_MousePosX_w3C5A0],	ax
call	idk_ChkMousDoEga ; Call	Procedure
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24648	; Call Procedure
pop	cx
pop	cx
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	sub_24A74	; Call Procedure
pop	cx
pop	cx
push	[idk_MousePosX_w3C5A0]
push	[idk_MousePosX_w3C5A2]
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
pop	ax
mov	[bx], ax
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE

loc_2B88B:		; CODE XREF: sub_2B470+2F2j
			; sub_2B470+38Bj
mov	ax, si
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2B470

push	bp
mov	bp, sp
mov	ax, [bp+6]
inc	ax		; Increment by 1
mov	[idk_Mouse_w3C5A8], ax
mov	[w36A32], 0FFFFh
pop	bp
retf			; Return Far from Procedure


; Attributes: bp-based frame

proc sub_2B8A7 far	; CODE XREF: sub_1B341+42P
push	bp
mov	bp, sp
mov	ax, [idk_Mouse_w3C5A8]
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
endp sub_2B8A7



; Attributes: bp-based frame

proc idk_Mouse_s2B8B1 far
			; CODE XREF: Load_Fonts_SndDrv:loc_17DF7P
			; idk_Load_FntSty_SndDrv_Mos:loc_17E56P

arg_0_SI= word ptr  6

push	bp
mov	bp, sp
mov	ax, 357
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr idk2_dw3C5B2+2], dx
mov	[word ptr idk2_dw3C5B2], ax
mov	ax, [bp+arg_0_SI]
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jz	short loc_2B8DF	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short IF_ARG_EQ_1 ; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_2B94F	; Jump if Zero (ZF=1)
jmp	short loc_2B951	; Jump

loc_2B8DF:		; CODE XREF: idk_Mouse_s2B8B1+20j
			; idk_Mouse_s2B8B1:loc_2B94Fj
call	set_w360A2_1	; Call Procedure
mov	[hrmMouseInstalled], 0
mov	[idk_MousePosX_w3C5A2],	158
mov	[idk_MousePosX_w3C5A0],	100
mov	ax, 100
push	ax
mov	ax, 158
push	ax
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
jmp	short loc_2B953	; Jump

IF_ARG_EQ_1:		; CODE XREF: idk_Mouse_s2B8B1+25j
mov	ax, offset word_36A3E
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	MOUSE_SetupRangeRoutine	; Call Procedure
mov	[hrmMouseInstalled], ax
cmp	[hrmMouseInstalled], 0 ; If (AX	!= 0) Then Set (ZF = 1)
jnz	short MOUSE_INSTALLED ;	Jump if	Not Zero (ZF=0)
call	set_w360A2_1	; Call Procedure
mov	[idk_MousePosX_w3C5A2],	158
mov	[idk_MousePosX_w3C5A0],	100
mov	ax, 100
push	ax
mov	ax, 158
push	ax
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
jmp	short loc_2B94D	; Jump

MOUSE_INSTALLED:	; CODE XREF: idk_Mouse_s2B8B1+72j
mov	[hrmMouseInstalled], 1

loc_2B94D:		; CODE XREF: idk_Mouse_s2B8B1+94j
jmp	short loc_2B953	; Jump

loc_2B94F:		; CODE XREF: idk_Mouse_s2B8B1+2Aj
jmp	short loc_2B8DF	; Jump

loc_2B951:		; CODE XREF: idk_Mouse_s2B8B1+2Cj
jmp	short $+2	; Jump

loc_2B953:		; CODE XREF: idk_Mouse_s2B8B1+54j
			; idk_Mouse_s2B8B1:loc_2B94Dj
mov	ax, 100
push	ax
mov	ax, 158
push	ax
call	idk_VGA_s247F9	; Call Procedure
pop	cx
pop	cx
mov	[word_3C59E], 0
mov	[w36A32], 0FFFFh
mov	[idk_CfgMom_w36A54], 0
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
pop	bp
retf			; Return Far from Procedure
endp idk_Mouse_s2B8B1



; Attributes: bp-based frame

proc sub_2B97A far	; CODE XREF: _f010509_MainMenuScreen+3F9P
			; sub_1D1B5:loc_1D1E1P
			; sub_2A755+27Dp
			; sub_2B1F9+1ABp
			; sub_3CFC0:loc_3D255P
			; sub_3DBA6:loc_3DEA2P
			; sub_3E1DE:loc_3E4EBP
			; sub_3EBA0:loc_3ED35P
			; sub_3F3C6:loc_3F514P
			; sub_3F7D8+17EP
			; sub_3FBE0+1BBP
			; sub_4067D:loc_409FBP
			; LBX_NewGame_s41A5F+34DP
			; sub_4D5B0:loc_4D73AP
			; sub_4DB4D:loc_4DD78P
			; ST_LoadMusicSoundfxIntro+E8P
			; sub_56450+E5P
push	bp
mov	bp, sp
push	si
cmp	[word_3C59E], 0	; Compare Two Operands
jle	short loc_2B98F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
dec	[word_3C59E]	; Decrement by 1

loc_2B989:		; CODE XREF: sub_2B97A+29j
xor	ax, ax		; Logical Exclusive OR

loc_2B98B:		; CODE XREF: sub_2B97A+45j
jmp	short loc_2B9C1	; Jump
jmp	short loc_2B99C	; Jump

loc_2B98F:		; CODE XREF: sub_2B97A+9j
cmp	[word_3C59E], 0	; Compare Two Operands
jge	short loc_2B99C	; Jump if Greater or Equal (SF=OF)
mov	[word_3C59E], 0

loc_2B99C:		; CODE XREF: sub_2B97A+13j
			; sub_2B97A+1Aj
cmp	[idk_Mouse_w3C5A8], 1 ;	Compare	Two Operands
jg	short loc_2B9A5	; Jump if Greater (ZF=0	& SF=OF)
jmp	short loc_2B989	; Jump

loc_2B9A5:		; CODE XREF: sub_2B97A+27j
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands
jz	short loc_2B9B2	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_24DAE ; Call Procedure
jmp	short loc_2B9B6	; Jump

loc_2B9B2:		; CODE XREF: sub_2B97A+30j
push	cs
call	near ptr sub_26026 ; Call Procedure

loc_2B9B6:		; CODE XREF: sub_2B97A+36j
mov	si, ax
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, si
jmp	short loc_2B98B	; Jump

loc_2B9C1:		; CODE XREF: sub_2B97A:loc_2B98Bj
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_2B97A



; Attributes: bp-based frame

proc sub_2B9C4 far	; CODE XREF: _f010509_MainMenuScreen+3EBP
			; sub_28583+34p
			; sub_2A755+33p
			; sub_2B1F9+17p
			; sub_2E2F1+Cp
			; sub_3EBA0+18CP
			; sub_3F3C6+145P

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	ax, [bp+arg_0]
mov	[word_3C59E], ax
call	get_w360AC_set0	; Call Procedure
call	_f332647_Get_w360B4_Set0 ; Call	Procedure
pop	bp
retf			; Return Far from Procedure
endp sub_2B9C4

push	bp
mov	bp, sp
mov	ax, [word_3C59E]
jmp	short $+2	; Jump
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
mov	cx, [bp+6]
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2B9F6:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ah
jnz	short loc_2BA10	; Jump if Not Zero (ZF=0)
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+12h], 0

loc_2BA10:		; CODE XREF: seg034:6C5Bj
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
mov	cx, [bp+6]
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jnz	short loc_2BA3F	; Jump if Not Zero (ZF=0)
mov	ax, cx
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+12h], 1

loc_2BA3F:		; CODE XREF: seg034:6C8Aj
pop	bp
retf			; Return Far from Procedure


; Attributes: bp-based frame

proc sub_2BA41 far	; CODE XREF: sub_2E303:loc_2E31Cp

var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 14h		; Integer Subtraction
push	si
push	di		; argSrc
mov	ax, [idk_ScrnPosX0_w35EC2]
mov	[bp+var_E], ax
mov	ax, [idk_ScrnPosX319_w35EC6]
mov	[bp+var_10], ax
mov	ax, [idk_ScrnPosY0_w35EC4]
mov	[bp+var_12], ax
mov	ax, [idk_ScrnPosY199_w35EC8]
mov	[bp+var_14], ax
call	idk_ScrnPos_0_319_0_199	; Call Procedure
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	si, 1
jmp	loc_2CDB3	; Jump

loc_2BA71:		; CODE XREF: sub_2BA41+1378j
cmp	[w36A32], si	; Compare Two Operands
jnz	short loc_2BAAE	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 4 ;	Compare	Two Operands
jz	short loc_2BAAE	; Jump if Zero (ZF=1)

loc_2BA8B:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2BA98:		; Compare Two Operands
cmp	[word ptr es:bx+8], 0Ch
jz	short loc_2BAAE	; Jump if Zero (ZF=1)
mov	ax, 1
push	ax
push	si

loc_2BAA4:		; No Operation
nop
push	cs
call	near ptr sub_2CF44 ; Call Procedure
pop	cx
pop	cx
jmp	loc_2CDB2	; Jump

loc_2BAAE:		; CODE XREF: sub_2BA41+34j
			; sub_2BA41+48j
			; sub_2BA41+5Cj
mov	ax, si
mov	dx, 26h	; '&'

loc_2BAB3:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+8]
cmp	bx, 0Bh		; switch 12 cases
jbe	short loc_2BAC7	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_2CC53	; default

loc_2BAC7:		; CODE XREF: sub_2BA41+81j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_2CF2C+bx] ; switch jump

loc_2BACE:		; DATA XREF: seg034:off_2CF2Co
mov	ax, si		; case 0x0
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2BADB:
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2BAEF:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2BB04:		; Add
add	bx, ax
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2BB17:
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2BB29:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2BB40:		; int
push	[word ptr es:bx+0Ch]
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2BB60:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2BBA1:
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2BBB7:		; Add
add	bx, ax
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax

loc_2BBD5:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
jmp	loc_2CC55	; Jump

loc_2BBF4:		; CODE XREF: sub_2BA41+88j
			; DATA XREF: seg034:off_2CF2Co
mov	ax, si		; case 0x1
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jz	short loc_2BC0D	; Jump if Zero (ZF=1)
jmp	loc_2BD2A	; Jump

loc_2BC0D:		; CODE XREF: sub_2BA41+1C7j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
jmp	loc_2BEB8	; Jump

loc_2BD2A:		; CODE XREF: sub_2BA41+1C9j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ch], 0	; Compare Two Operands
jnz	short loc_2BD94	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
jmp	short loc_2BDB0	; Jump

loc_2BD94:		; CODE XREF: sub_2BA41+2FBj
mov	ax, 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_2BDB0:		; CODE XREF: sub_2BA41+351j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A36] ; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A34] ; Add

loc_2BEB8:		; CODE XREF: sub_2BA41+2E6j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
jmp	loc_2CC55	; Jump

loc_2BEC4:		; CODE XREF: sub_2BA41+88j
			; DATA XREF: seg034:off_2CF2Co
mov	ax, si		; case 0x2
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2BECF:		; Add
add	bx, ax
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jz	short loc_2BEDD	; Jump if Zero (ZF=1)

loc_2BEDA:		; Jump
jmp	loc_2BFFA

loc_2BEDD:		; CODE XREF: sub_2BA41+497j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2BEE4:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si

loc_2BF0A:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2BF13:		; Add
add	bx, ax
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2BF3E:		; int
push	[word ptr es:bx+0Eh]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx

loc_2BFF5:		; Add
add	ax, dx
jmp	loc_2C188	; Jump

loc_2BFFA:		; CODE XREF: sub_2BA41:loc_2BEDAj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ch], 0	; Compare Two Operands
jnz	short loc_2C064	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
jmp	short loc_2C080	; Jump

loc_2C064:		; CODE XREF: sub_2BA41+5CBj
mov	ax, 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_2C080:		; CODE XREF: sub_2BA41+621j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, si

loc_2C0BC:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A36] ; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax

loc_2C15A:
mov	ax, si
mov	dx, 26h	; '&'

loc_2C15F:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2C17E:
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A34] ; Add

loc_2C188:		; CODE XREF: sub_2BA41+5B6j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
jmp	loc_2CC55	; Jump

loc_2C194:		; CODE XREF: sub_2BA41+88j
			; DATA XREF: seg034:off_2CF2Co
mov	ax, si		; case 0x3
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	ax, [bx]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cmp	ax, [es:bx+18h]	; Compare Two Operands
jnz	short loc_2C1BF	; Jump if Not Zero (ZF=0)
jmp	loc_2C2D9	; Jump

loc_2C1BF:		; CODE XREF: sub_2BA41+779j
mov	ax, si
mov	dx, 26h	; '&'

loc_2C1C4:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
mov	ax, si

loc_2C1D8:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2C1F4:
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2C21B:		; Add
add	bx, ax
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2C228:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int

loc_2C232:		; Call Procedure
call	idk_PalFnt_s1AB64
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right

loc_2C244:
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si

loc_2C26C:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction

loc_2C27F:		; Shift	Arithmetic Right
sar	ax, 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx

loc_2C294:		; Add
add	ax, dx
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2C2A7:
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_2C2BA:		; Integer Subtraction
sub	ax, [es:bx]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2C2D0:
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
jmp	loc_2C467	; Jump

loc_2C2D9:		; CODE XREF: sub_2BA41+77Bj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ch], 0	; Compare Two Operands
jnz	short loc_2C343	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_2C2EF:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
jmp	short loc_2C35F	; Jump

loc_2C343:		; CODE XREF: sub_2BA41+8AAj
mov	ax, 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_2C35F:		; CODE XREF: sub_2BA41+900j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2C38E:
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add

loc_2C41F:		; Add
add	ax, [word_36A36]
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A34] ; Add

loc_2C467:		; CODE XREF: sub_2BA41+895j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
jmp	loc_2CC55	; Jump

loc_2C473:		; CODE XREF: sub_2BA41+88j
			; DATA XREF: seg034:off_2CF2Co
push	[word_36A50]	; case 0xA
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
call	sub_1A542	; Call Procedure
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_4], ax
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_2C4B9	; Jump if Not Zero (ZF=0)
mov	[bp+var_4], 1

loc_2C4B9:		; CODE XREF: sub_2BA41+A71j
call	sub_1BBF9	; Call Procedure
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	ax, [bx]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cmp	ax, [es:bx+18h]	; Compare Two Operands
jnz	short loc_2C4EC	; Jump if Not Zero (ZF=0)
jmp	loc_2C56F	; Jump

loc_2C4EC:		; CODE XREF: sub_2BA41+AA6j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2C502	; Jump if Zero (ZF=1)
jmp	short loc_2C530	; Jump

loc_2C502:		; CODE XREF: sub_2BA41+ABDj
push	[word_36A50]	; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add

loc_2C530:		; CODE XREF: sub_2BA41+ABFj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
inc	ax		; Increment by 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
jmp	loc_2C657	; Jump

loc_2C56F:		; CODE XREF: sub_2BA41+AA8j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+22h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2C59C:		; Add
add	bx, ax

loc_2C59E:
push	[word ptr es:bx+1Eh]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2C5A9:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+1Ch]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+10h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
add	ax, [bp+var_2]	; Add
inc	ax		; Increment by 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+4]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
sub	ax, [bp+var_4]	; Integer Subtraction
inc	ax		; Increment by 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
dec	ax		; Decrement by 1
push	ax
call	sub_18579	; Call Procedure
add	sp, 12h		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
inc	ax		; Increment by 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1993F	; Call Procedure
add	sp, 6		; Add

loc_2C657:		; CODE XREF: sub_2BA41+B2Bj
jmp	loc_2CC55	; Jump

loc_2C65A:		; CODE XREF: sub_2BA41+88j
			; DATA XREF: seg034:off_2CF2Co
cmp	[w36A32], si	; case 0x4
jnz	short loc_2C663	; Jump if Not Zero (ZF=0)
jmp	loc_2C798	; Jump

loc_2C663:		; CODE XREF: sub_2BA41+C1Dj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h] ; int

loc_2C674:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure

loc_2C69B:		; Add
add	sp, 6
mov	ax, si
mov	dx, 26h	; '&'

loc_2C6A3:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ah], 0	; Compare Two Operands

loc_2C6B0:		; Jump if Zero (ZF=1)
jz	short loc_2C710
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+1Ah]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2C6D0:
push	[word ptr es:bx+6]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+4]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
dec	ax		; Decrement by 1
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add

loc_2C710:		; CODE XREF: sub_2BA41:loc_2C6B0j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ch], 0	; Compare Two Operands
jnz	short loc_2C75D	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'

loc_2C74B:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1993F	; Call Procedure
jmp	short loc_2C795	; Jump

loc_2C75D:		; CODE XREF: sub_2BA41+CE1j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si

loc_2C770:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2C77B:
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2C786:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+4]
call	sub_196B8	; Call Procedure

loc_2C795:		; CODE XREF: sub_2BA41+D1Aj
add	sp, 6		; Add

loc_2C798:		; CODE XREF: sub_2BA41+C1Fj
jmp	loc_2CC55	; Jump

loc_2C79B:		; CODE XREF: sub_2BA41+88j
			; DATA XREF: seg034:off_2CF2Co
mov	ax, si		; case 0x6
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+1Ah]
mov	[bp+var_8], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+22h]
mov	[bp+var_A], ax
push	es
mov	ax, [bp+var_8]
mov	bx, [bp+var_A]
mov	es, ax
mov	ax, [es:bx]
mov	[bp+var_6], ax
pop	es
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jle	short loc_2C7FD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+16h]
mov	[bp+var_6], ax

loc_2C7FD:		; CODE XREF: sub_2BA41+DA6j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jge	short loc_2C827	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
mov	[bp+var_6], ax

loc_2C827:		; CODE XREF: sub_2BA41+DD0j
push	es
mov	ax, [bp+var_6]
mov	cx, [bp+var_8]
mov	bx, [bp+var_A]
mov	es, cx
mov	[es:bx], ax
pop	es
jmp	loc_2CC55	; Jump

loc_2C83A:		; CODE XREF: sub_2BA41+88j
			; DATA XREF: seg034:off_2CF2Co
cmp	[word_36A70], si ; case	0xB
jnz	short loc_2C843	; Jump if Not Zero (ZF=0)
jmp	loc_2C9CF	; Jump

loc_2C843:		; CODE XREF: sub_2BA41+DFDj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2C84E:		; Add
add	bx, ax
mov	ax, [es:bx+22h]
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_2C85C	; Jump if Not Zero (ZF=0)
jmp	loc_2C8DF	; Jump

loc_2C85C:		; CODE XREF: sub_2BA41+E16j
or	ax, ax		; Logical Inclusive OR
jz	short loc_2C868	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_2C8A5	; Jump if Zero (ZF=1)
jmp	loc_2C919	; Jump

loc_2C868:		; CODE XREF: sub_2BA41+E1Dj
			; sub_2BA41:loc_2C919j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure

loc_2C8A0:		; CODE XREF: sub_2BA41+E9Cj
			; sub_2BA41+ED6j
add	sp, 6		; Add
jmp	short loc_2C91C	; Jump

loc_2C8A5:		; CODE XREF: sub_2BA41+E22j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch]
call	sub_19257	; Call Procedure
jmp	short loc_2C8A0	; Jump

loc_2C8DF:		; CODE XREF: sub_2BA41+E18j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch]
call	sub_1922A	; Call Procedure
jmp	short loc_2C8A0	; Jump

loc_2C919:		; CODE XREF: sub_2BA41+E24j
jmp	loc_2C868	; Jump

loc_2C91C:		; CODE XREF: sub_2BA41+E62j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ah], 0	; Compare Two Operands
jz	short loc_2C98E	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+1Ah]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+6]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2C95F:
push	[word ptr es:bx+4]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
dec	ax		; Decrement by 1
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add

loc_2C98E:		; CODE XREF: sub_2BA41+EEDj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
add	ax, 0Ah		; Add
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
jmp	loc_2CC51	; Jump

loc_2C9CF:		; CODE XREF: sub_2BA41+DFFj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2C9D6:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+22h]
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_2C9E8	; Jump if Not Zero (ZF=0)
jmp	loc_2CA6B	; Jump

loc_2C9E8:		; CODE XREF: sub_2BA41+FA2j
or	ax, ax		; Logical Inclusive OR
jz	short loc_2C9F4	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands

loc_2C9EF:		; Jump if Zero (ZF=1)
jz	short loc_2CA31
jmp	loc_2CAA5	; Jump

loc_2C9F4:		; CODE XREF: sub_2BA41+FA9j
			; sub_2BA41:loc_2CAA5j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure

loc_2CA2C:		; CODE XREF: sub_2BA41+1028j
			; sub_2BA41+1062j
add	sp, 6		; Add
jmp	short loc_2CAA8	; Jump

loc_2CA31:		; CODE XREF: sub_2BA41:loc_2C9EFj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h]
mov	ax, si
mov	dx, 26h	; '&'

loc_2CA47:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch]
call	sub_19257	; Call Procedure
jmp	short loc_2CA2C	; Jump

loc_2CA6B:		; CODE XREF: sub_2BA41+FA4j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h]
mov	ax, si

loc_2CA7E:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch]
call	sub_1922A	; Call Procedure
jmp	short loc_2CA2C	; Jump

loc_2CAA5:		; CODE XREF: sub_2BA41+FB0j
jmp	loc_2C9F4	; Jump

loc_2CAA8:		; CODE XREF: sub_2BA41+FEEj
call	sub_19D2A	; Call Procedure
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ah], 0	; Compare Two Operands
jz	short loc_2CB1F	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+1Ah]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+6]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+4]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2CB10:		; Add
add	bx, ax
mov	ax, [es:bx]
dec	ax		; Decrement by 1
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure

loc_2CB1C:		; Add
add	sp, 0Ah

loc_2CB1F:		; CODE XREF: sub_2BA41+107Ej
mov	[bp+var_C], 0

loc_2CB24:
mov	ax, [word_36A66]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right

loc_2CB2C:		; Compare Two Operands
cmp	ax, [word_36A68]
jz	short loc_2CB37	; Jump if Zero (ZF=1)
mov	[bp+var_C], 1

loc_2CB37:		; CODE XREF: sub_2BA41+10EFj
mov	ax, [word_36A66]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[word_36A68], ax
inc	[word_36A66]	; Increment by 1
cmp	[word_36A66], 3	; Compare Two Operands
jle	short loc_2CB53	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[word_36A66], 0

loc_2CB53:		; CODE XREF: sub_2BA41+110Aj
cmp	[bp+var_C], 0	; Compare Two Operands
jz	short loc_2CBCD	; Jump if Zero (ZF=1)
cmp	[word_36A68], 0	; Compare Two Operands
jnz	short loc_2CB86	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_2CB65	; Jump

loc_2CB64:		; CODE XREF: sub_2BA41+113Cj
inc	di		; Increment by 1

loc_2CB65:		; CODE XREF: sub_2BA41+1121j
cmp	[byte ptr di-5790h], 5Fh ; '_' ; Compare Two Operands
jz	short loc_2CB7F	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'

loc_2CB71:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[es:bx+20h], di	; Compare Two Operands
jg	short loc_2CB64	; Jump if Greater (ZF=0	& SF=OF)

loc_2CB7F:		; CODE XREF: sub_2BA41+1129j
mov	[byte ptr di-5790h], 0
jmp	short loc_2CBCD	; Jump

loc_2CB86:		; CODE XREF: sub_2BA41+111Dj
xor	di, di		; Logical Exclusive OR
jmp	short loc_2CB8B	; Jump

loc_2CB8A:		; CODE XREF: sub_2BA41+1165j
inc	di		; Increment by 1

loc_2CB8B:		; CODE XREF: sub_2BA41+1147j
cmp	[byte ptr di-5790h], 0 ; Compare Two Operands
jz	short loc_2CBA8	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+20h]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jg	short loc_2CB8A	; Jump if Greater (ZF=0	& SF=OF)

loc_2CBA8:		; CODE XREF: sub_2BA41+114Fj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+20h]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jle	short loc_2CBCD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 4D78h
push	ax
mov	ax, 0A870h
push	ax		; argDst

loc_2CBC6:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx

loc_2CBCD:		; CODE XREF: sub_2BA41+1116j
			; sub_2BA41+1143j
			; sub_2BA41+117Bj
mov	ax, si

loc_2CBCF:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+18h], 0	; Compare Two Operands
jz	short loc_2CC1B	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+18h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_2CC1B:		; CODE XREF: sub_2BA41+119Ej
mov	ax, 0A870h
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si

loc_2CC32:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
add	ax, 0Ah		; Add
push	ax

loc_2CC44:		; Call Procedure
call	sub_1993F
add	sp, 6		; Add
call	sub_19D1C	; Call Procedure

loc_2CC51:		; CODE XREF: sub_2BA41+F8Bj
jmp	short loc_2CC55	; Jump

loc_2CC53:		; CODE XREF: sub_2BA41+83j
			; sub_2BA41+88j
			; DATA XREF: seg034:off_2CF2Co
jmp	short $+2	; default

loc_2CC55:		; CODE XREF: sub_2BA41+1B0j
			; sub_2BA41+480j
			; sub_2BA41+750j
			; sub_2BA41+A2Fj
			; sub_2BA41:loc_2C657j
			; sub_2BA41:loc_2C798j
			; sub_2BA41+DF6j
			; sub_2BA41:loc_2CC51j
cmp	[word_36A6C], 0	; Compare Two Operands
jnz	short loc_2CC5F	; Jump if Not Zero (ZF=0)
jmp	loc_2CDB2	; Jump

loc_2CC5F:		; CODE XREF: sub_2BA41+1219j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2CC66:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 8 ;	Compare	Two Operands
jnz	short loc_2CC76	; Jump if Not Zero (ZF=0)
jmp	loc_2CDB2	; Jump

loc_2CC76:		; CODE XREF: sub_2BA41+1230j
mov	ax, 0Eh
push	ax

loc_2CC7A:
mov	ax, si

loc_2CC7C:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+4]
mov	ax, si
mov	dx, 26h	; '&'

loc_2CCA1:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2CCA9:
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1805A	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0Eh
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2CCD0:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+6]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1805A	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0Eh
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+6]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+4]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+6]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1805A	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0Eh
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+6]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+4]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'

loc_2CD9E:		; Signed Multiply
imul	dx

loc_2CDA0:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+4]
call	sub_1805A	; Call Procedure
add	sp, 0Ah		; Add

loc_2CDB2:		; CODE XREF: sub_2BA41+6Aj
			; sub_2BA41+121Bj
			; sub_2BA41+1232j
inc	si		; Increment by 1

loc_2CDB3:		; CODE XREF: sub_2BA41+2Dj
cmp	si, [idk_Mouse_w3C5A8] ; Compare Two Operands
jge	short loc_2CDBC	; Jump if Greater or Equal (SF=OF)
jmp	loc_2BA71	; Jump

loc_2CDBC:		; CODE XREF: sub_2BA41+1376j
cmp	[FLAG_w36A6E], 0 ; Compare Two Operands
jnz	short loc_2CDC6	; Jump if Not Zero (ZF=0)
jmp	loc_2CF12	; Jump

loc_2CDC6:		; CODE XREF: sub_2BA41+1380j
cmp	[idk_Flag_w36A7A], 0 ; Compare Two Operands
jnz	short loc_2CDD0	; Jump if Not Zero (ZF=0)
jmp	loc_2CF12	; Jump

loc_2CDD0:		; CODE XREF: sub_2BA41+138Aj
xor	si, si		; Logical Exclusive OR
jmp	loc_2CF09	; Jump

loc_2CDD5:		; CODE XREF: sub_2BA41+14CEj
mov	ax, si
mov	dx, 5
imul	dx		; Signed Multiply
mov	di, ax
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
db 83h,3Fh,0FFh	; <BAD>cmp     [word ptr bx], 0FFFFh ; Compare Two Operands
jnz	short loc_2CDF0	; Jump if Not Zero (ZF=0)
jmp	loc_2CF08	; Jump

loc_2CDF0:		; CODE XREF: sub_2BA41+13AAj
mov	ax, 0B4h ; ''
push	ax
mov	ax, di
add	ax, 2		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
add	ax, 3		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
add	ax, 2		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
call	sub_1805A	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0B4h ; ''
push	ax
mov	ax, di
add	ax, 4		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
add	ax, 2		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
call	sub_1805A	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0B4h ; ''
push	ax
mov	ax, di
add	ax, 4		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di

loc_2CE8F:		; Add
add	ax, 3
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
add	ax, 4		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
call	sub_1805A	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0B4h ; ''
push	ax
mov	ax, di
add	ax, 4		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
add	ax, 3		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
add	ax, 2		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, di
add	ax, 3		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [idk_Flag_w3C578]
add	bx, ax		; Add
push	[word ptr bx]
call	sub_1805A	; Call Procedure

loc_2CF05:		; Add
add	sp, 0Ah

loc_2CF08:		; CODE XREF: sub_2BA41+13ACj
inc	si		; Increment by 1

loc_2CF09:		; CODE XREF: sub_2BA41+1391j
cmp	si, [idk_Flag_w36A7A] ;	Compare	Two Operands
jge	short loc_2CF12	; Jump if Greater or Equal (SF=OF)
jmp	loc_2CDD5	; Jump

loc_2CF12:		; CODE XREF: sub_2BA41+1382j
			; sub_2BA41+138Cj
			; sub_2BA41+14CCj
push	[bp+var_14]
push	[bp+var_10]
push	[bp+var_12]
push	[bp+var_E]

loc_2CF1E:		; dx = arg_0 ... word_35EC2
call	wtfCompareSwap	; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2BA41

off_2CF2C dw offset loc_2BACE
			; DATA XREF: sub_2BA41+88r
dw offset loc_2BBF4	; jump table for switch	statement
dw offset loc_2BEC4
dw offset loc_2C194
dw offset loc_2C65A
dw offset loc_2CC53
dw offset loc_2C79B
dw offset loc_2CC53
dw offset loc_2CC53
dw offset loc_2CC53
dw offset loc_2C473
dw offset loc_2C83A


; Attributes: bp-based frame

proc sub_2CF44 far	; CODE XREF: sub_24DAE+BF1p
			; sub_2BA41+65p
			; sub_2E00A+5Cp
			; sub_2E00A+124p
			; sub_2E00A+133p
			; sub_2E00A+142p
			; sub_2E00A+1A6p

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+8]
cmp	bx, 0Ch		; switch 13 cases
jbe	short loc_2CF68	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_2DFE8	; default

loc_2CF68:		; CODE XREF: sub_2CF44+1Fj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_2DFF0+bx] ; switch jump

loc_2CF6F:		; DATA XREF: seg034:off_2DFF0o
cmp	[bp+arg_2], 0	; case 0x0
jz	short loc_2CF78	; Jump if Zero (ZF=1)
jmp	loc_2D095	; Jump

loc_2CF78:		; CODE XREF: sub_2CF44+2Fj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2CFAE:		; Add
add	bx, ax
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si

loc_2D040:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D04B:
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add

loc_2D052:		; Integer Subtraction
sub	ax, [bp+var_2]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2D05D:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
jmp	loc_2D226	; Jump

loc_2D095:		; CODE XREF: sub_2CF44+31j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2D0A0:		; Add
add	bx, ax
cmp	[word ptr es:bx+1Ch], 0	; Compare Two Operands
jnz	short loc_2D0FF	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2D0EC:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx]

loc_2D0F5:		; Call Procedure
call	sub_1F655

loc_2D0FA:		; Add
add	sp, 8
jmp	short loc_2D11B	; Jump

loc_2D0FF:		; CODE XREF: sub_2CF44+163j
mov	ax, 1
push	ax

loc_2D103:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]

loc_2D114:		; Call Procedure
call	sub_1FA6E
pop	cx
pop	cx

loc_2D11B:		; CODE XREF: sub_2CF44+1B9j
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D13C:
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]

loc_2D150:		; Call Procedure
call	sub_1F655
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2D163:		; Add
add	bx, ax
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D176:		; int
push	[word ptr es:bx+0Ch]
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right

loc_2D18C:
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; int

loc_2D1A0:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_2D1C0:		; Integer Subtraction
sub	ax, [es:bx+2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A36] ; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A34] ; Add

loc_2D226:		; CODE XREF: sub_2CF44+14Ej
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
jmp	loc_2DFEA	; Jump

loc_2D232:		; CODE XREF: sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
cmp	[bp+arg_2], 0	; case 0x1
jz	short loc_2D251	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 1 ; Compare Two Operands
jz	short loc_2D251	; Jump if Zero (ZF=1)
jmp	loc_2D36E	; Jump

loc_2D251:		; CODE XREF: sub_2CF44+2F2j
			; sub_2CF44+308j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D29A:
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2D2C1:		; Add
add	bx, ax
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure

loc_2D2CC:
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2D35F:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
jmp	loc_2D4FF	; Jump

loc_2D36E:		; CODE XREF: sub_2CF44+30Aj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+1Ch], 0	; Compare Two Operands
jnz	short loc_2D3D8	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'

loc_2D3C3:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
jmp	short loc_2D3F4	; Jump

loc_2D3D8:		; CODE XREF: sub_2CF44+43Cj
mov	ax, 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_2D3F4:		; CODE XREF: sub_2CF44+492j
xor	ax, ax		; Logical Exclusive OR

loc_2D3F6:
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D4B0:
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A36] ; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A34] ; Add

loc_2D4FF:		; CODE XREF: sub_2CF44+427j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
jmp	loc_2DFEA	; Jump

loc_2D50B:		; CODE XREF: sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
mov	ax, si		; case 0x2
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
cmp	[word ptr bx], 0 ; Compare Two Operands
jz	short loc_2D524	; Jump if Zero (ZF=1)
jmp	loc_2D64A	; Jump

loc_2D524:		; CODE XREF: sub_2CF44+5DBj
cmp	[bp+arg_2], 1	; Compare Two Operands
jnz	short loc_2D52D	; Jump if Not Zero (ZF=0)
jmp	loc_2D64A	; Jump

loc_2D52D:		; CODE XREF: sub_2CF44+5E4j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]

loc_2D53E:		; Call Procedure
call	sub_1FAD4
pop	cx

loc_2D544:		; Logical Exclusive OR
xor	ax, ax

loc_2D546:
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si

loc_2D56B:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2D574:		; Add
add	bx, ax
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, si
mov	dx, 26h	; '&'

loc_2D597:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D59F:		; int
push	[word ptr es:bx+0Ch]

loc_2D5A3:		; Call Procedure
call	idk_PalFnt_s1AB64
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, si
mov	dx, 26h	; '&'

loc_2D5CE:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
jmp	loc_2D7DB	; Jump

loc_2D64A:		; CODE XREF: sub_2CF44+5DDj
			; sub_2CF44+5E6j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx

loc_2D655:		; Add
add	bx, ax
cmp	[word ptr es:bx+1Ch], 0	; Compare Two Operands
jnz	short loc_2D6B4	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_2D660:
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D66B:
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure

loc_2D674:
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'

loc_2D67D:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
jmp	short loc_2D6D0	; Jump

loc_2D6B4:		; CODE XREF: sub_2CF44+718j
mov	ax, 1
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2D6BF:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_2D6D0:		; CODE XREF: sub_2CF44+76Ej
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D71A:		; int
push	[word ptr es:bx+0Eh]

loc_2D71E:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int

loc_2D72F:		; Call Procedure
call	idk_PalFnt_s1AB64
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction

loc_2D73F:		; Shift	Arithmetic Right
sar	ax, 1
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; int
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A36] ; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; int

loc_2D79B:
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2D7A2:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_2D7A8:
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'

loc_2D7B2:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A34] ; Add

loc_2D7DB:		; CODE XREF: sub_2CF44+703j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
jmp	loc_2DFEA	; Jump

loc_2D7E7:		; CODE XREF: sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
cmp	[bp+arg_2], 0	; case 0x3
jnz	short loc_2D804	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 0FC18h
jmp	short loc_2D82A	; Jump

loc_2D804:		; CODE XREF: sub_2CF44+8A7j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
pop	ax
mov	[bx], ax

loc_2D82A:		; CODE XREF: sub_2CF44+8BEj
mov	di, si
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	ax, [bx]
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cmp	ax, [es:bx+18h]	; Compare Two Operands
jnz	short loc_2D857	; Jump if Not Zero (ZF=0)
jmp	loc_2D971	; Jump

loc_2D857:		; CODE XREF: sub_2CF44+90Ej
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
jmp	loc_2DAFF	; Jump

loc_2D971:		; CODE XREF: sub_2CF44+910j
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2D97E:		; Compare Two Operands
cmp	[word ptr es:bx+1Ch], 0
jnz	short loc_2D9DB	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FAD4	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 8		; Add
jmp	short loc_2D9F7	; Jump

loc_2D9DB:		; CODE XREF: sub_2CF44+A3Fj
mov	ax, 1
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx

loc_2D9F7:		; CODE XREF: sub_2CF44+A95j
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+2]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
call	sub_1BBF9	; Call Procedure
dec	ax		; Decrement by 1
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_2], ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h] ; int
mov	ax, di
mov	dx, 26h	; '&'

loc_2DA7E:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A36] ; Add
sub	ax, [bp+var_2]	; Integer Subtraction
push	ax		; int
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, di
mov	dx, 26h	; '&'

loc_2DAD6:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx]
pop	dx
add	ax, dx		; Add
add	ax, [word_36A34] ; Add

loc_2DAFF:		; CODE XREF: sub_2CF44+A2Aj
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
jmp	loc_2DFEA	; Jump

loc_2DB0B:		; CODE XREF: sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
cmp	[bp+arg_2], 0	; case 0xA
jnz	short loc_2DB28	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	[word ptr bx], 0
jmp	short loc_2DB62	; Jump

loc_2DB28:		; CODE XREF: sub_2CF44+BCBj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2DB62	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
pop	ax
mov	[bx], ax

loc_2DB62:		; CODE XREF: sub_2CF44+BE2j
			; sub_2CF44+BF6j
mov	di, si
push	[word_36A50]	; int
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Eh] ; int
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
call	sub_1A542	; Call Procedure
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_4], ax
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_2DBAA	; Jump if Not Zero (ZF=0)
mov	[bp+var_4], 1

loc_2DBAA:		; CODE XREF: sub_2CF44+C5Fj
call	sub_1BBF9	; Call Procedure
mov	[bp+var_2], ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
mov	ax, [bx]
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cmp	ax, [es:bx+18h]	; Compare Two Operands
jnz	short loc_2DBDD	; Jump if Not Zero (ZF=0)
jmp	loc_2DCA1	; Jump

loc_2DBDD:		; CODE XREF: sub_2CF44+C94j
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2DC2F	; Jump if Zero (ZF=1)
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
inc	ax		; Increment by 1
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
jmp	short loc_2DC9E	; Jump

loc_2DC2F:		; CODE XREF: sub_2CF44+CABj
push	[word_36A50]	; int
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+14h] ; int
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+0Ch] ; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
inc	ax		; Increment by 1
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
call	sub_19D1C	; Call Procedure

loc_2DC9E:		; CODE XREF: sub_2CF44+CE9j
jmp	loc_2DD89	; Jump

loc_2DCA1:		; CODE XREF: sub_2CF44+C96j
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+22h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+20h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+1Eh]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+1Ch]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+10h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
add	ax, [bp+var_2]	; Add
inc	ax		; Increment by 1
push	ax

loc_2DD0C:
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx+4]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
sub	ax, [bp+var_4]	; Integer Subtraction
inc	ax		; Increment by 1

loc_2DD32:
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2DD3A:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	ax, [es:bx]
dec	ax		; Decrement by 1
push	ax
call	sub_18579	; Call Procedure
add	sp, 12h		; Add
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2DD54:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
push	[word ptr es:bx+16h]
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+2]
inc	ax		; Increment by 1
push	ax
mov	ax, di
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
push	[word ptr es:bx]
call	sub_1993F	; Call Procedure
add	sp, 6		; Add

loc_2DD89:		; CODE XREF: sub_2CF44:loc_2DC9Ej
jmp	loc_2DFEA	; Jump

loc_2DD8C:		; CODE XREF: sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
cmp	[bp+arg_2], 1	; case 0xC
jz	short loc_2DD95	; Jump if Zero (ZF=1)
jmp	loc_2DFA2	; Jump

loc_2DD95:		; CODE XREF: sub_2CF44+E4Cj
call	get__Mouse_w360A4 ; Call Procedure
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cwd			; AX ->	DX:AX (with sign)
idiv	[word ptr es:bx+18h] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ch]
pop	ax
mov	[bx], ax
call	get__Mouse_w360A6 ; Call Procedure
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx+2]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cwd			; AX ->	DX:AX (with sign)
idiv	[word ptr es:bx+1Ah] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Eh]
pop	ax
mov	[bx], ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cwd			; AX ->	DX:AX (with sign)
idiv	[word ptr es:bx+18h] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2DE55:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	bx, [es:bx+1Ch]
pop	ax
cmp	ax, [bx]	; Compare Two Operands
jge	short loc_2DEB0	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+4]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
sub	ax, [es:bx]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cwd			; AX ->	DX:AX (with sign)
idiv	[word ptr es:bx+18h] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ch]
pop	ax
mov	[bx], ax

loc_2DEB0:		; CODE XREF: sub_2CF44+F1Ej
mov	ax, si
mov	dx, 26h	; '&'

loc_2DEB5:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_2DED0:		; Integer Subtraction
sub	ax, [es:bx+2]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cwd			; AX ->	DX:AX (with sign)
idiv	[word ptr es:bx+1Ah] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Eh]
pop	ax
cmp	ax, [bx]	; Compare Two Operands
jge	short loc_2DF4C	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_2DF1F:		; Integer Subtraction
sub	ax, [es:bx+2]
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
cwd			; AX ->	DX:AX (with sign)
idiv	[word ptr es:bx+1Ah] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Eh]
pop	ax
mov	[bx], ax

loc_2DF4C:		; CODE XREF: sub_2CF44+FB9j
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ch]
cmp	[word ptr bx], 0 ; Compare Two Operands
jge	short loc_2DF77	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ch]
mov	[word ptr bx], 0

loc_2DF77:		; CODE XREF: sub_2CF44+101Cj
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2DF7E:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	bx, [es:bx+1Eh]
cmp	[word ptr bx], 0 ; Compare Two Operands
jge	short loc_2DFA2	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply

loc_2DF94:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add
mov	bx, [es:bx+1Eh]
mov	[word ptr bx], 0

loc_2DFA2:		; CODE XREF: sub_2CF44+E4Ej
			; sub_2CF44+1047j
jmp	short loc_2DFEA	; Jump

loc_2DFA4:		; CODE XREF: sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
cmp	[bp+arg_2], 1	; case 0x6
jnz	short loc_2DFB0	; Jump if Not Zero (ZF=0)
push	si
push	cs
call	near ptr sub_2A235 ; Call Procedure

loc_2DFAF:
pop	cx

loc_2DFB0:		; CODE XREF: sub_2CF44+1064j
jmp	short loc_2DFEA	; Jump

loc_2DFB2:		; CODE XREF: sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
cmp	[bp+arg_2], 1	; case 0x9
jnz	short loc_2DFDE	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h	; '&'   ; int
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [es:bx+18h]	; int
push	ax
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	bx, [es:bx+1Ah]
pop	ax
mov	[bx], ax

loc_2DFDE:		; CODE XREF: sub_2CF44+1072j
jmp	short loc_2DFEA	; Jump

loc_2DFE0:		; CODE XREF: sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
push	si		; case 0x4
push	cs
call	near ptr sub_28141 ; Call Procedure
pop	cx
jmp	short loc_2DFEA	; Jump

loc_2DFE8:		; CODE XREF: sub_2CF44+21j
			; sub_2CF44+26j
			; DATA XREF: seg034:off_2DFF0o
jmp	short $+2	; default

loc_2DFEA:		; CODE XREF: sub_2CF44+2EBj
			; sub_2CF44+5C4j
			; sub_2CF44+8A0j
			; sub_2CF44+BC4j
			; sub_2CF44:loc_2DD89j
			; sub_2CF44:loc_2DFA2j
			; sub_2CF44:loc_2DFB0j
			; sub_2CF44:loc_2DFDEj
			; sub_2CF44+10A2j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2CF44 ; sp-analysis failed

off_2DFF0 dw offset loc_2CF6F
			; DATA XREF: sub_2CF44+26r
dw offset loc_2D232	; jump table for switch	statement
dw offset loc_2D50B
dw offset loc_2D7E7
dw offset loc_2DFE0
dw offset loc_2DFE8
dw offset loc_2DFA4
dw offset loc_2DFE8
dw offset loc_2DFE8
dw offset loc_2DFB2
dw offset loc_2DB0B
dw offset loc_2DFE8
dw offset loc_2DD8C


; Attributes: bp-based frame

proc sub_2E00A far	; CODE XREF: sub_24DAE+207p
			; sub_24DAE+4ACp
			; sub_24DAE+870p
			; sub_24DAE:loc_25883p
			; sub_24DAE+CC4p
			; sub_24DAE:loc_25CCEp
			; sub_26026+1D0p
			; sub_26026+3E8p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
or	di, di		; Logical Inclusive OR
jge	short loc_2E01C	; Jump if Greater or Equal (SF=OF)
jmp	loc_2E1E1	; Jump

loc_2E01C:		; CODE XREF: sub_2E00A+Dj
cmp	di, 140h	; Compare Two Operands
jl	short loc_2E025	; Jump if Less (SF!=OF)
jmp	loc_2E1E1	; Jump

loc_2E025:		; CODE XREF: sub_2E00A+16j
cmp	[bp+arg_4], 0	; Compare Two Operands
jge	short loc_2E02E	; Jump if Greater or Equal (SF=OF)
jmp	loc_2E1E1	; Jump

loc_2E02E:		; CODE XREF: sub_2E00A+1Fj
cmp	[bp+arg_4], 0C8h ; '' ; Compare Two Operands
jl	short loc_2E038	; Jump if Less (SF!=OF)
jmp	loc_2E1E1	; Jump

loc_2E038:		; CODE XREF: sub_2E00A+29j
cmp	[hrmMouseInstalled], 0 ; Compare Two Operands

loc_2E03D:		; Jump if Not Zero (ZF=0)
jnz	short loc_2E042
jmp	loc_2E19C	; Jump

loc_2E042:		; CODE XREF: sub_2E00A:loc_2E03Dj
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
cmp	si, [w36A32]	; Compare Two Operands
jnz	short loc_2E050	; Jump if Not Zero (ZF=0)
jmp	loc_2E195	; Jump

loc_2E050:		; CODE XREF: sub_2E00A+41j
db 83h,3Eh,22h,4Dh,0FFh	; <BAD>cmp     [w36A32], 0FFFFh	; Compare Two Operands
jnz	short loc_2E0B2	; Jump if Not Zero (ZF=0)
call	idk_ChkMousDoEga ; Call	Procedure
mov	[w36A32], si

loc_2E060:
mov	ax, 1
push	ax
push	si
push	cs
call	near ptr sub_2CF44 ; Call Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 26h	; '&'

loc_2E070:		; Signed Multiply
imul	dx
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 4 ;	Compare	Two Operands
jnz	short loc_2E08E	; Jump if Not Zero (ZF=0)
call	get__Mouse_w360A4 ; Call Procedure
mov	di, ax
call	get__Mouse_w360A6 ; Call Procedure
mov	[bp+arg_4], ax

loc_2E08E:		; CODE XREF: sub_2E00A+73j
push	[bp+arg_4]
push	di
call	sub_24648	; Call Procedure
pop	cx
pop	cx
push	[bp+arg_4]
push	di
call	sub_24A74	; Call Procedure
pop	cx
pop	cx
push	[bp+arg_4]
push	di
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx
jmp	loc_2E195	; Jump

loc_2E0B2:		; CODE XREF: sub_2E00A+4Bj
cmp	[w36A32], si	; Compare Two Operands
jnz	short loc_2E0BB	; Jump if Not Zero (ZF=0)
jmp	loc_2E195	; Jump

loc_2E0BB:		; CODE XREF: sub_2E00A+ACj
call	idk_ChkMousDoEga ; Call	Procedure
mov	ax, [w36A32]
mov	dx, 26h
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_2E0CE:		; Compare Two Operands
cmp	[word ptr es:bx+8], 3
jnz	short loc_2E0E9	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h
imul	dx		; Signed Multiply

loc_2E0DC:		; Load Full Pointer to ES:xx
les	bx, [idk2_dw3C5B2]
add	bx, ax		; Add

loc_2E0E2:		; Compare Two Operands
cmp	[word ptr es:bx+8], 3
jnz	short loc_2E142	; Jump if Not Zero (ZF=0)

loc_2E0E9:		; CODE XREF: sub_2E00A+C9j
mov	ax, [w36A32]

loc_2E0EC:
mov	dx, 26h
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jnz	short loc_2E135	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_2E100:
mov	dx, 26h
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 0Ah	; Compare Two Operands
jnz	short loc_2E133	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 26h
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+12h], 0	; Compare Two Operands
jz	short loc_2E133	; Jump if Zero (ZF=1)
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[w36A32]
push	cs
call	near ptr sub_2CF44 ; Call Procedure

loc_2E131:
pop	cx
pop	cx

loc_2E133:		; CODE XREF: sub_2E00A+106j
			; sub_2E00A+11Aj
jmp	short loc_2E142	; Jump

loc_2E135:		; CODE XREF: sub_2E00A+F2j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[w36A32]
push	cs
call	near ptr sub_2CF44 ; Call Procedure
pop	cx
pop	cx

loc_2E142:		; CODE XREF: sub_2E00A+DDj
			; sub_2E00A:loc_2E133j
mov	[w36A32], si
mov	ax, 1
push	ax
push	si
push	cs
call	near ptr sub_2CF44 ; Call Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 26h	; '&'
imul	dx		; Signed Multiply
les	bx, [idk2_dw3C5B2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+8], 4 ;	Compare	Two Operands
jnz	short loc_2E174	; Jump if Not Zero (ZF=0)
call	get__Mouse_w360A4 ; Call Procedure
mov	di, ax
call	get__Mouse_w360A6 ; Call Procedure
mov	[bp+arg_4], ax

loc_2E174:		; CODE XREF: sub_2E00A+159j
push	[bp+arg_4]
push	di
call	sub_24648	; Call Procedure
pop	cx
pop	cx

loc_2E17F:
push	[bp+arg_4]
push	di
call	sub_24A74	; Call Procedure
pop	cx
pop	cx

loc_2E18A:
push	[bp+arg_4]
push	di
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx

loc_2E195:		; CODE XREF: sub_2E00A+43j
			; sub_2E00A+A5j
			; sub_2E00A+AEj
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
jmp	short loc_2E1E1	; Jump

loc_2E19C:		; CODE XREF: sub_2E00A+35j
call	idk_ChkMousDoEga ; Call	Procedure
call	idk_VGA_s1E4BA	; Call Procedure

loc_2E1A6:
mov	[w36A32], si
mov	ax, 1
push	ax
push	si
push	cs
call	near ptr sub_2CF44 ; Call Procedure
pop	cx
pop	cx
mov	[w36A32], 0FFFFh
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
push	[bp+arg_4]
push	di
call	sub_24648	; Call Procedure
pop	cx
pop	cx
push	[bp+arg_4]
push	di
call	sub_24A74	; Call Procedure
pop	cx
pop	cx
push	[bp+arg_4]
push	di
call	CALL_PositionMouseCursor ; Call	Procedure
pop	cx
pop	cx

loc_2E1E1:		; CODE XREF: sub_2E00A+Fj
			; sub_2E00A+18j
			; sub_2E00A+21j
			; sub_2E00A+2Bj
			; sub_2E00A+190j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_2E00A



; Attributes: bp-based frame

proc idk_SetValue_w36A38_s2E1E5	far

arg_0= word ptr	 6

push	bp
mov	bp, sp

loc_2E1E8:
mov	ax, [bp+arg_0]
mov	[idk_Value_w36A38], ax
pop	bp
retf			; Return Far from Procedure
endp idk_SetValue_w36A38_s2E1E5



; Attributes: bp-based frame

proc idk_SetValue_w36A38_FFFF_s2E1F0 far
push	bp
mov	bp, sp
mov	[idk_Value_w36A38], 0FFFFh
pop	bp
retf			; Return Far from Procedure
endp idk_SetValue_w36A38_FFFF_s2E1F0



; Attributes: bp-based frame

proc sub_2E1FB far	; CODE XREF: _f010509_MainMenuScreen+3D0P
			; sub_3CFC0+285P
			; sub_3DBA6+2ECP
			; sub_3E1DE+2FDP
			; sub_3EBA0+16BP
			; sub_3F3C6+134P
			; idk_Load_NEWGAME_LBX+53P
			; sub_3F7D8+169P
			; sub_3FBE0+1A6P
			; sub_3FBE0+258P
			; sub_4067D+36EP
			; sub_4067D+6E6P
			; LBX_NewGame_s41A5F+157P
			; LBX_NewGame_s41A5F+718P
			; sub_4D5B0:loc_4D72EP
			; sub_4D8FA+D8P
			; sub_4DB4D+1F8P
			; sub_4E9F4+174P
			; sub_4EF74+18AP
			; idk_OVR_LoadLbxHelp+4F8P
			; sub_56450+AEP

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	bx, [bp+arg_4]
mov	ax, [bp+arg_2]
mov	dx, [bp+arg_0]
mov	[word ptr dword_3C5AE+2], ax
mov	[word ptr dword_3C5AE],	dx
mov	[idk_FLAG_w36A2C], 1
or	bx, bx		; Logical Inclusive OR
jle	short loc_2E223	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	bx, 10		; Compare Two Operands
jge	short loc_2E223	; Jump if Greater or Equal (SF=OF)
mov	[idk_InitRoland_w36A3C], bx
jmp	short loc_2E229	; Jump

loc_2E223:		; CODE XREF: sub_2E1FB+1Bj
			; sub_2E1FB+20j
mov	[idk_InitRoland_w36A3C], 2

loc_2E229:		; CODE XREF: sub_2E1FB+26j
pop	bp
retf			; Return Far from Procedure
endp sub_2E1FB



; Attributes: bp-based frame

proc sub_2E22B far	; CODE XREF: sub_4D8FA+6BP
			; idk_OVR_LoadLbxHelp+4E7P
push	bp
mov	bp, sp

loc_2E22E:
mov	ax, [word ptr dword_3C5AE+2]
mov	dx, [word ptr dword_3C5AE]
mov	[word_3C5AC], ax
mov	[word_3C5AA], dx
pop	bp
retf			; Return Far from Procedure
endp sub_2E22B



; Attributes: bp-based frame

proc sub_2E23E far	; CODE XREF: sub_4D8FA+F9P
			; idk_OVR_LoadLbxHelp+505P
push	bp
mov	bp, sp
mov	ax, [word_3C5AC]
mov	dx, [word_3C5AA]
mov	[word ptr dword_3C5AE+2], ax
mov	[word ptr dword_3C5AE],	dx
mov	[idk_FLAG_w36A2C], 1
pop	bp
retf			; Return Far from Procedure
endp sub_2E23E



; Attributes: bp-based frame

proc sub_2E257 far	; CODE XREF: _f010509_MainMenuScreen:loc_13CA4P
			; sub_1D1B5+24P
			; sub_3CFC0:loc_3D355P
			; sub_3DBA6:loc_3DF7CP
			; sub_3E1DE+31FP
			; sub_3E1DE+362P
			; sub_3EBA0+1BFP
			; sub_3EBA0+1E4P
			; sub_3F3C6+17DP
			; idk_Load_NEWGAME_LBX+F5P
			; sub_3F7D8:loc_3F9EBP
			; sub_3FBE0+238P
			; sub_3FBE0:loc_40021P
			; sub_4067D:loc_40D42P
			; sub_4067D:loc_40E9DP
			; LBX_NewGame_s41A5F:loc_4215BP
			; LBX_NewGame_s41A5F:loc_421C9P
			; idk_BuildingWorlds+82P
			; sub_4D5B0+1CDP
			; sub_4DB4D:loc_4E017P
			; sub_4E9F4+1FEP
			; sub_4EF74+212P
			; sub_56450+7P
			; sub_56450+123P
push	bp
mov	bp, sp
mov	[idk_FLAG_w36A2C], 0
pop	bp
retf			; Return Far from Procedure
endp sub_2E257

push	bp
mov	bp, sp
mov	[idk_FLAG_w36A2C], 1
pop	bp
retf			; Return Far from Procedure


; Attributes: bp-based frame

proc sub_2E26D far	; CODE XREF: sub_24DAE+B9Cp
			; sub_24DAE+CB6p
			; sub_24DAE:loc_25BA7p
			; sub_28141+18p
			; sub_28963+46p
			; sub_2A755+A35p
			; sub_2B1F9+1E6p
			; sub_2E27D+15p
			; sub_2E2B7+15p
push	bp
mov	bp, sp
cmp	[idk_FLAG_w36A2C], 0 ; Compare Two Operands
jz	short loc_2E27B	; Jump if Zero (ZF=1)
call	[dword_3C5AE]	; Indirect Call	Far Procedure

loc_2E27B:		; CODE XREF: sub_2E26D+8j
pop	bp
retf			; Return Far from Procedure
endp sub_2E26D



; Attributes: bp-based frame

proc sub_2E27D far	; CODE XREF: sub_24DAE+267p
			; sub_24DAE+2BDp
			; sub_24DAE+305p
			; sub_24DAE+566p
			; sub_24DAE+878p
			; sub_24DAE+B31p
			; sub_26026+4A7p
push	bp
mov	bp, sp
cmp	[idk_FLAG_w36A2C], 0 ; Compare Two Operands
jz	short loc_2E2AB	; Jump if Zero (ZF=1)
call	_f020105_bios_timeofday	; Call Procedure
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
push	cs
call	near ptr sub_2E26D ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_2E303 ; Call Procedure
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
jmp	short loc_2E2B5	; Jump

loc_2E2AB:		; CODE XREF: sub_2E27D+8j
call	idk_SetPalette_s1C4F4 ;	Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_2E303 ; Call Procedure

loc_2E2B5:		; CODE XREF: sub_2E27D+2Cj
pop	bp
retf			; Return Far from Procedure
endp sub_2E27D



; Attributes: bp-based frame

proc sub_2E2B7 far	; CODE XREF: sub_24DAE+DD3p
			; sub_27C84:loc_27CA8p
			; sub_27CC0+148p
			; sub_27CC0+15Fp
push	bp
mov	bp, sp
cmp	[idk_FLAG_w36A2C], 0 ; Compare Two Operands
jz	short loc_2E2E5	; Jump if Zero (ZF=1)

loc_2E2C1:		; Call Procedure
call	_f020105_bios_timeofday

loc_2E2C6:		; Call Procedure
call	VGA_MathThenSetVarToVgaLoc
push	cs
call	near ptr sub_2E26D ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
nop			; No Operation
push	cs

loc_2E2D6:		; Call Procedure
call	near ptr sub_2E303
push	[idk_InitRoland_w36A3C]
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
jmp	short loc_2E2EF	; Jump

loc_2E2E5:		; CODE XREF: sub_2E2B7+8j
call	idk_SetPalette_s1C4F4 ;	Call Procedure

loc_2E2EA:		; No Operation
nop
push	cs
call	near ptr sub_2E303 ; Call Procedure

loc_2E2EF:		; CODE XREF: sub_2E2B7+2Cj
pop	bp
retf			; Return Far from Procedure
endp sub_2E2B7



; Attributes: bp-based frame

proc sub_2E2F1 far
push	bp
mov	bp, sp
push	cs
call	near ptr setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, 1
push	ax
push	cs
call	near ptr sub_2B9C4 ; Call Procedure
pop	cx
pop	bp
retf			; Return Far from Procedure
endp sub_2E2F1



; Attributes: bp-based frame

proc sub_2E303 far	; CODE XREF: _f010509_MainMenuScreen+482P
			; ST_execl_WizardsExe+1DP
			; sub_1D1B5+244P
			; sub_1D40D:loc_1D577P
			; sub_28963+3D4p
			; sub_2A755+A3Fp
			; sub_2B1F9+218p
			; sub_2E27D+1Fp
			; sub_2E27D+35p
			; sub_2E2B7:loc_2E2D6p
			; sub_2E2B7+35p
			; sub_3CFC0+36DP
			; sub_3DBA6+3A4P
			; sub_3E1DE+3F6P
			; sub_3EBA0+203P
			; sub_3F3C6+1BDP
			; idk_Load_NEWGAME_LBX+65P
			; sub_3F7D8+1EDP
			; sub_3FBE0+285P
			; sub_3FBE0+419P
			; sub_4067D+7F8P
			; LBX_NewGame_s41A5F+736P
			; sub_43572+3P
			; idk_BuildingWorlds+87P
			; sub_4CAF3+58P
			; sub_4F44D+324P
			; ST_LoadMusicSoundfxIntro:loc_55B10P
			; idk_OVR_LoadLbxHelp+4DDP
			; sub_56450+43P
			; sub_56450+184P
push	bp
mov	bp, sp
push	si
push	di
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
call	get__Mouse_w360A4 ; Call Procedure

loc_2E312:
mov	si, ax
call	get__Mouse_w360A6 ; Call Procedure
mov	di, ax
push	cs

loc_2E31C:		; Call Procedure
call	near ptr sub_2BA41
push	di
push	si
call	idk_Mouse_s23F82 ; Call	Procedure
pop	cx
pop	cx
push	di
push	si
call	sub_2471B	; Call Procedure
pop	cx
pop	cx
push	di
push	si

loc_2E333:		; Call Procedure
call	sub_24A9A

loc_2E338:
pop	cx
pop	cx

loc_2E33A:		; Call Procedure
call	idk_VGA_CRTR_s1E4F1

loc_2E33F:		; Call Procedure
call	sub_2495B

loc_2E344:		; Call Procedure
call	idk_Dseg_RepMovSw

loc_2E349:		; FLAG_w3609E =	FLAG_w360BE
call	Restore_Set_FLAG_Mouse_Skip

loc_2E34E:
pop	di

loc_2E34F:
pop	si

loc_2E350:
pop	bp

locret_2E351:		; Return Far from Procedure
retf
endp sub_2E303

ends seg034


; Segment type:	Pure code
segment	seg035 byte public 'CODE' use16
assume cs:seg035
;org 2
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
word_2E352 dw 0		; DATA XREF: _AIL_startup+5w
			; _AIL_register_timer:loc_2EB1Fw
			; _AIL_register_timer+55r
			; _AIL_release_timer_handle+21w
			; sub_2F1CC+Cr
			; sub_2F203+Cr
word_2E354 dw 0		; DATA XREF: seg035:040Cw
			; seg035:041Br
			; seg035:04D3w
			; _AIL_startup+Cw
byte_2E356 db 40h dup(0)
word_2E396 dw 0		; DATA XREF: sub_2E870+21w
word_2E398 dw 0		; DATA XREF: sub_2E870+26w
byte_2E39A db 42h dup(0)
word_2E3DC dw 0		; DATA XREF: _AIL_register_timer+62w
byte_2E3DE db 88h dup(0)
word_2E466 dw 0		; DATA XREF: seg035:045Er
			; sub_2E82D+6w
			; sub_2E98A+57r
			; sub_2E98A+6Cw
word_2E468 dw 0		; DATA XREF: seg035:0463r
			; sub_2E82D+Dw
			; sub_2E98A+5Er
			; sub_2E98A+70w
dword_2E46A dd 0	; DATA XREF: seg035:loc_2E86Ar
			; sub_2E870+14w
			; sub_2E8BC+Cr
			; sub_2E870+19w
			; sub_2E8BC+11r
word_2E46E dw 0		; DATA XREF: seg035:0437w
			; seg035:loc_2E78Er
			; seg035:loc_2E7EDw
			; seg035:04A2r
			; sub_2E8BC:loc_2E8C1w
			; sub_2E98A:loc_2E9EFw
word_2E470 dw 0		; DATA XREF: sub_2E98A+6w
			; sub_2E98A+38r
			; sub_2E98A:loc_2E9C9w
			; sub_2E98A:loc_2E9D8r
word_2E472 dw 0		; DATA XREF: sub_2E98A+Dw
			; sub_2E98A+2Fr
			; sub_2E98A+43w
			; sub_2E98A+52r
word_2E474 dw 0		; DATA XREF: hrmTimer+Fw
			; _AIL_interrupt_divisor+5r
byte_2E476 db 84h dup(0)
word_2E4FA dw 0		; DATA XREF: _AIL_shutdown+8w
			; _AIL_shutdown:loc_2EA79r
			; _AIL_shutdown+3Cr
			; _AIL_shutdown:loc_2EAB2w
			; _AIL_shutdown+4Dr
			; _AIL_register_driver+8w
			; _AIL_register_driver:loc_2ED82r
			; _AIL_register_driver+24w
			; _AIL_register_driver+29r
			; _AIL_register_driver+71r
			; _AIL_register_driver:loc_2EE05r
			; _AIL_register_driver+B4r
align 8
word_2E500 dw 0		; DATA XREF: _AIL_init_driver:loc_2EEDAw
			; _AIL_init_driver+56w
			; _AIL_init_driver+92r
			; _AIL_init_driver+9Ar
aTest db 'Test',0       ; DATA XREF: seg035:04C1r
			; seg035:04CAr
byte_2E507 db 203h dup(0)
word_2E70A dw 0D3h	; DATA XREF: _AIL_register_driver+8Br
; [00000038 BYTES: COLLAPSED FUNCTION AIL_find_proc. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function

proc AIL_call_driver far
			; CODE XREF: _AIL_describe_driver+1Ep
			; _AIL_detect_device+3j
			; _AIL_init_driver+80p
			; _AIL_shutdown_driver+2Fj
			; _AIL_index_VOC_block+3j
			; _AIL_register_sound_buffer+3j
			; _AIL_format_sound_buffer+3j
			; _AIL_sound_buffer_status+3j
			; _AIL_play_VOC_file+3j
			; _AIL_format_VOC_file+3j
			; _AIL_VOC_playback_status+3j
			; _AIL_start_digital_playback+3j
			; _AIL_stop_digital_playback+3j
			; _AIL_pause_digital_playback+3j
			; _AIL_resume_digital_playback+3j
			; _AIL_set_digital_playback_volume+3j
			; _AIL_digital_playback_volume+3j
			; _AIL_set_digital_playback_panpot+3j
			; _AIL_digital_playback_panpot+3j
			; _AIL_state_table_size+3j
			; _AIL_register_sequence+3j
			; _AIL_release_sequence_handle+3j
			; _AIL_default_timbre_cache_size+3j
			; _AIL_define_timbre_cache+3j
			; _AIL_timbre_request+3j
			; _AIL_install_timbre+3j
			; _AIL_protect_timbre+3j
			; _AIL_unprotect_timbre+3j
			; _AIL_timbre_status+3j
			; _AIL_start_sequence+3j
			; _AIL_stop_sequence+3j
			; _AIL_resume_sequence+3j
			; _AIL_sequence_status+3j
			; _AIL_relative_volume+3j
			; _AIL_relative_tempo+3j
			; _AIL_set_relative_volume+3j
			; _AIL_set_relative_tempo+3j
			; _AIL_beat_count+3j
			; _AIL_measure_count+3j
			; _AIL_branch_index+3j
			; _AIL_controller_value+3j
			; _AIL_set_controller_value+3j
			; _AIL_channel_notes+3j
			; _AIL_send_channel_voice_message+3j
			; _AIL_send_sysex_message+3j
			; _AIL_write_display+3j
			; _AIL_install_callback+3j
			; _AIL_cancel_callback+3j
			; _AIL_lock_channel+3j
			; _AIL_map_sequence_channel+3j
			; _AIL_release_channel+3j
			; _AIL_true_sequence_channel+3j
mov	bx, sp
mov	bx, [ss:bx+4]
push	cs
call	near ptr AIL_find_proc ;   mov	   bx, sp
			;   mov	    bx,	ss:[bx+4]
			;   push    cs
			;   OR
			;   mov	    ax,	67h
			;   mov	    bx,	[bp+arg_2]
			;   push    cs
			; Return:
			;   mov	    ax,	es:[bx+2]
			;   mov	    dx,	es
			;   OR
			;   mov	    ax,	0
			;   mov	    dx,	0
cmp	ax, 0		; Compare Two Operands
jnz	short loc_2E758	; Jump if Not Zero (ZF=0)
cmp	dx, 0		; If (DX == 0) Then Set	(ZF = 1)
jz	short locret_2E75B ; Jump if Zero (ZF=1)

loc_2E758:		; CODE XREF: AIL_call_driver+Dj
push	dx
push	ax
retf			; Return Far from Procedure

locret_2E75B:		; CODE XREF: AIL_call_driver+12j
retf			; Return Far from Procedure
endp AIL_call_driver ; sp-analysis failed

inc	[cs:word_2E354]	; Increment by 1
cld			; Clear	Direction Flag
push	ax
push	bx
push	cx
push	dx
push	si
push	di
push	bp
push	es
push	ds
cmp	[cs:word_2E354], 1 ; Compare Two Operands
jz	short loc_2E776	; Jump if Zero (ZF=1)
jmp	loc_2E804	; Jump

loc_2E776:		; CODE XREF: seg035:0421j
mov	[word ptr cs:byte_2E507+1FFh], ss
mov	[word ptr cs:byte_2E507+201h], sp
mov	ax, cs
mov	ss, ax
assume ss:seg035
mov	sp, 3B6h
mov	[cs:word_2E46E], 0

loc_2E78E:		; CODE XREF: seg035:04A8j
mov	si, [cs:word_2E46E]
shl	si, 1		; Shift	Logical	Left

loc_2E795:		; Compare Two Operands
db 2Eh,83h,0BCh,6Ch,0,2	; <BAD>cmp     [word ptr cs:si+6Ch], 2
jnz	short loc_2E7ED	; Jump if Not Zero (ZF=0)
db 2Eh,8Eh,9Ch,4Ah,0 ; <BAD>mov	    ds,	[word ptr cs:si+4Ah]
shl	si, 1		; Shift	Logical	Left
mov	ax, [cs:si+8Eh]
mov	dx, [cs:si+90h]
add	ax, [cs:word_2E466] ; Add
adc	dx, [cs:word_2E468] ; Add with Carry

loc_2E7B8:		; Compare Two Operands
cmp	dx, [cs:si+0D4h]

loc_2E7BD:		; Jump if Below	(CF=1)
jb	short loc_2E7C8
ja	short loc_2E7D4	; Jump if Above	(CF=0 &	ZF=0)
cmp	ax, [cs:si+0D2h] ; Compare Two Operands
jnb	short loc_2E7D4	; Jump if Not Below (CF=0)

loc_2E7C8:		; CODE XREF: seg035:loc_2E7BDj
mov	[cs:si+8Eh], ax

loc_2E7CD:
mov	[cs:si+90h], dx
jmp	short loc_2E7ED	; Jump

loc_2E7D4:		; CODE XREF: seg035:046Fj
			; seg035:0476j
sub	ax, [cs:si+0D2h] ; Integer Subtraction
sbb	dx, [cs:si+0D4h] ; Integer Subtraction with Borrow
mov	[cs:si+8Eh], ax
mov	[cs:si+90h], dx
db 2Eh,0FFh,9Ch,6,0 ; <BAD>call	   [dword ptr cs:si+6] ; Indirect Call Far Procedure

loc_2E7ED:		; CODE XREF: seg035:044Bj
			; seg035:0482j
inc	[cs:word_2E46E]	; Increment by 1
cmp	[cs:word_2E46E], 10h ; Compare Two Operands
jbe	short loc_2E78E	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	ss, [word ptr cs:byte_2E507+1FFh]
assume ss:nothing
mov	sp, [word ptr cs:byte_2E507+201h]

loc_2E804:		; CODE XREF: seg035:0423j
pop	ds
pop	es
pop	bp
pop	di
pop	si
pop	dx
pop	cx
pop	bx
mov	al, 20h	; ' '
out	20h, al		; Interrupt controller,	8259A.
pop	ax
cmp	[word ptr cs:aTest], 6554h ; "Test"

loc_2E818:		; Jump if Not Zero (ZF=0)
jnz	short loc_2E829
cmp	[word ptr cs:aTest+2], 7473h ; Compare Two Operands
jnz	short loc_2E829	; Jump if Not Zero (ZF=0)
dec	[cs:word_2E354]	; Decrement by 1
iret			; Interrupt Return

loc_2E829:		; CODE XREF: seg035:loc_2E818j
			; seg035:04D1j
			; seg035:04DBj
sti			; Set Interrupt	Flag
int	3		; Trap to Debugger
jmp	short loc_2E829	; Jump
; [00000034 BYTES: COLLAPSED FUNCTION sub_2E82D. PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2E85E+1 ; Call Procedure
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
pushf			; Push Flags Register onto the Stack

loc_2E86A:		; Indirect Call	Far Procedure
call	[cs:dword_2E46A]
retf			; Return Far from Procedure
; [00000044 BYTES: COLLAPSED FUNCTION sub_2E870. PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2E8B1+1 ; Call Procedure
pop	di
pop	si
pop	ds
assume ds:dseg
retf			; Return Far from Procedure
; [00000028 BYTES: COLLAPSED FUNCTION sub_2E8BC. PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2E8E1+1 ; Call Procedure
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
; [00000020 BYTES: COLLAPSED FUNCTION hrmTimer.	PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2E909+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
; [0000002A BYTES: COLLAPSED FUNCTION sub_2E915. PRESS KEYPAD "+" TO EXPAND]
; [0000004B BYTES: COLLAPSED FUNCTION sub_2E93F. PRESS KEYPAD "+" TO EXPAND]
; [0000008D BYTES: COLLAPSED FUNCTION sub_2E98A. PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2EA14+1 ; Call Procedure
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
; [00000043 BYTES: COLLAPSED FUNCTION _AIL_startup. PRESS KEYPAD "+" TO	EXPAND]
push	cs
call	near ptr loc_2EA5F+1 ; Call Procedure
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
; [0000005C BYTES: COLLAPSED FUNCTION _AIL_shutdown. PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2EAC3+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
; [000000C2 BYTES: COLLAPSED FUNCTION _AIL_register_timer. PRESS KEYPAD	"+" TO EXPAND]
push	cs
call	near ptr loc_2EB8E+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
; [00000040 BYTES: COLLAPSED FUNCTION _AIL_release_timer_handle. PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2EBD7+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
; [00000016 BYTES: COLLAPSED FUNCTION _AIL_release_all_timers. PRESS KEYPAD "+"	TO EXPAND]
push	cs
call	near ptr loc_2EBF6+1 ; Call Procedure
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
; [0000001F BYTES: COLLAPSED FUNCTION _AIL_start_timer.	PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2EC1D+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
_AIL_start_all_timers db 1Eh, 56h, 57h,	9Ch, 0FAh, 0BEh, 0Fh, 0

loc_2EC31:		; CODE XREF: seg035:08EAj
push	si
push	cs
call	_AIL_start_timer ; Call	Procedure
add	sp, 2		; Add
dec	si		; Decrement by 1
jge	short loc_2EC31	; Jump if Greater or Equal (SF=OF)

loc_2EC3C:		; CODE XREF: seg035:08F0p
or	bh, 0		; Logical Inclusive OR
push	cs
call	near ptr loc_2EC3C+1 ; Call Procedure
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
; [00000028 BYTES: COLLAPSED FUNCTION _AIL_stop_timer. PRESS KEYPAD "+"	TO EXPAND]
_AIL_stop_all_timers db	1Eh, 56h, 57h, 9Ch, 0FAh, 0BEh,	0Fh, 0

loc_2EC77:		; CODE XREF: seg035:0930j
push	si
push	cs
call	near ptr _AIL_stop_timer ; Call	Procedure
add	sp, 2		; Add
dec	si		; Decrement by 1
jge	short loc_2EC77	; Jump if Greater or Equal (SF=OF)

loc_2EC82:		; CODE XREF: seg035:0936p
or	bh, 0		; Logical Inclusive OR
push	cs
call	near ptr loc_2EC82+1 ; Call Procedure
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
; [0000004C BYTES: COLLAPSED FUNCTION _AIL_set_timer_period. PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2ECD6+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
; [00000038 BYTES: COLLAPSED FUNCTION _AIL_set_timer_frequency.	PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2ED17+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
; [0000003C BYTES: COLLAPSED FUNCTION _AIL_set_timer_divisor. PRESS KEYPAD "+" TO EXPAND]
; [0000000C BYTES: COLLAPSED FUNCTION _AIL_interrupt_divisor. PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2ED68+1 ; Call Procedure
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
; [00000099 BYTES: COLLAPSED FUNCTION _AIL_register_driver. PRESS KEYPAD "+" TO	EXPAND]
push	cs
call	near ptr loc_2EE09+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
; [00000041 BYTES: COLLAPSED CHUNK OF FUNCTION _AIL_register_driver. PRESS KEYPAD "+" TO EXPAND]
; [00000047 BYTES: COLLAPSED FUNCTION _AIL_release_driver_handle. PRESS	KEYPAD "+" TO EXPAND]
; [00000026 BYTES: COLLAPSED FUNCTION _AIL_describe_driver. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_detect_device. PRESS	KEYPAD "+" TO EXPAND]
; [000000A9 BYTES: COLLAPSED FUNCTION _AIL_init_driver.	PRESS KEYPAD "+" TO EXPAND]
push	cs
call	near ptr loc_2EF6F+1 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
; [00000033 BYTES: COLLAPSED FUNCTION _AIL_shutdown_driver. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_index_VOC_block. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_register_sound_buffer. PRESS	KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_format_sound_buffer.	PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_sound_buffer_status.	PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_play_VOC_file. PRESS	KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_format_VOC_file. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_VOC_playback_status.	PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_start_digital_playback. PRESS KEYPAD	"+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_stop_digital_playback. PRESS	KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_pause_digital_playback. PRESS KEYPAD	"+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_resume_digital_playback. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_set_digital_playback_volume.	PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_digital_playback_volume. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_set_digital_playback_panpot.	PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_digital_playback_panpot. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_state_table_size. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_register_sequence. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_release_sequence_handle. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_default_timbre_cache_size. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_define_timbre_cache.	PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_timbre_request. PRESS KEYPAD	"+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_install_timbre. PRESS KEYPAD	"+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_protect_timbre. PRESS KEYPAD	"+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_unprotect_timbre. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_timbre_status. PRESS	KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_start_sequence. PRESS KEYPAD	"+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_stop_sequence. PRESS	KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_resume_sequence. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_sequence_status. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_relative_volume. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_relative_tempo. PRESS KEYPAD	"+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_set_relative_volume.	PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_set_relative_tempo. PRESS KEYPAD "+"	TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_beat_count. PRESS KEYPAD "+"	TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_measure_count. PRESS	KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_branch_index. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_controller_value. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_set_controller_value. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_channel_notes. PRESS	KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_send_channel_voice_message. PRESS KEYPAD "+"	TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_send_sysex_message. PRESS KEYPAD "+"	TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_write_display. PRESS	KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_install_callback. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_cancel_callback. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_lock_channel. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_map_sequence_channel. PRESS KEYPAD "+" TO EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_release_channel. PRESS KEYPAD "+" TO	EXPAND]
; [00000006 BYTES: COLLAPSED FUNCTION _AIL_true_sequence_channel. PRESS	KEYPAD "+" TO EXPAND]
byte_2F0CE db 64h, 0, 0DAh, 13h, 65h, 0, 5Ah, 14h, 66h
			; DATA XREF: _AIL_register_driver+CEo
db 0, 68h, 14h,	68h, 0,	0CDh, 14h, 7Bh,	0
db 9Ah,	16h, 7Dh, 0, 6Bh, 18h, 7Eh, 0, 0B3h
db 18h,	7Ch, 0,	0F7h, 18h, 78h,	2 dup(0)
db 15h,	79h, 0,	26h, 16h, 7Ah, 0, 85h, 16h
db 85h,	0, 40h,	17h, 86h, 0, 2Eh, 18h, 2 dup(0FFh)
db 0D2h, 0, 2, 0, 56h, 4Fh, 43h, 0, 0CCh
db 0Dh
word_2F10E dw 0		; DATA XREF: sub_2F72A+73w
db 8 dup(0FFh)
word_2F118 dw 0		; DATA XREF: sub_2F72A:loc_2F768w
byte_2F11A db 52h dup(0)
dword_2F16C dd 0	; DATA XREF: sub_2F72A+1Cw
			; sub_2F72A:loc_2F74Br
			; sub_2F81D+18w
			; sub_2F81D+1Dr
			; sub_2F72A:loc_2F73Dw
			; sub_2F81D+Fw
word_2F170 dw 0		; DATA XREF: _AIL_register_driver+B8w
			; _AIL_release_driver_handle+2Dr
word_2F172 dw 0		; DATA XREF: _AIL_startup+13w
			; _AIL_register_driver+A5r
			; _AIL_register_driver+ADw
			; _AIL_release_driver_handle+22r
			; _AIL_release_driver_handle+34w
word_2F174 dw 0		; DATA XREF: _AIL_register_driver+DAw
			; sub_2F72A:loc_2F730r
			; sub_2F72A+42w
dword_2F176 dd 0	; DATA XREF: _AIL_register_driver+C9w
			; sub_2F72A+Er
			; sub_2F72A:loc_2F773r
			; sub_2F81D+Ar
			; _AIL_register_driver+C5w
word_2F17A dw 0		; DATA XREF: sub_2F1CC+3r
			; sub_2F203+3r
			; sub_2F2E2+6r
			; sub_2F653+C2r
			; sub_2F72A+2Bw
			; sub_2F72A+32r
word_2F17C dw 0		; DATA XREF: sub_2F653+4Ew
word_2F17E dw 0		; DATA XREF: sub_2F653+53w
word_2F180 dw 0		; DATA XREF: sub_2F653+22w
word_2F182 dw 0		; DATA XREF: sub_2F653+26w
word_2F184 dw 0		; DATA XREF: sub_2F653+2Dw
word_2F186 dw 0		; DATA XREF: sub_2F47E+F0w
			; sub_2F5D5+23w
word_2F188 dw 0		; DATA XREF: sub_2F2E2:loc_2F30Aw
word_2F18A dw 0		; DATA XREF: sub_2F2E2+2Dw
word_2F18C dw 0		; DATA XREF: sub_2F2E2:loc_2F321w
			; sub_2F2E2+9Fw
word_2F18E dw 0		; DATA XREF: sub_2F2E2:loc_2F2F4w
word_2F190 dw 0		; DATA XREF: sub_2F2E2+19w
word_2F192 dw 0		; DATA XREF: sub_2F2E2+21w
db 14h dup(0)
word_2F1A8 dw 0		; DATA XREF: sub_2F457+6r
			; sub_2F7B8+52w
			; sub_2FC03:loc_2FC30w
word_2F1AA dw 0		; DATA XREF: sub_2F457+11r
			; sub_2F7B8+59w
			; sub_2FC03:loc_2FC37w
word_2F1AC dw 0		; DATA XREF: sub_2F7B8+4Bw
			; seg035:162Cr
			; seg035:1645w
			; seg035:16B4w
			; seg035:loc_2FBC1r
word_2F1AE dw 0		; DATA XREF: sub_2F457+19w
			; sub_2F47E:loc_2F4A8w
			; sub_2F7B8+44w
			; seg035:16C4w
			; seg035:loc_2FA82w
			; seg035:1879r
			; seg035:188Aw
			; seg035:loc_2FBEBr
			; seg035:18A3w
			; sub_2FC03+6w
			; seg035:loc_2FC4Dr
word_2F1B0 dw 0		; DATA XREF: seg035:loc_2F3E4r
			; sub_2F5D5:loc_2F5E7w
dword_2F1B2 dd 0	; DATA XREF: sub_2F281+3r
			; sub_2F290+3r
			; sub_2F402+3r
			; sub_2F402+47w
			; sub_2F47E:loc_2F4B8r
			; sub_2F47E+4Ar
			; sub_2F47E+68w
			; sub_2F47E:loc_2F4FFr
			; sub_2F47E:loc_2F55Fr
			; seg035:170Aw
			; seg035:1795w
			; seg035:17CBr
			; seg035:17FDr
			; sub_2F402+4Cw
			; sub_2F47E+6Dw
			; seg035:170Fw
			; seg035:loc_2FAEAw
dword_2F1B6 dd 0	; DATA XREF: sub_2F47E+4Fw
			; sub_2F47E+63r
			; sub_2F47E+54w
word_2F1BA dw 0		; DATA XREF: sub_2F47E+42w
			; sub_2F47E:loc_2F4D9r
			; sub_2F47E+72r
			; sub_2F47E+7Aw
			; sub_2F7B8+3Dw
dword_2F1BC dd 0	; DATA XREF: sub_2F628+Fw
			; sub_2F653+32r
			; sub_2F653+92w
			; sub_2F628+14w
			; sub_2F653+97w
word_2F1C0 dw 0		; DATA XREF: seg035:1064r
			; seg035:1083r
			; sub_2F628+19w
			; sub_2F653:loc_2F667r
			; sub_2F653+1Br
			; sub_2F653+9Cr
			; sub_2F653+B0w
word_2F1C2 dw 0		; DATA XREF: seg035:1068r
			; seg035:1087r
			; sub_2F628+1Dw
			; sub_2F653+Cr
			; sub_2F653+A0r
			; sub_2F653+ABw
db 2 dup(0)
byte_2F1C6 db 2	dup(0)	; DATA XREF: sub_2F2E2:loc_2F2F4o
			; sub_2F653+26o
word_2F1C8 dw 0		; DATA XREF: sub_2F7B8+21w
			; sub_2F81D+22r
word_2F1CA dw 0		; DATA XREF: sub_2F1CC+14r
			; sub_2F1CC+20w
			; sub_2F203+14r
			; sub_2F203+2Cw
			; sub_2F7B8+25w



proc sub_2F1CC far	; CODE XREF: sub_2F653+B5p
push	ds
push	si
push	di
test	[cs:word_2F17A], 8 ; Logical Compare
jz	short loc_2F1FF	; Jump if Zero (ZF=1)
cmp	[cs:word_2E352], 0 ; Compare Two Operands
jz	short loc_2F1FF	; Jump if Zero (ZF=1)
cmp	[cs:word_2F1CA], 0 ; Compare Two Operands
jz	short loc_2F1FF	; Jump if Zero (ZF=1)
push	cs
call	sub_2E8BC	; Call Procedure
mov	[cs:word_2F1CA], 0
jmp	short loc_2F1FF	; Jump
db 0B8h, 93h, 6, 2Eh, 8Bh, 16h,	24h, 1,	0CDh
db 66h

loc_2F1FF:		; CODE XREF: sub_2F1CC+Aj
			; sub_2F1CC+12j
			; sub_2F1CC+1Aj
			; sub_2F1CC+27j
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
endp sub_2F1CC




proc sub_2F203 far	; CODE XREF: seg035:1061p
			; seg035:1080p
			; sub_2FC03+3Cp
push	ds
push	si
push	di
test	[cs:word_2F17A], 8 ; Logical Compare
jz	short loc_2F236	; Jump if Zero (ZF=1)
cmp	[cs:word_2E352], 0 ; Compare Two Operands
jz	short loc_2F236	; Jump if Zero (ZF=1)
cmp	[cs:word_2F1CA], 0 ; Compare Two Operands
jnz	short loc_2F236	; Jump if Not Zero (ZF=0)
push	cs
call	_AIL_interrupt_divisor ; Call Procedure
push	ax
push	cs
call	hrmTimer	; Call Procedure
add	sp, 2		; Add
push	cs
call	sub_2E870	; Call Procedure
mov	[cs:word_2F1CA], 1

loc_2F236:		; CODE XREF: sub_2F203+Aj
			; sub_2F203+12j
			; sub_2F203+1Aj
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
endp sub_2F203



; Attributes: bp-based frame

proc sub_2F23A far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	ds
push	si
push	di
mov	ax, [bp+arg_6]
mov	dx, 0
shl	ax, 1		; Shift	Logical	Left
rcl	dx, 1		; Rotate Through Carry Left
shl	ax, 1		; Shift	Logical	Left
rcl	dx, 1		; Rotate Through Carry Left
shl	ax, 1		; Shift	Logical	Left
rcl	dx, 1		; Rotate Through Carry Left
shl	ax, 1		; Shift	Logical	Left
rcl	dx, 1		; Rotate Through Carry Left
add	ax, [bp+arg_4]	; Add

loc_2F259:		; Add with Carry
adc	dx, 0
mov	bx, [bp+arg_2]
mov	cx, 0
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, [bp+arg_0]	; Add
adc	cx, 0		; Add with Carry
sub	ax, bx		; Integer Subtraction
sbb	dx, cx		; Integer Subtraction with Borrow
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2F23A




proc sub_2F281 far	; CODE XREF: sub_2F47E+4p
			; seg035:171Bp
			; seg035:17A6p
			; seg035:17BEp
push	ds
push	si
push	di
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
lodsb			; Load String
mov	ah, 0
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
endp sub_2F281




proc sub_2F290 far	; CODE XREF: seg035:1724p
			; seg035:17AFp
push	ds
push	si
push	di
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
cmp	[byte ptr si], 4 ; Compare Two Operands
mov	ax, 0FFFFh
jnz	short loc_2F2A3	; Jump if Not Zero (ZF=0)
mov	ax, [si+4]

loc_2F2A3:		; CODE XREF: sub_2F290+Ej
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
endp sub_2F290



; Attributes: bp-based frame

proc sub_2F2A7 far	; CODE XREF: sub_2F47E+EAp
			; sub_2F5D5+1Dp
			; seg035:loc_2FB24p
			; seg035:184Ap

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	ds
push	si
push	di
mov	bx, [bp+arg_0]
mov	bh, 0
mov	ax, 100h
sub	ax, bx		; Integer Subtraction
push	ax
push	bp
mov	bp, sp
mov	[word ptr bp+2], 0
pop	bp
push	ax
push	ax
push	bp
mov	bp, sp
mov	[word ptr bp+2], 0Fh
pop	bp
push	ax
push	bp
mov	bp, sp
mov	[word ptr bp+2], 4240h
pop	bp
push	cs
call	near ptr sub_2E93F ; Call Procedure
add	sp, 8		; Add
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2F2A7



; Attributes: bp-based frame

proc sub_2F2E2 far	; CODE XREF: seg035:181Bp
			; seg035:185Ep

arg_0= word ptr	 6
arg_2= dword ptr  8
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	ds
push	si
push	di
test	[cs:word_2F17A], 2 ; Logical Compare
jnz	short loc_2F2F4	; Jump if Not Zero (ZF=0)
jmp	loc_2F390	; Jump

loc_2F2F4:		; CODE XREF: sub_2F2E2+Dj
mov	[cs:word_2F18E], offset	byte_2F1C6
mov	[cs:word_2F190], cs
mov	ax, [bp+arg_0]
mov	[cs:word_2F192], ax
lds	si, [bp+arg_2]	; Load Full Pointer to DS:xx

loc_2F30A:		; CODE XREF: sub_2F2E2+98j
mov	[cs:word_2F188], si
mov	[cs:word_2F18A], ds
cmp	[bp+arg_8], 0	; Compare Two Operands
ja	short loc_2F321	; Jump if Above	(CF=0 &	ZF=0)
cmp	[bp+arg_6], 8000h ; Compare Two	Operands
jbe	short loc_2F37C	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_2F321:		; CODE XREF: sub_2F2E2+36j
mov	[cs:word_2F18C], 8000h
push	ds
push	si
push	cs
pop	ds
assume ds:seg035
mov	si, 0E38h
mov	ax, 68Ah
int	66h		; reserved for user interrupt
pop	si
pop	ds
assume ds:dseg
push	bx
push	cx
mov	bx, ds
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add

loc_2F34E:		; Add with Carry
adc	cx, 0
add	bx, 8000h	; Add
adc	cx, 0		; Add with Carry
mov	si, bx
and	si, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right

loc_2F36B:		; Rotate Through Carry Right
rcr	bx, 1
mov	ds, bx
pop	cx
pop	bx
sub	[bp+arg_6], 8000h ; Integer Subtraction
sbb	[bp+arg_8], 0	; Integer Subtraction with Borrow
jmp	short loc_2F30A	; Jump

loc_2F37C:		; CODE XREF: sub_2F2E2+3Dj
mov	cx, [bp+arg_6]

loc_2F37F:		; Jump if CX is	0
jcxz	short loc_2F390
mov	[cs:word_2F18C], cx
push	cs
pop	ds
assume ds:seg035
mov	si, 0E38h
mov	ax, 68Ah
int	66h		; reserved for user interrupt

loc_2F390:		; CODE XREF: sub_2F2E2+Fj
			; sub_2F2E2:loc_2F37Fj
pop	di
pop	si

loc_2F392:
pop	ds
assume ds:dseg
pop	bp
retf			; Return Far from Procedure
endp sub_2F2E2



; Attributes: bp-based frame

proc sub_2F395 far	; CODE XREF: sub_2F47E+8Cp
			; sub_2F47E+FAp
			; sub_2F5D5+2Dp
			; sub_2FC03+22p

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	ds
push	si
push	di

loc_2F39B:
mov	ax, cs
mov	ds, ax
assume ds:seg035
mov	bx, [bp+arg_0]
mov	dx, [bp+arg_2]

loc_2F3A5:
mov	ax, 68Eh

loc_2F3A8:		; reserved for user interrupt
int	66h
pop	di
pop	si
pop	ds
assume ds:dseg
pop	bp
retf			; Return Far from Procedure
endp sub_2F395

align 2
push	cs
call	near ptr sub_2F203 ; Call Procedure
mov	ax, [cs:word_2F1C0]
or	ax, [cs:word_2F1C2] ; Logical Inclusive	OR
jz	short loc_2F3C5	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_2F653 ; Call Procedure
jmp	short locret_2F3CD ; Jump

loc_2F3C5:		; CODE XREF: seg035:106Dj
push	cs
call	near ptr sub_2F402 ; Call Procedure
push	cs
call	near ptr sub_2F47E ; Call Procedure

locret_2F3CD:		; CODE XREF: seg035:1073j
retf			; Return Far from Procedure
cld			; Clear	Direction Flag
push	cs
call	near ptr sub_2F203 ; Call Procedure
mov	ax, [cs:word_2F1C0]
or	ax, [cs:word_2F1C2] ; Logical Inclusive	OR
jz	short loc_2F3E4	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_2F653 ; Call Procedure
jmp	short locret_2F401 ; Jump

loc_2F3E4:		; CODE XREF: seg035:108Cj
mov	bx, [cs:word_2F1B0]
mov	[word ptr cs:bx+0E58h],	3
push	cs
call	near ptr sub_2F457 ; Call Procedure
cmp	ax, 0FFFFh	; Compare Two Operands
jz	short locret_2F401 ; Jump if Zero (ZF=1)
push	ax
push	cs
call	near ptr sub_2F5D5 ; Call Procedure
add	sp, 2		; Add

locret_2F401:		; CODE XREF: seg035:1092j
			; seg035:10A7j
retf			; Return Far from Procedure



proc sub_2F402 far	; CODE XREF: seg035:1076p
			; sub_2F47E+35p
			; sub_2F47E+47p
			; seg035:172Ap
			; seg035:17B5p
			; seg035:1822p
push	ds
push	si
push	di
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
inc	si		; Increment by 1
lodsw			; Load String
mov	dl, [si]
mov	dh, 0
inc	si		; Increment by 1
push	bx
push	cx
mov	bx, ds
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add
adc	cx, 0		; Add with Carry
add	bx, ax		; Add
adc	cx, dx		; Add with Carry
mov	si, bx
and	si, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right

loc_2F43D:		; Shift	Logical	Right
shr	cx, 1
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	ds, bx
pop	cx
pop	bx
mov	[word ptr cs:dword_2F1B2], si
mov	[word ptr cs:dword_2F1B2+2], ds
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
endp sub_2F402




proc sub_2F457 far	; CODE XREF: seg035:10A1p
			; seg035:1882p
push	ds
push	si
push	di
mov	ax, 0
cmp	[cs:word_2F1A8], 0 ; Compare Two Operands
jz	short loc_2F47A	; Jump if Zero (ZF=1)
mov	ax, 1
cmp	[cs:word_2F1AA], 0 ; Compare Two Operands
jz	short loc_2F47A	; Jump if Zero (ZF=1)
mov	[cs:word_2F1AE], 3
mov	ax, 0FFFFh

loc_2F47A:		; CODE XREF: sub_2F457+Cj
			; sub_2F457+17j
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure
endp sub_2F457




proc sub_2F47E far	; CODE XREF: seg035:107Ap
			; seg035:18ABp
push	ds
push	si
push	di

loc_2F481:		; CODE XREF: sub_2F47E+38j
			; sub_2F47E+59j
			; sub_2F47E+78j
			; sub_2F47E+7Fj
push	cs
call	near ptr sub_2F281 ; Call Procedure
cmp	ax, 0		; Compare Two Operands
jz	short loc_2F4A8	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jnz	short loc_2F492	; Jump if Not Zero (ZF=0)
jmp	loc_2F55F	; Jump

loc_2F492:		; CODE XREF: sub_2F47E+Fj
cmp	ax, 2		; Compare Two Operands
jz	short loc_2F4FF	; Jump if Zero (ZF=1)
cmp	ax, 4		; Compare Two Operands
jz	short loc_2F4A8	; Jump if Zero (ZF=1)
cmp	ax, 6		; Compare Two Operands
jz	short loc_2F4B8	; Jump if Zero (ZF=1)
cmp	ax, 7		; Compare Two Operands
jz	short loc_2F4D9	; Jump if Zero (ZF=1)
jmp	short loc_2F4B2	; Jump

loc_2F4A8:		; CODE XREF: sub_2F47E+Aj
			; sub_2F47E+1Cj
mov	[cs:word_2F1AE], 3
jmp	loc_2F5D1	; Jump

loc_2F4B2:		; CODE XREF: sub_2F47E+28j
			; sub_2F47E+61j
push	cs
call	near ptr sub_2F402 ; Call Procedure
jmp	short loc_2F481	; Jump

loc_2F4B8:		; CODE XREF: sub_2F47E+21j
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
mov	ax, [si+4]
mov	[cs:word_2F1BA], ax
push	cs
call	near ptr sub_2F402 ; Call Procedure
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
mov	[word ptr cs:dword_2F1B6], si
mov	[word ptr cs:dword_2F1B6+2], ds
jmp	short loc_2F481	; Jump

loc_2F4D9:		; CODE XREF: sub_2F47E+26j
cmp	[cs:word_2F1BA], 0 ; Compare Two Operands
jz	short loc_2F4B2	; Jump if Zero (ZF=1)
lds	si, [cs:dword_2F1B6] ; Load Full Pointer to DS:xx
mov	[word ptr cs:dword_2F1B2], si
mov	[word ptr cs:dword_2F1B2+2], ds
db 2Eh,83h,3Eh,6Ah,0Eh,0FFh ; <BAD>cmp	   [cs:word_2F1BA], 0FFFFh ; Compare Two Operands
jz	short loc_2F481	; Jump if Zero (ZF=1)
dec	[cs:word_2F1BA]	; Decrement by 1
jmp	short loc_2F481	; Jump

loc_2F4FF:		; CODE XREF: sub_2F47E+17j
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
mov	ax, 105Fh
push	cs
push	ax
push	cs
call	near ptr sub_2F395 ; Call Procedure
add	sp, 4		; Add
mov	ax, [si+1]
mov	dl, [si+3]
mov	dh, 0
push	bx
push	cx
mov	bx, ds
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add
adc	cx, 0		; Add with Carry
add	bx, 4		; Add
adc	cx, 0		; Add with Carry
mov	si, bx
and	si, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	ds, bx
pop	cx
pop	bx
push	dx
push	ax
push	ds
push	si
push	cs
call	near ptr sub_2F628 ; Call Procedure
add	sp, 8		; Add
jmp	short loc_2F5D1	; Jump

loc_2F55F:		; CODE XREF: sub_2F47E+11j
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
push	[word ptr si+4]
push	cs
call	near ptr sub_2F2A7 ; Call Procedure
add	sp, 2		; Add
mov	[cs:word_2F186], ax
mov	ax, 105Fh
push	cs
push	ax
push	cs
call	near ptr sub_2F395 ; Call Procedure
add	sp, 4		; Add

loc_2F57E:
mov	ax, [si+1]
mov	dl, [si+3]
mov	dh, 0
sub	ax, 2		; Integer Subtraction
sbb	dx, 0		; Integer Subtraction with Borrow
push	bx
push	cx
mov	bx, ds
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add
adc	cx, 0		; Add with Carry
add	bx, 6		; Add
adc	cx, 0		; Add with Carry
mov	si, bx
and	si, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	ds, bx
pop	cx
pop	bx
push	dx
push	ax
push	ds
push	si
push	cs
call	near ptr sub_2F628 ; Call Procedure
add	sp, 8		; Add

loc_2F5D1:		; CODE XREF: sub_2F47E+31j
			; sub_2F47E+DFj
pop	di

loc_2F5D2:
pop	si
pop	ds
retf			; Return Far from Procedure
endp sub_2F47E



; Attributes: bp-based frame

proc sub_2F5D5 far	; CODE XREF: seg035:10ABp
			; seg035:1893p

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	ds
push	si

loc_2F5DA:
push	di
mov	si, [bp+arg_0]
shl	si, 1		; Shift	Logical	Left

loc_2F5E0:
mov	[word ptr cs:si+0E58h],	2

loc_2F5E7:
mov	[cs:word_2F1B0], si
push	[word ptr cs:si+0E54h]
push	cs
call	near ptr sub_2F2A7 ; Call Procedure

loc_2F5F5:		; Add
add	sp, 2
mov	[cs:word_2F186], ax
mov	ax, 107Eh
push	cs
push	ax
push	cs
call	near ptr sub_2F395 ; Call Procedure
add	sp, 4		; Add
push	[word ptr cs:si+0E50h]

loc_2F60D:
push	[word ptr cs:si+0E4Ch]
push	[word ptr cs:si+0E48h]
push	[word ptr cs:si+0E44h]
push	cs
call	near ptr sub_2F628 ; Call Procedure
add	sp, 8		; Add
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2F5D5



; Attributes: bp-based frame

proc sub_2F628 far	; CODE XREF: sub_2F47E+D9p
			; sub_2F47E+14Dp
			; sub_2F5D5+48p

arg_0= dword ptr  6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
push	ds
push	si
push	di
lds	si, [bp+arg_0]	; Load Full Pointer to DS:xx
mov	ax, [bp+arg_4]
mov	dx, [bp+arg_6]
mov	[word ptr cs:dword_2F1BC], si
mov	[word ptr cs:dword_2F1BC+2], ds
mov	[cs:word_2F1C0], ax
mov	[cs:word_2F1C2], dx

loc_2F64A:
push	cs
call	near ptr sub_2F653 ; Call Procedure
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2F628



; Attributes: bp-based frame

proc sub_2F653 far	; CODE XREF: seg035:1070p
			; seg035:108Fp
			; sub_2F628+23p

var_2= word ptr	-2

push	bp
mov	bp, sp

loc_2F656:		; Integer Subtraction
sub	sp, 2
push	ds
push	si
push	di
mov	ax, 8000h
cmp	[cs:word_2F1C2], 0 ; Compare Two Operands
ja	short loc_2F672	; Jump if Above	(CF=0 &	ZF=0)

loc_2F667:		; Compare Two Operands
cmp	[cs:word_2F1C0], ax
ja	short loc_2F672	; Jump if Above	(CF=0 &	ZF=0)
mov	ax, [cs:word_2F1C0]

loc_2F672:		; CODE XREF: sub_2F653+12j
			; sub_2F653+19j
mov	[bp+var_2], ax
mov	[cs:word_2F180], ax
mov	[cs:word_2F182], offset	byte_2F1C6
mov	[cs:word_2F184], cs
lds	si, [cs:dword_2F1BC] ; Load Full Pointer to DS:xx
push	ax
push	bx
mov	ax, ds
mov	bx, si
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
shr	bx, 1		; Shift	Logical	Right
add	ax, bx		; Add
mov	ds, ax

loc_2F69C:		; Logical AND
and	si, 0Fh
pop	bx
pop	ax
mov	[cs:word_2F17C], si
mov	[cs:word_2F17E], ds
push	bx
push	cx
mov	bx, ds

loc_2F6AF:		; Logical Exclusive OR
xor	cx, cx

loc_2F6B1:		; Shift	Logical	Left
shl	bx, 1
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add
adc	cx, 0		; Add with Carry
add	bx, [bp+var_2]	; Add
adc	cx, 0		; Add with Carry
mov	si, bx

loc_2F6CE:		; Logical AND
and	si, 0Fh
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	ds, bx
pop	cx
pop	bx
mov	[word ptr cs:dword_2F1BC], si
mov	[word ptr cs:dword_2F1BC+2], ds
mov	ax, [cs:word_2F1C0]
mov	dx, [cs:word_2F1C2]
sub	ax, [bp+var_2]	; Integer Subtraction
sbb	dx, 0		; Integer Subtraction with Borrow
mov	[cs:word_2F1C2], dx
mov	[cs:word_2F1C0], ax
push	cs
call	near ptr sub_2F1CC ; Call Procedure
mov	ax, cs
mov	ds, ax
assume ds:seg035
mov	si, 0E2Ch
mov	ax, 688h
test	[cs:word_2F17A], 2 ; Logical Compare
jz	short loc_2F721	; Jump if Zero (ZF=1)
mov	ax, 68Bh

loc_2F721:		; CODE XREF: sub_2F653+C9j
int	66h		; reserved for user interrupt
pop	di
pop	si
pop	ds
assume ds:dseg
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2F653



; Attributes: bp-based frame

proc sub_2F72A far	; CODE XREF: sub_2F7B8+37p
push	bp
mov	bp, sp
push	ds
push	si
push	di

loc_2F730:		; Compare Two Operands
cmp	[cs:word_2F174], 0
jnz	short loc_2F773	; Jump if Not Zero (ZF=0)
les	di, [cs:dword_2F176] ; Load Full Pointer to ES:xx

loc_2F73D:
mov	[word ptr cs:dword_2F16C+2], es

loc_2F742:		; Add
add	di, 100h
mov	[word ptr cs:dword_2F16C], di

loc_2F74B:		; Indirect Call	Far Procedure
call	[cs:dword_2F16C]
mov	ax, 68Ch
int	66h		; reserved for user interrupt
mov	[cs:word_2F17A], ax
mov	ax, 0FFFFh
test	[cs:word_2F17A], 8 ; Logical Compare
jz	short loc_2F768	; Jump if Zero (ZF=1)
mov	ax, 0

loc_2F768:		; CODE XREF: sub_2F72A+39j
mov	[cs:word_2F118], ax
mov	[cs:word_2F174], 1

loc_2F773:		; CODE XREF: sub_2F72A+Cj
les	di, [cs:dword_2F176] ; Load Full Pointer to ES:xx
mov	si, 0
mov	cx, 4Eh	; 'N'

loc_2F77E:		; CODE XREF: sub_2F72A+63j
mov	al, [es:di+0Ch]
cmp	al, 20h	; ' '   ; Compare Two Operands
jb	short loc_2F78F	; Jump if Below	(CF=1)
mov	[cs:si+0DCCh], al
inc	si		; Increment by 1
inc	di		; Increment by 1
loop	loc_2F77E	; Loop while CX	!= 0

loc_2F78F:		; CODE XREF: sub_2F72A+5Aj
mov	[byte ptr cs:si+0DCCh],	0
mov	[byte ptr cs:si+0DCDh],	0
mov	dx, cs
mov	[cs:word_2F10E], dx
mov	ax, 0DB4h
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2F72A



; Attributes: bp-based frame

proc sub_2F7AA far
push	bp
mov	bp, sp
push	ds
push	si
push	di
mov	ax, 1
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2F7AA



; Attributes: bp-based frame

proc sub_2F7B8 far
push	bp
mov	bp, sp
push	ds
push	si
push	di
push	ax
push	bp
mov	bp, sp
mov	[word ptr bp+2], 0
pop	bp
push	ax
push	bp
mov	bp, sp

loc_2F7CC:
mov	[word ptr bp+2], 0
pop	bp
push	cs
call	_AIL_register_timer ; Call Procedure
add	sp, 4		; Add
mov	[cs:word_2F1C8], ax
mov	[cs:word_2F1CA], 1
push	ax
push	bp
mov	bp, sp

loc_2F7E8:
mov	[word ptr bp+2], 0
pop	bp
push	cs
call	near ptr sub_2F72A ; Call Procedure
add	sp, 2		; Add
mov	[cs:word_2F1BA], 0
mov	[cs:word_2F1AE], 0
mov	[cs:word_2F1AC], 1
mov	[cs:word_2F1A8], 3
mov	[cs:word_2F1AA], 3
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2F7B8



; Attributes: bp-based frame

proc sub_2F81D far
push	bp
mov	bp, sp
push	ds
push	si
push	di
push	cs
call	near ptr sub_2FC03 ; Call Procedure
les	di, [cs:dword_2F176] ; Load Full Pointer to ES:xx
mov	[word ptr cs:dword_2F16C+2], es
add	di, 103h	; Add
mov	[word ptr cs:dword_2F16C], di
call	[cs:dword_2F16C] ; Indirect Call Far Procedure
push	[cs:word_2F1C8]
push	cs
call	_AIL_release_timer_handle ; Call Procedure
add	sp, 2		; Add
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2F81D

push	bp
mov	bp, sp
push	ds
push	si
push	di
lds	si, [bp+8]	; Load Full Pointer to DS:xx
mov	ax, [si+14h]
push	bx
push	cx
mov	bx, ds
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add
adc	cx, 0		; Add with Carry
add	bx, ax		; Add
adc	cx, 0		; Add with Carry
mov	si, bx
and	si, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	ds, bx
pop	cx
pop	bx
mov	bx, [bp+0Ch]

loc_2F898:		; CODE XREF: seg035:15ACj
mov	al, [si]
mov	ah, 0
cmp	ax, 0		; Compare Two Operands
jnz	short loc_2F8A4	; Jump if Not Zero (ZF=0)
jmp	loc_2F971	; Jump

loc_2F8A4:		; CODE XREF: seg035:154Fj
cmp	ax, 1		; Compare Two Operands
jnz	short loc_2F8B0	; Jump if Not Zero (ZF=0)
db 83h,0FBh,0FFh ; <BAD>cmp	bx, 0FFFFh ; Compare Two Operands
jz	short loc_2F8FE	; Jump if Zero (ZF=1)
jmp	short loc_2F8BD	; Jump

loc_2F8B0:		; CODE XREF: seg035:1557j
cmp	ax, 4		; Compare Two Operands
jnz	short loc_2F8BD	; Jump if Not Zero (ZF=0)
cmp	bx, [si+4]	; Compare Two Operands
jnz	short loc_2F8BD	; Jump if Not Zero (ZF=0)
mov	bx, 0FFFFh

loc_2F8BD:		; CODE XREF: seg035:155Ej
			; seg035:1563j
			; seg035:1568j
inc	si		; Increment by 1
lodsw			; Load String
mov	dl, [si]
mov	dh, 0
inc	si		; Increment by 1
push	bx
push	cx
mov	bx, ds
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add
adc	cx, 0		; Add with Carry
add	bx, ax		; Add
adc	cx, dx		; Add with Carry
mov	si, bx
and	si, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	ds, bx
pop	cx
pop	bx
jmp	short loc_2F898	; Jump

loc_2F8FE:		; CODE XREF: seg035:155Cj
les	di, [bp+0Eh]	; Load Full Pointer to ES:xx
mov	al, [si+4]
mov	ah, 0
mov	[es:di+2], ax
mov	al, [si+5]
mov	ah, 0
mov	[es:di], ax
mov	ax, [si+1]
mov	dl, [si+3]
mov	dh, 0
sub	ax, 2		; Integer Subtraction
sbb	dx, 0		; Integer Subtraction with Borrow
mov	[es:di+8], ax
mov	[es:di+0Ah], dx
mov	dx, ds
mov	ax, si
push	bx
push	cx
mov	bx, dx
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, ax		; Add
adc	cx, 0		; Add with Carry
add	bx, 6		; Add
adc	cx, 0		; Add with Carry
mov	ax, bx
and	ax, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	dx, bx
pop	cx
pop	bx
mov	[es:di+4], ax
mov	[es:di+6], dx

loc_2F96E:
mov	ax, 1

loc_2F971:		; CODE XREF: seg035:1551j
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
push	ds
push	si
push	di
cmp	[cs:word_2F1AC], 0 ; Compare Two Operands
jnz	short loc_2F99C	; Jump if Not Zero (ZF=0)
push	ax
push	bp
mov	bp, sp
mov	[word ptr bp+2], 0
pop	bp
push	cs
call	near ptr sub_2FC03 ; Call Procedure
add	sp, 2		; Add
mov	[cs:word_2F1AC], 1

loc_2F99C:		; CODE XREF: seg035:1632j
mov	di, [bp+8]
shl	di, 1		; Shift	Logical	Left
lds	si, [bp+0Ah]	; Load Full Pointer to DS:xx
mov	ax, [si+2]
mov	[cs:di+0E54h], ax
les	bx, [si+4]	; Load Full Pointer to ES:xx
mov	[cs:di+0E44h], bx
mov	[word ptr cs:di+0E48h],	es
mov	ax, [si+8]
mov	[cs:di+0E4Ch], ax
mov	ax, [si+0Ah]
mov	[cs:di+0E50h], ax
mov	[word ptr cs:di+0E58h],	0
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
push	ds
push	si
push	di
mov	bx, [bp+8]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [cs:bx+0E58h]
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	ds
push	si
push	di
push	ax
push	bp
mov	bp, sp
mov	[word ptr bp+2], 0
pop	bp
push	cs

loc_2F9FE:		; Call Procedure
call	near ptr sub_2FC03
add	sp, 2		; Add
mov	[cs:word_2F1AC], 0
les	di, [bp+8]	; Load Full Pointer to ES:xx
mov	[bp-4],	di
mov	[word ptr bp-2], es
mov	[cs:word_2F1AE], 3
lds	si, [bp-4]	; Load Full Pointer to DS:xx
mov	ax, [si+14h]
push	bx
push	cx
mov	bx, ds
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add
adc	cx, 0		; Add with Carry
add	bx, ax		; Add
adc	cx, 0		; Add with Carry
mov	si, bx
and	si, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	ds, bx
pop	cx
pop	bx
mov	[word ptr cs:dword_2F1B2], si
mov	[word ptr cs:dword_2F1B2+2], ds
db 83h,7Eh,0Ch,0FFh ; <BAD>cmp	   [word ptr bp+0Ch], 0FFFFh ; Compare Two Operands
jz	short loc_2FA82	; Jump if Zero (ZF=1)

loc_2FA6A:		; CODE XREF: seg035:1730j
push	cs
call	near ptr sub_2F281 ; Call Procedure
cmp	ax, 0		; Compare Two Operands
jz	short loc_2FA89	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_2F290 ; Call Procedure
mov	si, ax
push	cs
call	near ptr sub_2F402 ; Call Procedure
cmp	si, [bp+0Ch]	; Compare Two Operands
jnz	short loc_2FA6A	; Jump if Not Zero (ZF=0)

loc_2FA82:		; CODE XREF: seg035:1718j
mov	[cs:word_2F1AE], 0

loc_2FA89:		; CODE XREF: seg035:1721j
pop	di
pop	si
pop	ds
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction
push	ds
push	si
push	di
mov	[byte ptr bp-6], 0FFh
les	di, [bp+8]	; Load Full Pointer to ES:xx
mov	[bp-4],	di
mov	[word ptr bp-2], es
lds	si, [bp-4]	; Load Full Pointer to DS:xx
mov	ax, [si+14h]
push	bx
push	cx
mov	bx, ds
xor	cx, cx		; Logical Exclusive OR
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
shl	bx, 1		; Shift	Logical	Left
rcl	cx, 1		; Rotate Through Carry Left
add	bx, si		; Add
adc	cx, 0		; Add with Carry
add	bx, ax		; Add
adc	cx, 0		; Add with Carry
mov	si, bx
and	si, 0Fh		; Logical AND
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
shr	cx, 1		; Shift	Logical	Right
rcr	bx, 1		; Rotate Through Carry Right
mov	ds, bx
pop	cx
pop	bx
mov	[word ptr cs:dword_2F1B2], si

loc_2FAEA:
mov	[word ptr cs:dword_2F1B2+2], ds
db 83h,7Eh,0Ch,0FFh ; <BAD>cmp	   [word ptr bp+0Ch], 0FFFFh ; Compare Two Operands
jz	short loc_2FB0D	; Jump if Zero (ZF=1)

loc_2FAF5:		; CODE XREF: seg035:17BBj
push	cs
call	near ptr sub_2F281 ; Call Procedure
cmp	ax, 0		; Compare Two Operands

loc_2FAFC:		; Jump if Zero (ZF=1)
jz	short loc_2FB77
push	cs
call	near ptr sub_2F290 ; Call Procedure
mov	si, ax
push	cs
call	near ptr sub_2F402 ; Call Procedure
cmp	si, [bp+0Ch]	; Compare Two Operands
jnz	short loc_2FAF5	; Jump if Not Zero (ZF=0)

loc_2FB0D:		; CODE XREF: seg035:17A3j
			; seg035:1825j
push	cs
call	near ptr sub_2F281 ; Call Procedure
cmp	ax, 0		; Compare Two Operands
jz	short loc_2FB77	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jnz	short loc_2FB48	; Jump if Not Zero (ZF=0)
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
push	[word ptr si+4]
push	cs

loc_2FB24:		; Call Procedure
call	near ptr sub_2F2A7
add	sp, 2		; Add
mov	[bp-8],	ax
mov	al, [si+5]
and	al, 0Fh		; Logical AND
mov	[bp-6],	al
mov	ax, [si+1]
mov	dx, [si+3]
mov	dh, 0
sub	ax, 2		; Integer Subtraction
sbb	dx, 0		; Integer Subtraction with Borrow
add	si, 6		; Add
jmp	short loc_2FB5D	; Jump

loc_2FB48:		; CODE XREF: seg035:17C9j
cmp	ax, 2		; Compare Two Operands
jnz	short loc_2FB71	; Jump if Not Zero (ZF=0)
lds	si, [cs:dword_2F1B2] ; Load Full Pointer to DS:xx
mov	ax, [si+1]
mov	dx, [si+3]
mov	dh, 0
add	si, 4		; Add

loc_2FB5D:		; CODE XREF: seg035:17F6j
cmp	[byte ptr bp-6], 0 ; Compare Two Operands
jnz	short loc_2FB71	; Jump if Not Zero (ZF=0)
push	dx
push	ax
push	ds
push	si
push	[word ptr bp-8]
push	cs
call	near ptr sub_2F2E2 ; Call Procedure
add	sp, 0Ah		; Add

loc_2FB71:		; CODE XREF: seg035:17FBj
			; seg035:1811j
push	cs
call	near ptr sub_2F402 ; Call Procedure
jmp	short loc_2FB0D	; Jump

loc_2FB77:		; CODE XREF: seg035:loc_2FAFCj
			; seg035:17C4j
pop	di
pop	si
pop	ds
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	ds
push	si
push	di
lds	si, [bp+8]	; Load Full Pointer to DS:xx
mov	ax, [si+8]
mov	dx, [si+0Ah]
mov	[bp-4],	ax
mov	[bp-2],	dx
push	[word ptr si+2]
push	cs
call	near ptr sub_2F2A7 ; Call Procedure
add	sp, 4		; Add
push	[word ptr bp-2]
push	[word ptr bp-4]
push	[word ptr si+6]
push	[word ptr si+4]
push	ax
push	cs
call	near ptr sub_2F2E2 ; Call Procedure
add	sp, 0Ah		; Add
pop	di
pop	si
pop	ds
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
push	ds
push	si
push	di

loc_2FBC1:		; Compare Two Operands
cmp	[cs:word_2F1AC], 0
jz	short loc_2FBEB	; Jump if Zero (ZF=1)
cmp	[cs:word_2F1AE], 2 ; Compare Two Operands
jz	short loc_2FBFE	; Jump if Zero (ZF=1)
push	cs
call	near ptr sub_2F457 ; Call Procedure
cmp	ax, 0FFFFh	; Compare Two Operands

loc_2FBD8:		; Jump if Zero (ZF=1)
jz	short loc_2FBFE
mov	[cs:word_2F1AE], 2
push	ax
push	cs
call	near ptr sub_2F5D5 ; Call Procedure
add	sp, 2		; Add

loc_2FBE9:		; Jump
jmp	short loc_2FBFE

loc_2FBEB:		; CODE XREF: seg035:1877j
cmp	[cs:word_2F1AE], 0 ; Compare Two Operands
jnz	short loc_2FBFE	; Jump if Not Zero (ZF=0)
mov	[cs:word_2F1AE], 2
push	cs
call	near ptr sub_2F47E ; Call Procedure

loc_2FBFE:		; CODE XREF: seg035:187Fj
			; seg035:loc_2FBD8j
			; seg035:loc_2FBE9j
			; seg035:18A1j
pop	di
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure


; Attributes: bp-based frame

proc sub_2FC03 far	; CODE XREF: sub_2F81D+7p
			; seg035:163Fp
			; seg035:loc_2F9FEp
push	bp
mov	bp, sp
push	ds
push	si
push	di
mov	[cs:word_2F1AE], 0
push	ax
push	bp

loc_2FC12:
mov	bp, sp
mov	[word ptr bp+2], 0
pop	bp
push	ax
push	bp
mov	bp, sp

loc_2FC1E:
mov	[word ptr bp+2], 0
pop	bp
push	cs
call	near ptr sub_2F395 ; Call Procedure
add	sp, 4		; Add
mov	ax, 68Fh
int	66h		; reserved for user interrupt

loc_2FC30:
mov	[cs:word_2F1A8], 3

loc_2FC37:
mov	[cs:word_2F1AA], 3

loc_2FC3E:
push	cs
call	near ptr sub_2F203 ; Call Procedure

loc_2FC42:
pop	di
pop	si

loc_2FC44:
pop	ds
pop	bp

locret_2FC46:		; Return Far from Procedure
retf
endp sub_2FC03

push	bp

loc_2FC48:
mov	bp, sp

loc_2FC4A:
push	ds
push	si

loc_2FC4C:
push	di

loc_2FC4D:
mov	ax, [cs:word_2F1AE]

loc_2FC51:
pop	di

loc_2FC52:
pop	si

loc_2FC53:
pop	ds

loc_2FC54:
pop	bp

locret_2FC55:		; Return Far from Procedure
retf
ends seg035


; Segment type:	Pure code
segment	seg036 byte public 'CODE' use16
assume cs:seg036
;org 6
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc idk_DosReadFromFileHAndle_s2FC56 far
			; CODE XREF: ST_LoadSound+10Cp

argDosFileHandle= word ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_2FC57:
mov	bp, sp
push	si

loc_2FC5A:
mov	si, [bp+argDosFileHandle]

loc_2FC5D:		; Logical Inclusive OR
or	si, si
jnz	short loc_2FC68	; Jump if Not Zero (ZF=0)

loc_2FC61:		; CODE XREF: idk_DosReadFromFileHAndle_s2FC56:loc_2FC99j
xor	dx, dx		; Logical Exclusive OR
xor	ax, ax		; Logical Exclusive OR

loc_2FC65:		; CODE XREF: idk_DosReadFromFileHAndle_s2FC56+B9j
jmp	loc_2FD12	; Jump

loc_2FC68:		; CODE XREF: idk_DosReadFromFileHAndle_s2FC56+9j
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
push	si
call	DOS_MoveFilePointer ; Call Procedure
add	sp, 8		; Add

loc_2FC7A:		; CODE XREF: idk_DosReadFromFileHAndle_s2FC56+4Cj
			; idk_DosReadFromFileHAndle_s2FC56+55j
push	si
mov	ax, 1
push	ax
mov	ax, 6
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0A8C2h
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
cmp	[byte_3C5D3], 0FFh ; Compare Two Operands
jnz	short loc_2FC9B	; Jump if Not Zero (ZF=0)

loc_2FC99:		; Jump
jmp	short loc_2FC61

loc_2FC9B:		; CODE XREF: idk_DosReadFromFileHAndle_s2FC56+41j
mov	al, [byte_3C5D3]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_2]	; Compare Two Operands
jnz	short loc_2FC7A	; Jump if Not Zero (ZF=0)
mov	al, [byte_3C5D2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_4]	; Compare Two Operands
jnz	short loc_2FC7A	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3C5D6]
push	[word_3C5D4]
push	si
call	DOS_MoveFilePointer ; Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3C5B6
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ch		; Add
les	bx, [dword_3C5EE] ; Load Full Pointer to ES:xx
mov	ax, [word_3C5B6]
mov	[es:bx], ax
push	si
mov	ax, 1
push	ax
mov	ax, [word_3C5B6]
sub	ax, 2		; Integer Subtraction
push	ax
mov	ax, [word ptr dword_3C5EE]
add	ax, 2		; Add
push	[word ptr dword_3C5EE+2]
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
mov	dx, [word ptr dword_3C5EE+2]
mov	ax, [word ptr dword_3C5EE]
jmp	loc_2FC65	; Jump

loc_2FD12:		; CODE XREF: idk_DosReadFromFileHAndle_s2FC56:loc_2FC65j
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_DosReadFromFileHAndle_s2FC56



; Attributes: bp-based frame

; int __fastcall __far ST_LoadSoundDrivers(int,	int, int, int, int, int, int, int, int,	int, int, int)
proc ST_LoadSoundDrivers far
			; CODE XREF: Load_Fonts_SndDrv+4FP
			; Load_Fonts_SndDrv+81P
			; idk_Load_FntSty_SndDrv_Mos+28P
			; idk_Load_FntSty_SndDrv_Mos+44P

var_32=	word ptr -32h
var_30=	word ptr -30h
var_2E=	word ptr -2Eh
var_2C=	word ptr -2Ch
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h

push	bp
mov	bp, sp
sub	sp, 32h		; Integer Subtraction
push	si
push	di		; argSrc
mov	si, [bp+arg_0]
mov	[bp+var_8], 0
mov	[bp+var_12], 0
mov	[idk_AIL_SndDrvNbr_w36A8A], si
mov	ax, [bp+arg_A]
mov	[AIL_playback_w36A8C], ax
cmp	[idk_AIL_w36A8E], 0 ; Compare Two Operands
jz	short loc_2FD41	; Jump if Zero (ZF=1)

RETURN_1:		; CODE XREF: ST_LoadSoundDrivers+8Ej
			; ST_LoadSoundDrivers:loc_303ACj
mov	ax, 1
jmp	loc_303AF	; Jump

loc_2FD41:		; CODE XREF: ST_LoadSoundDrivers+24j
db 83h,7Eh,0Ah,0FFh ; <BAD>cmp	   [bp+arg_4], 0FFFFh ;	Compare	Two Operands
jnz	short loc_2FD53	; Jump if Not Zero (ZF=0)

loc_2FD47:		; Compare Two Operands
db 83h,7Eh,0Ch,0FFh ; <BAD>cmp	   [bp+arg_6], 0FFFFh

loc_2FD4B:		; Jump if Not Zero (ZF=0)
jnz	short loc_2FD53

loc_2FD4D:		; Compare Two Operands
db 83h,7Eh,0Eh,0FFh ; <BAD>cmp	   [bp+arg_8], 0FFFFh
jz	short loc_2FD6A	; Jump if Zero (ZF=1)

loc_2FD53:		; CODE XREF: ST_LoadSoundDrivers+30j
			; ST_LoadSoundDrivers:loc_2FD4Bj
mov	[bp+var_8], 1
mov	ax, [bp+arg_4]
mov	[bp+var_1C], ax
mov	ax, [bp+arg_6]
mov	[bp+var_1E], ax
mov	ax, [bp+arg_8]
mov	[bp+var_20], ax

loc_2FD6A:		; CODE XREF: ST_LoadSoundDrivers+3Cj
db 83h,7Eh,12h,0FFh ; <BAD>cmp	   [bp+arg_C], 0FFFFh ;	Compare	Two Operands
jnz	short loc_2FD7C	; Jump if Not Zero (ZF=0)
db 83h,7Eh,14h,0FFh ; <BAD>cmp	   [bp+arg_E], 0FFFFh ;	Compare	Two Operands
jnz	short loc_2FD7C	; Jump if Not Zero (ZF=0)

loc_2FD76:		; Compare Two Operands
db 83h,7Eh,16h,0FFh ; <BAD>cmp	   [bp+arg_10],	0FFFFh
jz	short loc_2FD93	; Jump if Zero (ZF=1)

loc_2FD7C:		; CODE XREF: ST_LoadSoundDrivers+59j
			; ST_LoadSoundDrivers+5Fj
mov	[bp+var_12], 1
mov	ax, [bp+arg_C]
mov	[bp+var_2E], ax
mov	ax, [bp+arg_E]
mov	[bp+var_30], ax
mov	ax, [bp+arg_10]
mov	[bp+var_32], ax

loc_2FD93:		; CODE XREF: ST_LoadSoundDrivers+65j
or	si, si		; Logical Inclusive OR
jnz	short loc_2FDA7	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_A], 0	; Compare Two Operands
jnz	short loc_2FDA7	; Jump if Not Zero (ZF=0)

loc_2FD9D:		; CODE XREF: ST_LoadSoundDrivers+ABj
			; ST_LoadSoundDrivers+D0j
mov	[AIL_shutdown_w36AA0], 0
jmp	short RETURN_1	; Jump
jmp	short loc_2FDEF	; Jump

loc_2FDA7:		; CODE XREF: ST_LoadSoundDrivers+80j
			; ST_LoadSoundDrivers+86j
cmp	si, 1		; Compare Two Operands
jnz	short loc_2FDB4	; Jump if Not Zero (ZF=0)

loc_2FDAC:
mov	[AIL_shutdown_w36AA0], 1
jmp	short loc_2FDEF	; Jump

loc_2FDB4:		; CODE XREF: ST_LoadSoundDrivers+95j
cmp	[bp+arg_2], 1	; Compare Two Operands
jnz	short loc_2FDC4	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_A], 0	; Compare Two Operands
jnz	short loc_2FDC4	; Jump if Not Zero (ZF=0)
jmp	short loc_2FD9D	; Jump
jmp	short loc_2FDCA	; Jump

loc_2FDC4:		; CODE XREF: ST_LoadSoundDrivers+A3j
			; ST_LoadSoundDrivers+A9j
mov	[AIL_shutdown_w36AA0], 1

loc_2FDCA:		; CODE XREF: ST_LoadSoundDrivers+ADj
cmp	[bp+arg_2], 2	; Compare Two Operands
jnz	short loc_2FDDF	; Jump if Not Zero (ZF=0)

loc_2FDD0:		; Compare Two Operands
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1
jle	short loc_2FDDF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[AIL_shutdown_w36AA0], 2
jmp	short loc_2FDEF	; Jump

loc_2FDDF:		; CODE XREF: ST_LoadSoundDrivers+B9j
			; ST_LoadSoundDrivers+C0j
cmp	[bp+arg_A], 0	; Compare Two Operands
jnz	short loc_2FDE9	; Jump if Not Zero (ZF=0)
jmp	short loc_2FD9D	; Jump
jmp	short loc_2FDEF	; Jump

loc_2FDE9:		; CODE XREF: ST_LoadSoundDrivers+CEj
mov	[AIL_shutdown_w36AA0], 1

loc_2FDEF:		; CODE XREF: ST_LoadSoundDrivers+90j
			; ST_LoadSoundDrivers+9Dj
			; ST_LoadSoundDrivers+C8j
			; ST_LoadSoundDrivers+D2j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 4 ;	Compare	Two Operands
jz	short loc_2FDFD	; Jump if Zero (ZF=1)
cmp	[idk_AIL_SndDrvNbr_w36A8A], 5 ;	Compare	Two Operands
jnz	short loc_2FE47	; default

loc_2FDFD:		; CODE XREF: ST_LoadSoundDrivers+DFj
nop			; No Operation
push	cs
call	near ptr idk_Env_BLASTER_s3095D	; Call Procedure
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_2FE14	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax		; ? Case 0x00 ?
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_2FE14:		; CODE XREF: ST_LoadSoundDrivers+F4j
mov	bx, [bp+var_2]
dec	bx		; Decrement by 1
cmp	bx, 3		; switch 4 cases
ja	short loc_2FE47	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_303B5+bx] ; switch jump

loc_2FE24:		; CODE XREF: ST_LoadSoundDrivers:loc_2FE2Fj
			; DATA XREF: seg036:off_303B5o
mov	[idk_AIL_SndDrvNbr_w36A8A], 3 ;	case 0x0
mov	si, 3
jmp	short loc_2FE47	; default

loc_2FE2F:		; CODE XREF: ST_LoadSoundDrivers+10Aj
			; DATA XREF: seg036:off_303B5o
jmp	short loc_2FE24	; case 0x2

loc_2FE31:		; CODE XREF: ST_LoadSoundDrivers+10Aj
			; DATA XREF: seg036:off_303B5o
mov	[idk_AIL_SndDrvNbr_w36A8A], 4 ;	case 0x1
mov	si, 4
jmp	short loc_2FE47	; default

loc_2FE3C:		; CODE XREF: ST_LoadSoundDrivers+10Aj
			; DATA XREF: seg036:off_303B5o
mov	[idk_AIL_SndDrvNbr_w36A8A], 5 ;	case 0x3
mov	si, 5
jmp	short $+2	; Jump

loc_2FE47:		; CODE XREF: ST_LoadSoundDrivers+E6j
			; ST_LoadSoundDrivers+106j
			; ST_LoadSoundDrivers+118j
			; ST_LoadSoundDrivers+125j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;	default
jle	short loc_2FE6D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
push	ax		; argLbxEntryNumber
mov	ax, offset argFileNameBase ; "SNDDRV.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[AIL_driver_base_addr1b], dx
mov	[AIL_driver_base_addr1a], ax

loc_2FE6D:		; CODE XREF: ST_LoadSoundDrivers+137j
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_2FE95	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [AIL_playback_w36A8C]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
inc	ax		; Increment by 1
push	ax		; argLbxEntryNumber
mov	ax, offset argFileNameBase ; "SNDDRV.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[AIL_driver_base_addr2b], dx
mov	[AIL_driver_base_addr2a], ax

loc_2FE95:		; CODE XREF: ST_LoadSoundDrivers+15Dj
call	far ptr	_AIL_startup ; Call Procedure
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;	Compare	Two Operands
jle	short loc_2FEB3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[AIL_driver_base_addr1b]
push	[AIL_driver_base_addr1a] ; driver_base_addr
call	far ptr	_AIL_register_driver ; Call Procedure
pop	cx
pop	cx
mov	[AIL_HDRIVER1],	ax

loc_2FEB3:		; CODE XREF: ST_LoadSoundDrivers+18Aj
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_2FECC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[AIL_driver_base_addr2b]
push	[AIL_driver_base_addr2a] ; driver_base_addr
call	far ptr	_AIL_register_driver ; Call Procedure
pop	cx
pop	cx
mov	[AIL_HDRIVER2],	ax

loc_2FECC:		; CODE XREF: ST_LoadSoundDrivers+1A3j
db 83h,3Eh,80h,4Dh,0FFh	; <BAD>cmp     [AIL_HDRIVER1], 0FFFFh ;	Compare	Two Operands
jnz	short loc_2FEF7	; Jump if Not Zero (ZF=0)
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;	Compare	Two Operands
jle	short loc_2FEF7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	[AIL_shutdown_w36AA0], 0
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_2FEF7:		; CODE XREF: ST_LoadSoundDrivers+1BCj
			; ST_LoadSoundDrivers+1C3j
db 83h,3Eh,82h,4Dh,0FFh	; <BAD>cmp     [AIL_HDRIVER2], 0FFFFh ;	Compare	Two Operands
jnz	short loc_2FF22	; Jump if Not Zero (ZF=0)
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_2FF22	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	[AIL_shutdown_w36AA0], 0
mov	ax, 2
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_2FF22:		; CODE XREF: ST_LoadSoundDrivers+1E7j
			; ST_LoadSoundDrivers+1EEj
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;	Compare	Two Operands
jle	short loc_2FF3A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[AIL_HDRIVER1]
call	_AIL_describe_driver ; Call Procedure
pop	cx
mov	[word ptr idk_AIL_DrvDesc1_d3C602+2], dx
mov	[word ptr idk_AIL_DrvDesc1_d3C602], ax

loc_2FF3A:		; CODE XREF: ST_LoadSoundDrivers+212j
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_2FF52	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[AIL_HDRIVER2]
call	_AIL_describe_driver ; Call Procedure
pop	cx
mov	[word ptr idk_AIL_DrvDesc2_d3C5FE+2], dx

loc_2FF4F:
mov	[word ptr idk_AIL_DrvDesc2_d3C5FE], ax

loc_2FF52:		; CODE XREF: ST_LoadSoundDrivers+22Aj
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
cmp	[word ptr es:bx+2], 3 ;	Compare	Two Operands
jz	short loc_2FF81	; Jump if Zero (ZF=1)

loc_2FF5D:		; Compare Two Operands
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1
jle	short loc_2FF81	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	[AIL_shutdown_w36AA0], 0
mov	ax, 3
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_2FF81:		; CODE XREF: ST_LoadSoundDrivers+246j
			; ST_LoadSoundDrivers+24Dj
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
cmp	[word ptr es:bx+2], 2 ;	Compare	Two Operands
jz	short loc_2FFB0	; Jump if Zero (ZF=1)
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_2FFB0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	[AIL_shutdown_w36AA0], 0
mov	ax, 4
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_2FFB0:		; CODE XREF: ST_LoadSoundDrivers+275j
			; ST_LoadSoundDrivers+27Cj
cmp	[bp+var_8], 0	; Compare Two Operands
jz	short loc_3000A	; Jump if Zero (ZF=1)
db 83h,7Eh,0Eh,0FFh ; <BAD>cmp	   [bp+arg_8], 0FFFFh ;	Compare	Two Operands
jz	short loc_2FFD2	; Jump if Zero (ZF=1)
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
mov	ax, [es:bx+10h]
mov	[bp+var_26], ax
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_20]
mov	[es:bx+10h], ax

loc_2FFD2:		; CODE XREF: ST_LoadSoundDrivers+2A5j
db 83h,7Eh,0Ah,0FFh ; <BAD>cmp	   [bp+arg_4], 0FFFFh ;	Compare	Two Operands
jz	short loc_2FFEE	; Jump if Zero (ZF=1)
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
mov	ax, [es:bx+0Ch]
mov	[bp+var_22], ax
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_1C]
mov	[es:bx+0Ch], ax

loc_2FFEE:		; CODE XREF: ST_LoadSoundDrivers+2C1j
db 83h,7Eh,0Ch,0FFh ; <BAD>cmp	   [bp+arg_6], 0FFFFh ;	Compare	Two Operands
jz	short loc_3000A	; Jump if Zero (ZF=1)
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
mov	ax, [es:bx+0Eh]
mov	[bp+var_24], ax
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_1E]
mov	[es:bx+0Eh], ax

loc_3000A:		; CODE XREF: ST_LoadSoundDrivers+29Fj
			; ST_LoadSoundDrivers+2DDj
cmp	[bp+var_12], 0	; Compare Two Operands
jz	short loc_30064	; Jump if Zero (ZF=1)
db 83h,7Eh,16h,0FFh ; <BAD>cmp	   [bp+arg_10],	0FFFFh ; Compare Two Operands

loc_30014:		; Jump if Zero (ZF=1)
jz	short loc_3002C
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [es:bx+10h]
mov	[bp+var_2A], ax
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_32]
mov	[es:bx+10h], ax

loc_3002C:		; CODE XREF: ST_LoadSoundDrivers:loc_30014j
db 83h,7Eh,12h,0FFh ; <BAD>cmp	   [bp+arg_C], 0FFFFh ;	Compare	Two Operands
jz	short loc_30048	; Jump if Zero (ZF=1)
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [es:bx+0Ch]
mov	[bp+var_28], ax
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_2E]
mov	[es:bx+0Ch], ax

loc_30048:		; CODE XREF: ST_LoadSoundDrivers+31Bj
db 83h,7Eh,14h,0FFh ; <BAD>cmp	   [bp+arg_E], 0FFFFh ;	Compare	Two Operands
jz	short loc_30064	; Jump if Zero (ZF=1)
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [es:bx+0Eh]
mov	[bp+var_2C], ax
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_30]
mov	[es:bx+0Eh], ax

loc_30064:		; CODE XREF: ST_LoadSoundDrivers+2F9j
			; ST_LoadSoundDrivers+337j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;	Compare	Two Operands
jg	short loc_3006E	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_30134	; Jump

loc_3006E:		; CODE XREF: ST_LoadSoundDrivers+354j
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+12h]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+10h]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Eh]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Ch]
push	[AIL_HDRIVER1]
call	_AIL_detect_device ; Call Procedure
add	sp, 0Ah		; Add
or	ax, ax		; Logical Inclusive OR
jz	short loc_300A1	; Jump if Zero (ZF=1)
jmp	loc_30134	; Jump

loc_300A1:		; CODE XREF: ST_LoadSoundDrivers+387j
cmp	[bp+var_8], 0	; Compare Two Operands
jz	short loc_30117	; Jump if Zero (ZF=1)
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_26]
mov	[es:bx+10h], ax
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_22]

loc_300B9:
mov	[es:bx+0Ch], ax

loc_300BD:		; Load Full Pointer to ES:xx
les	bx, [idk_AIL_DrvDesc1_d3C602]
mov	ax, [bp+var_24]
mov	[es:bx+0Eh], ax
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+12h]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+10h]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Eh]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Ch]
push	[AIL_HDRIVER1]
call	_AIL_detect_device ; Call Procedure
add	sp, 0Ah		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_30115	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	[AIL_shutdown_w36AA0], 0
mov	ax, 5
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_30115:		; CODE XREF: ST_LoadSoundDrivers+3E1j
jmp	short loc_30134	; Jump

loc_30117:		; CODE XREF: ST_LoadSoundDrivers+390j
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	[AIL_shutdown_w36AA0], 0
mov	ax, 6
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_30134:		; CODE XREF: ST_LoadSoundDrivers+356j
			; ST_LoadSoundDrivers+389j
			; ST_LoadSoundDrivers:loc_30115j
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jg	short loc_3013E	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_30204	; Jump

loc_3013E:		; CODE XREF: ST_LoadSoundDrivers+424j
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+12h]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+10h]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Eh]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Ch]
push	[AIL_HDRIVER2]
call	_AIL_detect_device ; Call Procedure
add	sp, 0Ah		; Add
or	ax, ax		; Logical Inclusive OR
jz	short loc_30171	; Jump if Zero (ZF=1)
jmp	loc_30204	; Jump

loc_30171:		; CODE XREF: ST_LoadSoundDrivers+457j
cmp	[bp+var_12], 0	; Compare Two Operands
jz	short loc_301E7	; Jump if Zero (ZF=1)
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_2A]
mov	[es:bx+10h], ax
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_28]
mov	[es:bx+0Ch], ax
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
mov	ax, [bp+var_2C]
mov	[es:bx+0Eh], ax
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+12h]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+10h]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Eh]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Ch]
push	[AIL_HDRIVER2]
call	_AIL_detect_device ; Call Procedure
add	sp, 0Ah		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_301E5	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	[AIL_shutdown_w36AA0], 0
mov	ax, 7
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_301E5:		; CODE XREF: ST_LoadSoundDrivers+4B1j
jmp	short loc_30204	; Jump

loc_301E7:		; CODE XREF: ST_LoadSoundDrivers+460j
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	[AIL_shutdown_w36AA0], 0
mov	ax, 8
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_30204:		; CODE XREF: ST_LoadSoundDrivers+426j
			; ST_LoadSoundDrivers+459j
			; ST_LoadSoundDrivers:loc_301E5j
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_30237	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+12h]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+10h]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Eh]
les	bx, [idk_AIL_DrvDesc2_d3C5FE] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Ch]
push	[AIL_HDRIVER2]
call	far ptr	_AIL_init_driver ; Call	Procedure
add	sp, 0Ah		; Add

loc_30237:		; CODE XREF: ST_LoadSoundDrivers+4F4j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;	Compare	Two Operands
jle	short loc_3026A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+12h]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+10h]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Eh]
les	bx, [idk_AIL_DrvDesc1_d3C602] ;	Load Full Pointer to ES:xx
push	[word ptr es:bx+0Ch]
push	[AIL_HDRIVER1]
call	far ptr	_AIL_init_driver ; Call	Procedure
add	sp, 0Ah		; Add

loc_3026A:		; CODE XREF: ST_LoadSoundDrivers+527j
push	[AIL_HDRIVER1]
call	_AIL_state_table_size ;	Call Procedure
pop	cx
mov	[bp+var_18], 0
mov	[bp+var_1A], ax
mov	dx, [bp+var_18]
mov	ax, [bp+var_1A]
mov	cl, 4
call	LXURSH@		; Call Procedure
inc	ax		; Increment by 1
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[bp+var_E], ax
push	[bp+var_E]
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_36A9A], dx
mov	[word_36A98], ax
mov	ax, offset aFat_ ; "FAT."
push	ax
mov	ax, offset idk_FileName_w3C60E
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, [word ptr idk_AIL_DrvDesc1_d3C602]
add	ax, 4		; Add
push	[word ptr idk_AIL_DrvDesc1_d3C602+2]
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset idk_FAT_FileExtension_w3C5D8
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
mov	ax, offset idk_FAT_FileExtension_w3C5D8
push	ax
mov	ax, offset idk_FileName_w3C60E
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
push	[AIL_HDRIVER1]
call	_AIL_default_timbre_cache_size ; Call Procedure
pop	cx
mov	di, ax
cmp	di, 2000	; Compare Two Operands
jbe	short loc_302F1	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	di, 2000

loc_302F1:		; CODE XREF: ST_LoadSoundDrivers+5D7j
or	di, di		; Logical Inclusive OR
jz	short loc_3032D	; Jump if Zero (ZF=1)
mov	ax, di
xor	dx, dx		; Logical Exclusive OR
mov	cl, 4
call	LXURSH@		; Call Procedure
inc	ax		; Increment by 1
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[bp+var_A], ax
push	[bp+var_A]
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[bp+var_14], dx
mov	[bp+var_16], ax
push	di
push	[bp+var_14]
push	[bp+var_16]
push	[AIL_HDRIVER1]
call	_AIL_define_timbre_cache ; Call	Procedure
add	sp, 8		; Add

loc_3032D:		; CODE XREF: ST_LoadSoundDrivers+5DEj
mov	[idk_AIL_w36A8E], 1
mov	ax, 20
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[bp+var_10], ax
push	[bp+var_10]
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3C5EE+2], dx
mov	[word ptr dword_3C5EE],	ax
cmp	[idk_AIL_SndDrvNbr_w36A8A], 9 ;	Compare	Two Operands
jnz	short loc_3037E	; Jump if Not Zero (ZF=0)
mov	ax, 20		; int
push	ax		; argLbxEntryNumber
mov	ax, offset argFileNameBase ; "SNDDRV.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
push	[bp+var_4]	; int
nop			; No Operation
push	cs
call	near ptr ST_LoadSound ;	Call Procedure
pop	cx
jmp	short $+2	; Jump

loc_30374:		; CODE XREF: ST_LoadSoundDrivers+667j
nop			; No Operation
push	cs
call	near ptr sub_307FD ; Call Procedure
cmp	ax, 2		; Compare Two Operands
jnz	short loc_30374	; Jump if Not Zero (ZF=0)

loc_3037E:		; CODE XREF: ST_LoadSoundDrivers+640j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 10 ; Compare Two Operands
jnz	short loc_303AC	; Jump if Not Zero (ZF=0)
mov	ax, 21		; int
push	ax		; argLbxEntryNumber
mov	ax, offset argFileNameBase ; "SNDDRV.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_0_0 ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_6], ax
push	[bp+var_6]	; int
nop			; No Operation
push	cs
call	near ptr ST_LoadSound ;	Call Procedure
pop	cx
jmp	short $+2	; Jump

loc_303A2:		; CODE XREF: ST_LoadSoundDrivers+695j
nop			; No Operation
push	cs
call	near ptr sub_307FD ; Call Procedure
cmp	ax, 2		; Compare Two Operands
jnz	short loc_303A2	; Jump if Not Zero (ZF=0)

loc_303AC:		; CODE XREF: ST_LoadSoundDrivers+66Ej
jmp	RETURN_1	; Jump

loc_303AF:		; CODE XREF: ST_LoadSoundDrivers+29j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_LoadSoundDrivers ; sp-analysis failed

off_303B5 dw offset loc_2FE24
			; DATA XREF: ST_LoadSoundDrivers+10Ar
dw offset loc_2FE31	; jump table for switch	statement
dw offset loc_2FE2F
dw offset loc_2FE3C


; Attributes: bp-based frame

; int __fastcall __far ST_LoadSound(int, int, int, int)
proc ST_LoadSound far	; CODE XREF: _f010109_main+39DP
			; ST_LoadSoundDrivers+659p
			; ST_LoadSoundDrivers+687p
			; ST_LoadMusicSoundfxIntro+52P
			; ST_LoadMusicSoundfxIntro+16BP
			; ST_LoadMusicSoundfxIntro+1C7P
			; ST_LoadMusicSoundfxIntro+1E0P
			; ST_LoadMusicSoundfxIntro+23CP
			; ST_LoadMusicSoundfxIntro+297P
			; ST_LoadMusicSoundfxIntro+2DCP
			; ST_LoadMusicSoundfxIntro+2F6P
			; ST_LoadMusicSoundfxIntro+310P
			; ST_LoadMusicSoundfxIntro+32AP

var_2= word ptr	-2
argOffset= dword ptr  6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di		; arg2_SI
mov	si, [word ptr bp+argOffset]
cmp	[idk_AIL_w36A8E], 0 ; Compare Two Operands
jz	short RETURN_1	; Jump if Zero (ZF=1)
cmp	[AIL_shutdown_w36AA0], 0 ; Compare Two Operands
jnz	short loc_303DC	; Jump if Not Zero (ZF=0)

RETURN_1:		; CODE XREF: ST_LoadSound+10j
			; ST_LoadSound+6Ej
			; ST_LoadSound+1A7j
			; ST_LoadSound+26Ej
mov	ax, 1
jmp	loc_30714	; Jump

loc_303DC:		; CODE XREF: ST_LoadSound+17j
cmp	[AIL_shutdown_w36AA0], 2 ; Compare Two Operands
jz	short loc_303E6	; Jump if Zero (ZF=1)
jmp	loc_3061A	; Jump

loc_303E6:		; CODE XREF: ST_LoadSound+24j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, 0DEAFh	; File Type ID of VOC Sub-Archive?
jz	short loc_3040D	; Jump if Zero (ZF=1)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	ax, 9		; ? Case 0x9 Not a valid sound file ?
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_3040D:		; CODE XREF: ST_LoadSound+37j
mov	ax, 2
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	di, ax
inc	si		; Increment by 1
cmp	di, 1		; Compare Two Operands
jz	short SND_SUBTYP_1 ; Jump if Zero (ZF=1)
jmp	loc_30555	; Jump

SND_SUBTYP_1:		; CODE XREF: ST_LoadSound+62j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 2 ;	Compare	Two Operands
jge	short loc_3042D	; Jump if Greater or Equal (SF=OF)
jmp	short RETURN_1	; Jump

loc_3042D:		; CODE XREF: ST_LoadSound+6Cj
nop			; No Operation
push	cs
call	near ptr AIL_someSequence ; Call Procedure
push	si
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_3C60C], dx
mov	[word_3C60A], ax
mov	ax, [word_3C60A]
or	ax, [word_3C60C] ; Logical Inclusive OR
jnz	short loc_30460	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	ax, 10		; ? Case 0x0A Couldn't load XMIDI file ?
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_30460:		; CODE XREF: ST_LoadSound+8Aj
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; int
push	ax
push	dx
push	[word_36A9A]
push	[word_36A98]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3C60C]
push	[word_3C60A]
push	[AIL_HDRIVER1]
call	_AIL_register_sequence ; Call Procedure
add	sp, 10h		; Add
mov	[AIL_timbre_w36A94], ax
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_30497	; Jump if Not Zero (ZF=0)
mov	ax, 11
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_30497:		; CODE XREF: ST_LoadSound+CEj
cmp	[idk_AIL_SndDrvNbr_w36A8A], 10 ; Compare Two Operands
jnz	short loc_304A1	; Jump if Not Zero (ZF=0)
jmp	loc_30543	; Jump

loc_304A1:		; CODE XREF: ST_LoadSound+DFj
mov	ax, offset aRb	; "rb"
push	ax
mov	ax, offset idk_FileName_w3C60E ; int
push	ax		; asczFileName
call	DOS_OpenFileModeCheck ;	Call Procedure
pop	cx
pop	cx
mov	[idk_DosFileHandle_w3C61E], ax
jmp	short loc_3051B	; Jump

loc_304B5:		; CODE XREF: ST_LoadSound+173j
mov	ax, [bp+var_2]
and	ax, 0FFh	; Logical AND
push	ax
mov	ax, [bp+var_2]
mov	cl, 8
shr	ax, cl		; Shift	Logical	Right
push	ax
push	[idk_DosFileHandle_w3C61E]
push	cs
call	near ptr idk_DosReadFromFileHAndle_s2FC56 ; Call Procedure
add	sp, 6		; Add
mov	[word_3C5F4], dx
mov	[word_3C5F2], ax
mov	ax, [word_3C5F2]
or	ax, [word_3C5F4] ; Logical Inclusive OR
jz	short loc_30504	; Jump if Zero (ZF=1)
push	[word_3C5F4]
push	[word_3C5F2]
mov	ax, [bp+var_2]
and	ax, 255		; Logical AND
push	ax
mov	ax, [bp+var_2]
mov	cl, 8
shr	ax, cl		; Shift	Logical	Right
push	ax
push	[AIL_HDRIVER1]
call	_AIL_install_timbre ; Call Procedure
add	sp, 0Ah		; Add
jmp	short loc_3051B	; Jump

loc_30504:		; CODE XREF: ST_LoadSound+120j
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	ax, 12
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_3051B:		; CODE XREF: ST_LoadSound+F6j
			; ST_LoadSound+145j
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_timbre_request ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_304B5	; Jump if Not Zero (ZF=0)
cmp	[idk_DosFileHandle_w3C61E], 0 ;	Compare	Two Operands
jz	short loc_30543	; Jump if Zero (ZF=1)
push	[idk_DosFileHandle_w3C61E]
call	DOS_CloseFileHandle ; Call Procedure
pop	cx

loc_30543:		; CODE XREF: ST_LoadSound+E1j
			; ST_LoadSound+17Aj
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_start_sequence ; Call Procedure
pop	cx
pop	cx
jmp	loc_3061A	; arg2_SI

loc_30555:		; CODE XREF: ST_LoadSound+64j
cmp	di, 2		; Compare Two Operands
jz	short SND_SUBTYP_2 ; Jump if Zero (ZF=1)
jmp	loc_30610	; Jump

SND_SUBTYP_2:		; CODE XREF: ST_LoadSound+19Bj
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jnz	short loc_30567	; Jump if Not Zero (ZF=0)
jmp	RETURN_1	; Jump

loc_30567:		; CODE XREF: ST_LoadSound+1A5j
push	si
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[LdSndDrv_w3C608], dx
mov	[LdSndDrv_w3C606], ax
mov	ax, [LdSndDrv_w3C606]
or	ax, [LdSndDrv_w3C608] ;	Logical	Inclusive OR
jnz	short loc_30595	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	ax, 13		; ? Case 0x0D Could not	load ?
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_30595:		; CODE XREF: ST_LoadSound+1BFj
mov	ax, 4
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, 0DEADh	; Compare Two Operands
jz	short loc_305ED	; Jump if Zero (ZF=1)
db 83h,3Eh,82h,4Dh,0FFh	; <BAD>cmp     [AIL_HDRIVER2], 0FFFFh ;	Compare	Two Operands
jz	short loc_305C1	; Jump if Zero (ZF=1)

loc_305B0:		; Compare Two Operands
cmp	[AIL_playback_w36A8C], 0
jle	short loc_305C1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[AIL_HDRIVER2]
call	_AIL_stop_digital_playback ; Call Procedure
pop	cx

loc_305C1:		; CODE XREF: ST_LoadSound+1F1j
			; ST_LoadSound+1F8j
mov	ax, 0DEADh
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
mov	ax, si
dec	ax		; Decrement by 1
push	ax		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	ax, 0FFFFh
push	ax
push	[LdSndDrv_w3C608]
push	[LdSndDrv_w3C606]
push	[AIL_HDRIVER2]
call	_AIL_format_VOC_file ; Call Procedure
add	sp, 8		; Add

loc_305ED:		; CODE XREF: ST_LoadSound+1EAj
mov	ax, 0FFFFh
push	ax
push	[LdSndDrv_w3C608]
push	[LdSndDrv_w3C606]
push	[AIL_HDRIVER2]
call	_AIL_play_VOC_file ; Call Procedure
add	sp, 8		; Add
push	[AIL_HDRIVER2]
call	_AIL_start_digital_playback ; Call Procedure
jmp	short loc_30619	; Jump

loc_30610:		; CODE XREF: ST_LoadSound+19Dj
mov	ax, 14		; ? Case 0x0E Not a valid ... Not a valid sound	file ?
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure

loc_30619:		; CODE XREF: ST_LoadSound+251j
pop	cx

loc_3061A:		; CODE XREF: ST_LoadSound+26j
			; ST_LoadSound+195j
cmp	[AIL_shutdown_w36AA0], 1 ; Compare Two Operands
jz	short loc_30624	; Jump if Zero (ZF=1)
jmp	loc_30714	; Jump

loc_30624:		; CODE XREF: ST_LoadSound+262j
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jnz	short loc_3062E	; Jump if Not Zero (ZF=0)
jmp	RETURN_1	; Jump

loc_3062E:		; CODE XREF: ST_LoadSound+26Cj
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, 0DEAFh	; File Type ID of VOC Sub-Archive?
jz	short loc_30655	; Jump if Zero (ZF=1)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	ax, 15		; ? Case 0x0F Not a valid ... Not a valid sound	file ?
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_30655:		; CODE XREF: ST_LoadSound+27Fj
mov	ax, 2
push	ax
push	si		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	di, ax
inc	si		; Increment by 1
cmp	di, 2		; Compare Two Operands
jz	short loc_3066C	; Jump if Zero (ZF=1)
jmp	loc_30714	; Jump

loc_3066C:		; CODE XREF: ST_LoadSound+2AAj
push	si
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[LdSndDrv_w3C608], dx
mov	[LdSndDrv_w3C606], ax
mov	ax, [LdSndDrv_w3C606]
or	ax, [LdSndDrv_w3C608] ;	Logical	Inclusive OR
jnz	short loc_3069A	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx
mov	ax, 16
push	ax
nop			; No Operation
push	cs
call	near ptr ST_SoundErrorHandler ;	Call Procedure
pop	cx

loc_3069A:		; CODE XREF: ST_LoadSound+2C4j
mov	ax, 4
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax		; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, 0DEADh	; Compare Two Operands
jz	short loc_306F2	; Jump if Zero (ZF=1)
db 83h,3Eh,82h,4Dh,0FFh	; <BAD>cmp     [AIL_HDRIVER2], 0FFFFh ;	Compare	Two Operands
jz	short loc_306C6	; Jump if Zero (ZF=1)
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_306C6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[AIL_HDRIVER2]
call	_AIL_stop_digital_playback ; Call Procedure
pop	cx

loc_306C6:		; CODE XREF: ST_LoadSound+2F6j
			; ST_LoadSound+2FDj
mov	ax, 0FFFFh
push	ax
push	[LdSndDrv_w3C608]
push	[LdSndDrv_w3C606]
push	[AIL_HDRIVER2]
call	_AIL_format_VOC_file ; Call Procedure
add	sp, 8		; Add
mov	ax, 0DEADh
push	ax		; argValue
mov	ax, 4
push	ax		; argOffset
mov	ax, si
dec	ax		; Decrement by 1
push	ax		; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add

loc_306F2:		; CODE XREF: ST_LoadSound+2EFj
mov	ax, 0FFFFh
push	ax
push	[LdSndDrv_w3C608]
push	[LdSndDrv_w3C606]
push	[AIL_HDRIVER2]
call	_AIL_play_VOC_file ; Call Procedure
add	sp, 8		; Add
push	[AIL_HDRIVER2]
call	_AIL_start_digital_playback ; Call Procedure
pop	cx

loc_30714:		; CODE XREF: ST_LoadSound+1Cj
			; ST_LoadSound+264j
			; ST_LoadSound+2ACj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_LoadSound ; sp-analysis	failed



; Attributes: bp-based frame

proc sub_3071A far

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
mov	si, [bp+arg_0]
cmp	[idk_AIL_w36A8E], 0 ; Compare Two Operands
jnz	short loc_3072F	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_3075D	; Jump

loc_3072F:		; CODE XREF: sub_3071A+Fj
db 83h,3Eh,84h,4Dh,0FEh	; <BAD>cmp     [AIL_timbre_w36A94], 0FFFEh ; Compare Two Operands
jz	short loc_3075D	; Jump if Zero (ZF=1)
or	si, si		; Logical Inclusive OR
jge	short loc_3073C	; Jump if Greater or Equal (SF=OF)
xor	si, si		; Logical Exclusive OR

loc_3073C:		; CODE XREF: sub_3071A+1Ej
cmp	si, 64h	; 'd'   ; Compare Two Operands
jle	short loc_30744	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	si, 64h	; 'd'

loc_30744:		; CODE XREF: sub_3071A+25j
mov	[bp+var_2], si
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+var_2]
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_set_relative_volume ; Call	Procedure
add	sp, 8		; Add

loc_3075D:		; CODE XREF: sub_3071A+13j
			; sub_3071A+1Aj
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
cmp	[idk_AIL_w36A8E], 0 ; Compare Two Operands
jnz	short loc_30773	; Jump if Not Zero (ZF=0)

loc_3076F:		; CODE XREF: sub_3071A:loc_30793j
xor	ax, ax		; Logical Exclusive OR

loc_30771:		; CODE XREF: sub_3071A+75j
jmp	short loc_30795	; Jump

loc_30773:		; CODE XREF: sub_3071A+53j
db 83h,3Eh,84h,4Dh,0FEh	; <BAD>cmp     [AIL_timbre_w36A94], 0FFFEh ; Compare Two Operands
jz	short loc_30793	; Jump if Zero (ZF=1)
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_relative_volume ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
jmp	short loc_30771	; Jump
jmp	short loc_30795	; Jump

loc_30793:		; CODE XREF: sub_3071A+5Ej
jmp	short loc_3076F	; Jump

loc_30795:		; CODE XREF: sub_3071A:loc_30771j
			; sub_3071A+77j
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
cmp	[idk_AIL_w36A8E], 0 ; Compare Two Operands
jnz	short loc_307AA	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_307F9	; Jump

loc_307AA:		; CODE XREF: sub_3071A+8Aj
db 83h,3Eh,84h,4Dh,0FEh	; <BAD>cmp     [AIL_timbre_w36A94], 0FFFEh ; Compare Two Operands
jz	short loc_307E1	; Jump if Zero (ZF=1)
mov	[bp+var_2], 0
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_sequence_status ; Call Procedure
pop	cx
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_307E1	; Jump if Not Zero (ZF=0)
mov	ax, 3E8h
push	ax
push	[bp+var_2]
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_set_relative_volume ; Call	Procedure
add	sp, 8		; Add

loc_307E1:		; CODE XREF: sub_3071A+95j
			; sub_3071A+AEj
db 83h,3Eh,82h,4Dh,0FFh	; <BAD>cmp     [AIL_HDRIVER2], 0FFFFh ;	Compare	Two Operands
jz	short loc_307F9	; Jump if Zero (ZF=1)
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_307F9	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	[AIL_HDRIVER2]
call	_AIL_stop_digital_playback ; Call Procedure
pop	cx

loc_307F9:		; CODE XREF: sub_3071A+8Ej
			; sub_3071A+CCj
			; sub_3071A+D3j
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3071A



; Attributes: bp-based frame

proc sub_307FD far	; CODE XREF: ST_LoadSoundDrivers+661p
			; ST_LoadSoundDrivers+68Fp

var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
cmp	[idk_AIL_w36A8E], 0 ; Compare Two Operands
jz	short loc_30811	; Jump if Zero (ZF=1)
cmp	[AIL_shutdown_w36AA0], 2 ; Compare Two Operands
jge	short loc_30816	; Jump if Greater or Equal (SF=OF)

loc_30811:		; CODE XREF: sub_307FD+Bj
mov	ax, 2

loc_30814:		; CODE XREF: sub_307FD+2Ej
jmp	short loc_3082D	; Jump

loc_30816:		; CODE XREF: sub_307FD+12j
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_sequence_status ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
jmp	short loc_30814	; Jump

loc_3082D:		; CODE XREF: sub_307FD:loc_30814j
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_307FD



; Attributes: bp-based frame

proc AIL_someSequence far
			; CODE XREF: _f010109_main+37CP
			; _f010309_RUN:loc_136D6P
			; _f050207_EXIT_CleanUp+3P
			; idk_CleanupPrintExit_s14391+19P
			; ST_execl_WizardsExe+AP
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+8P
			; ST_LoadSound+72p
			; sub_308E6+1Ep
			; sub_308E6:loc_3091Ep
			; sub_308E6+44p
			; sub_3DB5F+CP
push	bp
mov	bp, sp
cmp	[idk_AIL_w36A8E], 0 ; If (<word_36A8E> - 0) == 0 Then Set ZF=1
			; JNZ: Jump If <word_36A8E> is NOT 0
jnz	short loc_3083F	; Jump if Not Zero (ZF=0)

loc_3083B:		; CODE XREF: AIL_someSequence:loc_3084Dj
xor	ax, ax		; AX = 0
jmp	short loc_308AC	; Jump

loc_3083F:		; CODE XREF: AIL_someSequence+8j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 0 ;
			; If (<word_36A8A> - 0)	== 0 Then Set ZF=1
			; JZ: Jump If <word_36A8A> IS 0
jz	short loc_3084D	; Jump if Zero (ZF=1)
cmp	[AIL_shutdown_w36AA0], 0 ; If (<word_36AA0> - 0) == 0 Then Set ZF=1
			; JNZ: Jump If <word_36AA0> is NOT 0
jnz	short loc_3084F	; Jump if Not Zero (ZF=0)

loc_3084D:		; CODE XREF: AIL_someSequence+13j
jmp	short loc_3083B	; Jump

loc_3084F:		; CODE XREF: AIL_someSequence+1Aj
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;
			; If (<word_36A8A> - 1)	== 0 Then Set ZF=1
			; JZ: Jump If <word_36A8A> IS 1
jnz	short loc_30866	; Jump if Not Zero (ZF=0)
db 83h,3Eh,82h,4Dh,0FFh	; <BAD>cmp     [AIL_HDRIVER2], 0FFFFh ;	Compare	Two Operands
jz	short loc_30864	; Jump if Zero (ZF=1)
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short $+2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_30864:		; CODE XREF: AIL_someSequence+2Aj
jmp	short loc_308AC	; Jump

loc_30866:		; CODE XREF: AIL_someSequence+23j
db 83h,3Eh,84h,4Dh,0FEh	; <BAD>cmp     [AIL_timbre_w36A94], 0FFFEh ; Compare Two Operands
jz	short loc_308A5	; Jump if Zero (ZF=1)
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_sequence_status ; mov     ax, 0AEh
			; jmp	  near ptr sub_2E744
pop	cx
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_30890	; Jump if Not Zero (ZF=0)
push	[AIL_timbre_w36A94]

loc_30885:
push	[AIL_HDRIVER1]
call	_AIL_stop_sequence ; mov     ax, 0ABh
			; jmp	  near ptr sub_2E744
pop	cx
pop	cx

loc_30890:		; CODE XREF: AIL_someSequence+4Ej
push	[AIL_timbre_w36A94]
push	[AIL_HDRIVER1]
call	_AIL_release_sequence_handle ; mov     ax, 98h
			; jmp	  near ptr sub_2E744
pop	cx
pop	cx
mov	[AIL_timbre_w36A94], 0FFFEh

loc_308A5:		; CODE XREF: AIL_someSequence+3Aj
db 83h,3Eh,82h,4Dh,0FFh	; <BAD>cmp     [AIL_HDRIVER2], 0FFFFh ;	Compare	Two Operands
jz	short $+2	; Jump if Zero (ZF=1)

loc_308AC:		; CODE XREF: AIL_someSequence+Cj
			; AIL_someSequence:loc_30864j
pop	bp
retf			; Return Far from Procedure
endp AIL_someSequence



; Attributes: bp-based frame

proc Call_AIL_shutdown far
			; CODE XREF: _f050207_EXIT_CleanUp+DP
			; idk_CleanupPrintExit_s14391+23P
			; ST_execl_WizardsExe+27P
			; idk_Cleanup_PrintFileTextMode_Exit_s14489+12P
			; sub_3DB5F+11P
push	bp
mov	bp, sp
cmp	[idk_AIL_SndDrvNbr_w36A8A], 0 ;	If ([word_36A8A] == 0) Then Set	(ZF = 1)
			; JNZ: Jump If [word_36A8A] is NOT 0
jnz	short loc_308BF	; Jump if Not Zero (ZF=0)
cmp	[AIL_playback_w36A8C], 0 ; If ([word_36A8C] == 0) Then Set (ZF = 1)
			; JZ: Jump If [word_36A8C] IS 0
jz	short loc_308D2	; Jump if Zero (ZF=1)

loc_308BF:		; CODE XREF: Call_AIL_shutdown+8j
cmp	[idk_AIL_w36A8E], 0 ;
			; If ([word_36A8E] == 0) Then Set (ZF =	1)
			; JZ: Jump If [word_36A8E] IS 0
jz	short loc_308D2	; Jump if Zero (ZF=1)
push	ds
mov	ax, 4DB2h
push	ax
call	far ptr	_AIL_shutdown ;	Call Procedure
pop	cx
pop	cx

loc_308D2:		; CODE XREF: Call_AIL_shutdown+Fj
			; Call_AIL_shutdown+16j
mov	[AIL_HDRIVER1],	0FFFFh
mov	[AIL_HDRIVER2],	0FFFFh
mov	[idk_AIL_w36A8E], 0
pop	bp
retf			; Return Far from Procedure
endp Call_AIL_shutdown



; Attributes: bp-based frame

proc sub_308E6 far

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	ax, [bp+arg_0]
or	ax, ax		; Logical Inclusive OR
jz	short loc_308FC	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_3090F	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_30935	; Jump if Zero (ZF=1)
jmp	short loc_3095B	; Jump

loc_308FC:		; CODE XREF: sub_308E6+8j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 0 ;	Compare	Two Operands
jz	short loc_3090D	; Jump if Zero (ZF=1)
push	cs
call	near ptr AIL_someSequence ; Call Procedure
mov	[AIL_shutdown_w36AA0], 0

loc_3090D:		; CODE XREF: sub_308E6+1Bj
jmp	short loc_3095B	; Jump

loc_3090F:		; CODE XREF: sub_308E6+Dj
cmp	[idk_AIL_SndDrvNbr_w36A8A], 0 ;	Compare	Two Operands
jz	short loc_30929	; Jump if Zero (ZF=1)
cmp	[AIL_playback_w36A8C], 0 ; Compare Two Operands
jle	short loc_30929	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	cs

loc_3091E:		; Call Procedure
call	near ptr AIL_someSequence
mov	[AIL_shutdown_w36AA0], 1
jmp	short loc_30933	; Jump

loc_30929:		; CODE XREF: sub_308E6+2Ej
			; sub_308E6+35j
push	cs
call	near ptr AIL_someSequence ; Call Procedure
mov	[AIL_shutdown_w36AA0], 0

loc_30933:		; CODE XREF: sub_308E6+41j
jmp	short loc_3095B	; Jump

loc_30935:		; CODE XREF: sub_308E6+12j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;	Compare	Two Operands
jle	short loc_30944	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[AIL_shutdown_w36AA0], 2
jmp	short loc_30959	; Jump

loc_30944:		; CODE XREF: sub_308E6+54j
cmp	[idk_AIL_SndDrvNbr_w36A8A], 1 ;	Compare	Two Operands
jnz	short loc_30953	; Jump if Not Zero (ZF=0)
mov	[AIL_shutdown_w36AA0], 1
jmp	short loc_30959	; Jump

loc_30953:		; CODE XREF: sub_308E6+63j
mov	[AIL_shutdown_w36AA0], 0

loc_30959:		; CODE XREF: sub_308E6+5Cj
			; sub_308E6+6Bj
jmp	short $+2	; Jump

loc_3095B:		; CODE XREF: sub_308E6+14j
			; sub_308E6:loc_3090Dj
			; sub_308E6:loc_30933j
pop	bp
retf			; Return Far from Procedure
endp sub_308E6



; Attributes: bp-based frame

proc idk_Env_BLASTER_s3095D far
			; CODE XREF: ST_LoadSoundDrivers+EAp

varStrEnvBlaster= byte ptr -8Ch
varEnvBlaster= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
c= word	ptr -6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 140		; Integer Subtraction
push	si		; maxlen
push	di
mov	ax, offset name	; "BLASTER"
push	ax		; name
call	_getenv		; Get a	Value from the Environment Table
pop	cx
mov	[bp+varEnvBlaster], ax
cmp	[bp+varEnvBlaster], 0 ;
			; BLASTER.C
			; if (env==NULL) return	0;
jnz	short loc_3097E	; Jump if Not Zero (ZF=0)

loc_30979:		; CODE XREF: idk_Env_BLASTER_s3095D+44j
			; idk_Env_BLASTER_s3095D+126j
xor	ax, ax		; Logical Exclusive OR

loc_3097B:		; CODE XREF: idk_Env_BLASTER_s3095D+139j
jmp	loc_30A99	; Jump

loc_3097E:		; CODE XREF: idk_Env_BLASTER_s3095D+1Aj
mov	ax, 127
push	ax		; src
push	[bp+varEnvBlaster]
lea	ax, [bp+varStrEnvBlaster] ; Load Effective Address
push	ax		; dest
call	_strncpy	;
			; BLASTER.C
			; strncpy(string,env,127);
add	sp, 6		; Add
lea	ax, [bp+varStrEnvBlaster] ; Load Effective Address
push	ax		; s
call	_strlen		;
			; BLASTER.C
			; if (!strlen(string)) return 0;
pop	cx
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short loc_309A3	; Jump if Not Zero (ZF=0)
jmp	short loc_30979	; Jump

loc_309A3:		; CODE XREF: idk_Env_BLASTER_s3095D+42j
lea	ax, [bp+varStrEnvBlaster] ; Load Effective Address
push	ax		; s
call	_strupr		;
			; BLASTER.C
			; strupr(string);
pop	cx
xor	si, si		; Logical Exclusive OR
jmp	LOOP_StrLen_StrEnvBlaster ; Jump

loc_309B3:		; CODE XREF: idk_Env_BLASTER_s3095D+11Cj
or	si, si		; Logical Inclusive OR
jz	short loc_309C1	; Jump if Zero (ZF=1)
cmp	[bp+si+varStrEnvBlaster], ' ' ; Compare Two Operands
jz	short loc_309C1	; Jump if Zero (ZF=1)
jmp	loc_30A69	; Jump

loc_309C1:		; CODE XREF: idk_Env_BLASTER_s3095D+58j
			; idk_Env_BLASTER_s3095D+5Fj
cmp	[bp+si+varStrEnvBlaster], ' ' ; Compare Two Operands
jnz	short loc_309CD	; Jump if Not Zero (ZF=0)
mov	ax, 1
jmp	short loc_309CF	; Jump

loc_309CD:		; CODE XREF: idk_Env_BLASTER_s3095D+69j
xor	ax, ax		; Logical Exclusive OR

loc_309CF:		; CODE XREF: idk_Env_BLASTER_s3095D+6Ej
add	si, ax		; Add
mov	al, [bp+si+varStrEnvBlaster]
cbw			; AL ->	AX (with sign)
mov	[bp+var_4], ax
xor	di, di		; Logical Exclusive OR
jmp	loc_30A61	; Jump

loc_309DE:		; CODE XREF: idk_Env_BLASTER_s3095D+109j
mov	al, [byte ptr word_36AA2+di]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_30A60	; Jump if Not Zero (ZF=0)
mov	ax, si
inc	ax		; Increment by 1
mov	[bp+var_A], ax
mov	[bp+var_8], 0

loc_309F3:		; CODE XREF: idk_Env_BLASTER_s3095D+F2j
lea	ax, [bp+varStrEnvBlaster] ; Load Effective Address
mov	bx, [bp+var_A]
add	bx, ax		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+c],	ax
inc	[bp+var_A]	; Increment by 1
mov	[bp+var_2], 0

loc_30A0A:		; Jump
jmp	short loc_30A37

loc_30A0C:		; CODE XREF: idk_Env_BLASTER_s3095D+E5j
push	[bp+c]
call	idk_ctype_s10E9D ; Call	Procedure
pop	cx
mov	bx, [bp+var_2]
push	ax
mov	al, [byte ptr strHexTable+bx] ;	if (toupper(d) == "0123456789ABCDEF"[j])
cbw			; AL ->	AX (with sign)
pop	dx
cmp	dx, ax		; Compare Two Operands
jnz	short loc_30A34	; Jump if Not Zero (ZF=0)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_36AA8+bx]
imul	[bp+var_8]	; Signed Multiply
add	ax, [bp+var_2]	; Add
mov	[bp+var_8], ax

loc_30A34:		; CODE XREF: idk_Env_BLASTER_s3095D+C4j
inc	[bp+var_2]	; Increment by 1

loc_30A37:		; CODE XREF: idk_Env_BLASTER_s3095D:loc_30A0Aj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_36AA8+bx]
cmp	ax, [bp+var_2]	; Compare Two Operands
jg	short loc_30A0C	; Jump if Greater (ZF=0	& SF=OF)
push	[bp+c]		; c
call	_isalnum	; while	(isalnum(d));
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_309F3	; Jump if Not Zero (ZF=0)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	bx, [word_36AB0+bx]
mov	ax, [bp+var_8]
mov	[bx], ax
jmp	short loc_30A69	; Jump

loc_30A60:		; CODE XREF: idk_Env_BLASTER_s3095D+89j
inc	di		; Increment by 1

loc_30A61:		; CODE XREF: idk_Env_BLASTER_s3095D+7Ej
cmp	di, 4		; Compare Two Operands
jge	short loc_30A69	; Jump if Greater or Equal (SF=OF)
jmp	loc_309DE	; Jump

loc_30A69:		; CODE XREF: idk_Env_BLASTER_s3095D+61j
			; idk_Env_BLASTER_s3095D+101j
			; idk_Env_BLASTER_s3095D+107j
inc	si		;
			; for (m=0;m<strlen(string);m++)

LOOP_StrLen_StrEnvBlaster:
			; CODE XREF: idk_Env_BLASTER_s3095D+53j
lea	ax, [bp+varStrEnvBlaster] ; BLASTER.C
			; for (m=0;m<strlen(string);m++)
push	ax		; s
call	_strlen		; Call Procedure
pop	cx
cmp	ax, si		; Compare Two Operands
jle	short loc_30A7C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_309B3	; Jump

loc_30A7C:		; CODE XREF: idk_Env_BLASTER_s3095D+11Aj
cmp	[itr_tokens_AIDT], 0 ; if (!type) return 0;
jnz	short loc_30A86	; Jump if Not Zero (ZF=0)
jmp	loc_30979	; Jump

loc_30A86:		; CODE XREF: idk_Env_BLASTER_s3095D+124j
cmp	[itr_tokens_AIDT], 4 ; if (type	> 4) type=4;
jle	short loc_30A93	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[itr_tokens_AIDT], 4

loc_30A93:		; CODE XREF: idk_Env_BLASTER_s3095D+12Ej
mov	ax, [itr_tokens_AIDT]
jmp	loc_3097B	; Jump

loc_30A99:		; CODE XREF: idk_Env_BLASTER_s3095D:loc_3097Bj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_Env_BLASTER_s3095D



; Attributes: bp-based frame

proc ST_SoundErrorHandler far
			; CODE XREF: ST_LoadSoundDrivers+FBp
			; ST_LoadSoundDrivers+1DEp
			; ST_LoadSoundDrivers+209p
			; ST_LoadSoundDrivers+268p
			; ST_LoadSoundDrivers+297p
			; ST_LoadSoundDrivers+3FCp
			; ST_LoadSoundDrivers+41Bp
			; ST_LoadSoundDrivers+4CCp
			; ST_LoadSoundDrivers+4EBp
			; ST_LoadSound+4Cp
			; ST_LoadSound+9Fp
			; ST_LoadSound+D6p
			; ST_LoadSound+15Ap
			; ST_LoadSound+1D4p
			; ST_LoadSound+259p
			; ST_LoadSound+294p
			; ST_LoadSound+2D9p

arg0_PrintString= byte ptr -78h
argErrorNumber=	word ptr  6

push	bp
mov	bp, sp
sub	sp, 78h		; argSrc
mov	bx, [bp+argErrorNumber]
cmp	bx, 16		; switch 17 cases
jbe	short loc_30AB0	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_30B46	; default

loc_30AB0:		; CODE XREF: ST_SoundErrorHandler+Cj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_30B55+bx] ; switch jump

loc_30AB7:		; CODE XREF: ST_SoundErrorHandler:loc_30AD7j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aYouSelectedAnInvalidSoundDriver ; case 0x0

loc_30ABA:		; CODE XREF: ST_SoundErrorHandler+3Dj
			; ST_SoundErrorHandler+42j
			; ST_SoundErrorHandler+47j
			; ST_SoundErrorHandler+51j
			; ST_SoundErrorHandler+67j
push	ax
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset aReconfigureHardwareOptions ; "reconfigure hardware options"

loc_30AC9:		; CODE XREF: ST_SoundErrorHandler+6Cj
			; ST_SoundErrorHandler+71j
			; ST_SoundErrorHandler+76j
			; ST_SoundErrorHandler+7Bj
			; ST_SoundErrorHandler+A5j
push	ax
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc

loc_30AD3:		; CODE XREF: ST_SoundErrorHandler+A0j
pop	cx
pop	cx
jmp	short loc_30B46	; default

loc_30AD7:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
jmp	short loc_30AB7	; case 0x1

loc_30AD9:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aYouSelectedAnInvalidDigiDriver ; case 0x2
jmp	short loc_30ABA	; Jump

loc_30ADE:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aSoundDriverIsNotAValidXmidiDriv ; case 0x3
jmp	short loc_30ABA	; Jump

loc_30AE3:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aDigiDriverIsNotAValidDspDriver ; case 0x4
jmp	short loc_30ABA	; Jump

loc_30AE8:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aMusic ; case 0x5
jmp	short loc_30AF7	; Jump

loc_30AED:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aMusicIOParametersAreIncorrect ; case 0x6
jmp	short loc_30ABA	; Jump

loc_30AF2:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
jmp	short $+2	; case 0x7

loc_30AF4:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aDigiDriver ; case 0x8

loc_30AF7:		; CODE XREF: ST_SoundErrorHandler+4Cj
push	ax

loc_30AF8:		; Load Effective Address
lea	ax, [bp+arg0_PrintString]
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset aIOParametersAreIncorrect ; "I/O parameters are incorrect, "
jmp	short loc_30ABA	; Jump

loc_30B08:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aNotAValidSoundFile ; case 0x9
jmp	short loc_30AC9	; Jump

loc_30B0D:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aCouldntLoadXmidiFile ; case	0xA
jmp	short loc_30AC9	; Jump

loc_30B12:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aSequenceDidNotRegister ; case 0xB
jmp	short loc_30AC9	; Jump

loc_30B17:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aTimbreNotFound ; case 0xC
jmp	short loc_30AC9	; Jump

loc_30B1C:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aCouldNotLoad ; case	0xD
jmp	short loc_30B26	; Jump

loc_30B21:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
jmp	short $+2	; case 0xE

loc_30B23:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aNotAValid ;	case 0xF

loc_30B26:		; CODE XREF: ST_SoundErrorHandler+80j
push	ax
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, (offset aNotAValidSoundFile+0Bh)
push	ax
lea	ax, [bp+arg0_PrintString] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
jmp	short loc_30AD3	; Jump

loc_30B41:		; CODE XREF: ST_SoundErrorHandler+13j
			; DATA XREF: seg036:off_30B55o
mov	ax, offset aCouldNotLoadSoundFile ; case 0x10
jmp	short loc_30AC9	; Jump

loc_30B46:		; CODE XREF: ST_SoundErrorHandler+Ej
			; ST_SoundErrorHandler+36j
lea	ax, [bp+arg0_PrintString] ; default
push	ax		; arg0_PrintString
call	_f050207_EXIT_CleanUp ;	Call Procedure
pop	cx
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_SoundErrorHandler

byte_30B54 db 0
off_30B55 dw offset loc_30AB7
			; DATA XREF: ST_SoundErrorHandler+13r
dw offset loc_30AD7	; jump table for switch	statement
dw offset loc_30AD9
dw offset loc_30ADE
dw offset loc_30AE3
dw offset loc_30AE8
dw offset loc_30AED
dw offset loc_30AF2
dw offset loc_30AF4
dw offset loc_30B08
dw offset loc_30B0D
dw offset loc_30B12
dw offset loc_30B17
dw offset loc_30B1C
dw offset loc_30B21
dw offset loc_30B23
dw offset loc_30B41
ends seg036


; Segment type:	Pure code
segment	seg037 byte public 'CODE' use16
assume cs:seg037
;org 7
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
__OVRGROUP dw seg seg038
			; DATA XREF: __OVRINIT:loc_30B89r
			; OVR_SetOvrMgrIntVec+4r
			; __OVREXIT+4r
			; sub_30E8D+ABr
			; seg037:0549r
			; seg037:07C9r
			; __CHECKSTACK+Br
			; __CHECKOVERLAY+4r
			; __CHECKOVERLAY+44r
__DGROUP dw seg	dseg	; DATA XREF: __OVRINIT+C4r
byte_30B7B db 50h, 41h,	54h, 48h, 3Dh
idk_InitMod_w30B80 dw 0	; DATA XREF: __InitModules+Cw
; [00000130 BYTES: COLLAPSED FUNCTION __OVRINIT. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function bp-based	frame

proc OVR_SetOvrMgrIntVec far
			; CODE XREF: __OVRINIT+E3p
			; __OVREXIT+12p
push	bp
mov	bp, sp
push	ds
mov	ds, [cs:__OVRGROUP]
assume ds:seg038
mov	al, [str3F]
mov	ah, 35h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
push	es
push	bx
push	ds
mov	al, [str3F]
mov	dx, [word_314C2] ; 04 F6 (F6 04)
mov	ds, [seg_314C4]	; 30 B7	(B7 30); seg037
assume ds:seg037
mov	ah, 25h
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
assume ds:dseg

loc_30CD5:
pop	[LibMalloc_w31D12]
pop	[LibMalloc_w31D14]
cmp	[OVR_FileHandle], 0 ; Compare Two Operands
jz	short loc_30CF4	; Jump if Zero (ZF=1)
mov	bx, [OVR_FileHandle]
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
mov	[OVR_FileHandle], 0
jmp	short loc_30D02	; Jump

loc_30CF4:		; CODE XREF: OVR_SetOvrMgrIntVec+30j
lea	dx, [CopyRight+0Ah] ; Load Effective Address
mov	ah, 3Dh
mov	al, [byte ptr LibMalloc_w31D16]
int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read, 1 -	write, 2 - read	& write
mov	[OVR_FileHandle], ax

loc_30D02:		; CODE XREF: OVR_SetOvrMgrIntVec+40j
pop	ds
pop	bp
retf			; Return Far from Procedure
endp OVR_SetOvrMgrIntVec

; [00000022 BYTES: COLLAPSED FUNCTION __OVREXIT. PRESS KEYPAD "+" TO EXPAND]
; [0000000C BYTES: COLLAPSED FUNCTION OVR_s30D27. PRESS	KEYPAD "+" TO EXPAND]
; [00000045 BYTES: COLLAPSED FUNCTION fncCheckDOSVersion. PRESS	KEYPAD "+" TO EXPAND]
; [0000005D BYTES: COLLAPSED FUNCTION OVR_s30D78. PRESS	KEYPAD "+" TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION OVR_s30DD5. PRESS	KEYPAD "+" TO EXPAND]
; [00000010 BYTES: COLLAPSED FUNCTION DOS_ReadFromFile_NoBX. PRESS KEYPAD "+" TO EXPAND]
; [00000080 BYTES: COLLAPSED FUNCTION __InitModules. PRESS KEYPAD "+" TO EXPAND]
; [000000C0 BYTES: COLLAPSED FUNCTION sub_30E8D. PRESS KEYPAD "+" TO EXPAND]
mov	cl, 4
shr	ax, cl		; Shift	Logical	Right
ror	dx, cl		; Rotate Right
and	dx, 0F000h	; Logical AND

loc_30F57:		; Logical Inclusive OR
or	ax, dx
retn			; Return Near from Procedure
; [00000039 BYTES: COLLAPSED FUNCTION sub_30F5A. PRESS KEYPAD "+" TO EXPAND]
; [00000045 BYTES: COLLAPSED FUNCTION sub_30F93. PRESS KEYPAD "+" TO EXPAND]
; [00000060 BYTES: COLLAPSED FUNCTION sub_30FD8. PRESS KEYPAD "+" TO EXPAND]

__ReadOvrDisk:
mov	si, [es:8]
xor	di, di		; Logical Exclusive OR
add	si, [es:0Ah]	; Add
adc	di, 0		; Add with Carry
mov	dx, [es:4]
mov	cx, [es:6]
mov	ax, [es:10h]
call	sub_30F5A	; Call Procedure
jb	short locret_31065 ; Jump if Below (CF=1)
mov	cx, [es:0Ah]
jcxz	short loc_31064	; Jump if CX is	0
call	sub_30F93	; Call Procedure

loc_31064:		; CODE XREF: seg037:04EFj
clc			; Clear	Carry Flag

locret_31065:		; CODE XREF: seg037:04E8j
retn			; Return Near from Procedure
push	bp
mov	bp, sp
test	bp, 1		; Logical Compare
jz	short loc_31074	; Jump if Zero (ZF=1)
jmp	far ptr	__OverlayHalt ;	Jump

loc_31074:		; CODE XREF: seg037:04FDj
push	ax
push	bx
push	cx
push	dx
push	si
push	di
push	ds
push	es
mov	ax, seg	seg038
mov	ds, ax
assume ds:seg038
sti			; Set Interrupt	Flag
les	bx, [bp+2]	; Load Full Pointer to ES:xx
push	[word ptr es:bx]
sub	[word ptr bp+2], 2 ; Integer Subtraction
jnz	short loc_31093	; Jump if Not Zero (ZF=0)
call	CHUNK_OverlayHalt ; Call Procedure
jmp	short loc_310AB	; Jump

loc_31093:		; CODE XREF: seg037:051Cj
add	bp, 6		; Add
mov	ax, [bp+0]
xchg	ax, [bp-6]	; Exchange Register/Memory with	Register
mov	[bp+0],	ax
call	CHUNK_OverlayHalt ; Call Procedure
mov	ax, [bp+0]
xchg	ax, [bp-6]	; Exchange Register/Memory with	Register
mov	[bp+0],	ax

loc_310AB:		; CODE XREF: seg037:0521j
pop	bx
mov	al, [es:1Ah]
and	al, 8		; Logical AND
and	[byte ptr es:1Ah], 0F7h	; Logical AND
cbw			; AL ->	AX (with sign)
mov	ds, [cs:__OVRGROUP]
call	[off_314D6]	; Indirect Call	Far Procedure
pop	es
pop	ds
assume ds:dseg
pop	di
pop	si
pop	dx
pop	cx
pop	bx
pop	ax
pop	bp
iret			; Interrupt Return


; Attributes: library function

proc idk_OVR_s310CC near
			; CODE XREF: CHUNK_OverlayHalt+21p
push	es
inc	[word_31DCA]	; Increment by 1
call	sub_3131F	; Call Procedure
jmp	short loc_31104	; Jump

loc_310D6:		; CODE XREF: idk_OVR_s310CC+3Ej
popf			; Pop Stack into Flags Register
push	dx
jnb	short loc_310DD	; Jump if Not Below (CF=0)
call	sub_311A9	; Call Procedure

loc_310DD:		; CODE XREF: idk_OVR_s310CC+Cj
mov	es, [word_31DCC]
mov	ax, [es:1Ch]
mov	[word_31DCC], ax
cmp	[byte ptr es:1Bh], 0 ; Compare Two Operands
jnz	short loc_310F8	; Jump if Not Zero (ZF=0)
call	sub_31191	; Call Procedure
call	idk_OVR_s31313	; Call Procedure
jmp	short loc_31103	; Jump

loc_310F8:		; CODE XREF: idk_OVR_s310CC+22j
dec	[byte ptr es:1Bh] ; Decrement by 1
call	sub_31256	; Call Procedure
call	idk_OVR_s312A7	; Call Procedure

loc_31103:		; CODE XREF: idk_OVR_s310CC+2Aj
pop	dx

loc_31104:		; CODE XREF: idk_OVR_s310CC+8j
call	idk_OVR_s312F7	; Call Procedure
pushf			; Push Flags Register onto the Stack
cmp	dx, ax		; Compare Two Operands
ja	short loc_310D6	; Jump if Above	(CF=0 &	ZF=0)
popf			; Pop Stack into Flags Register
pop	es
mov	ax, [word_31DC0]
mov	[es:10h], ax
retn			; Return Near from Procedure
endp idk_OVR_s310CC



; Attributes: library function

proc CHUNK_OverlayHalt near
			; CODE XREF: seg037:051Ep
			; seg037:052Fp
			; __CHECKOVERLAY+2Ep

; FUNCTION CHUNK AT 31EB SIZE 0000001D BYTES

inc	[word ptr idk_OVR_dw31DBC] ; Increment by 1
cmp	[word ptr es:10h], 0 ; Compare Two Operands
jz	short loc_31131	; Jump if Zero (ZF=1)
mov	[byte ptr es:1Bh], 1
or	[byte ptr es:1Ah], 4 ; Logical Inclusive OR
jmp	short loc_3114D	; Jump
db 90h

loc_31131:		; CODE XREF: CHUNK_OverlayHalt+Aj
or	[byte ptr es:1Ah], 8 ; Logical Inclusive OR
call	idk_OVR_s310CC	; Call Procedure
push	ds
dec	ax		; Decrement by 1
mov	ds, ax
mov	[idk_OVR_w31D1E], es
pop	ds
call	[word ptr es:18h] ; Indirect Call Near Procedure
jb	short loc_3118C	; Jump if Below	(CF=1)

loc_3114A:		; Call Procedure
call	idk_OVR_s312A7

loc_3114D:		; CODE XREF: CHUNK_OverlayHalt+18j
call	idk_OVR_s311E4	; Call Procedure
mov	al, [es:1Ah]
and	al, 3		; Logical AND
add	[es:1Bh], al	; Add
push	es
call	idk_OVR_s312F7	; Call Procedure
mov	es, [word_31DCC]

loc_31163:		; CODE XREF: CHUNK_OverlayHalt+72j
mov	cx, [es:1Ch]
jcxz	short loc_3118A	; Jump if CX is	0
cmp	ax, [word ptr _heaptop@+2] ; Compare Two Operands
jnb	short loc_3118A	; Jump if Not Below (CF=0)
push	cx
push	ax
cmp	[byte ptr es:1Bh], 0 ; Compare Two Operands
jz	short loc_3117E	; Jump if Zero (ZF=1)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_31184	; Jump

loc_3117E:		; CODE XREF: CHUNK_OverlayHalt+62j
call	idk_OVR_s31223	; Call Procedure
call	idk_OVR_s31313	; Call Procedure

loc_31184:		; CODE XREF: CHUNK_OverlayHalt+66j
pop	cx
pop	es
add	ax, cx		; Add
jmp	short loc_31163	; Jump

loc_3118A:		; CODE XREF: CHUNK_OverlayHalt+52j
			; CHUNK_OverlayHalt+58j
pop	es
retn			; Return Near from Procedure

loc_3118C:		; CODE XREF: CHUNK_OverlayHalt+32j
jmp	far ptr	__OverlayHalt ;	Jump
endp CHUNK_OverlayHalt

; [00000018 BYTES: COLLAPSED FUNCTION sub_31191. PRESS KEYPAD "+" TO EXPAND]
; [0000003B BYTES: COLLAPSED FUNCTION sub_311A9. PRESS KEYPAD "+" TO EXPAND]
; [00000021 BYTES: COLLAPSED FUNCTION idk_OVR_s311E4. PRESS KEYPAD "+" TO EXPAND]
; [0000001E BYTES: COLLAPSED FUNCTION sub_31205. PRESS KEYPAD "+" TO EXPAND]
; [00000033 BYTES: COLLAPSED FUNCTION idk_OVR_s31223. PRESS KEYPAD "+" TO EXPAND]
; [00000051 BYTES: COLLAPSED FUNCTION sub_31256. PRESS KEYPAD "+" TO EXPAND]
; [0000001E BYTES: COLLAPSED FUNCTION idk_OVR_s312A7. PRESS KEYPAD "+" TO EXPAND]
; [0000000C BYTES: COLLAPSED FUNCTION sub_312C5. PRESS KEYPAD "+" TO EXPAND]
; [00000026 BYTES: COLLAPSED FUNCTION sub_312D1. PRESS KEYPAD "+" TO EXPAND]
; [0000001C BYTES: COLLAPSED FUNCTION idk_OVR_s312F7. PRESS KEYPAD "+" TO EXPAND]
; [0000000C BYTES: COLLAPSED FUNCTION idk_OVR_s31313. PRESS KEYPAD "+" TO EXPAND]
; [00000018 BYTES: COLLAPSED FUNCTION sub_3131F. PRESS KEYPAD "+" TO EXPAND]

__ISOVERLAYMOD:
push	ds
push	es
mov	ds, [cs:__OVRGROUP]
assume ds:seg038

loc_3133E:		; Compare Two Operands
cmp	ax, [word_31574]
jb	short loc_31367	; Jump if Below	(CF=1)
cmp	ax, [word_31576] ; Compare Two Operands
jnb	short loc_31367	; Jump if Not Below (CF=0)
dec	ax		; Decrement by 1
mov	es, ax
mov	es, [word ptr es:0Eh]
inc	ax		; Increment by 1
mov	bx, [word ptr byte_31560]
cmp	bx, [es:0]	; Compare Two Operands

loc_3135C:		; Jump if Not Zero (ZF=0)
jnz	short loc_31367
cmp	ax, [es:10h]	; Compare Two Operands
mov	ax, es
jz	short loc_3136A	; Jump if Zero (ZF=1)

loc_31367:		; CODE XREF: seg037:07D2j
			; seg037:07D8j
			; seg037:loc_3135Cj
xor	ax, ax		; Logical Exclusive OR
stc			; Set Carry Flag

loc_3136A:		; CODE XREF: seg037:07F5j
pop	es
pop	ds
assume ds:dseg
retf			; Return Far from Procedure


; Attributes: library function bp-based	frame

proc __CHECKSTACK far

var_2= byte ptr	-2

push	bp
mov	bp, sp

loc_31370:		; Integer Subtraction
sub	sp, 2
mov	[bp+var_2], 0
push	ds
mov	ds, [cs:__OVRGROUP]
assume ds:seg038
push	si
push	di
mov	bx, bp
mov	ax, [word ptr byte_31560]
mov	dx, [word_31574]
jmp	short loc_3138E	; Jump

loc_3138A:		; CODE XREF: __CHECKSTACK:loc_31399j
			; __CHECKSTACK+34j
			; __CHECKSTACK:loc_313ABj
			; __CHECKSTACK+43j
			; __CHECKSTACK+4Dj
shl	si, 1		; Shift	Logical	Left
mov	bx, si

loc_3138E:		; CODE XREF: __CHECKSTACK+1Bj
cmp	bx, cx		; Compare Two Operands
jnb	short loc_313BC	; Jump if Not Below (CF=0)
mov	si, [ss:bx]
shr	si, 1		; Shift	Logical	Right
jz	short loc_313BC	; Jump if Zero (ZF=1)

loc_31399:		; Jump if Below	(CF=1)
jb	short loc_3138A
mov	di, [ss:bx+4]
cmp	di, dx		; Compare Two Operands
jnb	short loc_3138A	; Jump if Not Below (CF=0)
mov	es, di
mov	di, [ss:bx+2]

loc_313A9:		; Logical Inclusive OR
or	di, di

loc_313AB:		; Jump if Not Zero (ZF=0)
jnz	short loc_3138A

loc_313AD:		; Compare Two Operands
cmp	[es:di], ax
jnz	short loc_3138A	; Jump if Not Zero (ZF=0)

loc_313B2:
mov	[bp+var_2], 1
mov	[es:di+2], di
jmp	short loc_3138A	; Jump

loc_313BC:		; CODE XREF: __CHECKSTACK+23j
			; __CHECKSTACK+2Aj
cmp	[bp+var_2], 1	; Compare Two Operands
jz	short loc_313C9	; Jump if Zero (ZF=1)
jmp	short loc_313FE	; Jump
db 90h

loc_313C5:		; CODE XREF: __CHECKSTACK+63j
			; __CHECKSTACK+6Bj
			; __CHECKSTACK+75j
			; __CHECKSTACK+7Cj
			; __CHECKSTACK+84j
			; __CHECKSTACK+8Fj
shl	si, 1		; Shift	Logical	Left
mov	bx, si

loc_313C9:		; CODE XREF: __CHECKSTACK+53j
mov	si, [ss:bx]
shr	si, 1		; Shift	Logical	Right
jz	short loc_313FE	; Jump if Zero (ZF=1)
jb	short loc_313C5	; Jump if Below	(CF=1)
mov	di, [ss:bx+4]
cmp	di, dx		; Compare Two Operands
jnb	short loc_313C5	; Jump if Not Below (CF=0)
mov	es, di
mov	di, [ss:bx+2]
or	di, di		; Logical Inclusive OR
jz	short loc_313C5	; Jump if Zero (ZF=1)
cmp	[es:0],	ax	; Compare Two Operands
jnz	short loc_313C5	; Jump if Not Zero (ZF=0)
cmp	[word ptr es:2], 0 ; Compare Two Operands
jnz	short loc_313C5	; Jump if Not Zero (ZF=0)
xchg	di, [es:2]	; Exchange Register/Memory with	Register
mov	[ss:bx+2], di
jmp	short loc_313C5	; Jump

loc_313FE:		; CODE XREF: __CHECKSTACK+55j
			; __CHECKSTACK+61j
pop	di
pop	si
pop	ds
assume ds:dseg
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp __CHECKSTACK



; Attributes: library function bp-based	frame

proc __CHECKOVERLAY far

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	ds
mov	ds, [cs:__OVRGROUP]
assume ds:seg038

loc_3140E:
mov	es, [bp+arg_2]
mov	cx, [word ptr byte_31560]
cmp	cx, [es:0]	; Compare Two Operands
jnz	short loc_3145A	; Jump if Not Zero (ZF=0)
cmp	[word ptr es:10h], 0 ; Compare Two Operands
jz	short loc_3142C	; Jump if Zero (ZF=1)

loc_31424:		; Compare Two Operands
cmp	[byte ptr es:20h], 0CDh	; ''
jnz	short loc_31453	; Jump if Not Zero (ZF=0)

loc_3142C:		; CODE XREF: __CHECKOVERLAY+1Dj
mov	[bp+arg_2], 0
push	si
push	di
call	CHUNK_OverlayHalt ; Call Procedure
pop	di
pop	si
mov	bx, [bp+arg_0]
push	es
mov	al, [es:1Ah]
and	al, 8		; Logical AND
and	[byte ptr es:1Ah], 0F7h	; Logical AND
cbw			; AL ->	AX (with sign)
mov	ds, [cs:__OVRGROUP]
call	[off_314D6]	; Indirect Call	Far Procedure
pop	es

loc_31453:		; CODE XREF: __CHECKOVERLAY+25j
mov	ax, [es:10h]
mov	[bp+arg_2], ax

loc_3145A:		; CODE XREF: __CHECKOVERLAY+15j
pop	ds
assume ds:dseg
pop	bp
retf			; Return Far from Procedure
endp __CHECKOVERLAY



; Attributes: library function noreturn

proc __OvrPrepare far	; DATA XREF: dseg:52A8o
push	ds
push	si
push	di
mov	ax, seg	seg038
mov	ds, ax
assume ds:seg038
call	__InitModules	; Call Procedure
mov	bx, [word_3156A]
mov	ax, seg	dseg
mov	ds, ax
assume ds:dseg

loc_31471:
mov	ax, seg	dseg
mov	es, ax
assume es:dseg
cmp	bx, [es:word_33D7E] ; Compare Two Operands
jnb	short loc_31484	; Jump if Not Below (CF=0)
mov	bx, [es:word_33D7E]
jmp	short loc_31486	; Jump

loc_31484:		; CODE XREF: __OvrPrepare+1Ej
shl	bx, 1		; Shift	Logical	Left

loc_31486:		; CODE XREF: __OvrPrepare+25j
inc	bx		; Increment by 1
push	bx
mov	ax, 10h
mul	bx		; Unsigned Multiplication of AL	or AX
push	dx
push	ax		; nbytes
call	_farmalloc	; DX:AX	- segment:offset address of allocated far heap
pop	bx
pop	bx
pop	bx
mov	cx, ax
or	cx, dx		; Logical Inclusive OR
jcxz	short loc_314B3	; Jump if CX is	0
inc	dx		; Increment by 1
add	bx, dx		; Add
push	dx
push	bx
xor	ax, ax		; Logical Exclusive OR
push	ax
push	ax

loc_314A6:		; No Operation
nop
push	cs

loc_314A8:		; Call Procedure
call	near ptr __OVRINIT
or	ax, ax		; Logical Inclusive OR
jnz	short loc_314B3	; Jump if Not Zero (ZF=0)
pop	di
pop	si
pop	ds
retf			; Return Far from Procedure

loc_314B3:		; CODE XREF: __OvrPrepare+3Ej
			; __OvrPrepare+50j
jmp	_abort		; Jump
retn			; Return Near from Procedure
endp __OvrPrepare




proc nullsub_3 far	; CODE XREF: __OVREXIT+16p
			; __OVREXIT:loc_30D20p
			; DATA XREF: seg038:off_314D2o
			; seg038:off_314D4o
retf			; Return Far from Procedure
endp nullsub_3

ends seg037


; Segment type:	Pure code
segment	seg038 byte public 'CODE' use16
assume cs:seg038
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
unk_314C0 db	0
unk_314C1 db	0
word_314C2 dw 4F6h	; DATA XREF: OVR_SetOvrMgrIntVec+16r
seg_314C4 dw seg seg037	; DATA XREF: OVR_SetOvrMgrIntVec+1Ar
AccessMode_READ	db 0	; DATA XREF: OVR_s30DD5+22r
unk_314C7 db	0
unk_314C8 db	0
unk_314C9 db	0
unk_314CA db	0
unk_314CB db	0
unk_314CC db	0
unk_314CD db	0
unk_314CE db	0
unk_314CF db	0
word_314D0 dw 948h
off_314D2 dw offset nullsub_3
			; DATA XREF: __OVREXIT:loc_30D20r
off_314D4 dw offset nullsub_3
			; DATA XREF: __OVREXIT+16r
off_314D6 dd nullsub_2	; DATA XREF: sub_30E8D:loc_30F3Dr
			; seg037:054Er
			; __CHECKOVERLAY+49r
db  0Eh
db    0
unk_314DC db	0
db    0
unk_314DE db	0
db    0
unk_314E0 db	0
db    0
db    0
db    0
unk_314E4 db	0
db    0
unk_314E6 db	0
db    0
unk_314E8 db	0
db    0
db    0
unk_314EB db	0
unk_314EC db	0
db    0
db    0
db    0
unk_314F0 db	0
db    0
db    0
unk_314F3 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_314FF db	0
unk_31500 db	0
db    0
db    0
db    0
unk_31504 db	0
db    0
unk_31506 db	0
db    0
db    0
db    0
db    0
db    0
unk_3150C db	0
db    0
unk_3150E db	0
unk_3150F db	0
unk_31510 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_31517 db	0
unk_31518 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3151F db	0
db    0
unk_31521 db	0
db    0
db    0
unk_31524 db	0
unk_31525 db	0
unk_31526 db	0
db    0
unk_31528 db	0
unk_31529 db	0
db    0
db    0
unk_3152C db	0
db    0
db    0
db    0
unk_31530 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_31540 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_31549 db	0
unk_3154A db	0
db    0
db    0
db    0
db    0
unk_3154F db	0
db    0
unk_31551 db	0
unk_31552 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3155E db	0
db    0
byte_31560 db 0CDh	; DATA XREF: __OVRINIT:loc_30B91r
			; seg037:07E3r
			; __CHECKSTACK+14r
			; __CHECKOVERLAY+Cr
str3F db 3Fh		; DATA XREF: OVR_SetOvrMgrIntVec+9r
			; OVR_SetOvrMgrIntVec+13r
align 4
word_31564 dw 0		; DATA XREF: __OVRINIT:loc_30C3Fw
word_31566 dw 0		; DATA XREF: __OVRINIT+C0w
word_31568 dw 0		; DATA XREF: __OVRINIT:loc_30C94w
word_3156A dw 0		; DATA XREF: __OVRINIT+102r
			; __OvrPrepare+Br
algn_3156C:
align 8
word_31570 dw 0		; DATA XREF: __OVRINIT+EDw
word_31572 dw 0		; DATA XREF: __InitModules+30w
word_31574 dw 0		; DATA XREF: __OVRINIT+EAw
			; __OVRINIT+FEr
			; seg037:loc_3133Er
			; __CHECKSTACK+17r
word_31576 dw 0		; DATA XREF: __OVRINIT+F3w
			; __OVRINIT+FAr
			; seg037:07D4r
word_31578 dw 0		; DATA XREF: __OVRINIT+4Cw
			; __OVRINIT+DBw
			; __OVRINIT+11Br
			; __OVREXIT+9r
algn_3157A:
align 4
word_3157C dw 0		; DATA XREF: idk_OVR_s312A7+Dr
			; idk_OVR_s312A7+14w
ofs_STARTX dd STARTX	; DATA XREF: __OVRINIT:loc_30BA8o
db    9
db  32h	; 2
db    1
db    0
db    0
unk_31587 db	0
db  20h
db  13h
db  21h	; !
db  0Dh
db    1
db    0
db    9
db    0
db 0F2h	; 
db  13h
db 0CFh	; 
db    0
db    1
db    0
db    2
unk_31597 db	0
db 0FFh
db  13h
db  9Ch	; 
db    1
db    1
db    0
db    0
db    0
db  18h
db  14h
db 0AEh	; 
db    0
db    1
db    0
db  0Ch
db    0
db  22h	; "
db  14h
db 0BDh	; 
db    3
db    1
db    0
db  0Eh
db    0
db  5Dh	; ]
db  14h
o_1_a_87_s_0_tpsig2_91 db  9Ah ; 
db    0
db    1
db    0
db  0Eh
unk_315B7 db	0
db  66h	; f
db  14h
db  27h	; '
db    1
db    1
db    0
db  0Ah
db    0
db  78h	; x
db  14h
db  91h	; 
db    6
db    1
db    0
db    7
db    0
db 0E1h	; 
db  14h
db  16h
db    1
db    1
db    0
db    2
db    0
db 0F2h	; 
db  14h
db  5Dh	; ]
db  11h
db    1
db    0
db    6
db    0
db    7
db  16h
db    5
db    1
db    1
db    0
db  0Dh
db    0
db  17h
db  16h
db 0C7h	; 
db    2
db    1
db    0
unk_315E6 db	6
db    0
db  43h	; C
db  16h
db  3Dh	; =
db  19h
db    1
db    0
db    7
db    0
db 0D6h	; 
db  17h
db    4
db    9
db    1
db    0
db  0Dh
db    0
db  66h	; f
db  18h
db  48h	; H
db    0
db    1
db    0
db    4
db    0
db  6Ah	; j
db  18h
db  8Ah	; 
db  0Bh
db    1
db    0
db    8
db    0
db  22h	; "
db  19h
db 0DBh	; 
db  18h
db    1
db    0
db  0Ah
db    0
db 0AFh	; 
db  1Ah
db 0BDh	; 
db    5
db    1
db    0
db  0Ch
db    0
db  0Ah
db  1Bh
db 0DAh	; 
db  0Dh
db    1
db    0
db  0Dh
db    0
db 0E7h	; 
db  1Bh
db  57h	; W
db    6
db    1
db    0
db  0Ah
db    0
db  4Ch	; L
db  1Ch
db 0FAh	; 
db    6
db    1
db    0
db    8
db    0
db 0BBh	; 
db  1Ch
db  2Eh	; .
db  0Ah
db    1
db    0
db  0Ah
db    0
db  5Dh	; ]
db  1Dh
db  72h	; r
db    5
db    1
db    0
db  0Eh
db    0
db 0B4h	; 
db  1Dh
db  93h	; 
db    5
db    1
db    0
db    2
db    0
db  0Dh
db  1Eh
db 0E9h	; 
db    3
db    1
db    0
db    4
db    0
db  4Bh	; K
db  1Eh
db 0FCh	; 
db    2
db    1
db    0
db  0Ah
db    0
db  7Ah	; z
db  1Eh
db 0D1h	; 
db    6
db    1
db    0
db  0Ch
db    0
db 0E7h	; 
db  1Eh
db  1Bh
db  33h	; 3
db    1
db    0
db    1
db    0
db  18h
db  22h	; "
db  33h	; 3
db    5
db    1
db    0
db  0Ch
db    0
db  6Bh	; k
db  22h	; "
db  27h	; '
db    6
db    1
db    0
db    4
db    0
db 0CDh	; 
db  22h	; "
db  77h	; w
db  0Ah
db    1
db    0
db    8
db    0
db  74h	; t
db  23h	; #
db  96h	; 
db    7
db    1
db    0
db    8
db    0
db 0EDh	; 
db  23h	; #
db 0DEh	; 
db  0Eh
db    1
db    0
db    6
db    0
db 0DAh	; 
db  24h	; $
db 0B2h	; 
db  95h	; 
db    1
db    0
db  0Eh
db    0
db  35h	; 5
db  2Eh	; .
db    6
db  19h
db    1
db    0
db    2
db    0
db 0C5h	; 
db  2Fh	; /
db  27h	; '
db  0Fh
db    1
unk_316A5 db	0
db    6
db    0
db 0B7h	; 
db  30h	; 0
db  4Ah	; J
db    9
db    1
db    0
db    7
db    0
db  4Ch	; L
db  31h	; 1
align 8
db  4Ch	; L
db  31h	; 1
align 8
unk_316C0 db  4Ch ; L
db  31h	; 1
align 8
db  4Ch	; L
db  31h	; 1
db  18h
db    3
db    0
db    0
db    0
db    0
db  56h	; V
db  31h	; 1
db 0FFh
db 0FFh
db    4
db    0
db    0
db    0
db  58h	; X
db  31h	; 1
db 0FFh
db 0FFh
db    4
db    0
db    0
db    0
db  58h	; X
db  31h	; 1
db 0FFh
db 0FFh
db    4
db    0
db    0
db    0
db  58h	; X
db  31h	; 1
db 0FFh
db 0FFh
db    4
db    0
db    0
db    0
db  58h	; X
db  31h	; 1
db 0FFh
db 0FFh
db    4
db    0
dd stru_317E0
align 4
db    1
db    0
dd stru_317E0
db  2Ah	; *
db    0
db    3
db    0
off_31706 dd stru_31810
db  39h	; 9
db    0
db    3
db    0
dd stru_31850
db 0DEh	; 
db    0
db    3
db    0
dd stru_31930
db  2Eh	; .
db    1
db    3
db    0
dd stru_31A60
db  25h	; %
db    0
db    3
db    0
dd stru_31A90
db  8Eh	; 
db    0
db    3
db    0
dd stru_31B20
db  39h	; 9
db    0
db    3
db    0
dd stru_31B60
db  25h	; %
db    0
db    3
db    0
off_3173E dd stru_31B90
db  75h	; u
db    0
db    3
db    0
dd stru_31C10
db  25h	; %
db    0
db    3
db    0
dd stru_31C40
db  3Eh	; >
db    0
db    3
db    0
dd stru_31C80
db  2Fh	; /
db    0
db    3
db    0
dd stru_31CB0
db  2Ah	; *
db    0
db    3
db    0
dd stru_31CE0
db  2Ah	; *
db    0
db    3
db    0
dd LibMalloc_w31D10
db  4Ah	; J
db 0AAh	; 
db    0
db    0
db    0
db    0
db 0FAh	; 
db  36h	; 6
db    3
db    0
db    4
db    0
unk_3177E db	4
db    0
db 0FAh	; 
db  36h	; 6
db    3
db    0
db    4
db    0
db    4
db    0
db 0FAh	; 
db  36h	; 6
db    3
db    0
db    4
db    0
db    4
db    0
db 0FAh	; 
db  36h	; 6
db    3
db    0
db    4
db    0
db    4
db    0
db 0FBh	; 
db  36h	; 6
db  0Bh
db    0
db    4
db    0
db  0Ch
db    0
db 0FBh	; 
db  36h	; 6
db  0Bh
db    0
db    4
unk_317A5 db	0
db  0Ch
db    0
db 0FCh	; 
db  36h	; 6
db    1
db    0
db    4
db    0
db    2
db    0
db 0FCh	; 
db  36h	; 6
db    1
db    0
db    4
db    0
db    2
db    0
db  75h	; u
db  3Ch	; <
db    9
db    0
db    4
db    0
db  0Ah
db    0
unk_317C0 db  76h ; v
db  3Ch	; <
db  80h	; 
db    0
db    0
db    0
db    0
db    0
aMagic_exe db 'magic.exe',0
			; DATA XREF: __OVRINIT:loc_30BA8o
align 4
dd 7CB0303h
ends seg038


; Segment type:	Pure code
segment	stub048	para public 'CODE' use16
assume cs:stub048
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_317E0  = _stub_descr ptr $
			; DATA XREF: seg038:0236o
			; seg038:023Eo
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 0			; fileoff
dw 7E0h			; codesize
dw 0AEh			; relsize
dw 2			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

; int __fastcall __far j_OVR_SaveGame_MagicSet(int, int, int, int)
proc j_OVR_SaveGame_MagicSet far
			; CODE XREF: _f010109_main+3BFP
			; sub_3DA30+F1P
			; sub_3DB5F+26P
			; sub_4D540:loc_4D588P
jmp	OVR_SaveGame_MagicSet ;	Jump
endp j_OVR_SaveGame_MagicSet

; [00000005 BYTES: COLLAPSED FUNCTION j_ST_LoadSaveGamByNbr. PRESS KEYPAD "+" TO EXPAND]

; Segment type:	Pure code
segment	stub049	para public 'CODE' use16
assume cs:stub049
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31810  = _stub_descr ptr $
			; DATA XREF: seg038:off_31706o
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 890h			; fileoff
dw 0A66h		; codesize
dw 0A4h			; relsize
dw 5			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc sub_31830 far
jmp	sub_3D378	; Jump
endp sub_31830



; Attributes: thunk

proc sub_31835 far	; CODE XREF: sub_3DBA6:loc_3DF33P
jmp	sub_3CFC0	; Jump
endp sub_31835

; [00000005 BYTES: COLLAPSED FUNCTION j_hrmSetFlags. PRESS KEYPAD "+" TO EXPAND]
; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_HelpEntry_s3D9F3. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc j_ST_MagicSet_ReadCreateWrite far
			; CODE XREF: _f010109_main+5DP
			; _f010509_MainMenuScreen+A3P
jmp	ST_MagicSet_ReadCreateWrite ; Jump
endp j_ST_MagicSet_ReadCreateWrite

ends stub049


; Segment type:	Pure code
segment	stub050	para public 'CODE' use16
assume cs:stub050
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31850  = _stub_descr ptr $
			; DATA XREF: seg038:024Eo
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 13B0h		; fileoff
dw 5B4Ch		; codesize
dw 56Ah			; relsize
dw 38			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc sub_31870 far
jmp	sub_43529	; Jump
endp sub_31870



; Attributes: thunk

proc sub_31875 far
jmp	sub_3DF8C	; Jump
endp sub_31875



; Attributes: thunk

proc sub_3187A far
jmp	sub_3E60E	; Jump
endp sub_3187A



; Attributes: thunk

proc sub_3187F far
jmp	sub_3EDD1	; Jump
endp sub_3187F



; Attributes: thunk

proc sub_31884 far
jmp	sub_3F6BF	; Jump
endp sub_31884



; Attributes: thunk

proc sub_31889 far
jmp	sub_40EC0	; Jump
endp sub_31889



; Attributes: thunk

proc sub_3188E far
jmp	sub_40037	; Jump
endp sub_3188E



; Attributes: thunk

proc sub_31893 far
jmp	sub_3FA0C	; Jump
endp sub_31893



; Attributes: thunk

proc sub_31898 far
jmp	sub_424BB	; Jump
endp sub_31898



; Attributes: thunk

proc sub_3189D far	; CODE XREF: _f010309_RUN:loc_136F4P
jmp	sub_3DA30	; Jump
endp sub_3189D



; Attributes: thunk

proc sub_318A2 far
jmp	sub_3E1DE	; Jump
endp sub_318A2



; Attributes: thunk

proc sub_318A7 far
jmp	sub_3EBA0	; Jump
endp sub_318A7



; Attributes: thunk

proc sub_318AC far
jmp	sub_3F3C6	; Jump
endp sub_318AC

; [00000005 BYTES: COLLAPSED FUNCTION j_idk_Load_NEWGAME_LBX. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_318B6 far
jmp	sub_4067D	; Jump
endp sub_318B6

; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_NewGame_s41A5F. PRESS KEYPAD "+" TO	EXPAND]


; Attributes: thunk

proc sub_318C0 far
jmp	sub_3FBE0	; Jump
endp sub_318C0



; Attributes: thunk

proc sub_318C5 far
jmp	sub_3F7D8	; Jump
endp sub_318C5



; Attributes: noreturn thunk

proc sub_318CA far	; CODE XREF: _f010309_RUN+A0P
jmp	sub_3DB5F	; Jump
endp sub_318CA



; Attributes: thunk

proc sub_318CF far	; CODE XREF: _f010509_MainMenuScreen:loc_1383DP
			; sub_56450+20P
			; sub_56450+12DP
jmp	sub_43349	; Jump
endp sub_318CF



; Attributes: thunk

proc sub_318D4 far	; CODE XREF: _f010309_RUN:loc_136EDP
jmp	sub_3DBA6	; Jump
endp sub_318D4

; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_HelpEntry_s433B8. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_318DE far	; CODE XREF: _f010509_MainMenuScreen+494P
jmp	sub_43381	; Jump
endp sub_318DE

; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_HelpEntry_s433EB. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_318E8 far
jmp	sub_3EAD2	; Jump
endp sub_318E8

; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_HelpEntry_s43484. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_318F2 far
jmp	sub_430A4	; Jump
endp sub_318F2



; Attributes: thunk

proc sub_318F7 far
jmp	sub_40584	; Jump
endp sub_318F7

; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_HelpEntry_s43451. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_31901 far
jmp	sub_4043A	; Jump
endp sub_31901

; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_HelpEntry_s4341E. PRESS KEYPAD "+" TO EXPAND]
; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_HelpEntry_s434F6. PRESS KEYPAD "+" TO EXPAND]
; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_HelpEntry_s434C3. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_31915 far
jmp	sub_421DA	; Jump
endp sub_31915



; Attributes: thunk

proc sub_3191A far
jmp	sub_4276F	; Jump
endp sub_3191A

; [00000005 BYTES: COLLAPSED FUNCTION filebuf::terminate(void).	PRESS KEYPAD "+" TO EXPAND]
; [00000005 BYTES: COLLAPSED FUNCTION filebuf::terminate(void).	PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_31929 far	; CODE XREF: sub_4D5B0+1C4P
			; sub_4DB4D+4BCP
			; sub_56450+101P
jmp	sub_43572	; Jump
endp sub_31929

ends stub050


; Segment type:	Pure code
segment	stub051	para public 'CODE' use16
assume cs:stub051
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31930  = _stub_descr ptr $
			; DATA XREF: seg038:0256o
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 74C0h		; fileoff
dw 9FBAh		; codesize
dw 15Ah			; relsize
dw 54			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea
; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_Cityname_s4B973. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc j_idk_BuildingWorlds far
			; CODE XREF: sub_3DA30:loc_3DB0EP
jmp	idk_BuildingWorlds ; Jump
endp j_idk_BuildingWorlds



; Attributes: thunk

proc sub_3195A far
jmp	sub_43839	; Jump
endp sub_3195A



; Attributes: thunk

proc sub_3195F far
jmp	sub_438C4	; Jump
endp sub_3195F



; Attributes: thunk

proc sub_31964 far
jmp	sub_43C95	; Jump
endp sub_31964



; Attributes: thunk

proc sub_31969 far
jmp	sub_43E4F	; Jump
endp sub_31969



; Attributes: thunk

proc sub_3196E far
jmp	sub_449D0	; Jump
endp sub_3196E



; Attributes: thunk

proc sub_31973 far
jmp	sub_44A0E	; Jump
endp sub_31973



; Attributes: thunk

proc sub_31978 far
jmp	sub_44CBB	; Jump
endp sub_31978



; Attributes: thunk

proc sub_3197D far
jmp	sub_450F6	; Jump
endp sub_3197D



; Attributes: thunk

proc sub_31982 far
jmp	sub_45389	; Jump
endp sub_31982



; Attributes: thunk

proc sub_31987 far
jmp	sub_45645	; Jump
endp sub_31987



; Attributes: thunk

proc sub_3198C far
jmp	sub_45B42	; Jump
endp sub_3198C



; Attributes: thunk

proc sub_31991 far
jmp	sub_45CDF	; Jump
endp sub_31991



; Attributes: thunk

proc sub_31996 far
jmp	sub_45DC9	; Jump
endp sub_31996



; Attributes: thunk

proc sub_3199B far
jmp	sub_46029	; Jump
endp sub_3199B



; Attributes: thunk

proc sub_319A0 far
jmp	sub_46406	; Jump
endp sub_319A0



; Attributes: thunk

proc sub_319A5 far
jmp	sub_467A7	; Jump
endp sub_319A5



; Attributes: thunk

proc sub_319AA far
jmp	sub_47247	; Jump
endp sub_319AA

; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_Terrtype_s472C7. PRESS KEYPAD "+" TO EXPAND]
; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_Terrtype_s4763F. PRESS KEYPAD "+" TO EXPAND]
; [00000005 BYTES: COLLAPSED FUNCTION j_LBX_Terrtype_s48821. PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_319BE far
jmp	sub_48C63	; Jump
endp sub_319BE



; Attributes: thunk

proc sub_319C3 far
jmp	sub_4910F	; Jump
endp sub_319C3



; Attributes: thunk

proc sub_319C8 far
jmp	sub_4A942	; Jump
endp sub_319C8



; Attributes: thunk

proc sub_319CD far
jmp	sub_4BA53	; Jump
endp sub_319CD



; Attributes: thunk

proc sub_319D2 far
jmp	sub_4BF93	; Jump
endp sub_319D2



; Attributes: thunk

proc sub_319D7 far
jmp	sub_4C37F	; Jump
endp sub_319D7



; Attributes: thunk

proc sub_319DC far
jmp	sub_4BF24	; Jump
endp sub_319DC



; Attributes: thunk

proc sub_319E1 far
jmp	sub_4C3E1	; Jump
endp sub_319E1



; Attributes: thunk

proc sub_319E6 far
jmp	sub_4C46D	; Jump
endp sub_319E6



; Attributes: thunk

proc sub_319EB far
jmp	sub_4C4FA	; Jump
endp sub_319EB



; Attributes: thunk

proc sub_319F0 far
jmp	sub_4C75E	; Jump
endp sub_319F0



; Attributes: thunk

proc sub_319F5 far
jmp	sub_4C79C	; Jump
endp sub_319F5



; Attributes: thunk

proc sub_319FA far
jmp	sub_4CAAF	; Jump
endp sub_319FA



; Attributes: thunk

proc sub_319FF far	; CODE XREF: sub_523A3:loc_523ABP
jmp	sub_4CAF3	; Jump
endp sub_319FF



; Attributes: thunk

proc sub_31A04 far
jmp	sub_4CB55	; Jump
endp sub_31A04



; Attributes: thunk

proc sub_31A09 far
jmp	sub_4CE35	; Jump
endp sub_31A09



; Attributes: thunk

proc sub_31A0E far
jmp	sub_4CF1C	; Jump
endp sub_31A0E



; Attributes: thunk

proc sub_31A13 far
jmp	sub_4CF8C	; Jump
endp sub_31A13



; Attributes: thunk

proc sub_31A18 far
jmp	sub_4CFE8	; Jump
endp sub_31A18



; Attributes: thunk

proc sub_31A1D far
jmp	sub_4D076	; Jump
endp sub_31A1D



; Attributes: thunk

proc sub_31A22 far
jmp	sub_4D0DF	; Jump
endp sub_31A22



; Attributes: thunk

proc sub_31A27 far
jmp	sub_4D140	; Jump
endp sub_31A27



; Attributes: thunk

proc sub_31A2C far
jmp	sub_4D1AE	; Jump
endp sub_31A2C



; Attributes: thunk

proc sub_31A31 far
jmp	sub_4D1F9	; Jump
endp sub_31A31



; Attributes: thunk

proc sub_31A36 far
jmp	sub_4D244	; Jump
endp sub_31A36



; Attributes: thunk

proc sub_31A3B far
jmp	sub_4D28F	; Jump
endp sub_31A3B



; Attributes: thunk

proc sub_31A40 far
jmp	sub_4D2EC	; Jump
endp sub_31A40



; Attributes: thunk

proc sub_31A45 far
jmp	sub_4D342	; Jump
endp sub_31A45



; Attributes: thunk

proc sub_31A4A far
jmp	sub_4D448	; Jump
endp sub_31A4A



; Attributes: thunk

proc sub_31A4F far
jmp	sub_4D4A9	; Jump
endp sub_31A4F



; Attributes: thunk

proc sub_31A54 far
jmp	sub_4D02B	; Jump
endp sub_31A54



; Attributes: thunk

; filebuf::terminate(void)
proc j_@filebuf@terminate$qv_2 far
jmp	@filebuf@terminate$qv_2	; filebuf::terminate(void)
endp j_@filebuf@terminate$qv_2

ends stub051


; Segment type:	Pure code
segment	stub052	para public 'CODE' use16
assume cs:stub052
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31A60  = _stub_descr ptr $
			; DATA XREF: seg038:025Eo
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 11730h		; fileoff
dw 67h			; codesize
dw 6			; relsize
dw 1			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc sub_31A80 far
jmp	sub_4D540	; Jump
endp sub_31A80

ends stub052


; Segment type:	Pure code
segment	stub053	para public 'CODE' use16
assume cs:stub053
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31A90  = _stub_descr ptr $
			; DATA XREF: seg038:0266o
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 117A0h		; fileoff
dw 2E3Ah		; codesize
dw 382h			; relsize
dw 22			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc sub_31AB0 far
jmp	sub_4D5B0	; Jump
endp sub_31AB0



; Attributes: thunk

proc sub_31AB5 far
jmp	sub_4D7A1	; Jump
endp sub_31AB5



; Attributes: thunk

proc sub_31ABA far
jmp	sub_4D8D2	; Jump
endp sub_31ABA



; Attributes: thunk

proc sub_31ABF far	; CODE XREF: sub_3FBE0+246P
			; sub_4067D+6D4P
			; LBX_NewGame_s41A5F:loc_42165P
jmp	sub_4D8E6	; Jump
endp sub_31ABF



; Attributes: thunk

proc sub_31AC4 far
jmp	sub_4D8FA	; Jump
endp sub_31AC4



; Attributes: thunk

proc sub_31AC9 far
jmp	sub_4DA02	; Jump
endp sub_31AC9



; Attributes: thunk

proc sub_31ACE far
jmp	sub_4DB4D	; Jump
endp sub_31ACE



; Attributes: thunk

proc sub_31AD3 far
jmp	sub_4E031	; Jump
endp sub_31AD3



; Attributes: thunk

proc sub_31AD8 far
jmp	sub_4E751	; Jump
endp sub_31AD8



; Attributes: thunk

proc j_idk_ResourceLbx far
jmp	idk_ResourceLbx	; Jump
endp j_idk_ResourceLbx



; Attributes: thunk

proc sub_31AE2 far
jmp	sub_4E9F4	; Jump
endp sub_31AE2



; Attributes: thunk

proc sub_31AE7 far
jmp	sub_4EC17	; Jump
endp sub_31AE7



; Attributes: thunk

proc sub_31AEC far
jmp	sub_4EF74	; Jump
endp sub_31AEC



; Attributes: thunk

proc sub_31AF1 far
jmp	sub_4F1AB	; Jump
endp sub_31AF1



; Attributes: thunk

proc sub_31AF6 far
jmp	sub_4F417	; Jump
endp sub_31AF6



; Attributes: thunk

proc sub_31AFB far
jmp	sub_4F44D	; Jump
endp sub_31AFB



; Attributes: thunk

proc sub_31B00 far
jmp	sub_4F7B3	; Jump
endp sub_31B00



; Attributes: thunk

proc sub_31B05 far
jmp	sub_4F808	; Jump
endp sub_31B05



; Attributes: thunk

proc sub_31B0A far
jmp	sub_50203	; Jump
endp sub_31B0A



; Attributes: thunk

proc sub_31B0F far
jmp	sub_5034B	; Jump
endp sub_31B0F



; Attributes: thunk

proc sub_31B14 far
jmp	sub_50356	; Jump
endp sub_31B14



; Attributes: thunk

proc sub_31B19 far
jmp	sub_503A0	; Jump
endp sub_31B19

ends stub053


; Segment type:	Pure code
segment	stub054	para public 'CODE' use16
assume cs:stub054
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31B20  = _stub_descr ptr $
			; DATA XREF: seg038:026Eo
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 14980h		; fileoff
dw 14E9h		; codesize
dw 2			; relsize
dw 5			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc sub_31B40 far	; CODE XREF: sub_518E0:loc_51AC5P
			; sub_518E0+3F5P
			; sub_518E0+61FP
			; sub_518E0+846P
jmp	sub_503F0	; Jump
endp sub_31B40



; Attributes: thunk

proc sub_31B45 far
jmp	sub_50B16	; Jump
endp sub_31B45



; Attributes: thunk

proc sub_31B4A far
jmp	sub_50E46	; Jump
endp sub_31B4A



; Attributes: thunk

proc sub_31B4F far
jmp	sub_510F4	; Jump
endp sub_31B4F



; Attributes: thunk

proc sub_31B54 far
jmp	sub_5173F	; Jump
endp sub_31B54

ends stub054


; Segment type:	Pure code
segment	stub055	para public 'CODE' use16
assume cs:stub055
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31B60  = _stub_descr ptr $
			; DATA XREF: seg038:0276o
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 15E80h		; fileoff
dw 0A00h		; codesize
dw 8			; relsize
dw 1			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc sub_31B80 far	; CODE XREF: sub_4BF24+34P
			; sub_4BF24:loc_4BF88P
jmp	sub_518E0	; Jump
endp sub_31B80

ends stub055


; Segment type:	Pure code
segment	stub056	para public 'CODE' use16
assume cs:stub056
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31B90  = _stub_descr ptr $
			; DATA XREF: seg038:off_3173Eo
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 16890h		; fileoff
dw 30CAh		; codesize
dw 3Eh			; relsize
dw 17			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc sub_31BB0 far	; CODE XREF: idk_BuildingWorlds+91P
jmp	sub_522E0	; Jump
endp sub_31BB0



; Attributes: thunk

proc sub_31BB5 far	; CODE XREF: sub_3DA30+E8P
jmp	sub_523A3	; Jump
endp sub_31BB5



; Attributes: thunk

proc sub_31BBA far
jmp	sub_5266E	; Jump
endp sub_31BBA



; Attributes: thunk

proc sub_31BBF far
jmp	sub_526A6	; Jump
endp sub_31BBF



; Attributes: thunk

proc sub_31BC4 far
jmp	sub_52792	; Jump
endp sub_31BC4



; Attributes: thunk

proc sub_31BC9 far
jmp	sub_52C4D	; Jump
endp sub_31BC9



; Attributes: thunk

proc sub_31BCE far
jmp	sub_52CE7	; Jump
endp sub_31BCE



; Attributes: thunk

proc sub_31BD3 far
jmp	sub_5301E	; Jump
endp sub_31BD3



; Attributes: thunk

proc sub_31BD8 far
jmp	sub_53A06	; Jump
endp sub_31BD8



; Attributes: thunk

proc sub_31BDD far	; CODE XREF: sub_3DA30+E3P
jmp	sub_5468B	; Jump
endp sub_31BDD



; Attributes: thunk

proc sub_31BE2 far
jmp	sub_5474D	; Jump
endp sub_31BE2



; Attributes: thunk

proc sub_31BE7 far
jmp	sub_54DC9	; Jump
endp sub_31BE7



; Attributes: thunk

proc sub_31BEC far
jmp	sub_54E00	; Jump
endp sub_31BEC



; Attributes: thunk

proc sub_31BF1 far
jmp	sub_54E71	; Jump
endp sub_31BF1



; Attributes: thunk

proc sub_31BF6 far
jmp	sub_552B3	; Jump
endp sub_31BF6



; Attributes: thunk

proc sub_31BFB far
jmp	sub_5244A	; Jump
endp sub_31BFB



; Attributes: thunk

proc sub_31C00 far
jmp	sub_55315	; Jump
endp sub_31C00

ends stub056


; Segment type:	Pure code
segment	stub057	para public 'CODE' use16
assume cs:stub057
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31C10  = _stub_descr ptr $
			; DATA XREF: seg038:0286o
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 199C0h		; fileoff
dw 422h			; codesize
dw 96h			; relsize
dw 1			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea
; [00000005 BYTES: COLLAPSED FUNCTION j_idk_Ems_TileFigureCont_s553B0. PRESS KEYPAD "+"	TO EXPAND]

; Segment type:	Pure code
segment	stub058	para public 'CODE' use16
assume cs:stub058
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31C40  = _stub_descr ptr $
			; DATA XREF: seg038:028Eo
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 19E80h		; fileoff
dw 4B5h			; codesize
dw 7Eh			; relsize
dw 6			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc j_ST_LoadMusicSoundfxIntro	far
			; CODE XREF: _f010109_main:loc_13530P
jmp	ST_LoadMusicSoundfxIntro ; Jump
endp j_ST_LoadMusicSoundfxIntro



; Attributes: thunk

proc sub_31C65 far
jmp	sub_55B7F	; Jump
endp sub_31C65



; Attributes: thunk

proc sub_31C6A far
jmp	sub_55BEF	; Jump
endp sub_31C6A



; Attributes: thunk

proc sub_31C6F far
jmp	sub_55BB7	; Jump
endp sub_31C6F



; Attributes: thunk

proc sub_31C74 far
jmp	sub_55C27	; Jump
endp sub_31C74



; Attributes: thunk

proc sub_31C79 far
jmp	sub_55C5E	; Jump
endp sub_31C79

ends stub058


; Segment type:	Pure code
segment	stub059	para public 'CODE' use16
assume cs:stub059
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31C80  = _stub_descr ptr $
			; DATA XREF: seg038:0296o
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 1A3C0h		; fileoff
dw 599h			; codesize
dw 62h			; relsize
dw 3			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea
; [00000005 BYTES: COLLAPSED FUNCTION j_idk_OVR_LoadLbxHelp. PRESS KEYPAD "+" TO EXPAND]
; [00000005 BYTES: COLLAPSED FUNCTION filebuf::terminate(void).	PRESS KEYPAD "+" TO EXPAND]


; Attributes: thunk

proc sub_31CAA far	; CODE XREF: sub_50356+4P
			; sub_503A0+4P
jmp	sub_56220	; Jump
endp sub_31CAA

ends stub059


; Segment type:	Pure code
segment	stub060	para public 'CODE' use16
assume cs:stub060
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31CB0  = _stub_descr ptr $
			; DATA XREF: seg038:029Eo
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 1A9C0h		; fileoff
dw 20Ah			; codesize
dw 16h			; relsize
dw 2			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc sub_31CD0 far	; CODE XREF: _f010609_DrawMainMenuScreen+8DP
jmp	sub_56240	; Jump
endp sub_31CD0



; Attributes: thunk

proc j_sub_56413 far	; CODE XREF: _f010109_main+33BP
			; _f010309_RUN+C6P
jmp	sub_56413	; Jump
endp j_sub_56413

ends stub060


; Segment type:	Pure code
segment	stub061	para public 'CODE' use16
assume cs:stub061
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
stru_31CE0  = _stub_descr ptr $
			; DATA XREF: seg038:02A6o
db 0CDh, 3Fh		; int_code
dw 0			; memswap
dd 1ABE0h		; fileoff
dw 436h			; codesize
dw 90h			; relsize
dw 2			; nentries
dw 0			; prevstub
db 10h dup(0)		; workarea


; Attributes: thunk

proc j_idk_HoF_s565F2 far
jmp	idk_HoF_s565F2	; Jump
endp j_idk_HoF_s565F2



; Attributes: thunk

proc j_s56450 far	; CODE XREF: _f010309_RUN:loc_13700P
jmp	sub_56450	; Jump
endp j_s56450

ends stub061


; Segment type:	Pure data
segment	dseg para public 'DATA' use16
assume cs:dseg
LibMalloc_w31D10 dw 0	; DATA XREF: sub_113A6+20r
			; sub_113A6:loc_11401r
			; sub_113A6+67r
			; LibMalloc_s114A0+54w
			; LibMalloc_s11504+2Fw
			; LibMalloc_s1155E+2w
			; LibMalloc_s1155E+6r
			; LibMalloc_s1155E+Cw
			; LibMalloc_s1155E+15r
			; _farmalloc+42r
			; LibMalloc_FarReAlloc_s115FE+20r
			; idk_MemAndVid_s1E0DA+Er
			; sub_1EA9E+Er
			; sub_226C2:loc_226D0r
			; sub_22DC6:loc_22DD4r
			; sub_230E7+Er
			; sub_23129:loc_2313Dr
			; sub_23160:loc_2317Fr
			; seg038:02AEo
LibMalloc_w31D12 dw 0	; DATA XREF: LibMalloc_s11343+9r
			; LibMalloc_s11343+Dr
			; sub_113A6+3r
			; sub_113A6+7w
			; sub_113A6+53r
			; LibMalloc_s114A0+58w
			; LibMalloc_s11504+33w
			; LibMalloc_s1155E+Fw
			; LibMalloc_s1155E+1Bw
			; _farmalloc+6Dw
			; sub_230E7+12r
			; sub_23129+17r
			; sub_23160+22r
			; sub_23243:loc_232AFr
			; sub_232ED+86r
			; OVR_SetOvrMgrIntVec:loc_30CD5w
LibMalloc_w31D14 dw 6F42h
			; DATA XREF: LibMalloc_s11417+Cr
			; sub_11440+18w
			; sub_11440+2Ew
			; _farmalloc+71o
			; OVR_SetOvrMgrIntVec+27w
LibMalloc_w31D16 dw 6C72h
			; DATA XREF: LibMalloc_s11417+2r
			; LibMalloc_s11417+8r
			; LibMalloc_s11417+10w
			; sub_11440+24w
			; sub_11440+32w
			; _farmalloc+48r
			; OVR_SetOvrMgrIntVec+48r
			; fncCheckDOSVersion:loc_30D3Bw
LibMalloc_w31D18 dw 6E61h
			; DATA XREF: LibMalloc_s11343+24r
			; sub_113A6+Dw
			; _farmalloc+69r
			; sub_22F25:loc_22F80r
byte_31D1A db 64h	; DATA XREF: idk_Font_s1CB05:loc_1CB1Ar
byte_31D1B db 20h	; DATA XREF: idk_Font_s1CB05+7Cr
			; idk_Font_s1CB05+85r
word_31D1C dw 2B43h	; DATA XREF: idk_Font_s1CB05:loc_1CB75r
			; sub_30FD8+44r
idk_OVR_w31D1E dw 202Bh	; DATA XREF: sub_30E8D+A1w
			; CHUNK_OverlayHalt+28w
			; sub_31256+30w
word_31D20 dw 202Dh	; DATA XREF: sub_1A3AF+2Er
			; idk_PalFnt_s1AB64+DFr
			; sub_31191+Cr
CopyRight db 'Copyright 1991 Borland Intl.',0
			; DATA XREF: OVR_SetOvrMgrIntVec:loc_30CF4o
			; OVR_s30D27+1o
			; fncCheckDOSVersion+25o
			; OVR_s30D78+2Bo
			; OVR_s30DD5:loc_30DECo
NullCheck db 'Null pointer assignment',0Dh,0Ah
			; DATA XREF: __checknull+1Fo
ZeroDivMSG db 'Divide error',0Dh,0Ah
			; DATA XREF: sub_1A3AF+34r
			; sub_1ACAA+3Er
			; sub_1AD1E+3Er
			; sub_1AD92+56r
abortMSG db 'Abnormal program termination',0Dh,0Ah
			; DATA XREF: STARTX+2B0o
_Int0Vector@ dd	 0	; DATA XREF: SaveVectors+6w
			; __restorezero+4r
			; SaveVectors+Aw
_Int4Vector@ dd	 0	; DATA XREF: SaveVectors+13w
			; __restorezero+Fr
			; SaveVectors+17w
_Int5Vector@ dd	 0	; DATA XREF: SaveVectors:loc_101D0w
			; __restorezero+1Ar
			; SaveVectors+24w
_Int6Vector@ dd	 0	; DATA XREF: SaveVectors+2Dw
			; __restorezero+25r
			; SaveVectors+31w
; int argc
argc dw	0		; DATA XREF: STARTX+154r
			; seg000:1CDDw
; char **argv
argv dw	0		; DATA XREF: STARTX+150r
			; seg000:1CE3w
envp dw	0		; DATA XREF: STARTX+14Cr
			; unknown_libname_2+59w
; size_t envLng
_envLng@ dw 0		; DATA XREF: STARTX+46w
			; seg000:1BFEr
			; unknown_libname_2+2r
_envseg@ dw 0		; DATA XREF: STARTX+1Dw
			; STARTX+28r
			; __exec+Br
			; seg000:1C0Er
			; unknown_libname_2+16r
			; fncCheckDOSVersion+13r
			; OVR_s30D78+6r
; size_t envSize
_envSize@ dw 0		; DATA XREF: STARTX+55w
			; unknown_libname_2+23r
; unsigned int psp
_psp@ dw 0		; DATA XREF: STARTX+19w
			; STARTX+ABr
			; __exec:CopyCmdLiner
			; idk_InBrkSbrk+8r
			; idk_InBrkSbrk+35r
			; idk_InBrkSbrk+3Fr
			; idk_InBrkSbrk+44r
			; idk_InBrkSbrk:loc_117B9r
			; seg000:1BEDr
			; __InitModules+5r
_version@ db 0		; DATA XREF: STARTX+16w
			; STARTX+D9r
			; seg000:1C07r
_osminor@ db 0		; DATA XREF: STARTX:loc_100E2r
errno dw 0		; DATA XREF: __IOERROR:ser_endw
			; ___brk:loc_10F1Fw
			; ___sbrk:loc_10F50w
			; __LoadProg+1Fw
			; __LoadProg+37w
			; __LoadProg+57w
_StartTime@ dw	0, 0	; DATA XREF: STARTX:loc_10124w
			; STARTX+128w
__heapbase dw 0AA4Ah	; [edata@] is the ending offset	of the Data Segment
			; AA4Ah	= 43594d
			; IF	  LDATA	EQ false
			; PubSym@	  __heapbase,	  <dw	DGROUP:edata@>,	  __CDECL__
			; ENDIF
__brklvl dw 0AA4Ah	; DATA XREF: ___brk+10w
			; ___sbrk+9r
			; ___sbrk+20w
			; _coreleft+2r
			; IFNDEF __HUGE__
			; PubSym@	  __brklvl,	  <dw	DGROUP:edata@>,	  __CDECL__
			; ENDIF
_heapbase@ dd 0		; DATA XREF: __brk+7r
			; __sbrk+4Br
			; _f010109_main+8o
			; STARTX+A3w
			; __brk+3r
			; __sbrk+47r
			; idk_OVR_s31223+26r
_brklvl@ dd 0		; DATA XREF: idk_InBrkSbrk+22w
			; __sbrk+10r
			; __sbrk+35r
			; __sbrk+6Ar
			; STARTX+A7w
			; idk_InBrkSbrk+1Fw
			; __sbrk+6r
			; __sbrk:loc_1183Er
			; __sbrk+67r
			; __InitModules+51r
_heaptop@ dd 0		; DATA XREF: idk_InBrkSbrk+69w
			; __brk+1Ar
			; __sbrk+58r
			; __InitModules+54r
			; STARTX+21w
			; STARTX+107w
			; idk_InBrkSbrk+2Fr
			; idk_InBrkSbrk+66w
			; __brk+16r
			; __sbrk+54r
			; CHUNK_OverlayHalt+54r
idk_InitMod_w31DBA db  69h ; i
			; DATA XREF: __InitModules+7Bw
			; idk_HoF_s565F2+1FAo
db  6Ah	; j
idk_OVR_dw31DBC	dd 496D6C6Bh
			; DATA XREF: CHUNK_OverlayHaltw
word_31DC0 dw 4B4Ah	; DATA XREF: sub_30E8D+52w
			; idk_OVR_s310CC+42r
			; sub_311A9+17w
			; sub_311A9+2Aw
			; sub_311A9+37w
			; sub_31256r
			; idk_OVR_s312A7+3w
			; idk_OVR_s312F7+Dr
			; idk_OVR_s312F7+16r
word_31DC2 dw 4D4Ch	; DATA XREF: sub_30E8Dr
word_31DC4 dw 7A79h	; DATA XREF: sub_30E8D+Ar
			; sub_30E8D+56r
			; sub_311A9+34r
word_31DC6 dw 7C7Bh	; DATA XREF: sub_30E8D+Er
			; sub_311A9+14r
			; idk_OVR_s312F7:loc_3130Ar
OVR_FileHandle dw 0C97Dh
			; DATA XREF: OVR_SetOvrMgrIntVec+2Br
			; OVR_SetOvrMgrIntVec+32r
			; OVR_SetOvrMgrIntVec+3Aw
			; OVR_SetOvrMgrIntVec+4Dw
			; sub_30F5A+1r
word_31DCA dw 0CBA5h	; DATA XREF: idk_OVR_s310CC+1w
word_31DCC dw 2DA6h	; DATA XREF: sub_30E8D+4w
			; sub_30E8D+6Cr
			; sub_30E8D+7Fr
			; idk_OVR_s310CC:loc_310DDr
			; idk_OVR_s310CC+19w
			; CHUNK_OverlayHalt+49r
			; sub_311A9r
			; sub_311A9+11w
			; sub_311A9+1Cr
			; sub_311A9+23w
			; idk_OVR_s312F7r
db 0A0h	; 
db 0A1h	; 
idk_InitMod_SI_u31DD0 db '01234b{+2',0
			; DATA XREF: __InitModules+19o
db 0A5h	; 
db    0
db 0CBh	; 
db    0
db  79h	; y
db    0
db  7Ah	; z
db    0
db  7Bh	; {
db    0
db  0Dh
AbortMSG db    0
unk_31DEC db  0Eh
db    0
db  0Fh
unk_31DEF db	0
unk_31DF0 db  49h ; I
db    0
db  4Ah	; J
unk_31DF3 db	0
db  4Bh	; K
unk_31DF5 db	0
db  69h	; i
unk_31DF7 db	0
unk_31DF8 db  6Ah ; j
db    0
db  6Bh	; k
unk_31DFB db	0
db    0
unk_31DFD db	0
db  70h	; p
db  20h
unk_31E00 db  78h ; x
unk_31E01 db  20h
db  7Fh	; 
db  20h
db  87h	; 
db  20h
unk_31E06 db  8Ch ; 	; DATA XREF: idk_HoF_s565F2+17o
db  20h
db  91h	; 
db  20h
db  99h	; 
db  20h
db 0AAh	; 
db  20h
db 0B5h	; 
db  20h
db 0C4h	; 
db  20h
db 0D0h	; 
db  20h
db 0D9h	; 
db  20h
db 0E6h	; 
db  20h
db  8Ch	; 
db    0
align 4
db  82h	; 
db    0
unk_31E1E db	5
unk_31E1F db	0
db  78h	; x
db    0
db  0Ah
db    0
unk_31E24 db  6Eh ; n
unk_31E25 db	0
db  0Fh
db    0
db  64h	; d
db    0
db  14h
db    0
unk_31E2C db  5Ah ; Z
db    0
unk_31E2E db  19h
db    0
unk_31E30 db  50h ; P
db    0
db  1Eh
db    0
db  46h	; F
db    0
unk_31E36 db  23h ; #
db    0
db  3Ch	; <
db    0
db  28h	; (
db    0
db  32h	; 2
db    0
db  2Dh	; -
db    0
unk_31E40 db  28h ; (
db    0
db  32h	; 2
db    0
db 0F6h	; 
unk_31E45 db  20h
unk_31E46 db	3
db  21h	; !
unk_31E48 db 0D9h ; 
db  20h
db  0Eh
db  21h	; !
db  1Ch
db  21h	; !
unk_31E4E db  29h ; )
unk_31E4F db  21h ; !
db  34h	; 4
db  21h	; !
unk_31E52 db  44h ; D
db  21h	; !
unk_31E54 db  4Bh ; K
unk_31E55 db  21h ; !
db  52h	; R
unk_31E57 db  21h ; !
db  5Eh	; ^
db  21h	; !
db  6Bh	; k
db  21h	; !
db  76h	; v
db  21h	; !
unk_31E5E db  80h ; 
db  21h	; !
unk_31E60 db  8Bh ; 
db  21h	; !
db 0AAh	; 
db  20h
db  98h	; 
db  21h	; !
unk_31E66 db 0A7h ; 
db  21h	; !
db 0B7h	; 
db  21h	; !
unk_31E6A db 0C4h ; 
db  21h	; !
db 0C4h	; 
db  20h
db 0CFh	; 
db  21h	; !
db 0DEh	; 
db  21h	; !
db 0EBh	; 
db  21h	; !
db 0E6h	; 
unk_31E75 db  20h
unk_31E76 db 0FCh ; 
db  21h	; !
unk_31E78 db	2
db    0
db    2
db    0
db    0
db    0
db    1
db    0
unk_31E80 db	1
db    0
unk_31E82 db	3
db    0
db  0Ah
db    0
db    1
unk_31E87 db	0
db    1
db    0
db    1
db    0
db    5
db    0
unk_31E8E db	1
db    0
db    5
db    0
db    1
db    0
db    1
db    0
unk_31E96 db  0Ah
db    0
db  0Ah
db    0
db    3
db    0
db    1
db    0
db    5
db    0
unk_31EA0 db	2
db    0
db    1
db    0
db    2
db    0
db    1
db    0
db    2
db    0
db    1
db    0
db    4
db    0
db    1
db    0
unk_31EB0 db	5
db    0
unk_31EB2 db	2
db    0
db    2
db    0
db    5
db    0
db    2
db    0
db  0Ah
db    0
db    0
db    0
unk_31EBE db	4
db    0
db    2
db    0
db    5
db    0
db    3
db    0
db    5
unk_31EC7 db	0
db  19h
db    0
db    5
db    0
unk_31ECC db	5
db    0
unk_31ECE db	5
unk_31ECF db	0
unk_31ED0 db	5
db    0
db    5
db    0
db    1
db    0
db    5
db    0
db    8
db    0
db    3
db    0
db    2
db    0
db    2
db    0
unk_31EE0 db	5
db    0
unk_31EE2 db	2
db    0
unk_31EE4 db	8
unk_31EE5 db	0
db    5
db    0
db    5
db    0
db    0
db    0
db  0Fh
db    0
unk_31EEE db  0Ah
db    0
db  28h	; (
db    0
db    5
db    0
db    5
db    0
db  32h	; 2
unk_31EF7 db	0
db 0C8h	; 
db    0
db    7
db    0
unk_31EFC db  0Ah
db    0
unk_31EFE db  0Ah
db    0
unk_31F00 db  28h ; (
db    0
db  0Fh
db    0
db  14h
db    0
db  0Ah
db    0
unk_31F08 db  28h ; (
db    0
db  0Ah
db    0
unk_31F0C db  0Ah
db    0
db  0Ah
db    0
unk_31F10 db	3
db    0
db  0Ah
db    0
db    5
db    0
db  0Ah
db    0
db    3
db    0
db    3
db    0
db    7
db  22h	; "
db    5
db    0
db 0FFh
db    0
db    0
db    4
unk_31F24 db  0Ah
unk_31F25 db	4
db  64h	; d
unk_31F27 db	0
db    2
db    4
db  0Ah
db    0
db    0
db    0
unk_31F2E db  0Ah
db    1
unk_31F30 db	0
db    1
db    0
db    0
db  41h	; A
db    0
db    0
db    0
db    0
db    0
db    0
unk_31F3B db	0
db    0
db    0
unk_31F3E db	0
db    0
db  0Dh
db  22h	; "
db    5
db    3
db  64h	; d
db    0
db    0
db    3
unk_31F48 db	6
db    4
db  64h	; d
db    0
unk_31F4C db	2
db    0
db  11h
db    0
db    1
db    0
db    9
db    1
unk_31F54 db	0
unk_31F55 db	1
db    0
unk_31F57 db	0
db    1
db    0
db    0
db    0
db    0
db    0
unk_31F5E db	0
db    0
db    0
db    0
db    0
db    0
db  17h
db  22h	; "
db    1
db    6
idk_Dseg_RepMovSw_CX db	 20h
			; DATA XREF: idk_Dseg_RepMovSw+11o
db    0
db    0
db    4
db    6
db    4
unk_31F6E db  64h ; d
db    0
db    2
db    8
db  1Ch
db    3
db    2
db    0
db    5
db    1
unk_31F78 db	0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  1Ch
db  22h	; "
db    4
db    4
unk_31F8C db  14h
db    8
unk_31F8E db	0
db    4
db    6
db    4
db  64h	; d
db    0
db    2
db    8
db    2
db    1
db    3
db    0
db    6
db    1
db    0
db    1
unk_31F9E db	0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  24h	; $
db  22h	; "
db    5
db    0
unk_31FB0 db 0FFh
db    0
db    0
db    4
db    6
db    4
db  64h	; d
db    0
db    2
db    1
db  12h
db    0
db    4
db    0
db    7
db    3
db    0
db    1
db    0
db    0
db  21h	; !
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_31FCC db	0
db    0
unk_31FCE db	0
db    0
db  30h	; 0
db  22h	; "
db    4
db    0
unk_31FD4 db 0FFh
unk_31FD5 db	0
db    0
db    5
db    6
db    4
db  64h	; d
db    0
db    2
db    8
unk_31FDE db  16h
db    0
unk_31FE0 db	5
db    0
db    6
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  35h	; 5
db  22h	; "
db    6
db    3
unk_31FF8 db  64h ; d
db    0
db    0
db    4
unk_31FFC db	6
db    4
unk_31FFE db  64h ; d
db    0
db    2
db  0Ch
db    6
db    0
unk_32004 db	6
unk_32005 db	0
db    8
db    1
db    0
db    1
db    0
db    0
db  41h	; A
db    0
unk_3200E db	0
db    0
unk_32010 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  41h	; A
db  22h	; "
db    3
db    6
db  23h	; #
db    0
db    0
db    5
unk_32020 db	7
db    4
db  64h	; d
db    0
db    2
db    8
db  1Eh
db    0
unk_32028 db	7
db    0
db    5
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  10h
db    0
db    0
db    0
db    0
db    0
unk_3203C db  48h ; H
db  22h	; "
db    5
db    4
db  14h
db    8
db    0
db    3
unk_32044 db	6
unk_32045 db	4
db  64h	; d
db    0
db    2
db    8
db  1Fh
db    1
db    8
db    0
unk_3204E db	7
db    1
unk_32050 db	0
db    1
db    0
db    0
db  60h	; `
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  51h	; Q
db  22h	; "
db    5
db    0
db 0FFh
db    0
db    0
db    5
unk_32068 db	6
db    4
db  64h	; d
db    0
unk_3206C db	2
db    8
db  20h
db    0
db    9
db    0
db    7
db    1
unk_32074 db	0
unk_32075 db	1
db    0
db    0
db    1
db    0
db    0
db    0
unk_3207C db	0
db    0
unk_3207E db	0
db    0
db    0
db    0
db    0
db    0
db  57h	; W
db  22h	; "
db    1
db    8
db  26h	; &
db    0
db    0
db    5
db    6
db    4
db  96h	; 
db    0
db    3
db    8
db  0Ch
db    3
db  0Ah
db    0
db    5
db    3
unk_32098 db	0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db  40h	; @
unk_320A4 db	0
unk_320A5 db	0
db    0
db    0
db  5Dh	; ]
db  22h	; "
db    6
db    0
unk_320AC db 0FFh
db    0
unk_320AE db	0
db    5
db    6
db    4
db  96h	; 
db    0
db    3
db    8
db  14h
db    0
db  0Bh
db    0
db    6
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_320C8 db	0
db    0
db    0
db    0
db  66h	; f
db  22h	; "
db    4
db    4
db  1Fh
db    0
db    0
db    4
unk_320D4 db	6
unk_320D5 db	4
db  96h	; 
db    0
db    3
db    8
db  1Ah
db    2
db  0Ch
db    0
unk_320DE db	7
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_320EC db	0
db    0
unk_320EE db	0
db    0
db  73h	; s
db  22h	; "
db    1
db    8
db  1Fh
unk_320F5 db	0
db    0
db    5
unk_320F8 db  0Ah
db    4
db  96h	; 
db    0
unk_320FC db	3
db    8
db  0Fh
db    3
unk_32100 db  0Dh
db    0
db    5
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  7Ch	; |
db  22h	; "
db    3
db    0
db 0FFh
db    0
db    0
db    5
unk_3211C db	6
db    4
unk_3211E db  96h ; 
db    0
db    3
db    8
db  21h	; !
db    0
db  0Eh
db    0
db    6
db    1
db    0
db    1
db    0
db    5
db    1
db    0
db    0
db    0
unk_32130 db	0
db    0
db    0
db    0
db    4
db    0
db    0
db    0
db  85h	; 
db  22h	; "
db    1
db    6
unk_3213C db  22h ; "
db    0
db    0
db    5
db    6
db    4
db 0C8h	; 
db    0
db    4
db    8
db  13h
db    3
db  0Fh
db    0
db    5
db    1
unk_3214C db	0
db    1
unk_3214E db	0
db    0
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db  10h
db    0
db    0
db    0
db    0
db  8Fh	; 
db  22h	; "
db    6
db    5
db  14h
db    8
db    0
db    5
db    6
db    4
db 0C8h	; 
db    0
db    4
db    8
db  19h
db    1
unk_3216C db  10h
db    0
db    8
db    2
db    0
db    1
db    0
db    0
db  61h	; a
db    0
db    0
db    0
db    0
db    0
db    0
db    0
maybe_w3217C dw	0	; DATA XREF: ILSe_RndCopySeed_s1CC59+Cr
maybe_w3217E dw	0	; DATA XREF: ILSe_RndCopySeed_s1CC59+13r
db  96h	; 
db  22h	; "
db    7
db    5
db  65h	; e
db    0
db    0
db    5
db    6
db    6
db 0C8h	; 
db    0
db    4
db    3
db    1
db    0
db  11h
db    0
db    8
db    1
db    0
db    1
db    0
db    0
db    8
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0A0h	; 
db  22h	; "
db    1
db    8
db  1Fh
db    0
db    0
db    5
db    6
db    4
db 0C8h	; 
db    0
db    4
db    8
db    3
db    3
db  12h
db    0
db    5
db    1
db    0
db    1
db    0
db    0
unk_321BC db	1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0A6h	; 
db  22h	; "
db    6
db    6
db  1Fh
db    0
db    0
db    6
db    6
db    4
db 0C8h	; 
db    0
db    4
db    8
db  22h	; "
db    0
db  13h
db    0
db    6
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_321EC db 0B1h ; 
db  22h	; "
db    6
unk_321EF db	0
db 0FFh
db    0
db    0
db    5
db    6
db    4
db  2Ch	; ,
db    1
db    6
db    8
db  1Dh
db    0
db  14h
db    0
db    7
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  40h	; @
db    0
db    0
db    0
db    0
db    0
db 0B7h	; 
db  22h	; "
db    7
db    0
db 0FFh
db    0
db    0
db    5
db    6
db    4
db  2Ch	; ,
db    1
unk_3221C db	6
db    8
db    8
unk_3221F db	0
db  15h
db    0
db    8
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
unk_3222D db	0
db    0
db    0
unk_32230 db	0
db    0
db    0
db    0
db 0BDh	; 
db  22h	; "
db    7
db    4
db  64h	; d
db    0
db    0
db    4
db    6
db    4
db  2Ch	; ,
db    1
db    6
db    8
db  0Dh
db    0
db  16h
db    0
db    8
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_32255 db	0
db    0
db    0
db 0C4h	; 
db  22h	; "
db    1
db    8
unk_3225C db  1Eh
db    0
db    0
unk_3225F db	5
unk_32260 db  0Ah
db    4
db  2Ch	; ,
db    1
db    6
db    8
db  15h
db    3
db  17h
db    0
db    5
db    1
unk_3226C db	0
db    1
db    0
db    0
db    1
db    0
db    4
db    0
db    0
unk_32275 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db 0CCh	; 
db  22h	; "
db    5
db    5
db  1Fh
db    0
db    0
db    4
db  0Ah
db    4
db  2Ch	; ,
db    1
db    6
db    8
db    5
db    2
unk_3228C db  18h
db    0
db    8
db    1
unk_32290 db	0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3229C db	0
db    0
db    0
db    0
db 0D4h	; 
db  22h	; "
db    1
db    5
db  20h
db    0
db    0
db    4
unk_322A8 db	6
db    4
db 0F4h	; 
db    1
db  0Ah
db    8
db  18h
db    3
db  19h
db    0
db    5
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    4
db    0
unk_322BC db	0
db    0
db    0
db    0
db  40h	; @
db    0
db    0
db    0
db 0E0h	; 
db  22h	; "
db    6
db    0
db 0FFh
db    0
db    0
db    5
db    6
db    4
db 0F4h	; 
db    1
db  0Ah
db    8
db    7
db    0
db  1Ah
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
unk_322DC db	1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0EAh	; 
db  22h	; "
db    2
db    8
unk_322EC db  23h ; #
db    0
db    0
unk_322EF db	5
unk_322F0 db	6
db    4
db 0F4h	; 
db    1
db  0Ah
db    8
db  17h
db    3
db  1Bh
db    0
db    5
db    1
unk_322FC db	0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  10h
db  40h	; @
db    0
db    0
db    0
db    0
db 0F4h	; 
db  22h	; "
db    9
db    0
db 0FFh
db    0
db    0
db    5
db    6
db    4
db 0F4h	; 
db    1
db  0Ah
db    8
db  0Eh
db    0
db  1Ch
db    0
db    8
db    1
unk_32320 db	0
db    1
db    0
db    0
db    1
db    0
db  20h
db    0
db    0
db    0
db  10h
db    0
db    3
db    0
db    0
db    0
unk_32330 db 0FCh ; 
db  22h	; "
db    9
db    0
db 0FFh
db    0
db    0
db    5
db    6
db    4
db 0F4h	; 
db    1
db  0Ah
db    8
db  10h
unk_3233F db	0
db  1Dh
db    0
db  0Ah
db    1
unk_32344 db	0
db    1
db    0
db    0
db    1
db    0
db  20h
db    0
db    0
db    0
db    0
unk_3234F db	0
unk_32350 db	3
db    0
db    0
db    0
db    9
db  23h	; #
db    5
db    8
db  14h
db    8
db    0
db    6
db    6
db    4
db 0F4h	; 
db    1
unk_32360 db  0Ah
db    7
db  1Bh
db    1
db  1Eh
db    0
db    6
db    1
db    0
db    1
db    0
db    0
db  21h	; !
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
db  23h	; #
db    8
db    0
db 0FFh
db    0
db    0
db    5
db    6
db    4
db 0F4h	; 
db    1
db  0Ah
db    8
unk_32386 db	9
db    0
db  1Fh
db    0
db    9
db    1
db    0
db    1
db    0
db    0
unk_32390 db	1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_32399 db	0
db    0
db    0
db  16h
db  23h	; #
db    1
db    7
db  21h	; !
db    0
db    0
db    5
db    6
db    4
db 0F4h	; 
db    1
db  0Ah
db    8
db  0Bh
db    3
unk_323AC db  20h
db    0
db    5
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
unk_323BC db	8
db    0
db    0
db    0
db  22h	; "
db  23h	; #
db    8
db    8
db  1Eh
db    0
db    0
db    5
db    9
db    4
db 0F4h	; 
db    1
db  0Ah
db    8
db    4
db    2
db  21h	; !
db    0
db    8
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_323E0 db	1
db    0
db    0
db    0
db  30h	; 0
db  23h	; #
db  0Ch
db    0
db 0FFh
db    0
db    0
db    8
unk_323EC db  0Ch
db    4
db  58h	; X
db    2
db    0
db  13h
db    0
db    0
unk_323F4 db  27h ; '
db    0
db  0Ch
db    1
db    0
db    1
db    0
db    0
db    1
db    0
db  24h	; $
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  37h	; 7
db  23h	; #
db    6
db    0
db 0FFh
db    0
db    0
db    4
db 4
db    4
db  3Ch	; <
db    0
db    2
unk_32415 db  0Eh
db  0Ch
db    0
db    0
db    0
db  0Ah
db    1
db    2
db    1
db    0
db    0
db    2
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  3Fh	; ?
db  23h	; #
db    8
db    2
db  14h
db    8
db    0
db    4
db    6
db    6
db  64h	; d
db    0
db    2
db  0Eh
db  0Dh
db    0
db    0
db    0
db  14h
db    1
unk_32440 db	5
db    1
db    0
db    0
db    2
unk_32445 db	0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_32450 db  46h ; F
db  23h	; #
db    0
db  0Ah
db  0Ah
db  0Ah
db    0
db    2
db    4
db    2
db  64h	; d
db    0
db    2
db  0Eh
db  21h	; !
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    8
unk_3246F db	1
db    0
db    0
db    0
db    0
db  4Fh	; O
db  23h	; #
db  0Ah
db  0Ah
unk_32478 db  0Ah
db  63h	; c
db    0
db    5
db    7
db    8
db 0A0h	; 
db    0
unk_32480 db	2
db  0Eh
db  0Eh
db    3
db    0
unk_32485 db	0
db  1Eh
db    1
db    3
db    1
db    0
db    0
db    2
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    1
db    1
db  64h	; d
db    0
db    0
unk_3249F db	2
db    5
db    2
db  0Fh
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
unk_324B0 db	0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    3
db    1
db  64h	; d
db    0
db    0
db    2
db    5
db    2
db  1Eh
unk_324C7 db	0
db    1
db    0
unk_324CA db	8
db    3
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
unk_324D4 db	0
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
unk_324E0 db  6Ah ; j
db  23h	; #
db    1
db    1
db  14h
db    8
db    0
db    1
db    5
db    2
db  1Eh
db    0
unk_324EC db	1
db    0
db  0Fh
db    3
unk_324F0 db	0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  71h	; q
db  23h	; #
db    4
db    1
db  64h	; d
db    0
db    0
db    2
db    5
db    4
db  3Ch	; <
unk_3250F db	0
unk_32510 db	1
db    0
db    9
db    3
db    0
db    0
db    3
db    1
db    0
db    4
db    0
db    0
unk_3251C db	1
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    2
db    0
db    0
db    0
db  79h	; y
db  23h	; #
db    2
db    2
db  23h	; #
db    4
db    0
unk_3252F db	3
db    7
db    2
db  32h	; 2
db    0
db    1
db    0
db  16h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db  10h
db  40h	; @
db    0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    1
db    5
db    2
db  3Ch	; <
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
unk_32565 db	0
db    0
db  80h	; 
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
unk_3256F db	0
db  89h	; 
db  23h	; #
db    7
db    3
db  64h	; d
db    0
db    0
db    3
db    7
db    2
db  78h	; x
db    0
db    2
db    0
db    6
db    0
db    0
db    0
unk_32582 db	3
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  57h	; W
db  23h	; #
unk_32596 db	2
db    0
db 0FFh
db    0
db    0
db    2
db    5
db    2
db  14h
unk_3259F db	0
db    1
db    1
db    0
db    0
db    0
db    0
db    2
db    1
db    0
db    8
db    0
db    0
unk_325AC db	0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    4
db    0
db 0FFh
db    0
db    0
db    2
db    5
db    2
db  28h	; (
db    0
db    1
db    1
db    3
db    8
db    0
db    0
db    2
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    5
db    0
db 0FFh
db    0
db    0
db    3
db    5
db    2
db  50h	; P
db    0
db    2
db    1
db    4
db    0
unk_325EC db	0
db    0
db    2
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  6Ah	; j
db  23h	; #
db    2
db    1
db  14h
db    8
db    0
db    1
db    5
db    2
db  3Ch	; <
db    0
db    2
db    1
db  0Fh
db    3
db    0
db    0
db    2
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
unk_3261C db	0
db    0
db    0
unk_3261F db	0
db    0
db    0
db    0
db    0
db 0A0h	; 
db  23h	; #
db    4
db    4
db  23h	; #
db    4
db    0
db    4
db    8
db    2
db  96h	; 
db    0
db    3
db    1
db  18h
db    0
db    0
db    0
db    2
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    1
db    0
db  10h
db  40h	; @
db    0
db    0
db    0
db    0
db 0A8h	; 
db  23h	; #
db    2
db    5
db  1Fh
db    4
db    0
unk_3264F db	3
db    9
db    2
db 0B4h	; 
db    0
db    4
db    1
db  15h
db    0
db    0
db    0
db    2
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    4
db  80h	; 
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0B2h	; 
db  23h	; #
db    2
db    0
db 0FFh
db    0
db    0
db    1
db    5
db    2
db  3Ch	; <
db    0
db    2
db    1
db  20h
db    0
db    0
db    0
db    2
db    1
db    0
db    6
db    1
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
unk_3268A db	8
db    0
db    0
db    0
db    0
unk_3268F db	0
db  80h	; 
db  23h	; #
db    1
db    0
db 0FFh
unk_32695 db	0
db    0
db    1
db    5
db    2
db  78h	; x
db    0
unk_3269C db	4
db    1
db    0
db    0
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
unk_326AD db	0
db  20h
db    0
db    0
db    0
db    0
db    0
db 0BCh	; 
db  23h	; #
db    3
db    2
db  14h
db    6
db    0
db    3
db    5
db    4
db  64h	; d
unk_326BF db	0
db    2
db    1
db    9
db    3
db    0
unk_326C5 db	0
db    3
db    1
db    0
db    4
db    0
db    0
unk_326CC db	1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0C5h	; 
db  23h	; #
db    5
db    0
db 0FFh
db    0
db    0
db    3
db    6
db    4
db 0A0h	; 
db    0
db    3
db    1
db  0Ah
db    3
db    0
db    0
db    7
db    2
db    0
db    2
db    0
unk_326EF db	6
db    8
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    4
db    0
db    0
db    0
db 0D0h	; 
db  23h	; #
db  0Ch
db    0
db 0FFh
db    0
unk_32702 db	2
db    4
db    7
db    2
db 0C8h	; 
db    0
db    4
db    1
db    6
db    0
unk_3270C db	0
db    0
db  0Ch
db    1
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
db    0
db    0
db    0
db    0
unk_3271F db	0
db  57h	; W
db  23h	; #
db    1
db    1
db  24h	; $
db    4
db    0
db    2
db    7
db    2
db  19h
db    0
db    1
db    2
db    0
db    0
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  80h	; 
unk_3273C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    3
db    1
db  24h	; $
db    4
db    0
db    2
db    7
db    2
db  32h	; 2
db    0
db    1
db    2
db    3
db    8
db    0
unk_32755 db	0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    4
db    1
unk_3276C db  24h ; $
db    4
db    0
db    3
db    7
db    2
db  64h	; d
db    0
db    2
db    2
db    4
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  71h	; q
db  23h	; #
db    4
db    1
db  24h	; $
db    4
db    0
db    2
db    7
unk_32795 db	4
db  64h	; d
db    0
db    2
db    2
db    3
db    9
unk_3279C db	0
db    0
db    3
db    1
db    0
db    4
db    0
db    0
db    1
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    2
db    0
db    0
db    0
db 0A0h	; 
db  23h	; #
db    3
db    6
db  23h	; #
db    4
db    0
db    4
db  0Ah
db    2
unk_327BA db 0C8h ; 
db    0
db    2
db    2
db  18h
db    0
db    0
db    0
db    1
db    1
db    0
unk_327C5 db	4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    1
db    0
db  10h
db  40h	; @
db    0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    1
db    7
db    2
db  96h	; 
db    0
db    3
db    2
db    0
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db 0DAh	; 
db  23h	; #
db    4
db    0
db 0FFh
db    0
db    0
db    3
db    7
db    2
db  78h	; x
db    0
db    3
db    2
db    5
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    1
unk_32810 db	0
db    0
db    0
db    0
db    0
db    0
db  40h	; @
db    0
db    4
db    0
db    0
db    0
db 0E6h	; 
db  23h	; #
db    1
db    7
db  1Fh
db    4
db    0
db    4
db    9
db    2
db 0F0h	; 
db    0
db    4
db    2
db  15h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    4
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_32840 db 0EFh ; 
db  23h	; #
db    8
db    5
db  24h	; $
unk_32845 db	4
db    0
db    4
db    8
db    6
db 0A0h	; 
db    0
db    4
db    2
db  0Bh
db    3
db    0
db    0
db  0Ah
db    2
db    0
db    2
db    0
db    0
db    8
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    1
db    1
db  65h	; e
db    0
db    0
db    3
db    6
db    4
db  19h
db    0
db    1
db    3
db    0
db    0
db    0
unk_32875 db	0
db    1
db    1
db    0
db    8
db    0
db    0
db    8
db    0
db    0
db  82h	; 
unk_32880 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    3
db    1
db  65h	; e
db    0
db    0
db    3
db    6
db    4
db  32h	; 2
db    0
db    1
db    3
db    3
db    8
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    8
db    0
db    0
db  82h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    4
db    1
db  65h	; e
db    0
db    0
db    4
db    6
unk_328B5 db	4
db  64h	; d
db    0
db    2
db    3
db    4
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    8
db    0
db    0
db  82h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  6Ah	; j
db  23h	; #
db    1
db    1
db  14h
db    8
db    0
db    2
db    6
db    4
db  2Dh	; -
db    0
db    2
db    3
db  0Fh
db    3
db    0
db    0
db    1
db    1
db    0
unk_328E5 db	6
db    0
db    0
db    8
db    0
db    0
db  82h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  79h	; y
db  23h	; #
db    2
db    2
db  23h	; #
db    4
db    0
db    4
db    8
db    4
db  4Bh	; K
db    0
db    2
db    3
db  16h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    8
db    0
db    0
db  82h	; 
db    0
db    0
db  10h
db  40h	; @
db    0
unk_32915 db	0
db    0
db    0
db 0A8h	; 
db  23h	; #
db    1
db    5
db  1Fh
db    4
db    0
db    4
db  0Ah
db    4
db 0B4h	; 
db    0
db    3
db    3
db  15h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    8
db    0
db    4
db  82h	; 
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0B2h	; 
db  23h	; #
db    1
db    1
db  65h	; e
db    0
db    0
db    2
db    6
db    4
db  64h	; d
db    0
db    2
db    3
db  0Ah
db  21h	; !
db    0
db    0
db    1
db    1
db    0
db    6
db    1
db    0
db    8
db    0
db    0
db  82h	; 
db    0
db    0
db    8
db    0
db    0
db    0
db    0
db    0
unk_32960 db  80h ; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    2
db    6
db    2
db  96h	; 
db    0
db    3
db    3
db    0
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    8
db    0
db    0
db  82h	; 
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db 0FAh	; 
db  23h	; #
db    8
db    6
db  65h	; e
db    0
db    0
db    3
db    9
db    6
db 0A0h	; 
db    0
db    3
db    3
db    9
db    3
db    0
db    0
db  0Ah
db    2
db    0
db    2
db    0
db    0
db    8
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    6
db  24h	; $
db    5
db  0Ah
db  0Ah
db  0Ah
db    0
db    5
db    8
db    8
db 0C8h	; 
db    0
db    4
db    3
db  0Dh
db    0
db    0
db    0
db  14h
db    2
db    0
db    1
db    0
db    0
db    8
db    0
db    0
db    2
db    0
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    3
db    0
db 0FFh
db    0
db    0
db    2
db    8
db    2
db  32h	; 2
db    0
db    2
db    4
db    3
db    8
db    0
db    0
db    3
db    1
db    0
db    6
db    0
db    0
db  40h	; @
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    4
db    0
db 0FFh
db    0
db    0
db    3
db    8
db    2
db  64h	; d
db    0
db    2
db    4
db    4
db    0
db    0
db    0
db    3
db    1
db    0
db    6
db    0
db    0
db  40h	; @
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0B2h	; 
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    1
db    8
db    2
db  28h	; (
db    0
db    2
db    4
db  20h
db    0
db    0
db    0
db    3
db    1
db    0
db    6
db    2
db    0
db  40h	; @
db    0
db    0
db  80h	; 
db    0
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  0Fh
db  24h	; $
db    8
db    0
db 0FFh
db    0
db    0
db    4
db    9
db    2
db 0A0h	; 
db    0
db    4
db    4
db    5
db    0
db    0
db    0
db    4
db    1
db    0
db    6
db    0
db    0
db  40h	; @
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  1Bh
db  24h	; $
db    0
db  0Ch
unk_32A60 db  0Ah
db  0Ah
db    0
db    2
db    9
db    2
db 0B4h	; 
db    0
db    4
unk_32A69 db	4
db  22h	; "
db    3
unk_32A6C db	0
db    0
db  0Ch
db    1
db    0
db    1
db    0
db    0
db  40h	; @
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  28h	; (
db  24h	; $
db  0Ch
db    0
db 0FFh
db    0
db    0
db    8
unk_32A88 db  0Fh
db    2
db 0C8h	; 
db    0
db    4
db    4
db    6
db    0
unk_32A90 db	0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
db    0
unk_32A99 db	0
db 0C0h	; 
db    0
db    0
db    0
db    0
db    0
unk_32AA0 db	0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    1
db    8
db    2
db  96h	; 
db    0
db    2
db    4
db    0
db    0
db    0
db    0
db  1Eh
db    1
unk_32AB8 db	0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
unk_32AC0 db	0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    3
db    0
db 0FFh
db    0
db    0
db    2
unk_32AD0 db	4
db    2
db  0Ah
db    0
db    1
db    5
db    0
db    0
db    0
db    0
unk_32ADA db	1
db    1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
unk_32AE8 db	0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    5
db    0
db 0FFh
db    0
db    0
db    2
db    4
db    2
db  14h
db    0
db    1
db    5
db    3
db    8
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
unk_32B0A db	2
db    0
db    0
db    0
db    0
db    0
unk_32B10 db  94h ; 
db  23h	; #
db    6
db    0
db 0FFh
db    0
db    0
db    3
unk_32B18 db	4
unk_32B19 db	2
db  28h	; (
db    0
db    1
db    5
db    4
db    0
unk_32B20 db	0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db  80h	; 
unk_32B30 db	0
db    0
db    0
db    0
db  6Ah	; j
db  23h	; #
db    3
db    1
db  14h
db    8
db    0
db    1
db    4
db    2
db  1Eh
db    0
db    1
db    5
db  0Fh
db    3
db    0
db    0
db    1
db    1
db    0
unk_32B49 db	6
unk_32B4A db	0
db    0
db    0
db    0
unk_32B4E db	0
db  80h	; 
unk_32B50 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
db    2
db    0
db 0FFh
db    0
db    0
db    1
unk_32B60 db	4
db    2
db  3Ch	; <
db    0
db    2
db    5
db    0
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db  2Eh	; .
db  24h	; $
unk_32B7E db	7
db    0
db 0FFh
db    0
db    0
db    3
db    4
db    6
db  64h	; d
db    0
db    2
unk_32B89 db	5
db    9
db    3
db    0
db    0
db    5
db    1
unk_32B90 db	0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    2
db    6
db    2
unk_32BAA db  0Fh
db    0
db    1
db    6
db    0
db    0
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
db    0
unk_32BB9 db	0
db    0
db  84h	; 
db    0
db    0
db    0
db    0
unk_32BC0 db	0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    2
db    0
db 0FFh
db    0
db    0
db    2
db    6
db    2
db  1Eh
db    0
db    1
db    6
db    3
db    8
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  84h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
unk_32BE7 db	0
db  6Ah	; j
unk_32BE9 db  23h ; #
db    1
db    1
db  14h
db    8
db    0
db    1
unk_32BF0 db	6
db    2
db  2Dh	; -
db    0
db    1
db    6
db  0Fh
db    3
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  84h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  79h	; y
db  23h	; #
unk_32C0E db	1
db    2
unk_32C10 db  23h ; #
db    4
db    0
db    3
db    8
db    2
db  4Bh	; K
db    0
db    1
unk_32C19 db	6
db  16h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  84h	; 
db    0
db    0
unk_32C2A db  10h
db  40h	; @
db    0
db    0
db    0
db    0
unk_32C30 db  80h ; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    1
db    6
db    2
db  5Ah	; Z
db    0
db    1
db    6
db    0
db    0
unk_32C40 db	0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  84h	; 
db    0
db    0
unk_32C4E db  20h
db    0
db    0
db    0
db    0
db    0
db  3Ah	; :
db  24h	; $
db    1
db    2
db  15h
db    6
db    0
db    2
db    6
db    2
db  64h	; d
db    0
db    1
db    6
db    4
db    0
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db    4
unk_32C70 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    1
db    0
db 0FFh
db    0
unk_32C7E db	1
db    2
unk_32C80 db	6
db    2
db  0Fh
db    0
db    1
db    7
db    0
db    0
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
db  20h
db    0
db    0
db  80h	; 
unk_32C94 db	0
db    0
db    0
db    0
db    0
unk_32C99 db	0
unk_32C9A db	0
db    0
db  60h	; `
db  23h	; #
db    3
db    0
db 0FFh
db    0
db    1
db    2
db    6
db    2
db  1Eh
db    0
db    1
unk_32CA9 db	7
db    3
unk_32CAB db	8
db    0
unk_32CAD db	0
db    1
db    1
unk_32CB0 db	0
db    6
unk_32CB2 db	0
db    0
db  20h
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    4
db    0
db 0FFh
db    0
db    1
db    3
db    6
db    2
db  3Ch	; <
db    0
db    1
db    7
db    4
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db  20h
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
unk_32CE0 db	0
db    0
db    0
db    0
db  71h	; q
db  23h	; #
db    4
db    0
db 0FFh
db    0
db    1
db    2
db    6
db    4
db  3Ch	; <
db    0
db    1
db    7
db    3
db    9
db    1
db    0
db    3
db    1
db    0
db    4
db    0
db    0
db  21h	; !
db    0
unk_32CFE db	0
db  80h	; 
db    0
db    0
db    0
db    0
db    2
db    0
db    0
db    0
db 0A8h	; 
db  23h	; #
db    1
db    5
db  1Fh
db    4
unk_32D0E db	1
db    3
db  0Ah
db    4
db 0B4h	; 
db    0
db    2
db    7
db  15h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
unk_32D20 db  20h
db    0
db    4
db  80h	; 
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
unk_32D2E db	0
db    0
unk_32D30 db 0FFh
db    0
db    1
db    1
db    6
db    2
db  5Ah	; Z
db    0
db    2
db    7
db    0
db    0
db    0
db    0
db  0Ah
db    1
unk_32D40 db	0
db    1
db    0
db    0
db  20h
db    0
db    0
db  80h	; 
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
unk_32D50 db  43h ; C
db  24h	; $
db    1
db    3
db  14h
db    8
db    1
db    2
db    6
db    2
unk_32D5A db  50h ; P
db    0
db    2
db    7
db  0Fh
db    3
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
unk_32D6E db	0
db    0
db    0
db    0
db    0
db    0
db  4Eh	; N
db  24h	; $
db    5
db    0
db 0FFh
db    0
db    2
db    4
db    9
db    4
db 0A0h	; 
db    0
db    3
db    7
db    6
db    0
db    0
db    0
db    3
db    1
db    0
db    4
unk_32D8A db	0
db    0
db  21h	; !
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    3
db    0
db    0
db    0
db  5Ah	; Z
db  24h	; $
db    5
db    3
db  14h
db    8
unk_32D9E db	1
db    4
db    8
db    6
db 0A0h	; 
db    0
db    3
db    7
unk_32DA6 db  0Bh
db    3
unk_32DA8 db	0
db    0
db    5
db    2
db    0
db    2
db    0
db    0
db    8
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    2
db    4
db    2
db  0Ah
db    0
db    1
db    8
db    0
db    0
db    0
db    0
unk_32DCE db	1
db    1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
unk_32DD9 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_32DE0 db  60h ; `
db  23h	; #
db    3
db    0
db 0FFh
db    0
db    0
db    2
db    4
db    2
db  14h
db    0
db    1
db    8
db    3
db    8
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
unk_32DFE db	2
db    0
db    0
unk_32E01 db	0
db    0
db    0
db  6Ah	; j
db  23h	; #
db    1
db    1
db  14h
db    8
db    0
db    1
db    4
db    2
db  1Eh
db    0
db    1
db    8
db  0Fh
db    3
db    0
db    0
db    1
db    1
db    0
db    6
unk_32E1A db	0
db    0
db    0
db    0
db    0
db  80h	; 
unk_32E20 db	0
unk_32E21 db	0
db    0
db    0
unk_32E24 db	0
db    0
db    0
db    0
db  71h	; q
db  23h	; #
db    4
db    0
db 0FFh
db    0
db    0
db    2
db    4
db    4
db  28h	; (
db    0
db    1
db    8
db    3
db    9
db    0
db    0
db    3
db    1
db    0
db    4
db    0
db    0
db    1
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    2
db    0
db    0
db    0
db 0A0h	; 
db  23h	; #
db    3
db    4
unk_32E50 db  23h ; #
db    4
db    0
db    4
db    7
db    2
db  64h	; d
db    0
db    1
db    8
unk_32E5A db  18h
db    0
db    0
db    0
db    1
db 1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    1
db    0
db  10h
db  40h	; @
db    0
db    0
db    0
db    0
db 0A8h	; 
db  23h	; #
db    1
db    5
db  1Fh
db    4
db    0
db    3
db    8
db    2
db  78h	; x
db    0
db    2
db    8
db  15h
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
unk_32E8A db	4
db  80h	; 
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0B2h	; 
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    1
db    4
db    2
db  28h	; (
db    0
db    1
db    8
db  20h
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    1
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    1
db    4
db    2
db  3Ch	; <
db    0
db    2
db    8
db    0
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
unk_32ED0 db	0
db    0
db    0
db  80h	; 
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db  62h	; b
db  24h	; $
db    5
db    0
db 0FFh
db    0
db    0
db    3
db    5
db    2
db  50h	; P
db    0
db    1
db    8
db    5
db    0
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    1
db    0
db    0
db    0
unk_32F00 db  6Ah ; j
db  24h	; $
db    6
db    0
db 0FFh
db    0
db    0
db    5
db    8
db    4
unk_32F0A db 0C8h ; 
db    0
db    3
db    8
db  19h
db    6
db    0
db    0
db    4
db    1
db    0
db    4
db    0
db    1
db    1
db    0
db  20h
db    0
db  80h	; 
db    0
db    0
db    0
db    3
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    4
db    5
db    2
db  14h
db    0
unk_32F30 db	1
db    9
db    0
db    0
db    0
db    0
db    1
db    1
db    0
db    8
unk_32F3A db	0
db    0
db    0
db    0
db    0
db  80h	; 
unk_32F40 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    3
db    0
db 0FFh
db    0
db    0
db    4
db    5
db    2
db  28h	; (
db    0
db    1
db    9
db    3
db    8
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    4
db    0
unk_32F70 db 0FFh
db    0
db    0
db    5
db    5
db    2
db  50h	; P
db    0
db    1
db    9
unk_32F7A db	4
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0B2h	; 
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    1
db    5
db    2
db  50h	; P
db    0
db    1
db    9
db  20h
db    0
unk_32FA0 db	0
db    0
db    1
db    1
db    0
db    6
db    1
db    0
db    0
db    0
unk_32FAA db	0
db  80h	; 
db    0
db    0
db    8
db    0
db    0
db    0
db    0
db    0
unk_32FB4 db  80h ; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    1
db    5
db    2
db  78h	; x
db    0
db    2
db    9
db    0
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
unk_32FD0 db	0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db  73h	; s
db  24h	; $
unk_32FDA db  0Fh
db    5
db  65h	; e
db    0
db    0
db    7
db    6
db    4
db 0A0h	; 
db    0
unk_32FE4 db	2
db    9
db    9
db    6
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    3
db    4
db    2
db  0Ah
db    0
db    1
db  0Ah
db    0
db    0
db    0
db    0
db    2
db    1
db    0
db    8
db    0
db    0
db    4
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    3
db    0
unk_33024 db 0FFh
db    0
db    0
db    3
db    4
db    2
db  14h
db    0
db    1
db  0Ah
db    3
db    8
db    0
db    0
db    2
db    1
db    0
db    6
db    0
db 0
db    4
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    4
db    0
db 0FFh
db    0
db    0
db    4
db    4
db    2
db  28h	; (
db    0
db    1
db  0Ah
db    4
db    0
db    0
db    0
db    2
db    1
db    0
db    6
db    0
db    0
db    4
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db  7Fh	; 
db  24h	; $
db    4
db    3
db  14h
db    6
db    0
db    4
db    5
db    2
db  50h	; P
db    0
db    2
db  0Ah
db    5
db    0
db    0
db    0
db    2
db    1
db    0
db    6
unk_3307E db	0
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  79h	; y
db  23h	; #
db    2
db    2
db  23h	; #
db    4
db    0
db    3
db    6
db    2
db  3Ch	; <
db    0
db    2
db  0Ah
db  16h
db    0
db    0
db    0
db    2
db    1
db    0
db    4
db    0
db    0
db    4
db    0
db    0
db  80h	; 
db    0
db    0
db  10h
db  40h	; @
db    0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    2
db    4
db    2
db  78h	; x
db    0
db    2
db  0Ah
db    0
db    0
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
db    4
db    0
db    0
db  80h	; 
db    0
unk_330CD db	0
db  20h
db    0
db    0
db    0
db    0
db    0
db  8Bh	; 
db  24h	; $
db  0Ah
db    5
db  65h	; e
db    0
db    0
db    8
db    8
db    4
db  64h	; d
db    0
db    1
db  0Ah
db    9
db    6
db    0
db    0
db  0Fh
db    1
db    0
db    1
db    0
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_330F8 db  57h ; W
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    2
db    4
db    2
unk_33102 db  0Ah
unk_33103 db	0
unk_33104 db	1
db  0Bh
db    0
db    0
unk_33108 db	0
db    0
db    1
unk_3310B db	1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    3
db    0
db 0FFh
db    0
db    0
db    2
db    4
db    2
db  14h
db    0
db    1
db  0Bh
db    3
db    8
db    0
db    0
db    1
db    1
unk_33130 db	0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  6Ah	; j
db  23h	; #
db    1
db    1
db  14h
db    8
db    0
db    1
db    4
db    2
db  1Eh
db    0
db    1
db  0Bh
db  0Fh
db    3
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0A0h	; 
db  23h	; #
db    3
db    4
db  23h	; #
db    4
db    0
db    4
db    7
db    2
db  64h	; d
db    0
db    1
db  0Bh
db  18h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
unk_33180 db	1
db    0
db  10h
db  40h	; @
db    0
db    0
db    0
db    0
db 0A8h	; 
db  23h	; #
db    1
db    5
db  1Fh
db    4
db    0
db    3
db    8
db    2
db  78h	; x
db    0
db    2
db  0Bh
db  15h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    4
db  80h	; 
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    1
db    4
db    2
db  3Ch	; <
db    0
db    2
db  0Bh
db    0
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db  99h	; 
db  24h	; $
db    4
db    2
db  14h
db    8
db    0
db    2
db    4
db    4
db  3Ch	; <
db    0
db    1
db  0Bh
db    9
db    3
db    0
db    0
db    3
db    1
db    0
db    4
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  62h	; b
db  24h	; $
db    5
db    0
db 0FFh
db    0
db    0
db    3
db    5
db    2
db  50h	; P
db    0
db    3
db  0Bh
db    5
db    0
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    1
db    0
db    0
db    0
db 0A5h	; 
db  24h	; $
db    4
db    3
db  14h
db    8
db    0
unk_3321F db	4
db    6
db    4
db  78h	; x
db    0
db    2
db  0Bh
db  0Ah
db    3
db    0
db    0
db    2
db    1
db    0
db    4
db    0
db    0
db  60h	; `
db    0
db    0
db    0
unk_33234 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0ADh	; 
db  24h	; $
db    9
db    0
db 0FFh
db    0
db    0
db    5
unk_33244 db	7
db    4
db 0C8h	; 
db    0
db    2
db  0Bh
db  0Bh
db    3
db    0
db    0
db  0Ah
db    1
db    0
db    2
db    0
db    0
db    8
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    3
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    1
db    0
unk_33264 db 0FFh
db    0
db    0
db    2
db    4
db    2
db  0Ah
db    0
db    1
db  0Ch
db    0
db    0
db    0
db    0
db    1
db    1
db    0
db    8
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  60h	; `
db  23h	; #
db    3
db    0
db 0FFh
db    0
db    0
db    2
db    4
db    2
db  14h
db    0
db    1
db  0Ch
db    3
db    8
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    4
db    0
db 0FFh
db    0
db    0
db    3
db    4
db    2
db  28h	; (
db    0
db    1
db  0Ch
db    4
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  6Ah	; j
db  23h	; #
db    1
db    1
db  14h
db    8
db    0
db    1
db    4
db    2
db  1Eh
db    0
db    1
db  0Ch
db  0Fh
db    3
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  71h	; q
db  23h	; #
db    4
db    0
unk_332F4 db 0FFh
db    0
db    0
db    2
db    4
db    4
db  28h	; (
db    0
db    1
db  0Ch
db    3
db    9
db    1
db    0
db    3
db    1
db    0
db    4
db    0
db    0
db    1
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  79h	; y
db  23h	; #
db    2
db    2
db  23h	; #
db    4
db    0
db    3
db    6
db    2
db  3Ch	; <
db    0
db    1
db  0Ch
db  16h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
unk_33330 db	0
db    0
db  10h
db  40h	; @
unk_33334 db	0
db    0
db    0
db    0
db 0A8h	; 
db  23h	; #
db    1
db    5
db  1Fh
db    4
db    0
db    3
db    8
db    2
db  78h	; x
db    0
db    2
db  0Ch
db  15h
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    4
db  80h	; 
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0B2h	; 
db  23h	; #
db    1
db    0
db 0FFh
db    0
db    0
db    1
unk_33364 db	4
db    2
db  28h	; (
db    0
db    1
db  0Ch
db  20h
db    0
db    0
db    0
db    1
unk_3336F db	1
db    0
db    6
db    1
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
unk_3337A db	8
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db  23h	; #
db    0
db    0
db 0FFh
db    0
db    0
db    1
db    4
db    2
db  3Ch	; <
db    0
db    2
db  0Ch
db    0
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db 0B6h	; 
db  24h	; $
unk_333A6 db	5
db    0
db 0FFh
unk_333A9 db	0
db    0
db    5
db    7
db    6
db 0C8h	; 
db    0
db    2
db  0Ch
db  0Bh
db    3
db    0
db    0
db  0Ah
db    1
db    0
db    2
db    0
db    6
db    8
db    0
db    0
db    2
db    0
db    0
db    0
db    0
db    4
db    0
db    0
db    0
db  57h	; W
db  23h	; #
db    3
db    0
db 0FFh
db    0
db    0
db    2
db    7
db    2
db  1Eh
unk_333D3 db	0
db    2
db  0Dh
db    0
db    0
db    0
db    0
unk_333DA db	4
db    1
db    0
db    4
db    0
db    0
unk_333E0 db	0
db    0
db    0
db  80h	; 
unk_333E4 db	0
db    0
db    0
db  20h
db    0
db    0
unk_333EA db	0
db    0
db  60h	; `
unk_333ED db  23h ; #
db    5
db    0
db 0FFh
db    0
db    0
db    2
db    7
db    2
db  3Ch	; <
db    0
db    3
db  0Dh
db    3
db    8
db    0
db    0
db    4
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    2
db  20h
db    0
db    0
db    0
db    0
db  94h	; 
db  23h	; #
db    6
db    0
unk_33414 db 0FFh
db    0
db    0
db    3
db    7
db    2
db  78h	; x
db    0
db    3
unk_3341D db  0Dh
db    4
db    0
unk_33420 db	0
db    0
db    4
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
unk_3342F db 0A0h ; 
unk_33430 db	0
db    0
db    0
db    0
db  79h	; y
db  23h	; #
db    4
db    2
db  23h	; #
db    4
db    0
db    3
db    8
db    2
db 0B4h	; 
db    0
db    2
db  0Dh
unk_33442 db  16h
db    0
db    0
db    0
db    4
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db  10h
db  60h	; `
unk_33454 db	0
db    0
db    0
db    0
db  80h	; 
unk_33459 db  23h ; #
db    0
db    0
db 0FFh
unk_3345D db	0
unk_3345E db	0
db    1
db    7
unk_33461 db	2
db 0B4h	; 
db    0
db    2
db  0Dh
db    0
db    0
db    0
db    0
db  28h	; (
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db  20h
db  20h
db    0
db    0
db    0
db    0
db 0C4h	; 
db  24h	; $
db    8
db    0
db 0FFh
db    0
db    0
db    4
unk_33484 db	8
db    4
db 0A0h	; 
db    0
db    3
db  0Dh
db    5
db    0
db    0
db    0
db    5
db    1
unk_33490 db	0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db 0CFh	; 
db  24h	; $
unk_334A2 db  0Ah
unk_334A3 db	0
db 0FFh
db    0
unk_334A6 db	0
db    6
db    9
db    4
db 0F0h	; 
db    0
db    4
db  0Dh
db    9
db    6
db    0
db    0
db  0Ch
db    1
unk_334B4 db	0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    8
db    0
db    2
db    0
db    0
db    0
db 0DCh	; 
db  24h	; $
db    5
db    0
db 0FFh
db    0
db    0
db    4
db    8
db    2
db  1Eh
db    0
db    1
unk_334D1 db  0Fh
unk_334D2 db	6
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  0Ch
unk_334E4 db	0	; DATA XREF: _f010109_main+2C8o
db    0
db    0
db    0
db 0E9h	; 
db  24h	; $
db    3
db    3
db  65h	; e
db    0
db    1
db    2
db    6
db    4
db  28h	; (
db    0
db    1
db  12h
db    6
db    0
db    0
db    0
db    4
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db 0F5h	; 
db  24h	; $
db    4
db    0
db 0FFh
db    0
db    1
db    8
db    7
db    4
db 0C8h	; 
db    0
db    5
db  12h
db    6
db    0
unk_3351C db	0
db    0
db    4
db    1
db    0
db    4
db    0
db    0
db    8
db    0
db  82h	; 
db    0
db    0
db    0
db    1
db    0
db    0
db    0
unk_3352E db	0
db    0
unk_33530 db 0FFh
db  24h	; $
db  0Ah
db  0Ah
db  0Ah
db    2
db    1
unk_33537 db	5
db    7
db    4
db  96h	; 
db    0
db    3
unk_3353D db  12h
db    6
db    0
db    0
db    0
db  0Fh
db    1
db    0
db    1
db    0
db    0
db  40h	; @
db    0
db    1
db    0
byte_3354C db 0
align 2
db    9
db    0
db    0
db    0
db    0
db    0
db  0Ah
db  25h	; %
db  0Ch
db    0
db 0FFh
db    0
db    0
db    4
db    6
db    2
db  64h	; d
db    0
db    4
db  12h
db    6
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db  83h	; 
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  19h
db  25h	; %
db    1
db    4
db  68h	; h
db    0
db    0
db    6
db  0Ah
db    2
db  90h	; 
db    1
db  0Ch
db  12h
db    6
db    0
db    0
db    0
db  0Fh
db    1
db    0
db    1
db    0
db    4
db    8
db    0
db    0
db    2
db  20h
db    0
db    1
db    0
db    4
db    0
db    0
db    0
db  25h	; %
db  25h	; %
db    7
db    4
db  65h	; e
db    0
db    1
db    5
db    8
db    4
db  5Eh	; ^
db    1
db  0Ah
db  12h
unk_335AA db	6
db    0
db    0
db    0
db    8
db    1
unk_335B0 db	0
db    4
db    0
db    0
db    8
db    0
db    0
db    2
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  2Dh	; -
db  25h	; %
db  0Ah
db    0
db 0FFh
db    0
db    1
db    5
db    9
db    8
db  2Ch	; ,
db    1
db    8
db  12h
db    6
db    0
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
db    8
db    0
db    0
db    2
db    8
db    0
db    1
db    0
db    0
db    0
db    0
db    0
unk_335E4 db  36h ; 6
db  25h	; %
db    9
db    9
db  1Fh
db    0
db    2
db    7
db  0Ah
db    6
db  26h	; &
db    2
db  0Fh
db  12h
db    6
db    0
db    0
db    0
db  0Ch
db    1
db    0
db    1
db    0
db    0
unk_335FC db	8
db    0
db    1
db  22h	; "
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  3Dh	; =
db  25h	; %
db    6
db    5
db  65h	; e
db    0
db    1
db    4
db  0Bh
db    2
db  8Ah	; 
db    2
db  0Eh
db  12h
unk_33616 db	6
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    9
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  20h
db    0
db    0
db    0
db    0
unk_3362C db  43h ; C
db  25h	; %
db  1Eh
db  1Eh
unk_33630 db  65h ; e
db    0
db    3
db  0Ah
db  0Ch
db    4
db  84h	; 
db    3
db  1Eh
db  12h
db    6
db    0
db    0
db    0
db  1Eh
db    1
db    0
db    1
db    0
db    0
db    8
db    0
db    0
db    2
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
unk_33650 db  4Fh ; O
db  25h	; %
db    3
db    0
db 0FFh
db    0
db    1
db    4
db    5
db    2
db  19h
db    0
db    1
db  14h
db    6
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db 0DCh	; 
db    0
db    0
unk_3366D db	0
db    1
db    0
db    0
db    0
db    0
db    0
db  59h	; Y
db  25h	; %
db    4
db    0
db 0FFh
db    0
db    1
db    3
db    6
db    2
db  50h	; P
db    0
db    1
db  14h
db    6
db    0
db    0
db    0
db    3
db    1
db    0
db    4
db    0
db    1
db    0
db    0
db 0D8h	; 
db    0
db    0
db    0
db  81h	; 
db    0
db    4
db    0
db    0
db    0
db  60h	; `
db  25h	; %
db    7
db    1
db  69h	; i
unk_3369D db	0
db    1
db    3
db    8
db    4
db 0FAh	; 
db    0
db    1
db  14h
db    6
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db 0FEh	; 
db    0
db    0
db 0D8h	; 
db    0
db    0
db    0
db  41h	; A
db    0
db    0
db    0
db    0
db    0
db  6Eh	; n
db  25h	; %
db    5
db    0
db 0FFh
db    0
db    1
db    1
db    6
db    4
db 0FAh	; 
db    0
db    5
db  14h
db    6
db    0
db    0
db    0
db    5
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db 0D8h	; 
db    1
db    0
db    0
db    1
db  20h
db    0
db    0
db    0
db    0
db  79h	; y
db  25h	; %
db  0Eh
db    0
db 0FFh
db    0
db    1
db    5
db    7
db    4
db  50h	; P
db    0
db    3
db  14h
db    6
db    0
db    0
db    0
db  0Ch
db    1
db    0
db    1
db    0
db    0
db    8
db    0
db 0DCh	; 
db    3
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  7Fh	; 
db  25h	; %
db    7
db    0
db 0FFh
db    0
db    2
db    6
db    8
db    4
db 0F4h	; 
db    1
db    5
db  14h
db    6
db    0
db    0
db    0
db    8
db    1
db    0
db    4
db    0
db 0FDh	; 
db    8
db    0
db 0D8h	; 
db    3
db    0
db    0
db    1
db    8
db    8
db    0
db    0
db    0
db  87h	; 
db  25h	; %
db    5
db    4
db  21h	; !
unk_3372D db	8
db    2
db    4
unk_33730 db	8
db    2
db  45h	; E
db    1
db    7
db  14h
db    6
db    0
db    0
db    0
db    5
db    1
db    0
db    4
db    0
db    0
unk_33740 db	8
db    0
db 0D8h	; 
db    3
db    0
db    0
db    5
db  28h	; (
db    0
db    0
db    0
db    0
db  95h	; 
db  25h	; %
db    9
db    0
unk_33750 db 0FFh
db    0
db    3
db    8
db  0Ah
db    6
db  58h	; X
db    2
db    8
db  14h
db    6
db    0
db    0
db    0
db    8
db    1
db    0
db    4
db    0
db 0FCh	; 
db    8
db    0
db 0D8h	; 
db    3
db    0
db    0
db    1
db    0
db  0Bh
unk_3376D db	0
db    0
db    0
unk_33770 db 0A3h ; 
db  25h	; %
db  14h
db  0Ah
db  21h	; !
db    8
db    3
db  0Ah
db  0Ch
db    4
db  84h	; 
db    3
db  0Fh
db  14h
db    6
db    0
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db 0FBh	; 
db    8
db    0
db 0D8h	; 
db  1Bh
db  20h
db    0
db    1
db    0
db    8
db    0
db    0
db    0
db 0AEh	; 
db  25h	; %
db    4
db    0
db 0FFh
db    0
db    1
db    3
db    3
unk_3379D db	2
db  1Eh
db    0
db    0
db  14h
db    6
db    0
db    0
db    0
db    3
db    1
db    0
db    6
db    0
db 0
db    0
db    0
db 0D8h	; 
db    0
unk_337B0 db	0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db 0B6h	; 
db  25h	; %
db    5
db    0
db 0FFh
db    0
db    2
db    3
db    7
db    4
db 0FAh	; 
db    0
db    5
db  13h
db    6
db    0
db    0
db    0
db    6
db    1
db    0
db    4
db    0
db    2
db  10h
db    0
db  80h	; 
db    0
db  40h	; @
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db 0BFh	; 
db  25h	; %
db  0Ah
db    0
db 0FFh
db    0
db    0
db    4
db  0Ah
db    2
db  32h	; 2
db    0
maybe_337E8 db 1
db  13h
db    6
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db  40h	; @
db    0
db    1
db  0Ch
db    0
db    0
db    0
db    0
db 0CFh	; 
db  25h	; %
db  0Dh
db    0
db 0FFh
db    0
db    2
db    7
db    8
db    6
db  26h	; &
db    2
db  0Fh
db  13h
db    6
db    0
db    0
db    0
db  0Fh
db    1
db    0
db    1
db    0
db    1
db    8
db    0
db    8
db    2
db  80h	; 
unk_3381D db	0
db    1
db    0
db    0
db    8
db    0
db    0
db 0D5h	; 
db  25h	; %
db  0Fh
db    0
db 0FFh
db    0
db    3
db  0Ah
db  0Ch
db    8
db 0B6h	; 
db    3
db  14h
db  13h
db    6
db    0
db    0
db    0
db  12h
db    1
db    0
db    1
db    0
unk_3383B db	2
db    8
db    0
db    8
db  42h	; B
db  80h	; 
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db 0E0h	; 
db  25h	; %
db    7
db    0
db 0FFh
unk_3384D db	0
db    0
db    3
unk_33850 db	6
db    4
db  46h	; F
db    0
db    2
db  10h
db    6
unk_33857 db	0
db    0
db    0
db    8
db    1
db    0
db    2
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db 0EAh	; 
db  25h	; %
db    2
db    3
db  25h	; %
db    4
db    1
db    2
db    8
db    4
db  64h	; d
db    0
db    3
db  10h
db    6
db    0
db    0
db    0
db    1
db    1
db    0
db    4
db    0
db    0
db  28h	; (
db    0
db    0
unk_33887 db	2
db    0
db    0
db    1
db    0
db    0
unk_3388D db	0
db    0
db    0
unk_33890 db 0F2h ; 
db  25h	; %
db    4
db    0
db 0FFh
db    0
db    1
db    3
db    7
db    4
db  13h
db    1
db    8
db  10h
db    6
db    0
db    0
db    0
db    3
db    1
db    0
db    4
db    0
db 0FDh	; 
db    8
db    0
db    0
db    2
db    0
db    0
db    1
db    0
db  80h	; 
db    0
db    0
db    0
db 0FEh	; 
db  25h	; %
db  0Fh
db    1
db  67h	; g
db    0
db    1
db    4
db    7
unk_338BD db	4
db  45h	; E
db    1
db    7
db  10h
db    6
db    0
db    0
db    0
db  1Eh
unk_338C7 db	1
db    0
db    1
db    0
db 0FFh
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    7
db  26h	; &
db    4
db    0
db 0FFh
db    0
db    1
db    3
db    7
db    4
db 0C8h	; 
db    0
db    4
db  10h
db    6
db    0
db    0
db    0
db  0Ah
db    1
db    0
unk_338ED db	2
db    0
db    4
db    0
db    0
db    0
db    0
db  10h
db    0
db    1
db    0
db    4
db    0
db    0
db    0
db  15h
db  26h	; &
db  0Fh
db  0Fh
db  0Ah
db    2
db    2
db    8
db    9
db    4
db 0C2h	; 
db    1
db    9
db  10h
db    6
db    0
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
unk_33914 db  40h ; @
db    0
db  82h	; 
db    0
db    0
unk_33919 db	0
db    9
db    0
db    0
unk_3391D db	0
db    0
db    0
db  21h	; !
unk_33921 db  26h ; &
db  14h
db  14h
db  0Ah
db    2
db    3
db  0Ah
db  0Fh
db    4
db  20h
db    3
db  11h
db  10h
db    6
db    0
db    0
db    0
db  1Eh
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db  82h	; 
db    0
db    0
db    0
db    9
db    0
db    2
db    0
db    0
db    0
db  2Ah	; *
db  26h	; &
db    8
db    1
db  67h	; g
db    0
db    2
db    7
db    9
unk_3394D db	4
db  57h	; W
db    2
unk_33950 db  0Fh
db  10h
unk_33952 db	6
db    0
db    0
db    0
db    9
db    1
db    0
db    4
db    0
db 0FEh	; 
db    8
db    0
db    0
unk_3395F db	2
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  32h	; 2
db  26h	; &
db  19h
db    0
db 0FFh
db    0
db    1
db    4
db    8
db    2
db 0A0h	; 
unk_33973 db	0
db    7
db  10h
unk_33976 db	6
db    0
db    0
db    0
db  1Eh
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db  82h	; 
db    0
db    0
db    0
db    9
db    0
db    0
db    0
db    0
db    0
db  42h	; B
db  26h	; &
db  19h
db    0
db 0FFh
db    0
db    2
db    9
db  0Ah
db    4
db 0BCh	; 
db    2
db  0Fh
db  10h
db    6
db    0
db    0
db    0
db  2Dh	; -
unk_3399F db	1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
unk_339A7 db	0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db  4Bh	; K
db  26h	; &
db  19h
db    0
db 0FFh
db    0
db    3
db  0Ch
db  0Ch
db    6
db 0E8h	; 
db    3
db  14h
db  10h
db    6
db    0
unk_339C0 db	0
db    0
db  2Dh	; -
db    1
db    0
db    1
db    0
db  0Fh
db  80h	; 
db    0
db    0
unk_339CB db	0
db    0
db    0
db    1
db    0
db    4
db    0
db    0
db    0
db  56h	; V
db  26h	; &
db    0
db    0
db 0FFh
db    0
db    0
db    0
db  0Ah
db    4
db  32h	; 2
db    0
db    5
db  11h
db    6
db    0
db    0
db    0
db  2Dh	; -
db    1
db    8
db    1
db    0
db    0
db    2
db    0
db 0C2h	; 
db    0
unk_339F0 db	0
db    0
db    1
unk_339F3 db	0
db    0
db    0
db    0
db    0
db  66h	; f
db  26h	; &
db  12h
db    0
db 0FFh
db    0
db    1
db    0
db    8
db    4
db 0E1h	; 
db    0
db    4
db  11h
db    6
db    0
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db 0C2h	; 
db    0
db    0
db    0
db    1
db    8
db  40h	; @
db    0
db    0
db    0
db  74h	; t
db  26h	; &
db    3
db    0
db 0FFh
db    0
db    0
db    0
db    6
db    2
db  14h
db    0
db    2
db  11h
db    6
db    0
db    0
db    0
db    1
db    1
db    0
db    6
db    0
db    0
db    0
db    0
db 0C2h	; 
db    0
db    0
db    0
db    1
db    8
db  40h	; @
db    0
db    0
db    0
unk_33A40 db  85h ; 
db  26h	; &
db  0Ch
db  0Ah
db  1Eh
db    4
db    2
db    7
db    9
db    4
db 0F4h	; 
db    1
db  0Ah
db  11h
db    6
db    0
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    9
db    0
db    1
db    0
db    0
db    0
db  91h	; 
db  26h	; &
db  0Fh
db    0
db 0FFh
db    0
db    1
db    8
db    9
db  0Ah
db 0AAh	; 
db    0
db    8
db  11h
db    6
db    0
db    0
db    0
db  0Ah
db    1
db    0
db    1
db    0
db    0
db    8
db    0
db  82h	; 
db    3
unk_33A80 db	0
db    0
db  41h	; A
db    0
db    0
db    0
db    0
db    0
db  9Fh	; 
db  26h	; &
db  0Fh
db    8
db  22h	; "
db    0
db    3
db    8
db  0Ah
db    6
db  8Ah	; 
db    2
db  11h
db  11h
db    6
db    0
db    0
db    0
db  14h
db    1
db    0
db    1
db    0
db    0
db  18h
db    0
db    0
db  22h	; "
db    0
db    0
db    1
db  10h
db    0
db    0
db    0
db    0
db 0A5h	; 
db  26h	; &
db  14h
db  14h
db  66h	; f
db    0
db    3
db  0Ah
db  0Eh
db    8
db 0E8h	; 
db    3
db  19h
db  11h
db    6
db    0
unk_33ABC db	0
db    0
db  19h
db    1
unk_33AC0 db	0
db    1
db    0
db    0
db    8
db    0
db  28h	; (
db    2
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db 0AFh	; 
db  26h	; &
db    4
db    0
db 0FFh
db    0
db    1
unk_33AD7 db	3
db    7
db    2
db  78h	; x
db    0
db    2
db  11h
db    6
db    0
db    0
db    0
db    6
db    1
db    0
db    2
db    0
db    4
db    4
db    0
db    0
db    0
db    0
db    0
db    1
db    0
unk_33AF0 db	6
db    0
db    0
db    0
db    0
db    0
word_33AF6 dw 14h	; DATA XREF: sub_4CB55+214r
word_33AF8 dw 3Ch	; DATA XREF: sub_4CB55+24Fr
word_33AFA dw 78h	; DATA XREF: sub_4CB55+289r
db 0C8h	; 
db    0
db  2Ch	; ,
db    1
db 0C2h	; 
db    1
db  58h	; X
db    2
db 0E8h	; 
db    3
db  0Dh
unk_33B07 db  22h ; "
db    3
db    0
db  14h
db    0
db  0Ah
db    0
db  19h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  0Fh
db    0
db    2
db    0
db    0
db    0
db 0B5h	; 
db  26h	; &
db    2
db    0
db  0Bh
db    0
db  0Dh
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_33B2D db	0
db    0
db    0
db    5
db    0
db    0
db    0
db    0
db    0
db 0BEh	; 
db  26h	; &
db    2
db    0
db  19h
db    0
db  0Eh
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
db    0
db 0FEh	; 
db 0FFh
db    1
db    0
db  96h	; 
db  22h	; "
db    3
db    0
db  21h	; !
db    0
db  0Bh
unk_33B55 db	0
db  0Eh
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    5
db    0
db 0FFh
db 0FFh
db    0
db    0
db 0C7h	; 
db  26h	; &
db    4
db    0
db    9
db    0
db  0Dh
db    0
db  14h
db    0
unk_33B70 db  18h
db    0
db    0
db    0
db    0
unk_33B75 db	0
db    0
db    0
db    7
db    0
db 0FEh	; 
db 0FFh
db    0
db    0
db 0CFh	; 
db  26h	; &
db    5
db    0
db  0Ah
db    0
db  11h
db    0
db  18h
db    0
db    6
db    0
db  0Eh
db    0
db    0
db    0
db    0
db    0
db    5
db    0
db 0FFh
db 0FFh
db    2
db    0
db 0D5h	; 
unk_33B97 db  26h ; &
db    4
db    0
db  14h
db    0
db    6
db    0
db    9
db    0
unk_33BA0 db  0Dh
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_33BA8 db  0Fh
db    0
db    0
db    0
db    0
db    0
db 0DEh	; 
db  26h	; &
db    2
db    0
db  18h
db    0
db  0Eh
db    0
db    0
db    0
db    0
unk_33BB9 db	0
unk_33BBA db	0
db    0
db    0
db    0
db    0
db    0
db    5
db    0
db 0FEh	; 
db 0FFh
db    1
db    0
db 0E7h	; 
db  26h	; &
db    1
unk_33BC9 db	0
db  0Bh
unk_33BCB db	0
db    0
unk_33BCD db	0
db    0
db    0
db    0
db    0
unk_33BD2 db	0
db    0
db    0
db    0
db    0
unk_33BD7 db	0
db  0Ah
db    0
db    0
db    0
db    0
db    0
db 0F0h	; 
db  26h	; &
unk_33BE0 db	3
db    0
db  17h
db    0
db  11h
db    0
db  0Dh
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_33BEF db	0
db    5
db    0
db 0FFh
db 0FFh
db    2
db    0
db 0F8h	; 
db  26h	; &
db    7
db    0
db    7
db    0
unk_33BFC db  0Ah
db    0
db  11h
db    0
db  18h
db    0
db  22h	; "
db    0
db  0Ch
db    0
db  0Fh
unk_33C07 db	0
db  0Ah
db    0
db    1
db    0
db    2
db    0
db    2
db  27h	; '
unk_33C10 db	2
db    0
db  0Eh
db    0
db  15h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  0Ah
db    0
db 0FFh
db 0FFh
db    0
db    0
db    8
db  27h	; '
db    0
db    0
db    0
db    0
db    0
db    0
unk_33C2E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  0Ah
db    0
db    0
db    0
db    0
db    0
db  0Ch
db  27h	; '
unk_33C40 db	4
db    0
db  0Bh
db    0
db  11h
db    0
db  22h	; "
db    0
db  0Dh
db    0
db    0
db    0
db    0
db    0
db    0
unk_33C4F db	0
unk_33C50 db	3
db    0
db 0FEh	; 
db 0FFh
db    2
db    0
db  77h	; w
db  20h
db  12h
db  27h	; '
db  19h
db  27h	; '
db  20h
db  27h	; '
db  28h	; (
db  27h	; '
db 0BFh	; 
db  20h
db  2Eh	; .
db  27h	; '
unk_33C64 db	1	; DATA XREF: sub_56450+18Eo
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  3Fh	; ?
db    1
db 0C7h	; 
db    0
word_33C70 dw 0		; DATA XREF: ST_LoadMusicSoundfxIntro:loc_55838o
			; sub_56450+Co
align 8
db  3Fh	; ?
db    1
db 0C7h	; 
db    0
db    6
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  3Fh	; ?
db    1
db 0C7h	; 
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  3Fh	; ?
db    1
db 0C7h	; 
db    0
db    7
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db  3Fh	; ?
db    1
db  9Eh	; 
db    0
db    1
db    2
db    4
db    8
db  10h
db  20h
db  34h	; 4
db  27h	; '
db  3Ch	; <
db  27h	; '
db  44h	; D
db  27h	; '
unk_33CAC db  52h ; R
db  27h	; '
db  61h	; a
db  27h	; '
db  71h	; q
db  27h	; '
db  80h	; 
db  27h	; '
db  8Dh	; 
db  27h	; '
db  99h	; 
unk_33CB7 db  27h ; '
db 0A3h	; 
db  27h	; '
db 0AAh	; 
db  27h	; '
db 0B3h	; 
db  27h	; '
db 0C1h	; 
unk_33CBF db  27h ; '
db 0CEh	; 
db  27h	; '
db 0D5h	; 
db  27h	; '
db 0E0h	; 
db  27h	; '
unk_33CC6 db 0E9h ; 
db  27h	; '
unk_33CC8 db 0F5h ; 
db  27h	; '
unk_33CCA db	1
db    0
db  28h	; (
db    0
db  14h
db    0
db  0Ah
db    0
db  0Ah
db    0
db 0D8h	; 
db 0FFh
db 0ECh	; 
db 0FFh
db  64h	; d
db    0
db  64h	; d
unk_33CDB db	0
db  64h	; d
db    0
db  64h	; d
db    0
db  64h	; d
db    0
db  64h	; d
db    0
db  64h	; d
db    0
db  64h	; d
db    0
db  64h	; d
db    0
db  64h	; d
db    0
unk_33CEC db  7Dh ; }
db    0
db  7Dh	; }
db    0
db  7Dh	; }
db    0
db  64h	; d
db    0
unk_33CF4 db  7Dh ; }
db    0
unk_33CF6 db  5Ah ; Z
unk_33CF7 db	0
db  96h	; 
unk_33CF9 db	0
db  96h	; 
db    0
db  96h	; 
db    0
db  96h	; 
db    0
db  96h	; 
db    0
db  64h	; d
db    0
db  96h	; 
db    0
db  4Bh	; K
db    0
db 0C8h	; 
db    0
db 0C8h	; 
db    0
db 0C8h	; 
db    0
db 0C8h	; 
db    0
db 0C8h	; 
db    0
db  6Eh	; n
db    0
db 0C8h	; 
db    0
db  3Ch	; <
db    0
db  90h	; 
db    1
db  90h	; 
db    1
db  90h	; 
db    1
db  90h	; 
db    1
db  90h	; 
unk_33D21 db	1
db  96h	; 
unk_33D23 db	0
db  90h	; 
db    1
db  1Eh
unk_33D27 db	0
db    0
db    0
unk_33D2A db	0
db    5
unk_33D2C db	0
db    0
db    0
unk_33D2F db	0
unk_33D30 db	5
unk_33D31 db	0
db    0
db    0
db  0Ah
db    0
unk_33D36 db	0
db    0
db    0
db  0Ah
unk_33D3A db	0
db    0
db    0
db  0Ah
db    0
db    0
db    2
unk_33D41 db	0
db    0
db    0
unk_33D44 db	5
db    0
db    0
db    0
db    0
db    5
db    0
db    0
db    5
db    0
db    0
db    5
db    0
db    5
db    0
db    0
unk_33D54 db	3
unk_33D55 db	0
db    0
unk_33D57 db	0
db    0
db  0Ah
db  0Ah
db    0
db  0Fh
db    0
unk_33D5E db  1Eh
db    0
db  0Ah
db    0
db  0Ah
db    0
db  0Fh
db    0
db  0Fh
db    0
db  0Ah
db    0
db  0Ah
db    0
db  0Ah
db    0
unk_33D6E db	1	; DATA XREF: _f010509_MainMenuScreen+388o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  3Fh	; ?
db    1
unk_33D78 db 0C7h ; 
db    0
db    0
db    0
word_33D7C dw 0		; DATA XREF: _f010509_MainMenuScreen+3Ew
			; _f010609_DrawMainMenuScreen+1C6r
			; _f010609_DrawMainMenuScreen+1D0w
word_33D7E dw 1000h	; DATA XREF: __OvrPrepare+19r
			; __OvrPrepare+20r
stru_33D80 struct_CitySizes <'Outpost', 'Hamlet', \
		  'Village', 'Town', \
		  'City', 'Capital'>
stru_33DA9  = struct_CityEnchantments ptr $
db 'Summoning Circle',0 ; SummoningCircl
db 'Earth Gate',0       ; EarthGate
db 'Stream Of Life',0   ; StreamOfLife
db 'Astral Gate',0      ; AstralGate
db 'Fortress',0         ; Fortress
db 'Dark Rituals',0     ; DarkRituals
db 'Altar of Battle',0  ; AltarOfBattle
db 'Wall of Fire',0     ; WallOfFire
db 'Chaos Rift',0       ; ChaosRift
db 'Evil Presence',0    ; EvilPresence
db 'Cursed Lands',0     ; CursedLands
db 'Pestilence',0       ; Pestilence
db 'Cloud of Shadow',0  ; CloudOfShadow
db 'Famine',0           ; Famine
db 'Flying',0           ; Flying
db 'Nature Ward',0      ; NatureWard
db 'Sorcery Ward',0     ; SorceryWard
db 'Chaos Ward',0       ; ChaosWard
db 'Life Ward',0        ; LifeWard
db 'Death Ward',0       ; DeathWard
db 'Nature',27h,'s Eye',0; NatureSEye
db 'Stream of Life',0   ; StreamOfLife_0
db 'Gaia',27h,'s Blessing',0; GaiasBlessing
db 'Inspirations',0     ; Inspirations
db 'Prosperity',0       ; Prosperity
db 'Heavenly Light',0   ; HeavenlyLight
db 'Consecration',0     ; Consecration
db 'Wall of Darkness',0 ; WallOfDarkness
db 'Nightshade',0       ; Nightshade
stru_33F17 struct_HeroTitles <'Dwarf', 'Barbarian',\
		   'Sage', 'Dervish', \
		   'Beastmaster', \
		   'Bard', \
		   'Orc Warrior', \
		   'Healer', 'Huntress',\
		   'Thief', 'Druid', \
		   'War Monk', \
		   'Warrior Mage', \
		   'Magician', \
		   'Assassin', \
		   'Wind Mage', \
		   'Ranger', \
		   'Draconian', 'Witch',\
		   'Golden One', \
		   'Ninja', 'Rogue', \
		   'Amazon', 'Warlock', \
		   'Unknown', \
		   'Illusionist', \
		   'Swordsman', \
		   'Priestess', \
		   'Paladin', \
		   'Black Knight', \
		   'Elven Archer', \
		   'Necromancer', \
		   'Chaos Warrior', \
		   'Chosen'>
stru_34047 struct_Units	<'Trireme', 'Galley', \
	      'Catapult', 'Warship', \
	      'Spearmen', 'Swordsmen', \
	      'Bowmen', 'Cavalry', \
	      'Shaman', 'Settlers', \
	      'Berserkers', \
	      'Halberdiers', 'Priests', \
	      'Magicians', 'Engineers', \
	      'Centaurs', 'Manticores', \
	      'Minotaurs', \
	      'Nightblades', 'Warlocks',\
	      'Nightmares', \
	      'Doom Drakes', 'Air Ship',\
	      'Hammerhands', \
	      'Steam Cannon', 'Golem', \
	      'Wolf Riders', 'Slingers',\
	      'Longbowmen', \
	      'Elven Lords', 'Pegasai', \
	      'Pikemen', 'Paladins', \
	      'Stag Beetle', \
	      'Javelineers', \
	      'Dragon Turtle', \
	      'Horsebowmen', 'Rangers', \
	      'Griffins', \
	      'Wyvern Riders', \
	      'War Trolls', \
	      'War Mammoths', \
	      'Magic Spirit', \
	      'Hell Hounds', \
	      'Gargoyles', 'Fire Giant',\
	      'Fire Elemental', \
	      'Chaos Spawn', 'Chimera', \
	      'Doom Bat', 'Efreet', \
	      'Hydra', 'Great Drake', \
	      'Skeletons', 'Ghouls', \
	      'Night Stalker', \
	      'Werewolves', 'Demon', \
	      'Wraiths', \
	      'Shadow Demons', \
	      'Death Knights', \
	      'Demon Lord', 'Zombies', \
	      'Unicorns', \
	      'Guardian Spirit', \
	      'Angel', 'Arch Angel', \
	      'War Bears', 'Sprites', \
	      'Cockatrices', 'Basilisk',\
	      'Giant Spiders', \
	      'Stone Giant', 'Colossus',\
	      'Gorgons', \
	      'Earth Elemental', \
	      'Behemoth', 'Great Wyrm', \
	      'Floating Island', \
	      'Phantom Beast', \
	      'Phantom Warriors', \
	      'Storm Giant', \
	      'Air Elemental', 'Djinn', \
	      'Sky Drake', 'Nagas'>
stru_343C5 struct_Races	<'Beastmen', 'Dark Elf', \
	      'Dwarven', 'Gnoll', \
	      'Halfling', 'High Elf', \
	      'High Men', 'Klackon', \
	      'Lizardman', 'Nomad', \
	      'Orc', 'Troll'>
stru_34422 struct_MagicRealms <'Arcane', 'Nature', \
		    'Sorcery', 'Chaos', \
		    'Death'>
stru_34444 struct_SpecialAbilities <'Alchemy', \
			 'Warlord', \
			 'Chaos Mastery',\
			 'Nature Mastery',\
			 'Sorcery Mastery',\
			 'Infernal Power',\
			 'Divine Power',\
			 'Sage Master', \
			 'Channeler', \
			 'Myrran', \
			 'Archmage', \
			 'Mana Focusing',\
			 'Node Mastery',\
			 'Famous', \
			 'Runemaster', \
			 'Conjurer', \
			 'Charismatic', \
			 'Artificer'>
; char strCONFIG_MOM[]
strCONFIG_MOM db 'CONFIG.MOM',0
			; DATA XREF: _f010109_main+12o
			; _f010109_main+2Fo
			; _f010309_RUN+Co
			; _f010309_RUN+29o
; char strRunInstall[]
strRunInstall db 'Run INSTALL to configure MASTER OF '
			; DATA XREF: _f010109_main:MISSING_CONFIG_MOMo
			; _f010309_RUN:ConfigMomMissingo
db 'MAGIC.',0Ah
db 0Ah,0
strRBr1	db 'rb',0       ; DATA XREF: _f010109_main:OPEN_READ_ConfigMomo
			; _f010309_RUN:ConfigMomFoundo
strInitRoland db 'Initializing Roland Drivers...$',0
			; DATA XREF: _f010109_main:INIT_ROLAND_DRIVERSo
strSAVE	db 'SAVE',0     ; DATA XREF: _f010109_main+1D9o
			; _f010509_MainMenuScreen:SAVE_GAMo
strGAM db '.GAM',0      ; DATA XREF: _f010109_main+1F7o
			; _f010509_MainMenuScreen+105o
; char strMAGIC_SETr1[]
strMAGIC_SETr1 db 'MAGIC.SET',0
			; DATA XREF: _f010109_main+241o
strWBr1	db 'wb',0       ; DATA XREF: _f010109_main+23Do
strFONTSLBXr1 db 'FONTS.LBX',0
			; DATA XREF: _f010109_main+2AFo
; char strMUSIC[]
strMUSIC db 'music',0   ; DATA XREF: _f010109_main+385o
; char strThankYou[]
strThankYou db 'Thank you for playing Master of Mag'
			; DATA XREF: _f010309_RUN:ThankYouExito
db 'ic!',0
; char strMAINSCRN[]
strMAINSCRN db 'MAINSCRN',0
			; DATA XREF: _f010409_LoadVortexAnimationImages+4o
			; _f010409_LoadVortexAnimationImages+11o
			; _f010409_LoadVortexAnimationImages+7Do
			; _f010509_MainMenuScreen+344o
; char strVORTEX[]
strVORTEX db 'VORTEX',0 ; DATA XREF: _f010409_LoadVortexAnimationImages+23o
			; _f010409_LoadVortexAnimationImages+35o
			; _f010409_LoadVortexAnimationImages+47o
			; _f010409_LoadVortexAnimationImages+59o
			; _f010409_LoadVortexAnimationImages+6Bo
; char strWIZARDS[]
strWIZARDS db 'WIZARDS',0
			; DATA XREF: _f010409_LoadVortexAnimationImages+8Bo
			; _f010409_LoadVortexAnimationImages+9Ao
strSPELLDAT db 'SPELLDAT',0
			; DATA XREF: _f010409_LoadVortexAnimationImages+B3o
			; LBX_SpellDat+11o
strC db	'C',0           ; DATA XREF: _f010509_MainMenuScreen+30Bo
strL db	'L',0           ; DATA XREF: _f010509_MainMenuScreen+32Bo
strH db	'H',0           ; DATA XREF: _f010509_MainMenuScreen+356o
strQ db	'Q',0           ; DATA XREF: _f010509_MainMenuScreen+368o
strESC db 1Bh,0		; DATA XREF: _f010509_MainMenuScreen+37Ao
strTERRSTAT db 'TERRSTAT',0
			; DATA XREF: fncLoadTERRSTAT+11o
strHLPENTRY db 'hlpentry',0
			; DATA XREF: LBX_HelpEntry_s13EEE:loc_13F04o
strSAVEGAMr2_1 db 'SAVE',0
			; DATA XREF: OVR_SaveGame_MagicSet+1Fo
			; ST_LoadSaveGamByNbr+1Do
strSAVEGAMr2_2 db '.GAM',0
			; DATA XREF: OVR_SaveGame_MagicSet+3Do
			; ST_LoadSaveGamByNbr+3Bo
strWBr2	db 'wb',0       ; DATA XREF: OVR_SaveGame_MagicSet+4Co
			; OVR_SaveGame_MagicSet+3C0o
; char strMAGIC_SETr2[]
strMAGIC_SETr2 db 'MAGIC.SET',0
			; DATA XREF: OVR_SaveGame_MagicSet+3C4o
strRBr2	db 'rb',0       ; DATA XREF: ST_LoadSaveGamByNbr:loc_3CC3Bo
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  3Fh	; ?
db    1
db 0C7h	; 
db    0
word_3461A dw 0FFFFh	; DATA XREF: _f010309_RUN:loc_136E5w
			; _f010509_MainMenuScreen:loc_1380Bw
			; sub_3CFC0:loc_3D35Fr
			; sub_3CFC0:loc_3D36Cw
			; sub_3DBA6+E3r
a5 db '5',0             ; DATA XREF: sub_3CFC0+Do
a@ db '@',0
aK db 'K',0
aF db 'f',0
aQ db 'q',0
db '|',0
aZ db '',0
aS db '',0
aT db '',0
aA db '',0
aZ_0 db	'',0
aG db '',0
aO db '',0
word_34636 dw 6262h	; DATA XREF: sub_3D378:loc_3D383r
word_34638 dw 6262h	; DATA XREF: sub_3D378+8r
strLOAD_LBX db 'LOAD.LBX',0
			; DATA XREF: sub_3CFC0+22o
			; sub_3CFC0+39o
			; sub_3CFC0+56o
			; sub_3CFC0+7Eo
			; sub_3CFC0+A6o
			; ST_MagicSet_ReadCreateWrite+D8o
			; ST_DefaultMagicSet+C6o
; BCpp30_DOSH_dosSearchInfo strMAGIC_SETr3
strMAGIC_SETr3 db 'MAGIC.SET',0
			; DATA XREF: sub_3CFC0+C4o
			; sub_3CFC0+DEo
			; sub_3CFC0+2BCo
			; ST_MagicSet_ReadCreateWrite+Co
			; ST_MagicSet_ReadCreateWrite+1Bo
			; ST_MagicSet_ReadCreateWrite+37o
			; ST_MagicSet_ReadCreateWrite+5Co
			; ST_MagicSet_ReadCreateWrite+F8o
strRBr3	db 'rb',0       ; DATA XREF: sub_3CFC0:Read_MagicSeto
			; ST_MagicSet_ReadCreateWrite:SIZE_GOODo
db 1Bh,0
db  4Fh	; O
db    0
strWBr3	db  77h	; w	; DATA XREF: sub_3CFC0:Write_MagicSeto
			; ST_MagicSet_ReadCreateWrite+33o
			; ST_MagicSet_ReadCreateWrite+F4o
db  62h	; b
db    0
aSoundEffects db 'Sound Effects',0
aBackgroundMusic db 'Background Music',0
aEventMusic db 'Event Music',0
aCitySpellEvent	db 'City Spell Events',0
aOverlandSpellE	db 'Overland Spell Events',0
aSummoningEvent	db 'Summoning Events',0
aEndOfTurnSumma	db 'End of Turn Summary',0
aRazeCity db 'Raze City',0
aRandomEvents db 'Random Events',0
aEndOfTurnWait db 'End of Turn Wait',0
aStrategicComba	db 'Strategic Combat Only',0
aAutoUnitInform	db 'Auto Unit Information',0
aMovementAnimat	db 'Movement Animations',0
aEnemyMoves db 'Enemy Moves',0
aEnemySpells db	'Enemy Spells',0
aSpellBookOrder	db 'Spell Book Ordering',0
aSpellAnimation	db 'Spell Animations',0
aShowNodeOwners	db 'Show Node Owners',0
aExpandingHelp db 'Expanding Help',0
aSoundAndMusic db 'Sound and Music',0
aMessages db 'Messages',0
aCombat	db 'Combat',0
aDisplay db 'Display',0
aHlpentry_lbx db 'hlpentry.lbx',0
			; DATA XREF: LBX_HelpEntry_s3D9F3+16o
align 2
unk_347CC db	1	; DATA XREF: sub_3DBA6+14Ao
			; sub_3E1DE:loc_3E3A3o
			; idk_Load_NEWGAME_LBX+33o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
a?_0 db	'?',1,'',0
unk_347D8 db  1Fh	; DATA XREF: idk_Load_NEWGAME_LBX+91o
db  1Eh
db  1Dh
db  1Ch
db  1Bh
db  1Ah
db  19h
db  18h
aMerlin	db 'Merlin',0
db    0
db    0
db    0
db    5
db    0
db    0
db    0
db    5
db    0
db    0
db    0
db    0
db    0
db    7
db    0
aRaven db 'Raven',0
db    0
db    0
db    0
db    0
db    0
db    0
db    6
db    0
db    5
db    0
db    0
db    0
db    0
db    0
db 0FFh
db 0FFh
aSharee	db 'Sharee',0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    5
db    0
db    5
db    0
db  0Fh
db    0
aLoPan db 'Lo Pan',0
unk_34829 db	0
unk_3482A db	0
db    0
db    0
db    0
db    5
db    0
unk_34830 db	0
db    0
db    0
db    0
unk_34834 db	5
db    0
db    8
db    0
aJafar db 'Jafar',0
db    0
db    0
db    0
unk_34841 db	0
unk_34842 db	0
db    0
db  0Ah
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
aOberic	db 'Oberic',0
db    0
db    0
db    0
db    0
unk_34859 db	0
unk_3485A db	0
db    0
db    5
db    0
db    0
db    0
db    5
db    0
db  0Bh
db    0
aRjak db 'Rjak',0
unk_34869 db	0
db    0
unk_3486B db	0
db    0
unk_3486D db	0
db    0
db    0
unk_34870 db	0
db    0
unk_34872 db	0
db    0
db    9
db    0
db    0
db    0
db    5
db    0
aSssRa db 'Sss',27h,'ra',0
align 4
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3488C dw 4		; DATA XREF: sub_5301E+8B9w
word_3488E dw 9		; DATA XREF: sub_5301E+8B3w
aTauron	db 'Tauron',0
db    0
db    0
unk_34899 db	0
unk_3489A db	0
db    0
db    0
db    0
unk_3489E db	0
db    0
db    0
db    0
db  0Ah
db    0
db    2
db    0
aFreya db 'Freya',0
db    0
unk_348AD db	0
db    0
db    0
db    0
db    0
unk_348B2 db	0
db    0
db  0Ah
db    0
db    0
db    0
db    0
db    0
db    3
db    0
aHorus db 'Horus',0
db    0
db    0
db    0
db    0
db    5
db    0
db    5
db    0
db    0
db    0
db    0
db    0
unk_348CE db	0
db    0
db  0Ah
db    0
aAriel db 'Ariel',0
db    0
db    0
db    0
db    0
db  0Ah
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  10h
db    0
aTlaloc	db 'Tlaloc',0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    4
db    0
db    5
db    0
db    0
db    0
db    1
db    0
aKali db 'Kali',0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    5
db    0
db    0
db    0
unk_3490E db	5
db    0
db    0
db    0
db  11h
unk_34913 db	0
aCustom	db 'Custom',0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0FFh
db 0FFh
db    2
db    0
db    3
db    0
db    4
db    0
db    5
db    0
db    6
db    0
db    7
db    0
unk_34936 db	8
db    0
unk_34938 db	9
db    0
db  0Ah
db    0
db  0Bh
db    0
db    1
db    0
db    2
db    0
db    3
db    0
db    4
db    0
db    5
db    0
db    6
db    0
db    7
db    0
db    8
db    0
db    9
db    0
db  0Ah
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
db    0
unk_34966 db	0
db    0
unk_34968 db	0
unk_34969 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
unk_34979 db	0
unk_3497A db	6
db    0
db    7
db    0
unk_3497E db	9
db    0
db    8
db    0
db    4
db    0
db    5
db    0
db    1
db    0
db    3
unk_34989 db	0
db    2
unk_3498B db	0
db  0Ah
unk_3498D db	0
db  11h
db    0
db  0Fh
unk_34991 db	0
word_34992 dw 1Bh	; DATA XREF: sub_430A4+122r
a1 db '1',0
db  32h	; 2
db    0
db  2Dh	; -
db    0
db  2Bh	; +
db    0
db  2Eh	; .
db    0
db  30h	; 0
db    0
db  2Fh	; /
db    0
db  2Ah	; *
db    0
db  29h	; )
db    0
db  2Ch	; ,
db    0
db  38h	; 8
db    0
db  3Ch	; <
db    0
word_349AC dw 41h	; DATA XREF: sub_430A4+17Ar
db  53h	; S
db    0
db  5Ah	; Z
unk_349B1 db	0
db  56h	; V
db    0
unk_349B4 db  54h ; T
db    0
db  55h	; U
db    0
db  59h	; Y
db    0
db  58h	; X
db    0
db  57h	; W
db    0
db  52h	; R
db    0
db  51h	; Q
unk_349C1 db	0
db  5Bh	; [
db    0
db  61h	; a
db    0
word_349C6 dw 6Ah	; DATA XREF: sub_430A4+1D2r
db  82h	; 
db    0
db  81h	; 
db    0
db  7Eh	; ~
db    0
db  7Fh	; 
db    0
db  7Dh	; }
db    0
db  7Ch	; |
db    0
db  7Ah	; z
db    0
db  7Bh	; {
db    0
db  80h	; 
unk_349D9 db	0
db  79h	; y
db    0
unk_349DC db  85h ; 
db    0
db  88h	; 
db    0
word_349E0 dw 93h	; DATA XREF: sub_430A4+22Ar
db 0A7h	; 
db    0
unk_349E4 db 0A6h ; 
db    0
db 0A2h	; 
db    0
db 0A3h	; 
db    0
db 0A5h	; 
db    0
db 0A9h	; 
db    0
unk_349EE db 0A8h ; 
db    0
unk_349F0 db 0A1h ; 
db    0
db 0AAh	; 
db    0
db 0A4h	; 
db    0
db 0AEh	; 
db    0
unk_349F8 db 0AFh ; 
db    0
word_349FA dw 0B8h	; DATA XREF: sub_430A4+282r
db    0
db    0
db    0
db    0
db    0
unk_34A01 db	0
unk_34A02 db	0
unk_34A03 db	0
db    0
db    0
db    0
db    0
unk_34A08 db	0
db    0
db    0
unk_34A0B db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    4
unk_34A21 db	0
db    0
db    0
unk_34A24 db	0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_34A30 db	4
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    4
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    4
db    0
db    0
db    0
db    0
unk_34A4D db	0
db    0
db    0
db    0
db    0
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_34A75 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_34A86 db	0
db    0
unk_34A88 db	4
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_34A95 db	0
db    4
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    3
db    0
unk_34AA8 db	0
unk_34AA9 db	0
unk_34AAA db	0
db    0
db    1
db    0
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_34AB9 db	0
db    0
unk_34ABB db	0
db    0
unk_34ABD db	0
db    0
db    0
db    2
db    0
unk_34AC2 db	3
db    0
db    0
db    0
db    0
db    0
unk_34AC8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_34AD9 db	0
unk_34ADA db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_34AE1 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_34AE9 db	0
db    0
unk_34AEB db	0
db    0
unk_34AED db	0
db    0
db    0
db    0
db    0
unk_34AF2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    8
db    0
db  0Ah
db    0
db  11h
unk_34B01 db	0
db  0Fh
db    0
unk_34B04 db	7
db    0
db    9
db    0
db    6
db    0
db  0Dh
db    0
db  0Eh
db    0
db  10h
unk_34B0F db	0
db    2
db    0
db    3
db    0
db    4
db    0
db    5
db    0
db  0Bh
db    0
db  0Ch
db    0
word_34B1C dw 6666h	; DATA XREF: sub_3DF8C+Br
word_34B1E dw 6666h	; DATA XREF: sub_3DF8C+8r
word_34B20 dw 6160h	; DATA XREF: sub_3DF8C+18r
word_34B22 dw 6160h	; DATA XREF: sub_3DF8C+15r
word_34B24 dw 1F1Fh	; DATA XREF: sub_3E60E+Ar
word_34B26 dw 1F1Fh	; DATA XREF: sub_3E60E+7r
word_34B28 dw 0BBBBh	; DATA XREF: sub_3E60E+17r
word_34B2A dw 0BBBBh	; DATA XREF: sub_3E60E+14r
aIntro db 'Intro',0
db    0
db    0
db    0
db    0
db    0
aEasy db 'Easy',0
db    0
db    0
db    0
db    0
db    0
db    0
aNormal	db 'Normal',0
db    0
db    0
db    0
db    0
aHard db 'Hard',0
align 8
aImpossible db 'Impossible',0
aSmall db 'Small',0
unk_34B69 db	0
aMedium	db 'Medium',0
aLarge db 'Large',0
align 2
aWeak db 'Weak',0
unk_34B7D db	0
db    0
db    0
db    0
aNormal_0 db 'Normal',0
db    0
db    0
aPowerful db 'Powerful',0
aOne db	'One',0
db    0
db    0
db    0
db    0
aTwo db	'Two',0
db    0
db    0
db    0
db    0
aThree db 'Three',0
unk_34BA9 db	0
unk_34BAA db	0
aFour db 'Four',0
db    0
db    0
db    0
db  1Fh
db  1Fh
db  1Fh
unk_34BB6 db  1Fh
db  1Fh
unk_34BB8 db  1Fh
unk_34BB9 db  1Fh
db    0
unk_34BBB db 0BBh ; 
db 0BBh	; 
unk_34BBD db 0BBh ; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
unk_34BC2 db 0BBh ; 
word_34BC3 dw 0B2B7h	; DATA XREF: sub_3EDD1+2Cr
unk_34BC5 db  1Fh	; DATA XREF: sub_3F6BF+Bo
db  1Fh
db  1Fh
db  1Fh
db  1Fh
db  1Fh
db  1Fh
unk_34BCC db	0
unk_34BCD db 0BBh ; 	; DATA XREF: sub_3F6BF+1Do
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
unk_34BD9 db 0BBh ; 
unk_34BDA db 0BBh ; 
db 0BBh	; 
db 0BBh	; 
db  1Fh
unk_34BDE db  1Fh
db  1Fh
db  1Fh
db  1Fh
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
unk_34BE6 db 0BBh ; 
db    0
unk_34BE8 db	0
unk_34BE9 db	0
db    5
unk_34BEB db	0
db    6
unk_34BED db	0
db    7
db    0
db    8
db    0
unk_34BF2 db	9
db    0
db  0Ah
db    0
db  0Bh
db    0
db  0Ch
db    0
db    1
unk_34BFB db	0
db    2
db    0
db    3
db    0
db    4
db    0
db  0Dh
db    0
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
word_34C0C dw 0B014h	; DATA XREF: sub_3FBE0+3Er
word_34C0E dw 3219h	; DATA XREF: sub_3FBE0+44r
word_34C10 dw 202h	; DATA XREF: sub_3FBE0+4Ar
align 4
unk_34C14 db	5
db    0
db    6
db    0
db    7
unk_34C19 db	0
db    8
db    0
db    9
db    0
unk_34C1E db  0Ah
db    0
db  0Bh
db    0
db  0Ch
db    0
db    1
db    0
db    2
db    0
db    3
db    0
db    4
db    0
db  0Dh
db    0
db  1Fh
db  1Fh
unk_34C30 db  1Fh
unk_34C31 db  1Fh
db  1Fh
db 0BBh	; 
unk_34C34 db 0BBh ; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0B4h	; 
db 0B4h	; 
db 0B4h	; 
db 0B4h	; 
db 0B4h	; 
word_34C3D dw 0B014h	; DATA XREF: sub_40037+62r
word_34C3F dw 3219h	; DATA XREF: sub_40037+68r
word_34C41 dw 1619h	; DATA XREF: sub_40037+6Er
word_34C43 dw 202h	; DATA XREF: sub_40037+74r
; int word_34C45
word_34C45 dw 0BBBBh	; DATA XREF: sub_4043A+Cr
word_34C47 dw 0BBBBh	; DATA XREF: sub_4043A+9r
word_34C49 dw 0B2B7h	; DATA XREF: sub_4043A+16r
align 2
unk_34C4C db 0FFh
db 0FFh
unk_34C4E db 0FFh
unk_34C4F db 0FFh
unk_34C50 db 0FFh
unk_34C51 db 0FFh
db 0FFh
db 0FFh
db 0FFh
db 0FFh
unk_34C56 db 0FFh
db 0FFh
aLife db 'Life',0
db    0
db    0
db    0
db    0
unk_34C61 db	0
aDeath_0 db 'Death',0
db    0
unk_34C69 db	0
db    0
unk_34C6B db	0
aChaos_0 db 'Chaos',0
unk_34C72 db	0
db    0
unk_34C74 db	0
db    0
aNature_0 db 'Nature',0
align 4
aSorcery_0 db 'Sorcery',0
db    0
unk_34C89 db	0
unk_34C8A db	1
db    0
db    2
db    0
db    8
db    0
db    9
db    0
db  0Fh
db    0
db    1
db    0
db    2
db    0
unk_34C98 db	8
unk_34C99 db	0
db    9
unk_34C9B db	0
db  0Fh
unk_34C9D db	0
db  1Fh
db  1Fh
db  1Fh
db  1Fh
unk_34CA2 db  1Fh
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
word_34CA8 dw 3219h	; DATA XREF: sub_40EC0+3Er
word_34CAA dw 1619h	; DATA XREF: sub_40EC0+44r
word_34CAC dw 0B216h	; DATA XREF: sub_40EC0+4Ar
word_34CAE dw 1010h	; DATA XREF: sub_40EC0+50r
db    1
db    1
db    1
db    0
db    1
db    1
unk_34CB6 db	0
db    1
unk_34CB8 db	0
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    3
db    0
db    4
db    0
db    2
unk_34CC7 db	0
db    0
unk_34CC9 db	0
unk_34CCA db	1
db    0
db  1Ah
db    0
unk_34CCE db  4Dh ; M
db    0
db  80h	; 
unk_34CD1 db	0
db  25h	; %
db    0
db  58h	; X
db    0
db  8Bh	; 
db    0
db  1Fh
unk_34CD9 db  1Fh
unk_34CDA db  1Fh
unk_34CDB db  1Fh
db  1Fh
unk_34CDD db 0BBh ; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
db 0BBh	; 
unk_34CE2 db  1Ah
db    0
db  4Dh	; M
db    0
unk_34CE6 db  80h ; 
unk_34CE7 db	0
unk_34CE8 db  25h ; %
unk_34CE9 db	0
unk_34CEA db  58h ; X
db    0
db  8Bh	; 
db    0
word_34CEE dw 3219h	; DATA XREF: sub_4276F+2Dr
word_34CF0 dw 0B216h	; DATA XREF: sub_4276F+33r
word_34CF2 dw 1010h	; DATA XREF: sub_4276F+39r
aCommon	db 'Common',0
db    0
db    0
db    0
aUncommon db 'Uncommon',0
align 2
aRare db 'Rare',0
unk_34D0D db	0
db    0
db    0
unk_34D10 db	0
unk_34D11 db	0
aVeryRare db 'Very Rare',0
aNature_1 db 'Nature',0
db    0
db    0
db    0
aSorcery_1 db 'Sorcery',0
align 4
aChaos_1 db 'Chaos',0
db    0
db    0
db    0
unk_34D39 db	0
aLife_0	db 'Life',0
align 2
unk_34D40 db	0
unk_34D41 db	0
unk_34D42 db	0
db    0
aDeath_1 db 'Death',0
db    0
db    0
db    0
db    0
strWIZARDSEXE db 'WIZARDS.EXE',0
			; DATA XREF: sub_3DB5F+38o
			; sub_3DB5F:loc_3DB8Bo
			; sub_3DBA6:loc_3DE09o
			; sub_3DBA6+2B7o
; char arg0[]
arg0 db	'JENNY',0       ; DATA XREF: sub_3DB5F+30o
			; sub_3DB5F+34o
strLOADLBXr2 db	'LOAD.LBX',0
			; DATA XREF: sub_3DBA6+Fo
			; sub_3DBA6+26o
			; sub_3DBA6+3Do
			; sub_3DBA6+54o
			; sub_3DBA6+6Bo
			; sub_3DBA6+82o
			; sub_3DBA6+99o
			; sub_3DBA6+B0o
			; sub_3DBA6+C7o
asc_34D69 db 1Bh,0	; DATA XREF: sub_3DBA6+15Eo
			; sub_3DBA6+16Fo
db 'L',0
strSAVEGAMr3_1 db 'SAVE',0
			; DATA XREF: sub_3DBA6:loc_3DD74o
strSAVEGAMr3_2 db '.GAM',0
			; DATA XREF: sub_3DBA6+1FDo
strSimTexCopyright db 'Copyright  Simtex Software, 1995   '
db 'V1.31',0
strNEWGAMELBX db 'NEWGAME.LBX',0
			; DATA XREF: sub_3E1DE+6Bo
			; sub_3E1DE+82o
			; sub_3E1DE+99o
			; sub_3E1DE+B0o
			; sub_3E1DE+C7o
			; sub_3E1DE+DEo
			; sub_3E1DE+F5o
			; sub_3E1DE+10Co
			; idk_Load_NEWGAME_LBX+Do
			; idk_Load_NEWGAME_LBX+24o
			; sub_4067D+36o
			; sub_4067D+4Do
			; sub_4067D+64o
			; sub_4067D+81o
			; sub_4067D+A3o
			; sub_4067D+BAo
			; sub_4067D+D1o
			; LBX_NewGame_s41A5F:loc_41A81o
			; LBX_NewGame_s41A5F+39o
			; LBX_NewGame_s41A5F+50o
			; LBX_NewGame_s41A5F+67o
			; LBX_NewGame_s41A5F+7Eo
			; LBX_NewGame_s41A5F+95o
			; LBX_NewGame_s41A5F:loc_41B0Bo
			; LBX_NewGame_s41A5F+C3o
			; LBX_NewGame_s41A5F:loc_41B3Fo
			; LBX_NewGame_s41A5F+102o
			; LBX_NewGame_s41A5F:loc_41B78o
			; LBX_NewGame_s41A5F:loc_41B8Fo
; BCpp30_DOSH_dosSearchInfo strMAGICSETr4
strMAGICSETr4 db 'MAGIC.SET',0
			; DATA XREF: sub_3E1DE+11Fo
			; sub_3E1DE+12Eo
			; sub_3E1DE+14Co
			; sub_3E1DE+339o
strRBr4	db 'rb',0       ; DATA XREF: sub_3E1DE:loc_3E326o
strWBr4	db 'wb',0       ; DATA XREF: sub_3E1DE+335o
aSelectWizard db 'Select Wizard',0
aSelectPicture db 'Select Picture',0
a__0 db	'.',0
aWizardSName db	'Wizard',27h,'s Name',0
			; DATA XREF: sub_3F6BF+5Fo
aSelectBanner db 'Select Banner',0
aYouCanNotSelec	db 'You can not select a Myrran race un'
db 'less you have the Myrran special.',0
aSelectRace db 'Select Race',0
aArcanianRaces db 'Arcanian Races:',0
aMyrranRaces db	'Myrran Races:',0
aYouNeedToMakeA	db 'You need to make all your picks bef'
			; DATA XREF: sub_4067D:loc_40A8Bo
			; LBX_NewGame_s41A5F:loc_42142o
db 'ore you can continue',0
aYouMayNotSelec	db 'You may not select more than 6 spec'
			; DATA XREF: sub_4067D:loc_40A9Eo
db 'ial abilities',0
aToSelect db 'To select ',0
			; DATA XREF: sub_4067D:loc_40AA3o
aYouNeed db ' you need:   ',0
			; DATA XREF: sub_4067D+44Co
aPicksIn db ' picks in ',0
			; DATA XREF: sub_4067D+4D8o
aMagic db ' Magic',0    ; DATA XREF: sub_4067D+502o
			; sub_4067D+693o
aPick db ' pick',0      ; DATA XREF: sub_4067D+561o
aSInAny	db 's in any ',0
			; DATA XREF: sub_4067D:PLURAL_PicksInAnyo
			; sub_4067D:SINGULAR_PickInAnyo
aRealmsOfMagic db ' Realms of Magic',0
			; DATA XREF: sub_4067D+5DFo
aRealmOfMagic db 'Realm of Magic',0
			; DATA XREF: sub_4067D:loc_40C61o
aComma db ', ',0        ; DATA XREF: sub_4067D+623o
aPickIn	db ' pick in ',0 ; DATA XREF: sub_4067D+669o
aYouCanNotSel_0	db 'You can not select both Life and De'
			; DATA XREF: sub_4067D:loc_40D2Eo
db 'ath magic',0
aYouHaveAlready	db 'You have already made all your pick'
			; DATA XREF: sub_4067D:loc_40D34o
db 's',0
aYouDonTHaveEno	db 'You don',27h,'t have enough picks left'
			; DATA XREF: sub_4067D:loc_40D3Ao
db ' to make this selection. You need 2'
db ' picks',0
aHlpentry_lbx_0	db 'hlpentry.lbx',0
			; DATA XREF: LBX_NewGame_s41A5F:loc_41C0Do
			; LBX_HelpEntry_s433B8+16o
			; LBX_HelpEntry_s433EB+16o
			; LBX_HelpEntry_s4341E:loc_43434o
			; LBX_HelpEntry_s43451+16o
			; LBX_HelpEntry_s43484+16o
			; LBX_HelpEntry_s434C3+16o
			; LBX_HelpEntry_s434F6+16o
aYouHaveNoPicks	db 'You have no picks left in this area'
			; DATA XREF: LBX_NewGame_s41A5F:loc_42154o
db ', to deselect click on a selected i'
db 'tem',0
aSelect	db 'Select ',0
aSpells	db ' Spells',0
db ': ',0
aAnd db	' and ',0
db    0
db    0
db    0
db 0FFh
db 0FFh
db    0
db    0
db    1
db    0
db    0
db    0
db    1
db    0
unk_35050 db	0
db    0
db 0FFh
db 0FFh
db    0
db    0
db    0
db    0
db    2
db    0
db    3
db    0
db    0
db    0
db    1
db    0
db    0
unk_35061 db	0
unk_35062 db 0FFh
db 0FFh
db    0
db    0
unk_35066 db	1
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db 0FFh
db 0FFh
db    0
db    0
db    0
db    0
unk_35074 db	6	; DATA XREF: idk_BuildingWorlds+2Do
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  3Fh	; ?
db    1
db 0C7h	; 
db    0
db  26h	; &
db  34h	; 4
db  2Ch	; ,
db  34h	; 4
db  37h	; 7
db  34h	; 4
db  43h	; C
db  34h	; 4
db  50h	; P
db  34h	; 4
db  60h	; `
db  34h	; 4
db  68h	; h
db  34h	; 4
db  77h	; w
db  34h	; 4
aJ4u4b4v db '444',0
aV_0 db	'',0
aV_1 db	'',0
aV_2 db	'',0
db '',0
db '',0
db '',0
db '',0
asc_350A6 db '',0
db '',0
db '',0
db '',0
db '',0
db '',0
aS_0 db	'',0
db '',0
db '',0
db '',0
db '',0
db '',0
aA_0 db	'',0
aU db '',0
aQ_0 db	'',0
aA_1 db	'',0
db '',0
db '',0
aI db '',0
db '',0
db 0FBh	; 
db    0
db 0FCh	; 
unk_350D1 db	0
unk_350D2 db 0FDh ; 
db    0
db 0FEh	; 
db    0
db 0BAh	; 
db    0
db 0BAh	; 
db    0
db 0BAh	; 
db    0
db 0BAh	; 
db    0
db 0C0h	; 
db    0
db 0C4h	; 
db    0
db 0ECh	; 
db    0
db 0C0h	; 
db    0
db 0F0h	; 
db    0
db 0F1h	; 
db    0
db 0F2h	; 
db    0
db 0F0h	; 
db    0
unk_350EE db 0F3h ; 
db    0
unk_350F0 db 0F4h ; 
db    0
db 0F5h	; 
db    0
db 0F6h	; 
db    0
db 0BEh	; 
db    0
db 0C2h	; 
db    0
db 0EAh	; 
db    0
db 0BEh	; 
db    0
db 0FFh
db    0
db    0
db    1
db    1
db    1
db    2
db    1
db 0F7h	; 
db    0
db 0F8h	; 
db    0
db 0F9h	; 
db    0
db 0FAh	; 
db    0
db 0D4h	; 
db    1
db 0D5h	; 
db    1
db 0D6h	; 
db    1
db 0D7h	; 
db    1
strBUILDDAT db 'BUILDDAT',0
			; DATA XREF: idk_BuildingWorlds+13o
aBuildingTheWorlds db 'Building The Worlds...',0
			; DATA XREF: idk_BuildingWorlds+69o
aTower db 'tower',0
aChaosNode db 'chaos node',0
aNatureNode db 'nature node',0
aSorceryNode db	'sorcery node',0
aMysteriousCave	db 'mysterious cave',0
aDungeon db 'dungeon',0
aAncientTemple db 'ancient temple',0
aAbandonedKeep db 'abandoned keep',0
aMonsterLair db	'monster lair',0
aAncientRuins db 'ancient ruins',0
aFallenTemple db 'fallen temple',0
strTERRTYPE db 'TERRTYPE',0
			; DATA XREF: LBX_Terrtype_s472C7+26o
			; LBX_Terrtype_s4763F+26o
			; LBX_Terrtype_s48821+26o
strCITYNAME db 'CITYNAME',0
			; DATA XREF: LBX_Cityname_s4B973+23o
align 4
db  11h
db  11h
db  11h
db  11h
db  11h
db    6
db    9
db  0Bh
db  0Dh
db  0Fh
db  14h
db 0B2h	; 
unk_351E0 db 0B3h ; 
db 0B4h	; 
db 0B4h	; 
unk_351E3 db  66h ; f
db 0FBh	; 
db 0FBh	; 
unk_351E6 db 0FBh ; 
db 0FBh	; 
db 0E4h	; 
db 0E4h	; 
db 0E4h	; 
db 0E4h	; 
db 0E4h	; 
db  2Dh	; -
db  2Dh	; -
db  2Dh	; -
db  2Dh	; -
db  2Dh	; -
word_351F2 dw 0		; DATA XREF: sub_4D5B0:loc_4D662r
word_351F4 dw 0		; DATA XREF: sub_4D5B0:loc_4D676r
word_351F6 dw 0		; DATA XREF: sub_4E9F4+BDr
			; sub_4E9F4+1C4r
			; sub_4EF74+C2r
			; sub_4EF74:loc_4F14Dr
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db 0F0h	; 
db  14h
db  14h
db  14h
db  14h
db  14h
db  19h
db 0B2h	; 
unk_3520E db 0B3h ; 
db 0B4h	; 
unk_35210 db 0B4h ; 
db  19h
db 0B2h	; 
db 0B3h	; 
db 0B4h	; 
db 0B4h	; 
db  19h
db 0B2h	; 
db 0B3h	; 
db 0B4h	; 
db 0B4h	; 
db  19h
db 0B2h	; 
db 0B3h	; 
db 0B4h	; 
db 0B4h	; 
db 0FEh	; 
db 0FFh
db    0
db    0
db 0EAh	; 
db 0FFh
db    8
db    0
db    2
db    0
db    2
db    0
db 0ECh	; 
db 0FFh
db 0FCh	; 
db 0FFh
db 0F4h	; 
db 0FFh
db 0FDh	; 
db 0FFh
db  46h	; F
db    0
db  49h	; I
db    0
db  3Eh	; >
db    0
db  44h	; D
unk_3523B db	0
db  46h	; F
db    0
word_3523E dw 1		; DATA XREF: sub_50203:loc_502B4r
			; sub_50203+B7w
			; sub_50203:loc_502BEr
			; sub_50203+D5r
			; sub_50203+FCr
			; sub_50203+11Fr
			; sub_50203:loc_50341w
			; sub_5034B+3w
strRESOURCE db 'RESOURCE',0
			; DATA XREF: idk_ResourceLbx+47o
			; idk_ResourceLbx+5Eo
			; idk_ResourceLbx+75o
			; idk_ResourceLbx+8Fo
			; idk_ResourceLbx+A6o
			; idk_ResourceLbx+BDo
			; idk_ResourceLbx+D7o
			; idk_ResourceLbx+EEo
			; idk_ResourceLbx+105o
			; idk_ResourceLbx+11Eo
			; idk_ResourceLbx+135o
			; idk_ResourceLbx+16Bo
strYES db 'Y',0
strNO db 'N',0
db 1Bh,0
align 2
db    2
db    0
db    1
db    0
db    3
db    0
db    0
db    0
db    4
db    0
db    1
db    0
db    0
db    0
db    1
db    0
db    1
db    0
db    1
unk_35263 db	0
db    5
db    0
db    2
db    0
db    1
db    0
db    2
db    0
db    3
db    0
db    1
db    0
db    2
db    0
db    1
db    0
db    1
db    0
db    2
db    0
db    2
db    0
db    5
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    2
db    0
db    0
db    0
db    2
db    0
db    5
db    0
db    3
db    0
db    3
db    0
db    2
db    0
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3529F db	0
unk_352A0 db	0
db    0
db    0
db    0
db    0
db    0
db    2
db    0
db    2
db    0
db    4
db    0
db    2
db    0
db    0
db    0
db    1
db    0
db    4
db    0
db    2
db    0
unk_352B6 db	3
db    0
db    0
db    0
db    3
db    0
db    2
db    0
db    2
db    0
db    3
db    0
db    0
db    0
db    2
db    0
db    3
db    0
db    4
db    0
db    1
db    0
db    0
db    0
db    4
db    0
unk_352D0 db	1
db    0
db    1
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_352E0 db	0
unk_352E1 db	0
unk_352E2 db	0
db    0
db    0
db  10h
unk_352E6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db  20h
db    0
db    2
db    0
db  2Ah	; *
db    0
unk_35310 db  30h ; 0
unk_35311 db	0
unk_35312 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  20h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3532C db	0
db    0
db    0
db    0
db    1
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3533E db	1
db    0
unk_35340 db	0
db  40h	; @
db    1
db    0
db  2Eh	; .
db    0
db  35h	; 5
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
unk_35350 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
unk_35360 db	1
db    0
db    0
db    0
db    0
db  40h	; @
db    2
db    0
db  7Dh	; }
db    0
db    0
db    0
db    0
db    0
unk_3536E db	0
db    0
unk_35370 db	1
db    0
db    0
db    0
db  40h	; @
db    0
unk_35376 db	0
db  40h	; @
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0D0h	; 
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
unk_3539D db	0
db  0Dh
db    0
unk_353A0 db  16h
unk_353A1 db	0
unk_353A2 db	5
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_353B6 db	0
db    0
db    1
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db  56h	; V
db    0
db  58h	; X
unk_353C5 db	0
db  5Eh	; ^
db    0
db    0
db    0
db    1
unk_353CB db	0
db    1
db    0
db    0
db    0
unk_353D0 db	4
db    0
db    3
db    0
db  53h	; S
db    0
db  60h	; `
db    0
db  5Ah	; Z
db    0
db  6Dh	; m
db    0
db    1
db    0
db    0
db    0
unk_353E0 db  40h ; @
unk_353E1 db	0
unk_353E2 db	0
db    0
db    0
unk_353E5 db	0
unk_353E6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    2
db    0
db  2Fh	; /
db    0
db  2Ch	; ,
unk_353FB db	0
db    0
db    0
unk_353FE db	0
db    0
unk_35400 db	0
db    0
db    0
db    0
db    0
db  80h	; 
db    0
db    0
db    1
db    0
db    2
db    0
db    7
db    0
db    0
db    0
unk_35410 db	0
unk_35411 db	0
unk_35412 db	2
db    0
db    0
db    0
db    0
db  80h	; 
unk_35418 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
db    0
db    1
db    0
db    0
db    0
db    0
db  50h	; P
db    3
db    0
db 0A9h	; 
db    0
unk_35430 db 0AAh ; 
db    0
db 0AEh	; 
db    0
db 0ACh	; 
db    0
db    2
db    0
db    2
db    0
db    0
unk_3543B db	0
db    0
db    0
unk_3543E db	1
db    0
unk_35440 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
db    0
db    0
db    0
db  40h	; @
db    0
db    0
db    0
unk_35450 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
db  11h
unk_3545F db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_35466 db	0
db    0
db    0
db    0
db    0
db    0
unk_3546C db	1
db    0
unk_3546E db	0
db    0
unk_35470 db  40h ; @
db  80h	; 
db    0
db  50h	; P
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
unk_35480 db	1
db    0
db    0
db    0
db    0
db    0
db    5
db    0
db  5Bh	; [
db    0
db  65h	; e
db    0
db  68h	; h
db    0
db    0
db    0
db    5
unk_35491 db	0
unk_35492 db	2
db    0
db    0
db    0
unk_35496 db	0
db    0
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
db    0
unk_354A4 db	1
db    0
db    0
db    0
db    0
unk_354A9 db  40h ; @
db    3
db    0
db  32h	; 2
db    0
db  35h	; 5
db    0
db  43h	; C
unk_354B1 db	0
db    0
db    0
db    1
db    0
db    0
db    0
db    9
db  92h	; 
db    0
db    0
db    0
db    0
db    0
unk_354BF db	0
unk_354C0 db	0
unk_354C1 db	0
unk_354C2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    4
db  72h	; r
db    4
db    0
db  86h	; 
db    0
db  7Dh	; }
db    0
unk_354D4 db  8Ch ; 
db    0
unk_354D6 db  96h ; 
db    0
db    1
unk_354D9 db	0
db    0
db    0
db    8
unk_354DD db	0
db    1
db    1
unk_354E0 db	0
unk_354E1 db	0
unk_354E2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db    0
db    0
db    0
unk_354EE db  48h ; H
unk_354EF db  90h ; 
unk_354F0 db	0
db    0
db    0
db    0
db    0
db    0
unk_354F6 db	0
db    0
db    0
db    0
db    0
db    0
db    3
db    0
db    2
db    0
db  40h	; @
unk_35501 db	0
unk_35502 db	0
unk_35503 db  40h ; @
db    1
db    0
unk_35506 db  29h ; )
db    0
db  38h	; 8
db    0
db    0
db    0
db    0
unk_3550D db	0
db    1
db    0
unk_35510 db	0
db    0
unk_35512 db  12h
db  10h
unk_35514 db	0
db  20h
db    0
db    0
db    0
unk_35519 db	0
db    0
unk_3551B db	0
unk_3551C db	0
db    0
unk_3551E db	0
unk_3551F db	0
unk_35520 db	2
unk_35521 db	0
db    1
db    0
db    0
db    0
db    4
db    0
db    4
db    0
db 0A2h	; 
db    0
db 0A5h	; 
db    0
db 0C3h	; 
db    0
db 0B6h	; 
unk_35531 db	0
unk_35532 db	3
db    0
db    2
db    0
db    0
db  10h
db    4
db    0
db    3
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    2
db    0
db    2
db    0
db    2
db  10h
db    1
unk_3554B db	1
db    5
db    0
db  80h	; 
db    0
unk_35550 db  7Dh ; }	; DATA XREF: OVR_SaveGame_MagicSet+31Ao
db    0
db  7Eh	; ~
db    0
db  8Dh	; 
db    0
strFIGUREX db 'FIGUREX',0
			; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_553B8o
strTILEXXX db 'TILEXXX',0
			; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_553CFo
strCONTXXX db 'CONTXXX',0
			; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_557BCo
word_3556E dw 0Fh	; DATA XREF: ST_LoadMusicSoundfxIntro+37Er
db  0Ch
db    0
db  1Eh
db    0
db  12h
db    0
db  19h
db    0
db  20h
db    0
db  18h
db    0
db  20h
db    0
db  1Eh
db    0
db  25h	; %
db    0
db  1Eh
unk_35583 db	0
db  0Bh
db    0
db  20h
db    0
strMUSICLBX db 'music.lbx',0
			; DATA XREF: ST_LoadMusicSoundfxIntro+18o
			; ST_LoadMusicSoundfxIntro+70o
strSOUNDFXLBX db 'soundfx.lbx',0
			; DATA XREF: ST_LoadMusicSoundfxIntro+39o
			; ST_LoadMusicSoundfxIntro+197o
			; ST_LoadMusicSoundfxIntro+1AEo
			; ST_LoadMusicSoundfxIntro+20Co
			; ST_LoadMusicSoundfxIntro+223o
			; ST_LoadMusicSoundfxIntro+267o
			; ST_LoadMusicSoundfxIntro+27Eo
			; ST_LoadMusicSoundfxIntro+2C3o
asc_3559E db 1Bh,0	; DATA XREF: ST_LoadMusicSoundfxIntro+8Do
strINTROLBX db 'INTRO.LBX',0
			; DATA XREF: ST_LoadMusicSoundfxIntro+A0o
strSimTexCopyrightr2 db	'Copyright  Simtex Software, 1995   '
			; DATA XREF: ST_LoadMusicSoundfxIntro+144o
db 'V1.31',0
align 2
db 0B9h	; 
db  2Fh	; /
db  2Fh	; /
db  2Fh	; /
db  2Fh	; /
db 0B8h	; 
db  37h	; 7
db  37h	; 7
db  37h	; 7
db  37h	; 7
aHelp db 'HELP',0       ; DATA XREF: idk_OVR_LoadLbxHelp:loc_55D89o
aHelp_0	db 'help',0     ; DATA XREF: idk_OVR_LoadLbxHelp+211o
			; idk_OVR_LoadLbxHelp+228o
			; idk_OVR_LoadLbxHelp+370o
word_355E8 dw 0		; DATA XREF: sub_56240:loc_562EBr
			; sub_56240:loc_5633Dr
			; sub_56240+118r
			; sub_56240+15Cr
			; sub_56240+192w
			; sub_56240+19Br
			; sub_56240+1A8w
			; sub_56413+3w
word_355EA dw 0		; DATA XREF: sub_56240+97r
			; sub_56240:loc_563C7w
			; sub_56240+18Br
			; sub_56240+196w
			; sub_56240:loc_563EEw
			; sub_56413+9w
word_355EC dw 0		; DATA XREF: sub_56240:loc_56248w
			; sub_56240:loc_5624Cr
			; sub_56240:loc_56254w
			; sub_56240:loc_5625Ar
			; sub_56240:loc_563E2w
unk_355EE db  9Eh ; 
db  39h	; 9
unk_355F0 db 0ACh ; 
db  39h	; 9
db 0ABh	; 
unk_355F3 db  39h ; 9
db 0ABh	; 
db  39h	; 9
db 0B9h	; 
db  39h	; 9
db 0C5h	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0D3h	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0ACh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0DCh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0EBh	; 
db  39h	; 9
db 0F4h	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db    9
db  3Ah	; :
db  16h
db  3Ah	; :
db  1Fh
db  3Ah	; :
db  27h	; '
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
unk_35620 db  35h ; 5
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
db  40h	; @
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
db  4Dh	; M
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
db  5Ah	; Z
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
db 0DCh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db  68h	; h
unk_35637 db  3Ah ; :
db  77h	; w
db  3Ah	; :
unk_3563A db  83h ; 
db  3Ah	; :
db  8Ch	; 
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db  98h	; 
db  3Ah	; :
unk_35644 db 0A0h ; 
db  3Ah	; :
db 0AFh	; 
db  3Ah	; :
db 0B9h	; 
db  3Ah	; :
db 0ABh	; 
unk_3564B db  39h ; 9
unk_3564C db 0C5h ; 
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
db 0D2h	; 
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
unk_35654 db 0E0h ; 
unk_35655 db  3Ah ; :
db 0ABh	; 
db  39h	; 9
db 0EEh	; 
db  3Ah	; :
db 0ABh	; 
db  39h	; 9
unk_3565C db 0F7h ; 
db  3Ah	; :
unk_3565E db 0ABh ; 
db  39h	; 9
unk_35660 db	2
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db  0Eh
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db  1Bh
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db  27h	; '
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db  34h	; 4
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db  43h	; C
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db  4Fh	; O
db  3Bh	; ;
db 0ABh	; 
unk_3567B db  39h ; 9
unk_3567C db  5Dh ; ]
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db  6Eh	; n
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db  79h	; y
db  3Bh	; ;
db  87h	; 
db  3Bh	; ;
db  8Eh	; 
db  3Bh	; ;
unk_3568C db  95h ; 
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
unk_35690 db  9Fh ; 
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  3Bh	; ;
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0B7h	; 
db  3Bh	; ;
db 0BEh	; 
unk_3569D db  3Bh ; ;
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0ABh	; 
db  39h	; 9
db 0CCh	; 
db  3Bh	; ;
db 0DBh	; 
db  3Bh	; ;
db 0ABh	; 
unk_356AB db  39h ; 9
db 0ABh	; 
db  39h	; 9
aGameDesigner db 'Game Designer',0
aSteveBarcia db	'Steve Barcia',0
aProgrammers db	'Programmers',0
aJimCowlishaw db 'Jim Cowlishaw',0
aKenBurd db 'Ken Burd',0
aGrisselBarcia db 'Grissel Barcia',0
aProducer db 'Producer',0
aDougCaspianKaufman db 'Doug Caspian-Kaufman',0
aArtDirector db	'Art Director',0
aJeffDee db 'Jeff Dee',0
aArtists db 'Artists',0
aShellyHollen db 'Shelly Hollen',0
aAmandaDee db 'Amanda Dee',0
aSteveAustin db	'Steve Austin',0
aGeorgePurdy db	'George Purdy',0
aPatrickOwens db 'Patrick Owens',0
aMusicProducer db 'Music Producer',0
aTheFatMan db 'The Fat Man',0
aComposer db 'Composer',0
aDaveGovett db 'Dave Govett',0
aQaLead	db 'QA Lead',0
aDestinStrader db 'Destin Strader',0
aPlayTest db 'Play Test',0
aMikeBalogh db 'Mike Balogh',0
aDamonHarris db	'Damon Harris',0
aGeoffGessner db 'Geoff Gessner',0
aTammyTalbott db 'Tammy Talbott',0
aMickUhl db 'Mick Uhl',0
aJimHendry db 'Jim Hendry',0
aFrankBrown db 'Frank Brown',0
aJimTricario db	'Jim Tricario',0
aJenMaclean db 'Jen MacLean',0
aBrianWilson db	'Brian Wilson',0
aBrianHelleson db 'Brian Helleson',0
aJeffDinger db 'Jeff Dinger',0
aChrisBowling db 'Chris Bowling',0
aCharlesBrubaker db 'Charles Brubaker',0
aTomHughes db 'Tom Hughes',0
aSoundEffects_0	db 'Sound Effects',0
aMidian	db 'Midian',0
aSpeech	db 'Speech',0
aMarkReis db 'Mark Reis',0
aPeterWoods db 'Peter Woods',0
aDavidEllis db 'David Ellis',0
aManual	db 'Manual',0
aPetraSchlunk db 'Petra Schlunk',0
aSpecialThanks db 'Special Thanks',0
aJennyCowlishaw	db 'Jenny Cowlishaw',0
a_ db '.',0             ; DATA XREF: sub_56240:loc_56382o
align 2
unk_358FE db  0Ah
db  3Ch	; <
db  15h
db  3Ch	; <
db  1Eh
unk_35903 db  3Ch ; <
db  29h	; )
db  3Ch	; <
db  34h	; 4
db  3Ch	; <
unk_35908 db  3Ch ; <
db  3Ch	; <
db  43h	; C
unk_3590B db  3Ch ; <
db  4Dh	; M
unk_3590D db  3Ch ; <
db  58h	; X
db  3Ch	; <
db  61h	; a
db  3Ch	; <
db  6Ah	; j
db  3Ch	; <
db  74h	; t
db  3Ch	; <
db  7Bh	; {
db  3Ch	; <
unk_35918 db  80h ; 
db  3Ch	; <
aBarbarians db 'Barbarians',0
aBeastmen_0 db 'Beastmen',0
aDarkElves db 'Dark Elves',0
aDraconians db 'Draconians',0
aDwarves db 'Dwarves',0
aGnolls	db 'Gnolls',0
aHalflings db 'Halflings',0
aHighElves db 'High Elves',0
aHighMen_0 db 'High Men',0
aKlackons db 'Klackons',0
aLizardmen db 'Lizardmen',0
aNomads	db 'Nomads',0
aOrcs db 'Orcs',0
aTrolls	db 'Trolls',0
aHalofam db 'HALOFAM',0 ; DATA XREF: sub_56450+54o
asc_3599F db 1Bh,0	; DATA XREF: sub_56450+C8o
asc_359A1 db ' ',0      ; DATA XREF: idk_HoF_s565F2+8o
aHall db 'Hall',0       ; DATA XREF: idk_HoF_s565F2:loc_56687o
aOf_0 db 'Of',0         ; DATA XREF: idk_HoF_s565F2+B3o
aFame db 'Fame',0       ; DATA XREF: idk_HoF_s565F2+D1o
aMaster	db 'Master',0   ; DATA XREF: idk_HoF_s565F2+154o
asc_359B7 db ')',0      ; DATA XREF: idk_HoF_s565F2+17Do
aOfThe db ' of the ',0  ; DATA XREF: idk_HoF_s565F2+1B2o
asc_359C2 db '(',0      ; DATA XREF: idk_HoF_s565F2+241o
asc_359C4 db '%)',0     ; DATA XREF: idk_HoF_s565F2+25Fo
unk_359C7 db	0
bios_time_lw dw	0	; DATA XREF: _f020105_bios_timeofday+Aw
			; _f020205_idk_DIFF_bios_time_lw+Ar
			; _f020305_idk_SleepWaitPause+1Er
			; _f020405_idk_CheckInputOrSleep_s13F7E+40r
bios_time_hw dw	0	; DATA XREF: _f020105_bios_timeofday+11w
			; _f020405_idk_CheckInputOrSleep_s13F7E+44r
idk_bios_time_w359CC dw	1
			; DATA XREF: _f020405_idk_CheckInputOrSleep_s13F7E+4r
offOldInt24ErrorHandler	dw 0
			; DATA XREF: idk_IntVec_s13FF3+Dw
segOldInt24ErrorHandler	dw 0
			; DATA XREF: idk_IntVec_s13FF3+11w
ptrWorstFreeKb dw 0FA00h
			; DATA XREF: ST_ExitWithMemDiag+Fr
			; ST_UpdateWorstFreeKb+Br
			; ST_UpdateWorstFreeKb:New_Worst_Free_Kbw
			; SEE: MAGIC_EXE - DOS ALLOCATE	MEMORY.txt
aData db 'Data',0       ; DATA XREF: ST_ExitWithMemDiag+1Do
aFree db ' Free: ',0    ; DATA XREF: ST_ExitWithMemDiag+2Co
			; ST_ExitWithMemDiag+71o
			; ST_ExitWithMemDiag+B3o
aBytesMemory db	' bytes   Memory',0
			; DATA XREF: ST_ExitWithMemDiag+62o
aKWorst	db 'k   Worst',0
			; DATA XREF: ST_ExitWithMemDiag+A4o
aKEmm db 'k   EMM: ',0  ; DATA XREF: ST_ExitWithMemDiag+E6o
aBlocks	db ' blocks',0  ; DATA XREF: ST_ExitWithMemDiag+11Ao
aErrorGameFile db 'Error- game file ',0
			; DATA XREF: ST_execl_WizardsExe+63o
aCouldNotBeFoun	db ' could not be found',0
			; DATA XREF: ST_execl_WizardsExe+7Eo
strRBr5	db 'rb',0       ; DATA XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+4Ao
; char strCRLF20[]
strCRLF20 db 0Dh,0Ah	; DATA XREF: idk_Cleanup_PrintFileTextMode_Exit_s14489+ECo
db 0Dh,0Ah		; (20)CR&LN (20)\r\n
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah
db 0Dh,0Ah,0
unk_35A5F db	0
unk_35A60 db	0
db    0
db    0
db    0
idk_OVL_w35A64 dw 100h	; DATA XREF: sub_14787:loc_1478Ar
			; sub_14792+6w
			; sub_1479D:loc_147A0w
			; EMM_CheckAllocation+21w
			; sub_147E5:loc_147F2r
			; sub_147E5:loc_147FFr
			; sub_147E5:loc_1480Ar
			; sub_147E5:loc_14810w
aNearAllocation	db 'Near Allocation too large by ',0
			; DATA XREF: EXIT_AllocationError+3o
; char argDst[]
argDst db ' bytes',0    ; DATA XREF: EXIT_AllocationError:loc_14855o
strInsfMem1 db 'Insufficient memory. You need at le'
			; DATA XREF: MemBlocksErrorExit+14o
db 'ast ',0
strInsfMem2 db 'K free. Try removing all TSR',27h,'s.',0
			; DATA XREF: MemBlocksErrorExit+48o
aDynamicAllocat	db 'Dynamic allocation too small for Al'
			; DATA XREF: MemBlocksErrorExit:DynAllocTooSmallForAllocSpaceo
db 'locate_Space()',0
aOf db ' of ',0         ; DATA XREF: MemBlocksErrorExit:loc_14D04o
aBlocks_0 db ' blocks',0
			; DATA XREF: MemBlocksErrorExit+B4o
aFailedToReload	db 'Failed to reload',0
			; DATA XREF: MemBlocksErrorExit:loc_14D35o
			; MemBlocksErrorExit:loc_14DA9o
aAllocate_next_	db ' Allocate_Next_Block()',0
			; DATA XREF: MemBlocksErrorExit+D5o
			; MemBlocksErrorExit:loc_14D97o
			; MemBlocksErrorExit+158o
aShortBy db ': Short by ',0
			; DATA XREF: MemBlocksErrorExit+E4o
			; MemBlocksErrorExit+167o
aAllocationSpac	db 'Allocation space has been corrupted'
			; DATA XREF: MemBlocksErrorExit:AllocationSpaceCorruptedo
db ' for',0
aEmm db	' (EMM) ',0     ; DATA XREF: MemBlocksErrorExit:loc_14DB8o
LBX_FLAG_NoMalloc dw 0	; DATA XREF: LBX_Load_Entry:OK_StringNotEmptyr
			; LBX_Load_Entry+27w
			; LBX_Load_s15453:loc_15474r
			; LBX_Load_s15453+28w
			; LBX_Load_HelpNewTerrCity:loc_1593Cr
			; LBX_Load_HelpNewTerrCity+28w
			; LBX_Load_Entry_4bytes:loc_15C6Ar
			; LBX_Load_Entry_4bytes+27w
; char *g_CurrentLbxFileHandle
g_CurrentLbxFileHandle dw 0FFFFh
			; DATA XREF: LBX_Load_Entry:GOT_ZEROr
			; LBX_Load_Entry+A1r
			; LBX_Load_Entry+A8r
			; LBX_Load_Entry+E3w
			; LBX_Load_Entry+E6r
			; LBX_Load_Entry+12Aw
			; LBX_Load_Entry+12Dr
			; LBX_Load_Entry:loc_1519Cr
			; LBX_Load_Entry:SEEK_SUCCESS1r
			; LBX_Load_Entry+227r
			; LBX_Load_Entry+396r
			; LBX_Load_Entry+3E2r
			; LBX_Load_s15453:loc_154BFr
			; LBX_Load_s15453+94r
			; LBX_Load_s15453+9Br
			; LBX_Load_s15453+D6w
			; LBX_Load_s15453+D9r
			; LBX_Load_s15453+120w
			; LBX_Load_s15453+123r
			; LBX_Load_s15453:loc_1558Br
			; LBX_Load_s15453+157r
			; LBX_Load_s15453:READ_LBX_HEADERr
			; LBX_Load_s15453+21Fr
			; LBX_Load_s15453:loc_15699r
			; LBX_Load_s15453+25Ar
			; LBX_Load_s15453+2C4r
			; LBX_Load_s15453:loc_1589Br
			; LBX_Load_s15453+494r
			; LBX_Load_HelpNewTerrCity:loc_15984r
			; LBX_Load_HelpNewTerrCity+91r
			; LBX_Load_HelpNewTerrCity+98r
			; LBX_Load_HelpNewTerrCity+D3w
			; LBX_Load_HelpNewTerrCity+D6r
			; LBX_Load_HelpNewTerrCity+11Aw
			; LBX_Load_HelpNewTerrCity+11Dr
			; LBX_Load_HelpNewTerrCity+13Cr
			; LBX_Load_HelpNewTerrCity:loc_15A7Ar
			; LBX_Load_HelpNewTerrCity+204r
			; LBX_Load_HelpNewTerrCity:SEEK_SUCCESSr
			; LBX_Load_HelpNewTerrCity+23Fr
			; LBX_Load_HelpNewTerrCity+2ACr
			; LBX_Load_HelpNewTerrCity+300r
			; LBX_Load_Entry_4bytes:loc_15CA4r
			; LBX_Load_Entry_4bytes+82r
			; LBX_Load_Entry_4bytes:CLOSE_GLOBAL_LBX_HANDLEr
			; LBX_Load_Entry_4bytes+C4w
			; LBX_Load_Entry_4bytes+C7r
			; LBX_Load_Entry_4bytes+10Bw
			; LBX_Load_Entry_4bytes+10Er
			; LBX_Load_Entry_4bytes:LSEEKr
			; LBX_Load_Entry_4bytes:LSEEK_SUCCESSr
			; LBX_Load_Entry_4bytes+20Er
LBX_Flag_w35B7A	dw 0	; DATA XREF: LBX_Load_Entry:loc_15084r
			; LBX_Load_Entry_4bytes+47r
; char g_LbxDirectoryPath[]
g_LbxDirectoryPath dw 0	; DATA XREF: LBX_Load_Entry:COULD_NOT_OPEN_FILEr
			; LBX_Load_Entry:TRY_SOME_OTHER_FILENAMEo
			; LBX_Load_s15453+E0r
			; LBX_Load_s15453:loc_15548o
			; LBX_Load_HelpNewTerrCity+DDr
			; LBX_Load_HelpNewTerrCity:loc_15A0Do
			; LBX_Load_Entry_4bytes:FAILURE_OPEN_FILEr
			; LBX_Load_Entry_4bytes:loc_15D2Do
			; ST_Set_LbxDirectoryPath+6o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_35B85 db	0
db    0
db    0
unk_35B88 db	0
db    0
unk_35B8A db	0
db    0
db    0
unk_35B8D db	0
db    0
unk_35B8F db	0
unk_35B90 db	0
db    0
unk_35B92 db	0
db    0
db    0
db    0
unk_35B96 db	0
db    0
unk_35B98 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_35BA5 db	0
db    0
db    0
db    0
db    0
db    0
unk_35BAB db	0
db    0
unk_35BAD db	0
strLBXext db '.LBX',0   ; DATA XREF: LBX_Load_Entry+CAo
			; LBX_Load_s15453+BDo
			; LBX_Load_HelpNewTerrCity+BAo
			; LBX_Load_Entry_4bytes+ABo
			; LBX_Load_ErrorHandler+11Eo
strLbxEntryPrefix db '.LBX [entry ',0
			; DATA XREF: LBX_Load_ErrorHandler+2Bo
strLbxEntrySuffix db '] ',0
			; DATA XREF: LBX_Load_ErrorHandler+4Ao
strNotFound db ' could not be found.',0
			; DATA XREF: LBX_Load_ErrorHandler:LbxErrNo_1o
strCorrupted db	' has been corrupted.',0
			; DATA XREF: LBX_Load_ErrorHandler:LbxErrNo_2o
strInsuffMem db	'Insufficient memory. You need at le'
			; DATA XREF: LBX_Load_ErrorHandler:CASE_0x2o
db 'ast ',0
strKFree db 'K free. Try removing all TSR',27h,'s.',0
			; DATA XREF: LBX_Load_ErrorHandler+B7o
strNotAllocated	db ' was not properly allocated or has '
			; DATA XREF: LBX_Load_ErrorHandler:CASE_0x3o
db 'been corrupted.',0
strAllocationTooSmall db ' failed to reload. Allocation too s'
			; DATA XREF: LBX_Load_ErrorHandler:LbxErrNo_5o
db 'mall by ',0
strPages db ' pages',0  ; DATA XREF: LBX_Load_ErrorHandler+F4o
strNotAnLbx db ' is not an LBX file',0
			; DATA XREF: LBX_Load_ErrorHandler:LbxErrNo_7o
strExceedsCount	db ' exceeds number of LBX entries',0
			; DATA XREF: LBX_Load_ErrorHandler:LbxErrNo_8o
strIncorrectSize db ' has an incorrect record size',0
			; DATA XREF: LBX_Load_ErrorHandler:CASE_0x8o
strExceedsRecords db ' exceeds number of defined records',0
			; DATA XREF: LBX_Load_ErrorHandler:loc_15F82o
strCannotBeReloaded db ' cannot be reloaded into EMS w/o be'
			; DATA XREF: LBX_Load_ErrorHandler+12Do
db 'ing first released.',0
strInsuffEMM db	' EMM loading error. Insufficient EM'
			; DATA XREF: LBX_Load_ErrorHandler:CASE_0xBo
			; LBX_Load_ErrorHandler:loc_15FB5o
			; LBX_Load_ErrorHandler+16Co
db 'M.',0
strOnlyPictures	db ' Only pictures may be loaded into r'
			; DATA XREF: LBX_Load_ErrorHandler:CASE_0xCo
db 'eserved EMM',0
strReservedEmm db ' (Reserved EMM) ',0
			; DATA XREF: LBX_Load_ErrorHandler+14Eo
			; LBX_Load_ErrorHandler+17Bo
strLbxTo db ' LBX to',0 ; DATA XREF: LBX_Load_ErrorHandler:loc_15FD3o
strVgaAnimFrameTooBig db ' Vga file animation frames cannot e'
			; DATA XREF: LBX_Load_ErrorHandler:VGA_ANIM_FRAME_TOO_BIGo
db 'xceed 65536 bytes',0
align 2
strR db	'r',0           ; DATA XREF: DOS_OpenFileModeCheck+7o
strRB db 'rb',0         ; DATA XREF: DOS_OpenFileModeCheck:loc_16094o
strW db	'w',0           ; DATA XREF: DOS_OpenFileModeCheck:NotReadModeo
strWBr5	db 'wb',0       ; DATA XREF: DOS_OpenFileModeCheck:loc_160C1o
EMM_PageFrameSegmentAddress dw 0
			; DATA XREF: EMM_GetPageFrameAddress:EMM_SUCCESSw
			; EMS_MapMemory_4+70r
			; idk_EmsMapMem_s16337+65r
			; fncGetEmmPageFrameSegmentAddress+6r
			; sub_17A50+11r
			; sub_17AFA:loc_17B09r
			; idk_Font_s1CB05:loc_1CB9Ar
			; idk_MemAndVid_s1E0DA+47r
			; idk_MemAndVid_s1E0DA:loc_1E1CEr
			; idk_VidLib_s1E2D0+3Cr
			; sub_1EA9E+42r
			; sub_1EA9E:loc_1EB8Er
			; sub_1EC88+3Cr
			; sub_1F8FD+12Er
			; sub_226C2:loc_22704r
			; sub_226C2+10Fr
			; sub_229E6+5Er
			; sub_22DC6+42r
			; sub_22DC6+A0r
			; sub_4F44D+BEr
			; sub_56220+12r
emm_name db 'EMMXXXX0',0
			; DATA XREF: EMM_GetPageFrameAddress:loc_1617Co
word_35DFF dw 0		; DATA XREF: sub_163FC+14w
db    0
db    0
word_35E03 dw 0		; DATA XREF: sub_163FC:loc_16415w
db    1
db    0
word_35E07 dw 0		; DATA XREF: sub_163FC:loc_1641Aw
db    2
db    0
word_35E0B dw 0		; DATA XREF: sub_163FC:loc_1641Fw
unk_35E0D db	3
db    0
db    0
; int ST_HeapBase
ST_HeapBase dw 28h	; DATA XREF: _f010109_main+8w
			; ST_ExitWithMemDiag+FEr
			; idk_Setup_EMM+146r
			; LBX_LoadFileMemory+106r
			; sub_17671+74w
			; EMM_Allocate+EDw
			; EMM_Allocate:NOT_ZEROr
			; EMM_Allocate+100r
hrmEmmPageCount	dw 0	; DATA XREF: idk_Setup_EMM:GetMoreHandlesw
			; idk_Setup_EMM+83r
			; idk_Setup_EMM+96r
			; idk_Setup_EMM+A5r
			; idk_Setup_EMM+B7w
			; idk_Setup_EMM:loc_16533r
			; idk_Setup_EMM+10Fr
			; idk_Setup_EMM+122r
			; idk_Setup_EMM+130w
			; idk_Setup_EMM+13Ar
			; LBX_LoadFileMemory:loc_1666Cr
			; LBX_LoadFileMemory:loc_16695r
			; LBX_AllocMem:LOOP_PageCountr
			; LBX_AllocMem:loc_168EAr
			; LBX_s16A80:loc_16AEFr
			; LBX_s16A80:loc_16B18r
			; Emm_PgCnt_s175B1:LOOP_PageCountr
			; Chk_RelMemHandle:loc_17622r
			; EMM_LoopRelease:LOOP_RELEASEr
			; sub_17671:loc_1774Ar
			; sub_17671+E1w
			; EMM_Allocate+45r
			; EMM_Allocate+55r
			; EMM_Allocate:argValue_NE_0r
			; EMM_Allocate+7Fr
			; EMM_Allocate:loc_177F4r
			; EMM_Allocate+AEr
			; EMM_Allocate+C1r
			; EMM_Allocate+D2r
			; EMM_Allocate+E0w
; char strYOMOMAr1[]
strYOMOMAr1 db 'YO MOMA',0
			; DATA XREF: idk_Setup_EMM+3Ao
			; idk_Setup_EMM:loc_164B6o
strYOMOMAr2 db 'YO MOMA',0
			; DATA XREF: idk_Setup_EMM:loc_164A1o
db    0
db    0
strVGAFILEH db 'VGAFILEH',0
			; DATA XREF: idk_Setup_EMM+164o
strEMMDATAH db 'EMMDATAH',0
			; DATA XREF: idk_Setup_EMM+17Bo
strDotLBX db '.LBX',0   ; DATA XREF: LBX_LoadFileMemory:loc_166AEo
			; sub_17671+3Ao
			; sub_17BB8:loc_17BE2o
aEmmReservedExceededBy db 'EMM reserved exceeded by ',0
			; DATA XREF: EMM_Allocate+10Eo
aBlocks_1 db ' blocks [',0
			; DATA XREF: EMM_Allocate+12Co
a_lbx db '.LBX]',0      ; DATA XREF: EMM_Allocate+147o
aReloadedIntoEmmDiffSi db ' reloaded into EMM, diff size =',0
			; DATA XREF: EMM_Allocate+1CEo
a2spaces db '  ',0      ; DATA XREF: EMM_Allocate+1ECo
			; EMM_Allocate+20Ao
; char aEmm2long[]
aEmm2long db 'EMM 2long',0
			; DATA XREF: sub_17BB8+A3o
strYouMustHaveAtLeast db 'You must have at least ',0
			; DATA XREF: fncBldMsgInsuffEMS:loc_17D44o
strKofExpandedMemory_ db 'K of expanded memory.',0
			; DATA XREF: fncBldMsgInsuffEMS:loc_17D5Co
idk_ScrnPosX0_w35EC2 dw	0
			; DATA XREF: wtfCompareSwap:loc_17F6Fw
			; idk_ScrnPos_0_319_0_199+3w
			; sub_17FA0+Er
			; sub_17FA0:loc_17FD3r
			; sub_17FA0+39r
			; sub_1801C+Br
			; sub_180AB:loc_180C8r
			; sub_180AB:loc_1817Cr
			; sub_180AB+D7r
			; sub_180AB+E5r
			; sub_180AB+105r
			; sub_180AB:loc_1822Fr
			; sub_180AB:loc_18242r
			; sub_180AB+19Dr
			; sub_180AB+1A5r
			; sub_19F94:loc_19FBAr
			; sub_1A296+66r
			; sub_1A3AF:loc_1A3F5r
			; sub_1A3AF+86r
			; sub_1A3AF+8Cr
			; sub_1A3AF:loc_1A44Dr
			; idk_VidLib_s1F743+47r
			; idk_VidLib_s1F743+67r
			; idk_VidLib_s1F743:loc_1F7BAr
			; idk_VidLib_s1F743+80r
			; idk_VidLib_s1FBBF+14Br
			; idk_VidLib_s1FBBF:loc_1FF97r
			; idk_VidLib_s1FBBF:loc_1FFACr
			; idk_VidLib_s1FBBF+419r
			; idk_VidLib_s1FBBF+472r
			; idk_VidLib_s1FBBF+91Br
			; idk_VidLib_s1FBBF:loc_204EFr
			; idk_VidLib_s1FBBF:loc_2051Br
			; idk_VidLib_s1FBBF+9B5r
			; idk_VidLib_s1FBBF:loc_2081Dr
			; idk_VidLib_s1FBBF:loc_20832r
			; idk_VidLib_s1FBBF+C9Fr
			; idk_VidLib_s1FBBF+CF8r
			; idk_VidLib_s1FBBF+FABr
			; idk_VidLib_s1FBBF:loc_20B7Fr
			; idk_VidLib_s1FBBF+FECr
			; idk_VidLib_s1FBBF+1045r
			; idk_VidLib_s2104D+4Er
			; idk_VidLib_s2104D:loc_210B7r
			; idk_VidLib_s2104D:loc_210C7r
			; idk_VidLib_s2104D:loc_210CFr
			; sub_29550:loc_2957Fr
			; sub_29550:loc_295A5r
			; sub_29550+7Cr
			; sub_29B06+Er
			; sub_29B06:loc_29B37r
			; sub_29B06+58r
			; sub_2BA41+8r
idk_ScrnPosY0_w35EC4 dw	0
			; DATA XREF: wtfCompareSwap+4Bw
			; idk_ScrnPos_0_319_0_199+Fw
			; sub_17FA0:loc_17FC3r
			; sub_17FA0:loc_17FDDr
			; sub_17FA0:loc_17FE3r
			; sub_1801C:loc_18039r
			; sub_180AB:loc_180FCr
			; sub_180AB:loc_1810Fr
			; sub_180AB:loc_18115r
			; sub_180AB+15Ar
			; sub_180AB:loc_182ADr
			; sub_180AB+20Er
			; sub_180AB+22Er
			; sub_19F94+2Cr
			; sub_1A296+43r
			; sub_1A3AF+57r
			; sub_1A3AF:loc_1A47Ar
			; sub_1A3AF+D1r
			; sub_1A3AF+D9r
			; idk_VidLib_s1F743+5Cr
			; idk_VidLib_s1F743+87r
			; idk_VidLib_s1F743:loc_1F7DAr
			; idk_VidLib_s1F743+A0r
			; idk_VidLib_s1FBBF+15Dr
			; idk_VidLib_s2104D+62r
			; idk_VidLib_s2104D:loc_210D5r
			; idk_VidLib_s2104D:loc_210E5r
			; idk_VidLib_s2104D+A0r
			; sub_29550+44r
			; sub_29550+B6r
			; sub_29550+DDr
			; sub_29B06+23r
			; sub_29B06+8Fr
			; sub_29B06+B7r
			; sub_2BA41+14r
idk_ScrnPosX319_w35EC6 dw 13Fh
			; DATA XREF: wtfCompareSwap+47w
			; idk_ScrnPos_0_319_0_199:loc_17F8Cw
			; sub_17FA0:loc_17FB8r
			; sub_17FA0:loc_17FEAr
			; sub_17FA0:loc_17FF0r
			; sub_1801C:loc_18031r
			; sub_180AB:loc_180D1r
			; sub_180AB+118r
			; sub_180AB:loc_181CFr
			; sub_180AB+145r
			; sub_180AB:loc_18235r
			; sub_180AB:loc_18257r
			; sub_180AB:loc_1825Dr
			; sub_19F94:loc_19FC6r
			; sub_1A296:loc_1A2E1r
			; sub_1A3AF+51r
			; sub_1A3AF:loc_1A463r
			; sub_1A3AF+BAr
			; idk_VidLib_s1F743+Br
			; idk_VidLib_s1F743+A7r
			; idk_VidLib_s1F743:loc_1F7F5r
			; idk_VidLib_s1FBBF+142r
			; idk_VidLib_s1FBBF+3E4r
			; idk_VidLib_s1FBBF+3F7r
			; idk_VidLib_s1FBBF:loc_1FFBEr
			; idk_VidLib_s1FBBF:loc_1FFCEr
			; idk_VidLib_s1FBBF:loc_20027r
			; idk_VidLib_s1FBBF+927r
			; idk_VidLib_s1FBBF+93Ar
			; idk_VidLib_s1FBBF+942r
			; idk_VidLib_s1FBBF+952r
			; idk_VidLib_s1FBBF:loc_2056Ar
			; idk_VidLib_s1FBBF+C6Ar
			; idk_VidLib_s1FBBF+C7Dr
			; idk_VidLib_s1FBBF:loc_20844r
			; idk_VidLib_s1FBBF+C95r
			; idk_VidLib_s1FBBF:loc_208ADr
			; idk_VidLib_s1FBBF+FB7r
			; idk_VidLib_s1FBBF:loc_20B89r
			; idk_VidLib_s1FBBF+FD2r
			; idk_VidLib_s1FBBF:loc_20BA1r
			; idk_VidLib_s1FBBF:loc_20BFAr
			; idk_VidLib_s2104D+Er
			; idk_VidLib_s2104D+A9r
			; idk_VidLib_s2104D:loc_21101r
			; sub_29550+35r
			; sub_29550+85r
			; sub_29550+ACr
			; sub_29B06+14r
			; sub_29B06+61r
			; sub_29B06+88r
			; sub_2BA41+Er
idk_ScrnPosY199_w35EC8 dw 0C7h
			; DATA XREF: wtfCompareSwap:loc_17F7Bw
			; idk_ScrnPos_0_319_0_199:loc_17F98w
			; sub_17FA0:loc_17FCBr
			; sub_17FA0:loc_17FF9r
			; sub_17FA0:loc_17FFFr
			; sub_1801C:loc_18041r
			; sub_180AB+57r
			; sub_180AB:loc_1811Cr
			; sub_180AB:loc_18122r
			; sub_180AB+163r
			; sub_180AB+241r
			; sub_180AB:loc_182F8r
			; sub_180AB+26Er
			; sub_19F94+38r
			; sub_1A296+32r
			; sub_1A3AF+62r
			; sub_1A3AF+E9r
			; sub_1A3AF+EFr
			; idk_VidLib_s1F743+19r
			; idk_VidLib_s1F743+BEr
			; idk_VidLib_s1F743:loc_1F80Cr
			; idk_VidLib_s1FBBF:loc_1FD13r
			; idk_VidLib_s2104D:loc_21066r
			; idk_VidLib_s2104D:loc_2111Cr
			; idk_VidLib_s2104D:loc_21127r
			; sub_29550+4Dr
			; sub_29550+E7r
			; sub_29550+10Er
			; sub_29B06:loc_29B2Fr
			; sub_29B06+C1r
			; sub_29B06+E8r
			; sub_2BA41+1Ar
strFONTSLBXr2 db 'FONTS.LBX',0
			; DATA XREF: Load_Fonts_SndDrv:DEFAULTo
			; idk_Load_FntSty_SndDrv_Mos:loc_17E20o
g_ptrVideoRamBuffer dw 0A000h
			; DATA XREF: idk_VGA_ScData_s186BC+57r
			; idk_VGA_ScData_s186BC+82r
			; sub_187C0:loc_187ECr
			; sub_187FA+95r
			; sub_18903:loc_189A6r
			; sub_18A5C:loc_18ADCr
			; sub_18BA2+A6r
			; idk_VidPalFnt_s18D9F+E2r
			; sub_18FCC+67r
			; sub_190B6+61r
			; sub_190B6+8Cr
			; sub_19F94+Er
			; sub_19F94+13Fw
			; sub_1ACAA:loc_1ACD5r
			; sub_1AD1E+2Br
			; sub_1AF9B+13r
			; sub_1D595+Er
			; ST_Read_VGA_Buffer+1Ar
			; _idk_EGA_s1E04D+4Dr
			; idk_MemAndVid_s1E0DA:loc_1E1B3r
			; idk_VidLib_s1E2D0+13r
			; idk_VGA_s1E4BA+Ew
			; VGA_MathThenSetVarToVgaLoc+12w
			; sub_1E4E2r
			; seg026:02BFr
			; sub_1E7AC:loc_1E7C4r
			; sub_1E8AC:loc_1E8BEr
			; sub_1EA9E+D5r
			; sub_1EC88:loc_1EC9Br
			; idk_VGA_ScIndexMapMask_s22194+18r
			; sub_223C9+12r
			; sub_226C2:loc_2279Br
			; sub_229E6+17r
			; sub_22F25+18r
			; sub_23B75+45r
			; sub_23CF1+3Fr
idk_VGA_w35ED6 dw 0	; DATA XREF: idk_VGA_s1E4BAr
			; VGA_MathThenSetVarToVgaLoc:loc_1E4CFr
			; idk_VGA_CRTR_s1E4F1+7r
			; idk_VGA_CRTR_s1E4F1+Bw
			; sub_1E547:loc_1E56Br
			; sub_1E60D:loc_1E616r
			; sub_1E65C+7r
			; sub_1E69F:loc_1E6A6r
			; sub_1E6E2:loc_1E6E9r
			; seg026:loc_1E72Cr
			; sub_24648+2Fr
			; sub_2471B+39r
			; idk_VGA_s247F9+13r
			; idk_ChkMousDoEga+3Er
			; sub_2495B:loc_2497Cr
			; sub_24AC0+34r
			; sub_24B91+37r
db  0Fh
db  0Eh
db  0Ch
db    8
unk_35EDC db	1
db    3
db    7
db  0Fh
unk_35EE0 db	1
db    2
db    4
db    8
db    0
db    0
unk_35EE6 db	0
db    0
unk_35EE8 db	0
db    0
db    0
db    0
db    0
unk_35EED db	0
db    0
unk_35EEF db	0
unk_35EF0 db	0
db    0
db    0
db    0
db    0
db    0
unk_35EF6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_35F12 db	0
db    0
db    0
db    0
unk_35F16 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_35F20 db	0
db    0
db    0
db    0
db  29h	; )
db  24h	; $
unk_35F26 db  3Fh ; ?
db    5
db  62h	; b
db  6Dh	; m
db  57h	; W
db  2Fh	; /
db  53h	; S
db  11h
db  4Ah	; J
db  72h	; r
db  72h	; r
db  3Ch	; <
db  6Ah	; j
db  6Ch	; l
db  33h	; 3
db  27h	; '
db  5Ch	; \
db  3Dh	; =
db    8
db  0Dh
db  3Fh	; ?
db  1Ah
db  25h	; %
db  5Fh	; _
db  0Eh
db  1Dh
db    7
db  38h	; 8
unk_35F42 db  48h ; H
db  5Fh	; _
db  33h	; 3
db  13h
db  4Eh	; N
db  49h	; I
db  44h	; D
db  3Ch	; <
unk_35F4A db  0Ch
db  27h	; '
db  20h
db    4
db  5Bh	; [
db  7Eh	; ~
unk_35F50 db  0Ah
db  39h	; 9
db  26h	; &
db  20h
db  5Dh	; ]
db  55h	; U
unk_35F56 db  4Ch ; L
db  7Dh	; }
db  17h
db  76h	; v
db  46h	; F
db  3Ch	; <
db  14h
db  0Eh
db  0Ah
db  0Bh
unk_35F60 db  1Dh
db  5Ch	; \
db  2Fh	; /
db  33h	; 3
db  20h
db  1Bh
db  51h	; Q
db  6Fh	; o
unk_35F68 db  41h ; A
db  79h	; y
db  37h	; 7
db  7Eh	; ~
db  13h
unk_35F6D db  4Ah ; J
db  33h	; 3
unk_35F6F db  77h ; w
db  1Fh
db  7Eh	; ~
db  4Ah	; J
db  5Dh	; ]
db  2Dh	; -
db  50h	; P
unk_35F76 db  15h
db  73h	; s
db  45h	; E
db  41h	; A
unk_35F7A db  67h ; g
db  51h	; Q
db  6Ch	; l
db  45h	; E
db  31h	; 1
db  38h	; 8
db  33h	; 3
db  3Ch	; <
db  22h	; "
db  23h	; #
db  76h	; v
db  23h	; #
db  12h
db  1Eh
db  62h	; b
db  0Ch
db  20h
db  5Bh	; [
db  31h	; 1
db  4Bh	; K
db  1Ah
db    3
unk_35F90 db  3Ah ; :
db  73h	; s
db  1Eh
db  4Ah	; J
db  2Ch	; ,
db    1
unk_35F96 db  7Fh ; 
db  46h	; F
unk_35F98 db  1Ah
db  56h	; V
db  6Ah	; j
db    0
db  33h	; 3
unk_35F9D db  6Bh ; k
db  4Ah	; J
unk_35F9F db  4Dh ; M
db  54h	; T
db  40h	; @
db  68h	; h
db  57h	; W
db  3Fh	; ?
db  15h
unk_35FA6 db  57h ; W
db  7Fh	; 
db  2Eh	; .
db  5Dh	; ]
db  0Fh
db  67h	; g
db    4
db  70h	; p
db  58h	; X
db  4Ah	; J
db  62h	; b
db  7Fh	; 
db  6Ah	; j
db  10h
db  61h	; a
db  4Eh	; N
db  52h	; R
db  1Fh
db  1Eh
db  1Dh
unk_35FBA db  17h
db  73h	; s
db  73h	; s
db  67h	; g
db  1Eh
db  71h	; q
unk_35FC0 db	5
db  50h	; P
unk_35FC2 db  4Bh ; K
db  78h	; x
db    2
db  58h	; X
unk_35FC6 db  69h ; i
db  3Ah	; :
db  2Dh	; -
db  54h	; T
db  4Ch	; L
db  4Ah	; J
db  13h
db  1Fh
db  34h	; 4
db  75h	; u
unk_35FD0 db  1Fh
db  0Dh
db  75h	; u
db  56h	; V
db  54h	; T
db  20h
db  55h	; U
db  25h	; %
unk_35FD8 db  5Ah ; Z
db  7Fh	; 
db  36h	; 6
db  50h	; P
db  33h	; 3
unk_35FDD db  23h ; #
db  75h	; u
unk_35FDF db  4Dh ; M
db  50h	; P
db  54h	; T
db  11h
db  2Eh	; .
db  48h	; H
db  54h	; T
unk_35FE6 db  10h
db  76h	; v
db  67h	; g
db  5Ah	; Z
unk_35FEA db  1Eh
db  2Bh	; +
db  66h	; f
db  41h	; A
db  78h	; x
db  2Ch	; ,
unk_35FF0 db  79h ; y
db    2
unk_35FF2 db	8
db  45h	; E
db  0Eh
db  60h	; `
db  51h	; Q
db    1
db  55h	; U
db  62h	; b
db  0Eh
db  3Fh	; ?
db  7Ch	; |
db    6
db  16h
db    8
unk_36000 db  3Ch ; <
db  34h	; 4
db    3
db  20h
db  18h
db  71h	; q
unk_36006 db  13h
db  5Bh	; [
unk_36008 db  65h ; e
db  55h	; U
db  4Fh	; O
db  32h	; 2
db    6
unk_3600D db  3Fh ; ?
db  6Ah	; j
unk_3600F db  16h
unk_36010 db  79h ; y
db  47h	; G
db  6Bh	; k
db    5
db  16h
db  74h	; t
unk_36016 db  0Fh
db  5Ah	; Z
db  17h
db  30h	; 0
unk_3601A db  68h ; h
db  69h	; i
db  55h	; U
db  78h	; x
db  4Bh	; K
db  4Bh	; K
db  51h	; Q
db  58h	; X
db  69h	; i
db  77h	; w
word_36024 dw 0		; DATA XREF: idk_SetConfigMomFlagValue_s1930B+6w
			; sub_19958:loc_19988r
			; sub_1A0DC:loc_1A10Cr
			; sub_1A5F1:loc_1A621r
idk_Flag_w36026	dw 0	; DATA XREF: sub_19958+4Cw
			; sub_19958:loc_19B29w
			; ILSe_display_text:loc_19C80r
			; sub_19D11+3w
word_36028 dw 0		; DATA XREF: hrmLotsOfFarMallocStoreSW+4w
word_3602A dw 0		; DATA XREF: sub_1B0AD+181w
			; sub_1B241:loc_1B337w
			; sub_1B654:loc_1B781r
			; sub_1BB10+3w
			; sub_1BB1B:loc_1BB1Er
			; sub_1BB1B+Ar
			; sub_1BB1B+17r
			; sub_1BB1B+24r
			; sub_1BB1B+31r
			; sub_1BB1B+3Ew
			; sub_1BB5F:loc_1BB8Er
			; sub_1BB5F+36r
			; sub_1BB5F+40r
			; sub_1BB5F+4Ar
			; sub_1BB5F+5Ar
			; sub_1BB5F:loc_1BBC9w
			; sub_1BC65:loc_1BDF3w
idk_PalNbr__w3602C dw 0FFFFh
			; DATA XREF: idk_Set_PalNbr__w3602C_to_neg1+3w
			; idk_SetDacReg_s1C1AF:loc_1C21Br
			; idk_SetDacReg_s1C1AF+73w
			; sub_1C37B:loc_1C386r
			; sub_1C37B:loc_1C3A8w
			; sub_1C37B:loc_1C3C5w
			; sub_1C37B+6Dw
			; sub_1C37B+8Aw
idk_RND_w3602E dw 3568h	; DATA XREF: sub_1CC24+6w
			; sub_1CC35:loc_1CC40r
			; ILSe_RndCopySeed_s1CC59+1Ew
			; idk_Arg_0Fail_ElseMathyDiSi+1Fr
			; idk_Arg_0Fail_ElseMathyDiSi:loc_1CCF4w
idk_RND_w36030 dw 3568h	; DATA XREF: sub_1CC24+Cw
			; sub_1CC35:loc_1CC3Br
			; ILSe_RndCopySeed_s1CC59+24w
			; idk_Arg_0Fail_ElseMathyDiSi:loc_1CCA7r
			; idk_Arg_0Fail_ElseMathyDiSi+74w
word_36032 dw 1
dw 2
word_36036 dw 4
word_36038 dw 8
dw 10h
dw 20h
dw 40h
word_36040 dw 80h
word_36042 dw 64h	; DATA XREF: sub_1D198+Cw
			; sub_1D1B5+7Fr
			; sub_1D1B5:loc_1D238r
			; sub_1D1B5+87r
			; sub_1D1B5:loc_1D240r
			; sub_1D1B5+A7r
			; sub_1D1B5+ABr
			; sub_1D1B5+AFr
			; sub_1D1B5+B3r
			; sub_1D1B5+FBr
			; sub_1D1B5+FFr
			; sub_1D1B5+103r
			; sub_1D1B5:loc_1D2BCr
			; sub_1D1B5+15Fr
			; sub_1D1B5+163r
			; sub_1D1B5+167r
			; sub_1D1B5:loc_1D320r
			; sub_1D1B5+1C5r
			; sub_1D1B5:loc_1D37Er
			; sub_1D1B5+1CDr
			; sub_1D1B5+1D1r
word_36044 dw 32h	; DATA XREF: sub_1D198:loc_1D1AAw
; int word_36046
word_36046 dw 0		; DATA XREF: sub_1D198+18w
			; sub_1D1B5:loc_1D284r
; int word_36048
word_36048 dw 0		; DATA XREF: sub_1D198+6w
			; sub_1D1B5+D3r
; char arg0_PrintString[]
arg0_PrintString db 'RND no 0',27h,'s',0
			; DATA XREF: idk_Arg_0Fail_ElseMathyDiSi:loc_1CC92o
aNo_help db 'NO_HELP',0
align 2
FLAG_DebugMode dw 0	; DATA XREF: IfDebugExitWithMemDiag:loc_1DB45r
			; ST_ScreenDump+9r
			; ST_SetDebugModeTrue+3w
			; fncCheckDebugMode+3r
strSCRDMP00FLI db 'SCRDMP00.FLI',0
			; DATA XREF: ST_ScreenDump+24o
			; ST_ScreenDump+AAo
a0 db '0',0             ; DATA XREF: ST_ScreenDump:loc_1DB95o
strSCRDMP db 'SCRDMP',0 ; DATA XREF: ST_ScreenDump:BUILD_FILENAMEo
strWB_SCRNDMP db 'wb',0 ; DATA XREF: ST_ScreenDump:WRITE_SCRNDMPo
align 4
unk_3607C db	1	; DATA XREF: idk_MemAndVid_s1E0DA:loc_1E1C7o
			; idk_VidLib_s1E2D0+31o
db    2
db    4
db    8
db    0
db    0
unk_36082 db	1	; DATA XREF: sub_1EC88+31o
db    2
db    4
db    8
unk_36086 db	1	; DATA XREF: idk_VGA_ScIndexMapMask_s22194+2Co
db    2
db    4
db    8
db    1
db    2
db    4
db    8
db    0
db    0
db    1
db    2
db    4
db    8
db    0
db    0
unk_36096 db	1	; DATA XREF: sub_23CF1:loc_23D62o
db    2
db    4
db    8
idk_Mouse_w3609A dw 0	; DATA XREF: wtf_s23F3E+3Ew
			; idk_Mouse_s23F82:loc_23F8Er
			; idk_Mouse_s23F82:loc_23FD5w
			; sub_23FDC+6r
			; sub_24648+Fr
			; sub_2471B+Fr
			; sub_24A74+Cr
			; sub_24A9A+Cr
idk_Mouse_w3609C dw 0	; DATA XREF: idk_Mouse_s23F82+Fw
			; sub_2471B+16r
			; idk_ChkMousDoEga:loc_248DAr
			; sub_2495B+Fr
			; sub_249EF:loc_249FEr
FLAG_Set_FLAG_Mouse_Skip dw 0
			; DATA XREF: MOUSE_SetupRangeRoutine+78w
			; DOS_MouseReset:loc_240F0w
			; MOUSE_ExchangeInterrupt+24w
			; hrmMsExchIntSub+24w
			; Mouse_InterruptCallback:loc_241CCr
			; Mouse_InterruptCallback:loc_241D6w
			; Mouse_InterruptCallback+C6w
			; Disable_Set_FLAG_Mouse_Skip+7r
			; Disable_Set_FLAG_Mouse_Skip+11w
			; Restore_Set_FLAG_Mouse_Skip+Bw
FLAG_MouseLeftHanded dw	0
			; DATA XREF: _f330547_GetMouseButtonsStatus+7r
			; MOUSE_SetupRangeRoutine+2Cw
			; DOS_MouseReset+9r
			; DOS_MouseReset:loc_24119w
			; MOUSE_ExchangeInterrupt+9r
			; hrmMsExchIntSub+9r
			; sub_24298+6r
			; CALL_PositionMouseCursor+15r
w360A2 dw 0		; DATA XREF: set_w360A2_1:loc_240D4w
			; sub_24298:loc_242A8r
idk_Mouse_w360A4 dw 9Eh	; DATA XREF: MOUSE_SetupRangeRoutine+40w
			; Mouse_InterruptCallback+14w
			; get__Mouse_w360A4+6r
			; CALL_PositionMouseCursor+Cw
idk_Mouse_w360A6 dw 64h	; DATA XREF: MOUSE_SetupRangeRoutine+44w
			; Mouse_InterruptCallback+17w
			; get__Mouse_w360A6+6r
			; CALL_PositionMouseCursor+12w
idk_Mouse_w360A8 dw 1	; DATA XREF: wtf_s23F3E+Cw
			; idk_Mouse_s23F82:loc_23F98r
			; Mouse_InterruptCallback+7Dr
			; sub_24D35:loc_24D88r
idk_Mouse_w360AA dw 0	; DATA XREF: wtf_s23F3E:loc_23F77w
			; idk_Mouse_s23F82:loc_23FD0w
			; idk_Get_Mouse_w360AA:loc_23FEDr
FLAG_Mouse_w360AC dw 0	; DATA XREF: MOUSE_SetupRangeRoutine+7Ew
			; DOS_MouseReset+1Aw
			; get_w360AC_set0+6r
			; get_w360AC_set0+Bw
			; sub_245E4+Fw
			; sub_2460E:loc_2462Aw
idk_Mouse_w360AE dw 0	; DATA XREF: idk_Get_Mouse_w360AE+6r
			; sub_245C6+12w
			; sub_245E4+18w
			; sub_2460E+2Bw
idk_Mouse_w360B0 dw 0	; DATA XREF: idk_Get_Mouse_w360B0:loc_24594r
			; sub_245C6+18w
			; sub_245E4+1Ew
			; sub_2460E+31w
idkMouse_w360B2	dw 0	; DATA XREF: idk_Get_Mouse_w360B2+6r
			; sub_245E4+24w
			; sub_2460E:loc_24627w
FLAG_Mouse_w360B4 dw 0	; DATA XREF: MOUSE_SetupRangeRoutine+84w
			; DOS_MouseReset+20w
			; _f332647_Get_w360B4_Set0+6r
			; _f332647_Get_w360B4_Set0+Bw
			; sub_245C6+9w
			; sub_245E4+9w
			; sub_2460E+22w
FLAG_Mouse_Skip	dw 0	; DATA XREF: MOUSE_SetupRangeRoutine+32w
			; Mouse_InterruptCallback+1Br
			; Mouse_InterruptCallback+2Bw
			; Mouse_InterruptCallback+D2w
word_360B8 dw 0		; DATA XREF: sub_24648+16r
			; sub_24648:loc_2466Dw
			; sub_2471B+1Dr
			; sub_2471B:loc_24747w
word_360BA dw 9Eh	; DATA XREF: MOUSE_SetupRangeRoutine+3Cr
			; DOS_MouseReset+2Bw
word_360BC dw 64h	; DATA XREF: MOUSE_SetupRangeRoutine+38r
			; DOS_MouseReset+33w
temp_Set_FLAG_Mouse_Skip dw 0
			; DATA XREF: Disable_Set_FLAG_Mouse_Skip+Bw
			; Restore_Set_FLAG_Mouse_Skip+7r
idk_Mouse_w360C0 dw 0	; DATA XREF: wtf_s23F3E+15w
			; idk_Mouse_s23F82:loc_23F94r
idk_Dseg_RepMovSw_DI dw	0
			; DATA XREF: idk_Dseg_RepMovSw+Bo
			; sub_2495B+34r
			; sub_2495B+3Er
			; sub_2495B+48r
			; sub_2495B:loc_249BEr
			; sub_249EF+20r
			; sub_249EF+2Ar
			; sub_249EF+34r
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_360E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_360F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36110 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36130 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_361BF db	0
unk_361C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_361EE db	0
db    0
unk_361F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36210 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36230 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36240 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36260 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36268 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36270 db	0
db    0
unk_36272 db	0
unk_36273 db	0
db    0
db    0
db    0
db    0
unk_36278 db	0
db    0
db    0
unk_3627B db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_362A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36300 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36310 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36340 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36370 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3638F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_363A8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_363B4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_363C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_363F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36400 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36420 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36430 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36440 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36460 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36470 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36490 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_364A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_364C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_364F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36500 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3650E db	0
db    0
unk_36510 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36520 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3653E db	0
db    0
unk_36540 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3654A db	0
db    0
db    0
db    0
db    0
db    0
unk_36550 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3655A db	0
db    0
db    0
db    0
db    0
db    0
unk_36560 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36570 db	0
db    0
idk_Dseg_RepMovSw_SI db	   0
			; DATA XREF: idk_Dseg_RepMovSw+Eo
db    0
unk_36574 db	0
unk_36575 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3657E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36588 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36590 db	0
db    0
unk_36592 db	0
unk_36593 db	0
db    0
db    0
db    0
db    0
unk_36598 db	0
db    0
db    0
unk_3659B db	0
db    0
db    0
db    0
db    0
unk_365A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_365AA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_365B8 db	0
db    0
db    0
db    0
db    0
unk_365BD db	0
db    0
db    0
unk_365C0 db	0
db    0
unk_365C2 db	0
unk_365C3 db	0
db    0
db    0
db    0
db    0
unk_365C8 db	0
db    0
db    0
unk_365CB db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_365F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_365F8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36602 db	0
unk_36603 db	0
db    0
db    0
db    0
db    0
unk_36608 db	0
db    0
db    0
unk_3660B db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36620 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36630 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36640 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3665E db	0
db    0
unk_36660 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36670 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3668C db	0
db    0
db    0
db    0
unk_36690 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_366A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_366AF db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_366BC db	0
db    0
db    0
db    0
unk_366C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_366D4 db	0
db    0
db    0
db    0
unk_366D8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_366DF db	0
db    0
db    0
unk_366E2 db	0
unk_366E3 db	0
db    0
db    0
db    0
db    0
unk_366E8 db	0
db    0
db    0
unk_366EB db	0
db    0
db    0
db    0
db    0
unk_366F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36700 db	0
db    0
db    0
db    0
unk_36704 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36710 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3671A db	0
db    0
db    0
db    0
db    0
unk_3671F db	0
unk_36720 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36740 db	0
db    0
db    0
db    0
unk_36744 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36754 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3676C db	0
db    0
db    0
db    0
unk_36770 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36786 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3678E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36798 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_367A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_367BE db	0
db    0
unk_367C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_367F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_367FF db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36808 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36812 db	0
unk_36813 db	0
db    0
db    0
db    0
db    0
unk_36818 db	0
db    0
db    0
unk_3681B db	0
db    0
db    0
db    0
db    0
unk_36820 db	0
db    0
db    0
db    0
unk_36824 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36830 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36838 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36840 db	0
db    0
unk_36842 db	0
unk_36843 db	0
db    0
db    0
db    0
db    0
unk_36848 db	0
db    0
db    0
unk_3684B db	0
db    0
db    0
unk_3684E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36860 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3686A db	0
db    0
db    0
db    0
db    0
db    0
unk_36870 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3687A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3688E db	0
db    0
unk_36890 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3689A db	0
db    0
db    0
db    0
db    0
db    0
unk_368A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_368AA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_368BE db	0
db    0
unk_368C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_368C8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_368D2 db	0
unk_368D3 db	0
db    0
db    0
db    0
db    0
unk_368D8 db	0
db    0
unk_368DA db	0
unk_368DB db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_368EA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36900 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36908 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36910 db	0
db    0
unk_36912 db	0
unk_36913 db	0
db    0
db    0
db    0
db    0
unk_36918 db	0
db    0
db    0
unk_3691B db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3692F db	0
unk_36930 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36938 db	0
db    0
db    0
db    0
db    0
db    0
unk_3693E db	0
db    0
unk_36940 db	0
db    0
unk_36942 db	0
unk_36943 db	0
db    0
db    0
db    0
db    0
unk_36948 db	0
db    0
db    0
unk_3694B db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36954 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3695F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3696E db	0
db    0
unk_36970 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36984 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_369AC db	0
db    0
unk_369AE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_369B8 db	0
db    0
unk_369BA db	0
db    0
db    0
db    0
db    0
db    0
unk_369C0 db	0
db    0
unk_369C2 db	0
unk_369C3 db	0
db    0
db    0
db    0
db    0
unk_369C8 db	0
db    0
unk_369CA db	0
unk_369CB db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_369DC db	0
db    0
unk_369DE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_369E8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_369EF db	0
unk_369F0 db	0
db    0
unk_369F2 db	0
unk_369F3 db	0
db    0
db    0
db    0
db    0
unk_369F8 db	0
db    0
db    0
unk_369FB db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36A0C db	0
db    0
unk_36A0E db	0
db    0
unk_36A10 db	0
db    0
db    0
db    0
unk_36A14 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36A1C db	0
db    0
db    0
db    0
unk_36A20 db	0
db    0
word_36A22 dw 0		; DATA XREF: sub_24C66+17w
			; sub_24C92+8r
			; sub_24CB0+4w
			; sub_24CB0:loc_24CD8w
			; sub_24CE7+Cr
			; sub_24CE7+44w
			; sub_24D35+Dr
word_36A24 dw 0		; DATA XREF: sub_24C66+1Aw
			; set_w36A24_0w
			; sub_24D35+9r
			; sub_24D35:loc_24DA5w
word_36A26 dw 0		; DATA XREF: set_w36A26_1w
			; sub_24C92:loc_24CA9w
			; sub_24CB0+33r
word_36A28 dw 0		; DATA XREF: sub_24C66r
			; sub_24C92r
			; sub_24CB0+Ar
			; sub_24CE7+7r
			; sub_24D35:loc_24D39r
			; sub_25D7A+1Bw
			; sub_25DAB+2Br
			; sub_25DFF+28r
word_36A2A dw 0		; DATA XREF: sub_24C66+Br
			; sub_24C92+Er
			; sub_24CB0+14r
			; sub_24CE7+10r
			; sub_24CE7+3Br
			; sub_24D35:loc_24D52r
			; sub_24D35:loc_24D6Dr
			; sub_25D7A:loc_25DA4w
			; sub_25DAB:loc_25DCEr
			; sub_25DFF+20r
idk_FLAG_w36A2C	dw 0	; DATA XREF: sub_2E1FB+13w
			; sub_2E23E+11w
			; sub_2E257+3w
			; seg034:94C5w
			; sub_2E26D+3r
			; sub_2E27D+3r
			; sub_2E2B7+3r
idk_Kbd_w36A2E dw 0	; DATA XREF: rschKBD_s2669B:loc_266AEr
			; rschKBD_s2669B+1Cw
			; rschKBD_s2669B:loc_266BDr
			; rschKBD_s2669B+96r
			; rschKBD_s2669B:loc_2683Bw
hrmMouseInstalled dw 0	; DATA XREF: sub_27913+Br
			; sub_27C84+19r
			; sub_27CC0:loc_27CDFr
			; sub_27E4B:loc_27ED5r
			; sub_28141+Dr
			; sub_28141:loc_2829Er
			; sub_28141:loc_28538r
			; sub_28583+12r
			; sub_28583:loc_28681r
			; sub_28583+381r
			; idk_Mouse_s2B8B1+33w
			; idk_Mouse_s2B8B1+6Aw
			; idk_Mouse_s2B8B1+6Dr
			; idk_Mouse_s2B8B1:MOUSE_INSTALLEDw
			; sub_2B97A:loc_2B9A5r
			; sub_2E00A:loc_2E038r
w36A32 dw 0FFFFh	; DATA XREF: sub_24DAE+Dw
			; sub_24DAE+2C0w
			; sub_24DAE:loc_252BAw
			; sub_24DAE:SET_w36A32_FFFFw
			; sub_24DAE:loc_254C9w
			; sub_24DAE:loc_25777w
			; sub_24DAE:loc_25805w
			; sub_24DAE:loc_25929r
			; sub_24DAE:loc_25933r
			; sub_24DAE:loc_2594Dr
			; sub_24DAE+BB4r
			; sub_24DAE+BC9r
			; sub_24DAE+BEBr
			; sub_24DAE:loc_259D0w
			; sub_24DAE+C3Br
			; sub_24DAE+C6Er
			; sub_24DAE+C8Ar
			; sub_24DAE:loc_25A4Dr
			; sub_24DAE:aSET_w36A32_FFFFw
			; sub_24DAE+E94w
			; sub_24DAE:loc_25C61w
			; sub_24DAE+F2Fw
			; sub_26026:loc_2624Fw
			; sub_26026:loc_262A9w
			; sub_26026:loc_2652Fw
			; sub_27AFB:loc_27BC3r
			; sub_27AFB:loc_27BCAr
			; sub_28141+413w
			; sub_28583+68w
			; sub_28583:loc_28916w
			; setFlagsMaybeMouseEGA+9w
			; seg034:6AFFw
			; idk_Mouse_s2B8B1+B7w
			; sub_2BA41:loc_2BA71r
			; sub_2BA41:loc_2C65Ar
			; sub_2E00A+3Dr
			; sub_2E00A:loc_2E050r
			; sub_2E00A+52w
			; sub_2E00A:loc_2E0B2r
			; sub_2E00A+B6r
			; sub_2E00A:loc_2E0E9r
			; sub_2E00A+11Fr
			; sub_2E00A+12Er
			; sub_2E00A:loc_2E142w
			; sub_2E00A:loc_2E1A6w
			; sub_2E00A+1ABw
word_36A34 dw 1		; DATA XREF: sub_29720+6w
			; sub_2BA41+473r
			; sub_2BA41+743r
			; sub_2BA41+A22r
			; sub_2CF44+2DEr
			; sub_2CF44+5B7r
			; sub_2CF44+893r
			; sub_2CF44+BB7r
word_36A36 dw 0FFFFh	; DATA XREF: sub_29720+Cw
			; sub_2BA41+42Fr
			; sub_2BA41+6FFr
			; sub_2BA41:loc_2C41Fr
			; sub_2CF44+29Ar
			; sub_2CF44+573r
			; sub_2CF44+84Fr
			; sub_2CF44+B73r
idk_Value_w36A38 dw 0FFFFh
			; DATA XREF: sub_2A755+1BEr
			; sub_2A755+3EFr
			; sub_2A755+5CEr
			; sub_2A755+7F3r
			; sub_2A755+98Fr
			; sub_2B1F9+12Ar
			; idk_SetValue_w36A38_s2E1E5+6w
			; idk_SetValue_w36A38_FFFF_s2E1F0+3w
word_36A3A dw 0		; DATA XREF: sub_24DAE:loc_2531Ar
			; sub_26026:loc_264D3r
			; sub_27E4B:loc_27EB6r
			; sub_2A755+Bw
			; sub_2A755+A69w
			; sub_2B1F9+Bw
			; sub_2B1F9+242w
idk_InitRoland_w36A3C dw 2
			; DATA XREF: sub_28963+3D7r
			; sub_2A755:loc_2B1A7r
			; sub_2B1F9:loc_2B424r
			; sub_2E1FB+22w
			; sub_2E1FB:loc_2E223w
			; sub_2E2B7+22r
word_36A3E dw 0		; DATA XREF: idk_Mouse_s2B8B1:IF_ARG_EQ_1o
dw 0
dw 0
dw 13Fh
dw 0C7h
dw 0
word_36A4A dw 0		; DATA XREF: sub_24DAE+18w
			; sub_24DAE+862w
			; sub_24DAE+AE4w
			; sub_24DAE:loc_25B6Aw
			; sub_24DAE:loc_25B90r
			; sub_24DAE:loc_25BAAw
			; sub_2601C+3r
			; sub_27C84+3w
			; setFlagsMaybeMouseEGA+Fw
idk_Flag_w36A4C	dw 1	; DATA XREF: sub_2A755:loc_2ADC1r
			; sub_2A755+A6Fw
			; sub_2B1F9+1E9r
			; sub_2B1F9+248w
			; idk_SetFlag_w36A4C_s2B465+3w
word_36A4E dw 0		; DATA XREF: sub_2A755+11w
			; sub_2A755+A75w
			; sub_2B470:loc_2B4E1r
			; sub_2B470:loc_2B521r
			; sub_2B470:loc_2B585r
			; sub_2B470:loc_2B663r
			; sub_2B470+23Dr
; int word_36A50
word_36A50 dw 0		; DATA XREF: sub_2A738+Fw
			; sub_2A738:loc_2A74Dw
			; sub_2BA41:loc_2C473r
			; sub_2BA41:loc_2C502r
			; sub_2CF44+C20r
			; sub_2CF44:loc_2DC2Fr
word_36A52 dw 0		; DATA XREF: sub_2A755:loc_2A76Cw
			; sub_2A755:loc_2ADE9r
			; sub_2A755:loc_2AFE6r
			; sub_2A755:loc_2B182w
			; sub_2B470+A8w
			; sub_2B470+BDw
			; sub_2B470+11Cw
			; sub_2B470+1FAw
			; sub_2B470:loc_2B6B4w
idk_CfgMom_w36A54 dw 0	; DATA XREF: sub_24DAE+C3r
			; sub_24DAE:loc_25513r
			; sub_24DAE+A5Dr
			; sub_24DAE:loc_258D4r
			; sub_24DAE+E9Ar
			; SetFlag_1_CfgMom_w36A54+3w
			; SetFlag_0_CfgMom_w36A54:loc_25E54w
			; idk_Mouse_s2B8B1+BDw
word_36A56 dw 0		; DATA XREF: sub_24DAE+2FCr
			; sub_24DAE:loc_2530Br
			; sub_24DAE+DBFr
			; SetFlag_1_w36A56+3w
			; SetFlag_0_w36A56+3w
			; sub_26026:loc_264C4r
aNotInUse db 'NOT IN USE',0
algn_36A63:
align 2
word_36A64 dw 0		; DATA XREF: sub_28141:loc_28165w
			; sub_28141:loc_2823Dw
			; sub_28141+100r
			; sub_28141+10Bw
			; sub_28141+1ECw
			; sub_28141+203r
			; sub_28141+212w
			; sub_28141:loc_2835Fr
			; sub_28141+225r
			; sub_28141:loc_28378w
			; sub_28141+24Cr
			; sub_28141:loc_28393r
			; sub_28141+276r
			; sub_28141:loc_283BEw
			; sub_28141:loc_283CBr
			; sub_28141+292r
			; sub_28141+298w
			; sub_28141+2A2r
			; sub_28141+2B0r
			; sub_28141:loc_28408w
			; sub_28141+34Er
			; sub_28141:loc_284A0r
			; sub_28141+369r
			; sub_28141+374w
			; sub_28141:loc_284E2w
			; sub_28141+419w
			; sub_28583+6Bw
			; sub_28583:loc_28645w
			; sub_28583+C6r
			; sub_28583+D1w
			; sub_28583+18Dw
			; sub_28583+1A4r
			; sub_28583+1B3w
			; sub_28583:loc_28742r
			; sub_28583+1C6r
			; sub_28583+1D8w
			; sub_28583+1EDr
			; sub_28583+1F3r
			; sub_28583+217r
			; sub_28583+21Ew
			; sub_28583:loc_287AEr
			; sub_28583+233r
			; sub_28583+239w
			; sub_28583+243r
			; sub_28583+260w
			; sub_28583+2E7r
			; sub_28583:loc_2887Br
			; sub_28583+302r
			; sub_28583+30Dw
			; sub_28583+33Aw
			; sub_28583+3A8w
			; sub_28963+151r
			; sub_28963:loc_28AC2r
			; sub_28963+18Cr
			; sub_28963+28Dr
			; sub_28963+29Br
			; sub_28963+2C8r
word_36A66 dw 0		; DATA XREF: sub_24DAE+35Aw
			; sub_24DAE+395w
			; sub_24DAE+3D3w
			; sub_24DAE+462w
			; sub_24DAE+6DAw
			; sub_24DAE+715w
			; sub_24DAE+8C0w
			; sub_24DAE:loc_256AEw
			; sub_24DAE+941w
			; sub_24DAE+D03w
			; sub_24DAE+D42w
			; sub_26026:loc_26312w
			; sub_26026:loc_2634Cw
			; sub_26026:loc_263C2w
			; sub_26026+619w
			; sub_26026+654w
			; sub_28141+2Aw
			; sub_28141:loc_282BEw
			; sub_28141+187r
			; sub_28141:loc_282CEw
			; sub_28141+1F2w
			; sub_28141+216w
			; sub_28141+23Bw
			; sub_28141+264w
			; sub_28141+281w
			; sub_28141+29Cw
			; sub_28141:loc_284EAw
			; sub_28141+41Fw
			; sub_28583:loc_285F4w
			; sub_28583:loc_286A1w
			; sub_28583+128r
			; sub_28583+12Ew
			; sub_28583+193w
			; sub_28583+1B7w
			; sub_28583+1DCw
			; sub_28583+205w
			; sub_28583+222w
			; sub_28583+23Dw
			; sub_28583+342w
			; sub_28583+3AEw
			; sub_28963+1AEr
			; sub_28963:loc_28B18r
			; sub_28963:loc_28B20r
			; sub_28963:loc_28B7Ar
			; sub_28963+21Er
			; sub_28963+2EAr
			; sub_2BA41:loc_2CB24r
			; sub_2BA41:loc_2CB37r
			; sub_2BA41+1101w
			; sub_2BA41+1105r
			; sub_2BA41+110Cw
word_36A68 dw 0		; DATA XREF: sub_24DAE+360w
			; sub_24DAE+39Bw
			; sub_24DAE:loc_25482w
			; sub_24DAE+8C6w
			; sub_24DAE+906w
			; sub_24DAE+D09w
			; sub_24DAE+D48w
			; sub_26026:loc_26318w
			; sub_26026+32Cw
			; sub_26026:loc_26639w
			; sub_28583:loc_285FAw
			; sub_28963:loc_28C5Cr
			; sub_28963+300w
			; sub_28963+30Cr
			; sub_28963:loc_28C76w
			; sub_28963+330r
			; sub_2BA41:loc_2CB2Cr
			; sub_2BA41+10FEw
			; sub_2BA41+1118r
word_36A6A dw 0		; DATA XREF: sub_24DAE:loc_25083r
			; sub_24DAE:loc_250E5r
			; sub_24DAE+366w
			; sub_24DAE:loc_251ABr
			; sub_24DAE+468w
			; sub_24DAE:loc_253D4r
			; sub_24DAE:loc_2564Ar
			; sub_24DAE+8CCw
			; sub_24DAE:loc_2571Ar
			; sub_24DAE:loc_2576Bw
			; sub_24DAE:loc_25A8Dr
			; sub_24DAE+D0Fw
			; sub_24DAE+D4Ew
			; sub_24DAE:loc_25B0Ar
			; sub_24DAE+DADw
			; sub_26026:loc_262EFr
			; sub_26026+2F8w
			; sub_26026:loc_2635Er
			; sub_26026+3A2w
			; sub_26026:loc_2658Br
			; setFlagsMaybeMouseEGA+15w
word_36A6C dw 0		; DATA XREF: sub_24DAE:loc_24E8Ar
			; sub_24DAE:loc_24E91w
			; sub_24DAE:loc_24E99w
			; sub_2BA41:loc_2CC55r
FLAG_w36A6E dw 0	; DATA XREF: sub_24DAE:FlipFLAG_w36A6Er
			; sub_24DAE:loc_24EB5w
			; sub_24DAE:loc_24EBDw
			; sub_2BA41:loc_2CDBCr
word_36A70 dw 0FFFFh	; DATA XREF: sub_24DAE+2DCr
			; sub_24DAE+36Cw
			; sub_24DAE:loc_25121r
			; sub_24DAE+3A1w
			; sub_24DAE+3D9w
			; sub_24DAE+424r
			; sub_24DAE+449r
			; sub_24DAE:loc_2521Cw
			; sub_24DAE+693r
			; sub_24DAE:loc_25458r
			; sub_24DAE+6F5r
			; sub_24DAE+8D5w
			; sub_24DAE:loc_25689r
			; sub_24DAE:loc_256BDw
			; sub_24DAE:loc_256F5w
			; sub_24DAE+97Fr
			; sub_24DAE:loc_25752r
			; sub_24DAE+9C3w
			; sub_24DAE+D18w
			; sub_24DAE:loc_25ACBr
			; sub_24DAE+D57w
			; sub_24DAE+D6Fr
			; sub_24DAE+D94r
			; sub_24DAE+DB3w
			; sub_26026+2FEw
			; sub_26026:loc_2632Ar
			; sub_26026+332w
			; sub_26026+383r
			; sub_26026:loc_263CEw
			; sub_26026+5D2r
			; sub_26026:loc_2660Fr
			; sub_26026:loc_2665Ar
			; setFlagsMaybeMouseEGA+1Bw
			; sub_2BA41:loc_2C83Ar
word_36A72 dw 0		; DATA XREF: sub_25D32+14w
			; sub_25D4E+14w
			; sub_25D6A+3w
			; sub_25DAB+49w
			; sub_25DFF+3Ew
			; sub_28141:loc_2828Cr
			; sub_28583:loc_2866Fr
word_36A74 dw 0		; DATA XREF: sub_25D7A+27w
word_36A76 dw 0		; DATA XREF: sub_25D32+3r
			; sub_25D4E+3r
			; sub_25D7A:loc_25D98w
			; sub_25DAB+7r
			; sub_25DFF+4r
idk_Flag_Mouse_w36A78 dw 0
			; DATA XREF: sub_24DAE+752r
			; sub_24DAE+B09r
			; idk_SetThreeFlagsOrValues_s25E72+9w
			; idk_SetThreeFlags_s25E89+3w
idk_Flag_w36A7A	dw 0	; DATA XREF: idk_SetThreeFlagsOrValues_s25E72+12w
			; idk_SetThreeFlags_s25E89+9w
			; sub_25EA0+1Dr
			; sub_25EA0+A7r
			; sub_25EA0:loc_25F51r
			; sub_2BA41:loc_2CDC6r
			; sub_2BA41:loc_2CF09r
FLAG_GotKey dw 0	; DATA XREF: rschKBD_s2669B:NOT_LOWERCASE_LETTERr
			; rschKBD_s2669B:loc_266E4r
			; rschKBD_s2669B:loc_2672Bw
			; rschKBD_s2669B:loc_26A06w
			; rschKBD_s2669B+39Ew
aRb_0 db 'rb',0         ; DATA XREF: sub_25DAB+Eo
aWb db 'wb',0           ; DATA XREF: sub_25DFF+Bo
word_36A84 dw 5
dw 6
word_36A88 dw 5Fh
idk_AIL_SndDrvNbr_w36A8A dw 0
			; DATA XREF: ST_LoadSoundDrivers+15w
			; ST_LoadSoundDrivers:loc_2FDD0r
			; ST_LoadSoundDrivers:loc_2FDEFr
			; ST_LoadSoundDrivers+E1r
			; ST_LoadSoundDrivers:loc_2FE24w
			; ST_LoadSoundDrivers:loc_2FE31w
			; ST_LoadSoundDrivers:loc_2FE3Cw
			; ST_LoadSoundDrivers:loc_2FE47r
			; ST_LoadSoundDrivers+185r
			; ST_LoadSoundDrivers+1BEr
			; ST_LoadSoundDrivers:loc_2FF22r
			; ST_LoadSoundDrivers:loc_2FF5Dr
			; ST_LoadSoundDrivers:loc_30064r
			; ST_LoadSoundDrivers:loc_30237r
			; ST_LoadSoundDrivers+63Br
			; ST_LoadSoundDrivers:loc_3037Er
			; ST_LoadSound:SND_SUBTYP_1r
			; ST_LoadSound:loc_30497r
			; AIL_someSequence:loc_3083Fr
			; AIL_someSequence:loc_3084Fr
			; Call_AIL_shutdown+3r
			; sub_308E6:loc_308FCr
			; sub_308E6:loc_3090Fr
			; sub_308E6:loc_30935r
			; sub_308E6:loc_30944r
AIL_playback_w36A8C dw 0
			; DATA XREF: ST_LoadSoundDrivers+1Cw
			; ST_LoadSoundDrivers:loc_2FE6Dr
			; ST_LoadSoundDrivers+15Fr
			; ST_LoadSoundDrivers:loc_2FEB3r
			; ST_LoadSoundDrivers+1E9r
			; ST_LoadSoundDrivers:loc_2FF3Ar
			; ST_LoadSoundDrivers+277r
			; ST_LoadSoundDrivers:loc_30134r
			; ST_LoadSoundDrivers:loc_30204r
			; ST_LoadSound:SND_SUBTYP_2r
			; ST_LoadSound:loc_305B0r
			; ST_LoadSound:loc_30624r
			; ST_LoadSound+2F8r
			; sub_3071A+CEr
			; AIL_someSequence+2Cr
			; Call_AIL_shutdown+Ar
			; sub_308E6+30r
idk_AIL_w36A8E dw 0	; DATA XREF: ST_LoadSoundDrivers+1Fr
			; ST_LoadSoundDrivers:loc_3032Dw
			; ST_LoadSound+Br
			; sub_3071A+Ar
			; sub_3071A+4Er
			; sub_3071A+85r
			; sub_307FD+6r
			; AIL_someSequence+3r
			; Call_AIL_shutdown:loc_308BFr
			; Call_AIL_shutdown+30w
AIL_HDRIVER1 dw	0FFFFh	; DATA XREF: ST_LoadSoundDrivers+19Bw
			; ST_LoadSoundDrivers:loc_2FECCr
			; ST_LoadSoundDrivers+214r
			; ST_LoadSoundDrivers+379r
			; ST_LoadSoundDrivers+3D3r
			; ST_LoadSoundDrivers+549r
			; ST_LoadSoundDrivers:loc_3026Ar
			; ST_LoadSoundDrivers+5C7r
			; ST_LoadSoundDrivers+60Cr
			; ST_LoadSound+BCr
			; ST_LoadSound+139r
			; ST_LoadSound+162r
			; ST_LoadSound+18Ar
			; sub_3071A+37r
			; sub_3071A+64r
			; sub_3071A+A0r
			; sub_3071A+BBr
			; sub_307FD+1Dr
			; AIL_someSequence+40r
			; AIL_someSequence:loc_30885r
			; AIL_someSequence+63r
			; Call_AIL_shutdown:loc_308D2w
AIL_HDRIVER2 dw	0FFFFh	; DATA XREF: ST_LoadSoundDrivers+1B4w
			; ST_LoadSoundDrivers:loc_2FEF7r
			; ST_LoadSoundDrivers+22Cr
			; ST_LoadSoundDrivers+449r
			; ST_LoadSoundDrivers+4A3r
			; ST_LoadSoundDrivers+516r
			; ST_LoadSound+1ECr
			; ST_LoadSound+1FAr
			; ST_LoadSound+224r
			; ST_LoadSound+23Cr
			; ST_LoadSound+248r
			; ST_LoadSound+2F1r
			; ST_LoadSound+2FFr
			; ST_LoadSound+315r
			; ST_LoadSound+341r
			; ST_LoadSound+34Dr
			; sub_3071A:loc_307E1r
			; sub_3071A+D5r
			; AIL_someSequence+25r
			; AIL_someSequence:loc_308A5r
			; Call_AIL_shutdown+2Aw
AIL_timbre_w36A94 dw 0FFFEh
			; DATA XREF: ST_LoadSound+C8w
			; ST_LoadSound:loc_3051Br
			; ST_LoadSound:loc_30543r
			; sub_3071A:loc_3072Fr
			; sub_3071A+33r
			; sub_3071A:loc_30773r
			; sub_3071A+60r
			; sub_3071A:loc_307AAr
			; sub_3071A+9Cr
			; sub_3071A+B7r
			; sub_307FD:loc_30816r
			; AIL_someSequence:loc_30866r
			; AIL_someSequence+3Cr
			; AIL_someSequence+50r
			; AIL_someSequence:loc_30890r
			; AIL_someSequence+6Ew
dw 0FFFEh
word_36A98 dw 0		; DATA XREF: ST_LoadSoundDrivers+58Cw
			; ST_LoadSound+ADr
word_36A9A dw 0		; DATA XREF: ST_LoadSoundDrivers+588w
			; ST_LoadSound+A9r
align 8
AIL_shutdown_w36AA0 dw 0
			; DATA XREF: ST_LoadSoundDrivers:loc_2FD9Dw
			; ST_LoadSoundDrivers:loc_2FDACw
			; ST_LoadSoundDrivers:loc_2FDC4w
			; ST_LoadSoundDrivers+C2w
			; ST_LoadSoundDrivers:loc_2FDE9w
			; ST_LoadSoundDrivers+1D2w
			; ST_LoadSoundDrivers+1FDw
			; ST_LoadSoundDrivers+25Cw
			; ST_LoadSoundDrivers+28Bw
			; ST_LoadSoundDrivers+3F0w
			; ST_LoadSoundDrivers+40Fw
			; ST_LoadSoundDrivers+4C0w
			; ST_LoadSoundDrivers+4DFw
			; ST_LoadSound+12r
			; ST_LoadSound:loc_303DCr
			; ST_LoadSound:loc_3061Ar
			; sub_307FD+Dr
			; AIL_someSequence+15r
			; sub_308E6+21w
			; sub_308E6+3Bw
			; sub_308E6+47w
			; sub_308E6+56w
			; sub_308E6+65w
			; sub_308E6:loc_30953w
word_36AA2 dw 4941h	; DATA XREF: idk_Env_BLASTER_s3095D:loc_309DEr
dw 5444h
dw 0
word_36AA8 dw 10h	; DATA XREF: idk_Env_BLASTER_s3095D+CAr
			; idk_Env_BLASTER_s3095D+DEr
dw 0Ah
dw 0Ah
dw 0Ah
word_36AB0 dw 0A8B4h	; DATA XREF: idk_Env_BLASTER_s3095D+F8r
dw 0A8B6h
dw 0A8B8h
dw 0A8C0h
; char argFileNameBase[]
argFileNameBase	db 'SNDDRV.LBX',0
			; DATA XREF: ST_LoadSoundDrivers+13Fo
			; ST_LoadSoundDrivers+167o
			; ST_LoadSoundDrivers+646o
			; ST_LoadSoundDrivers+674o
aFat_ db 'FAT.',0       ; DATA XREF: ST_LoadSoundDrivers+58Fo
aRb db 'rb',0           ; DATA XREF: ST_LoadSound:loc_304A1o
; char name[]
name db	'BLASTER',0     ; DATA XREF: idk_Env_BLASTER_s3095D+9o
strHexTable db '0123456789ABCDEF',0
			; DATA XREF: idk_Env_BLASTER_s3095D+BCr
aYouSelectedAnInvalidSoundDriver db 'You selected an invalid sound drive'
			; DATA XREF: ST_SoundErrorHandler:loc_30AB7o
db 'r, ',0
aReconfigureHardwareOptions db 'reconfigure hardware options',0
			; DATA XREF: ST_SoundErrorHandler+27o
aYouSelectedAnInvalidDigiDriver	db 'You selected an invalid digi driver'
			; DATA XREF: ST_SoundErrorHandler:loc_30AD9o
db ', ',0
aSoundDriverIsNotAValidXmidiDriv db 'Sound driver is not a valid XMIDI d'
			; DATA XREF: ST_SoundErrorHandler:loc_30ADEo
db 'river, ',0
aDigiDriverIsNotAValidDspDriver	db 'Digi driver is not a valid DSP driv'
			; DATA XREF: ST_SoundErrorHandler:loc_30AE3o
db 'er, ',0
aMusic db 'Music ',0    ; DATA XREF: ST_SoundErrorHandler:loc_30AE8o
aIOParametersAreIncorrect db 'I/O parameters are incorrect, ',0
			; DATA XREF: ST_SoundErrorHandler+64o
aMusicIOParametersAreIncorrect db 'Music I/O parameters are incorrect,'
			; DATA XREF: ST_SoundErrorHandler:loc_30AEDo
db ' ',0
aDigiDriver db 'Digi Driver ',0
			; DATA XREF: ST_SoundErrorHandler:loc_30AF4o
aNotAValidSoundFile db 'Not a valid sound file',0
			; DATA XREF: ST_SoundErrorHandler:loc_30B08o
			; ST_SoundErrorHandler+93o
aCouldntLoadXmidiFile db 'Couldn',27h,'t load XMIDI file',0
			; DATA XREF: ST_SoundErrorHandler:loc_30B0Do
aSequenceDidNotRegister	db 'Sequence did not register',0
			; DATA XREF: ST_SoundErrorHandler:loc_30B12o
aTimbreNotFound	db 'Timbre not found',0
			; DATA XREF: ST_SoundErrorHandler:loc_30B17o
aCouldNotLoad db 'Could not load',0
			; DATA XREF: ST_SoundErrorHandler:loc_30B1Co
aNotAValid db 'Not a valid',0
			; DATA XREF: ST_SoundErrorHandler:loc_30B23o
aCouldNotLoadSoundFile db 'Could not load sound file',0
			; DATA XREF: ST_SoundErrorHandler:loc_30B41o
align 2
_atexitcnt dw 0		; DATA XREF: _atexit+3r
			; _atexit:AddAtExitFunctionr
			; _atexit+25w
			; __exit_2of2:Loop_Next_AtExitTblw
			; __exit_2of2+11r
			; __exit_2of2:loc_10589r
public __ctype
; char _ctype[]
__ctype	db    0, 20h, 20h, 20h,	20h, 20h, 20h, 20h
			; DATA XREF: _isxdigit+7r
			; idk_ctype_s10E9D+16r
db  20h, 20h, 21h, 21h,	21h, 21h, 21h, 20h
db  20h, 20h, 20h, 20h,	20h, 20h, 20h, 20h
db  20h, 20h, 20h, 20h,	20h, 20h, 20h, 20h
db  20h,   1, 40h, 40h,	40h, 40h, 40h, 40h
db  40h, 40h, 40h, 40h,	40h, 40h, 40h, 40h
db  40h,   2,	2,   2,	  2,   2,   2,	 2
db    2,   2,	2, 40h,	40h, 40h, 40h, 40h
db  40h, 40h, 14h, 14h,	14h, 14h, 14h, 14h
db    4,   4,	4,   4,	  4,   4,   4,	 4
db    4,   4,	4,   4,	  4,   4,   4,	 4
db    4,   4,	4,   4,	40h, 40h, 40h, 40h
db  40h, 40h, 18h, 18h,	18h, 18h, 18h, 18h
db    8,   8,	8,   8,	  8,   8,   8,	 8
db    8,   8,	8,   8,	  8,   8,   8,	 8
db    8,   8,	8,   8,	40h, 40h, 40h, 40h
db  20h,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0,   0,	0,   0,	  0,   0,   0,	 0
db    0
align 2
ptr_exitbuf dd nullsub_1
			; DATA XREF: __exit_2of2+29r
			; __LoadProg:loc_11927r
			; _setvbuf+96w
			; _setvbuf+90w
ptr_exitfopen dd nullsub_1
			; DATA XREF: __exit_2of2:NotDontExitNotQuickr
			; hrmCheckAccessMode+9Dw
			; hrmCheckAccessMode:loc_12060w
ptr_exitopen dd	nullsub_1
			; DATA XREF: __exit_2of2+45r
word_36D9A dw 0		; DATA XREF: _getcharw
			; __GETFP+1o
			; __GETFP+11o
			; _setvbuf+3Eo
word_36D9C dw 209h	; DATA XREF: __setupio+43w
			; __setupio+4Dr
byte_36D9E db 0		; DATA XREF: __setupio:loc_10E2Cr
db    0
db    0
db    0
db    0
db    0
word_36DA4 dw 0		; DATA XREF: _getchar+6r
			; _getchar+Aw
align 4
db  8Ah	; 
db  50h	; P
word_36DAA dw 0		; DATA XREF: _putchar+6w
			; _setvbuf+29o
word_36DAC dw 20Ah	; DATA XREF: __setupio+7Bw
			; __setupio+85r
byte_36DAE db 1		; DATA XREF: __setupio+6Cr
db    0
db    0
db    0
db    0
db    0
word_36DB4 dw 0		; DATA XREF: _putchar+Cr
			; _putchar+10w
align 4
db  9Ah	; 
db  50h	; P
unk_36DBA db	0
db    0
db    2
db    2
db    2
db    0
unk_36DC0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0AAh	; 
db  50h	; P
db    0
db    0
unk_36DCC db  43h ; C
db    2
db    3
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0BAh	; 
db  50h	; P
db    0
db    0
unk_36DDC db  42h ; B
db    2
db    4
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36DE6 db	0
db    0
db 0CAh	; 
db  50h	; P
unk_36DEA db	0
db    0
db    0
db    0
db    0
db    0
unk_36DF0 db	0
db    0
db    0
db    0
unk_36DF4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E00 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E0C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E20 db	0
db    0
db    0
db    0
unk_36E24 db	0
db    0
unk_36E26 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E2F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E3C db	0
db    0
db    0
db    0
unk_36E40 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E4C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E56 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E5F db	0
unk_36E60 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E6A db	0
db    0
db    0
db    0
db    0
db    0
unk_36E70 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E7C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E90 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36E9A db	0
db    0
db    0
db    0
db    0
unk_36E9F db	0
unk_36EA0 db	0
db    0
db    0
db    0
unk_36EA4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36EAC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36EBC db	0
db    0
db    0
db    0
unk_36EC0 db	0
db    0
db    0
db    0
unk_36EC4 db	0
unk_36EC5 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36ECE db	0
db    0
unk_36ED0 db	0
db    0
db    0
db    0
unk_36ED4 db	0
db    0
unk_36ED6 db	0
db    0
db    0
db    0
; unsigned int _nfile
__nfile	dw 14h		; DATA XREF: STARTX+D2r
			; STARTX+F5r
			; __setupio+3r
			; __setupio+2Er
			; _close+6r
			; _fcloseall+15r
			; _fcloseall+3Br
			; _eof+9r
			; _flushall+Dr
			; __GETFP+Ar
			; ___read+Br
			; ___write+Fr
			; __xfclose+7r
			; __xfclose+1Fr
unk_36EDC db	1
db  60h	; `
db    2
db  60h	; `
unk_36EE0 db	2
db  60h	; `
db    4
db 0A0h	; 
db    2
db 0A0h	; 
db    0
db    0
db    0
db    0
db    0
db    0
unk_36EEC db	0
db    0
db    0
db    0
unk_36EF0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36F00 db	0
db    0
db    0
db    0
word_36F04 dw 4000h	; DATA XREF: hrmCheckAccessMode:loc_1204Er
			; _open+14r
word_36F06 dw 0FFFFh	; DATA XREF: _open+32r
; unsigned int _heaplen
__heaplen dw 0		; DATA XREF: STARTX:loc_10074r
			; STARTX:loc_1008Ar
_doserrno dw 0		; DATA XREF: __IOERROR:ser_dosErrorw
			; __IOERROR:ser_maybeSVerr_2of2w
			; _open+4Ar
			; _open+51r
_dosErrorToSV db 0		      ;	0
			; DATA XREF: __IOERROR+17r
db 13h			; 1 ; BORLANDC\CRTL\CLIB\IOERROR.CAS
db 2			; 2 ;
db 2			; 3
db 4			; 4
db 5			; 5
db 6			; 6
db 8			; 7
db 8			; 8
db 8			; 9
db 14h			; 10
db 15h			; 11
db 5			; 12
db 13h			; 13
db 0Eh			; 14
db 16h			; 15
db 5			; 16
db 11h			; 17
db 2			; 18
db 1Eh			; 19
db 29h			; 20
db 2Ch			; 21
db 28h			; 22
db 28h			; 23
db 28h			; 24
db 28h			; 25
db 28h			; 26
db 29h			; 27
db 2Ch			; 28
db 28h			; 29
db 28h			; 30
db 28h			; 31
db 5			; 32
db 5			; 33
db 29h			; 34
db 17h			; 35
db 17h			; 36
db 0Eh			; 37
db 0Eh			; 38
db 0Eh			; 39
db 0Eh			; 40
db 0Eh			; 41
db 0Eh			; 42
db 0Eh			; 43
db 0Eh			; 44
db 0Eh			; 45
db 0Eh			; 46
db 0Eh			; 47
db 0Eh			; 48
db 0Eh			; 49
db 0Fh			; 50
db 2Ch			; 51
db 23h			; 52
db 2			; 53
db 2Ch			; 54
db 0Fh			; 55
db 2Ah			; 56
db 28h			; 57
db 28h			; 58
db 28h			; 59
db 13h			; 60
db 1Bh			; 61
db 1Ch			; 62
db 2			; 63
db 2			; 64
db 5			; 65
db 0Fh			; 66
db 2			; 67
db 17h			; 68
db 28h			; 69
db 2Ah			; 70
db 13h			; 71
db 2Ah			; 72
db 0Eh			; 73
db 0Eh			; 74
db 0Eh			; 75
db 0Eh			; 76
db 0Eh			; 77
db 0Eh			; 78
db 0Eh			; 79
db 23h			; 80
db 0Eh			; 81
db 1Ch			; 82
db 28h			; 83
db 17h			; 84
db 23h			; 85
db 25h			; 86
db 13h			; 87
db 28h			; 88
db    0
__mkname_prefix	db 'TMP',0
__mkname_extension db '.$$$',0 ; NOTE: file extension for temporary files, common to the era
align 2
a_com db '.COM',0       ; DATA XREF: sub_10C20+B6o
a_exe db '.EXE',0       ; DATA XREF: sub_10C20+DBo
aPath db 'PATH',0       ; DATA XREF: __SEARCHPATH+9o
unk_36F7F db	0
; unsigned int _stklen
__stklen dw 1000h	; DATA XREF: STARTX+5Dr
			; STARTX+6Aw
			; STARTX:LDATA_EQ_falser
SegX_w36F82 dw 0	; DATA XREF: idk_InBrkSbrk+13r
			; idk_InBrkSbrk+5Cw
LibMalloc_w36F84 dw 0	; DATA XREF: sub_11973r
			; sub_11973:loc_11987r
			; sub_11973+2Bw
			; sub_119AD+2r
			; _malloc:loc_11A40r
			; LibMalloc_s11A85+2Aw
word_36F86 dw 0		; DATA XREF: _free+Cr
			; sub_11973+Ew
			; sub_11973+22w
			; sub_11973+2Ew
			; LibMalloc_s11A85+2Ew
			; LibMalloc_s11AC5+11r
			; LibMalloc_s11AC5+17w
			; sub_11B3C+Br
LibMalloc_w36F88 dw 0	; DATA XREF: sub_11973+31w
			; LibMalloc_s119E6+7w
			; LibMalloc_s119E6:loc_119FBw
			; sub_11A02r
			; sub_11A02:loc_11A1Aw
			; _malloc+22r
word_36F8A dw 0		; DATA XREF: seg000:1C9Bw
			; seg000:1CDAr
word_36F8C dw 0		; DATA XREF: seg000:1CACw
			; seg000:1CE0r
word_36F8E dw 0		; DATA XREF: seg000:unknown_libname_1w
			; seg000:1CE6r
word_36F90 dw 0		; DATA XREF: seg000:1BD7w
			; seg000:1CD6r
word_36F92 dw 0		; DATA XREF: seg000:1BDBw
			; seg000:1CD2r
word_36F94 dw 0		; DATA XREF: seg000:1BE4w
			; seg000:1CCAr
word_36F96 dw 0		; DATA XREF: seg000:1BE8w
			; seg000:1CCEr
; int word_36F98
word_36F98 dw 0		; DATA XREF: __LoadProg+43r
			; unknown_libname_2+30w
			; unknown_libname_2+56r
			; _getenv+20r
db  0Dh
db    0
word_36F9C dw 0		; DATA XREF: _setvbuf:loc_12C76r
			; _setvbuf+44w
word_36F9E dw 0		; DATA XREF: _setvbuf:loc_12C61r
			; _setvbuf+2Fw
word_36FA0 dw 0		; DATA XREF: __OVRINIT+CCw
word_36FA2 dw 0		; DATA XREF: __OVRINIT+D3w
InitStart db	0	; DATA XREF: STARTX+143o
db    2
unk_36FA6 db 0F8h ; 
db  0Dh
db    0
db    0
db    0
db  10h
db 0D3h	; 
db  1Bh
db    0
db    0
unk_36FB0 db	0
db  10h
db    6
db  1Dh
db    0
db    0
db    1
db    1
dd __OvrPrepare
InitEnd	db    1		; DATA XREF: STARTX+146o
			; STARTX+16Ao
db    1
off_36FBE dd __OVREXIT
; char *bdata
bdata@ dw 0		; DATA XREF: STARTX+C7o
			; STARTX+16Do
			; sub_56450+9Aw
			; idk_HoF_s565F2+15Er
			; idk_HoF_s565F2+16Er
			; idk_HoF_s565F2+232r
			; idk_HoF_s565F2+250r
; char *dest
dest dw	0		; DATA XREF: sub_56450+8Dw
			; idk_HoF_s565F2+99r
			; idk_HoF_s565F2:loc_5669Ar
			; idk_HoF_s565F2:loc_566A9r
			; idk_HoF_s565F2+C6r
			; idk_HoF_s565F2+D5r
			; idk_HoF_s565F2+E0r
			; idk_HoF_s565F2+172r
			; idk_HoF_s565F2+181r
			; idk_HoF_s565F2+18Cr
			; idk_HoF_s565F2+1A7r
			; idk_HoF_s565F2+1B6r
			; idk_HoF_s565F2+1CFr
			; idk_HoF_s565F2+1DAr
			; idk_HoF_s565F2+245r
			; idk_HoF_s565F2+254r
			; idk_HoF_s565F2+263r
			; idk_HoF_s565F2+26Er
word_36FC6 dw 0		; DATA XREF: _f010509_MainMenuScreen+19Fw
			; _f010509_MainMenuScreen:loc_139ACw
			; _f010509_MainMenuScreen+420r
			; _f010609_DrawMainMenuScreen+A1r
			; sub_3DBA6+1BAw
			; sub_3DBA6+361r
			; sub_3DF8C+1C5r
idk_LBX_w36FC8 dw 0	; DATA XREF: sub_3DBA6+1Bw
			; sub_3DF8C+58r
			; sub_3E1DE+77w
			; sub_3E60E+6Ar
			; sub_3EBA0:loc_3EBCCw
			; sub_3EDD1:loc_3EE1Cr
			; sub_3F3C6+1Bw
			; idk_Load_NEWGAME_LBX+19w
			; sub_3F6BF+2Ar
			; sub_3F7D8+2Dw
			; sub_3FA0C+2Cr
			; sub_3FBE0+63w
			; sub_40037+7Ar
			; sub_4067D+42w
			; sub_40EC0+7Ar
			; LBX_NewGame_s41A5F:loc_41A8Dw
			; sub_424BB+34r
word_36FCA dw 0		; DATA XREF: _f010409_LoadVortexAnimationImages+76w
			; _f010609_DrawMainMenuScreen+198r
			; _f010609_DrawMainMenuScreen+1A8r
			; _f010609_DrawMainMenuScreen:loc_13E6Dr
word_36FCC dw 0		; DATA XREF: _f010509_MainMenuScreen+29Ew
			; _f010509_MainMenuScreen+461r
			; _f010609_DrawMainMenuScreen+15Br
word_36FCE dw 0		; DATA XREF: _f010409_LoadVortexAnimationImages+40w
			; _f010609_DrawMainMenuScreen+161r
			; _f010609_DrawMainMenuScreen+171r
			; _f010609_DrawMainMenuScreen:loc_13E36r
word_36FD0 dw 0		; DATA XREF: _f010509_MainMenuScreen+2DFw
			; _f010509_MainMenuScreen+448r
			; _f010609_DrawMainMenuScreen+192r
			; sub_3DBA6+18Fw
			; sub_3DBA6+348r
			; sub_3DF8C+16Ar
			; sub_3E1DE+258w
			; sub_3E1DE+319r
			; LBX_NewGame_s41A5F:loc_41C4Aw
			; LBX_NewGame_s41A5F+358r
word_36FD2 dw 0		; DATA XREF: _f010409_LoadVortexAnimationImages+52w
			; _f010609_DrawMainMenuScreen+A7r
			; _f010609_DrawMainMenuScreen+B7r
			; _f010609_DrawMainMenuScreen:loc_13D7Cr
word_36FD4 dw 0		; DATA XREF: _f010509_MainMenuScreen+32w
			; _f010509_MainMenuScreen+3BEw
			; _f010509_MainMenuScreen+415w
			; _f010509_MainMenuScreen+429w
			; _f010509_MainMenuScreen+43Dw
			; _f010509_MainMenuScreen+456w
			; _f010509_MainMenuScreen+46Aw
			; _f010509_MainMenuScreen:loc_13C5Ar
			; _f010509_MainMenuScreen+4C4r
			; sub_3DF8C+2Fw
			; sub_3DF8C:loc_3E0F3r
			; sub_3DF8C+191r
			; sub_3DF8C+1C2r
			; sub_3E60E+136w
			; sub_3E60E+148r
			; sub_3E60E+226r
			; sub_3E60E+304r
			; sub_3E60E+3E2r
			; sub_424BB+31w
			; sub_424BB+1C9r
			; sub_424BB+209r
word_36FD6 dw 0		; DATA XREF: _f010409_LoadVortexAnimationImages+A9w
			; sub_3F6BF:loc_3F73Ar
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36FE0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_36FF0 db	0
db    0
db    0
db    0
word_36FF4 dw 0		; DATA XREF: _f010509_MainMenuScreen+38w
			; _f010509_MainMenuScreen+168w
			; _f010509_MainMenuScreen+178r
			; _f010509_MainMenuScreen:loc_13B0Ar
			; _f010609_DrawMainMenuScreen+97r
align 4
word_36FF8 dw 0		; DATA XREF: _f010409_LoadVortexAnimationImages+1Cw
			; _f010509_MainMenuScreen+3B4r
			; _f010609_DrawMainMenuScreen+34r
			; _f010609_DrawMainMenuScreen+44r
			; _f010609_DrawMainMenuScreen:loc_13D10r
word_36FFA dw 0		; DATA XREF: _f010509_MainMenuScreen+25Dw
			; _f010509_MainMenuScreen+3AAr
			; _f010509_MainMenuScreen+434r
			; _f010609_DrawMainMenuScreen+124r
word_36FFC dw 0		; DATA XREF: _f010409_LoadVortexAnimationImages+64w
			; _f010609_DrawMainMenuScreen+12Ar
			; _f010609_DrawMainMenuScreen+13Ar
			; _f010609_DrawMainMenuScreen:loc_13DFFr
word_36FFE dw 0		; DATA XREF: _f010509_MainMenuScreen+204w
			; _f010509_MainMenuScreen:loc_13A21w
			; _f010509_MainMenuScreen+40Cr
			; _f010609_DrawMainMenuScreen:loc_13DA0r
word_37000 dw 0		; DATA XREF: _f010409_LoadVortexAnimationImages+2Ew
			; _f010609_DrawMainMenuScreen+ECr
			; _f010609_DrawMainMenuScreen+FCr
			; _f010609_DrawMainMenuScreen:loc_13DC1r
word_37002 dw 0		; DATA XREF: _f010509_MainMenuScreen+2Cw
			; _f010509_MainMenuScreen:loc_1392Bw
			; _f010509_MainMenuScreen:loc_139B7r
			; _f010509_MainMenuScreen+300r
			; _f010609_DrawMainMenuScreen:loc_13D96r
word_37004 dw 0		; DATA XREF: _f010409_LoadVortexAnimationImages+88w
			; _f010609_DrawMainMenuScreen+73r
align 4
word_37008 dw 0		; DATA XREF: sub_3DBA6+60w
			; sub_3DF8C:loc_3E17Ar
align 4
idk_CfgMom_w3700C dw 0	; DATA XREF: _f010309_RUN+5Aw
			; _f010509_MainMenuScreen+8r
			; _f010509_MainMenuScreen+Fr
			; _f010509_MainMenuScreen+15w
			; sub_3DBA6+392w
word_3700E dw 0		; DATA XREF: _f010509_MainMenuScreen+C6w
			; _f010509_MainMenuScreen+12Dr
			; _f010509_MainMenuScreen:loc_13925w
			; _f010509_MainMenuScreen:loc_13933r
			; _f010509_MainMenuScreen:loc_1394Br
			; sub_3DBA6+1C3w
			; sub_3DBA6:loc_3DDC5r
			; sub_3DBA6+22Cw
			; sub_3DBA6:loc_3DDD8r
			; sub_3DBA6:loc_3DE53r
			; sub_3DBA6+339r
			; sub_3DF8C:loc_3E0EAr
word_37010 dw 0		; DATA XREF: _f010509_MainMenuScreen+137w
			; _f010509_MainMenuScreen+14Fw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37020 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37060 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
dw 0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37090 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_370AF db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_370C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_370DF db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_370E8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_370F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37150 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3716F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37180 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_371AF db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_371DF db	0
db    0
db    0
db    0
db    0
unk_371E4 db	0
unk_371E5 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_371EE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37210 db	0
db    0
db    0
db    0
unk_37214 db	0
unk_37215 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3721E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3722D db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3723E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37250 db	0
db    0
db    0
db    0
unk_37254 db	0
unk_37255 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3725D db	0
unk_3725E db	0
unk_3725F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37280 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3728F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3729D db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_372C8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_372CF db	0
db    0
db    0
unk_372D2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_372FF db	0
unk_37300 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3732F db	0
unk_37330 db	0
db    0
db    0
db    0
unk_37334 db	0
unk_37335 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3733E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3735F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37370 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3737D db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_373A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_373D0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37400 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37408 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37438 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3744C db	0
db    0
unk_3744E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37464 db	0
unk_37465 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3746E db	0
db    0
unk_37470 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37478 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37494 db	0
unk_37495 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3749E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_374AD db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_374CA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_374DD db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37524 db	0
unk_37525 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3752E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37558 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37564 db	0
unk_37565 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3756D db	0
unk_3756E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37594 db	0
unk_37595 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3759E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_375AD db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_375DD db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37614 db	0
unk_37615 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3761E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3763A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37644 db	0
unk_37645 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3764E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3765D db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37684 db	0
unk_37685 db	0
db    0
db    0
unk_37688 db	0
db    0
db    0
db    0
db    0
unk_3768D db	0
unk_3768E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_376B4 db	0
unk_376B5 db	0
db    0
db    0
unk_376B8 db	0
db    0
db    0
db    0
db    0
db    0
unk_376BE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_376CD db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_376E4 db	0
unk_376E5 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_376EE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_376FD db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37714 db	0
unk_37715 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3771E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3772A dw 0		; DATA XREF: sub_523A3+95r
			; idk_EmsPgNm_TileFigureCont_s553B0+402w
word_3772C dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3F6w
word_3772E dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3FCw
word_37730 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3EAw
word_37732 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_557A0w
word_37734 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3D2w
word_37736 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_55788w
word_37738 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3C6w
word_3773A dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_5577Cw
word_3773C dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_55770w
word_3773E dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3DEw
word_37740 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_55794w
word_37742 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3B4w
word_37744 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3BAw
align 4
unk_37748 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3775D db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37788 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_377B8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37838 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37868 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_378A8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
dword_378BC dd 0	; DATA XREF: fncLoadTERRSTAT+28w
			; sub_4C79C+61r
			; sub_4C79C+94r
			; sub_4C79C+C4r
			; sub_4C79C+F7r
			; sub_4C79C+12Ar
			; sub_4C79C+15Dr
			; fncLoadTERRSTAT+24w
word_378C0 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3B1w
word_378C2 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+173w
word_378C4 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+16Fw
word_378C6 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+159w
word_378C8 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+155w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_378D8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37908 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37938 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3795A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_37978 dw 0		; DATA XREF: sub_3CFC0+344w
word_3797A dw 0		; DATA XREF: sub_3CFC0+33Ew
word_3797C dw 0		; DATA XREF: sub_3CFC0+338w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3798A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
idk_LBX_w379C0 dw 0	; DATA XREF: sub_3E1DE+A5w
			; sub_3E1DE+21Dr
			; sub_4067D+59w
			; sub_40EC0+4E7r
			; sub_40EC0:loc_413B4r
			; LBX_NewGame_s41A5F:loc_41B17w
			; sub_424BB+1D2r
			; sub_424BB:loc_4269Ar
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_379CA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37AAA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_37B78 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+3A4w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37BDA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37C0A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37C18 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37C4F db	0
unk_37C50 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37C9A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37CDA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37D0A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37D8A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37DBA db	0
db    0
db    0
db    0
db    0
db    0
unk_37DC0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37DFA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37E1A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37E2A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37E5A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37E8A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_37EBC dw 0		; DATA XREF: sub_4EC17+15Dr
			; sub_4EC17:loc_4ED83r
			; sub_4EC17+196r
			; sub_4EC17+1A5r
			; sub_4F1AB+124r
			; sub_4F1AB+133r
			; sub_4F1AB+158r
			; sub_4F1AB+167r
			; idk_EmsPgNm_TileFigureCont_s553B0+52w
; int idk_LBX_w37EBE
idk_LBX_w37EBE dw 0	; DATA XREF: sub_3CFC0+1Ar
			; sub_3CFC0+31r
			; sub_3CFC0:loc_3D00Cr
			; sub_3CFC0:loc_3D034r
			; sub_3CFC0:loc_3D05Cr
			; sub_3DBA6+8r
			; sub_3DBA6+1Er
			; sub_3DBA6+35r
			; sub_3DBA6+4Cr
			; sub_3DBA6+63r
			; sub_3DBA6+7Ar
			; sub_3DBA6+91r
			; sub_3DBA6+A8r
			; sub_3DBA6+BFr
			; sub_3E1DE+64r
			; sub_3E1DE+7Ar
			; sub_3E1DE+91r
			; sub_3E1DE+A8r
			; sub_3E1DE+BFr
			; sub_3E1DE+D6r
			; sub_3E1DE+EDr
			; sub_3E1DE+104r
			; sub_3EBA0:loc_3EBB9r
			; sub_3EBA0:loc_3EBD3r
			; sub_3EBA0+5Br
			; sub_3EBA0:loc_3EC04r
			; sub_3EBA0:loc_3EC1Fr
			; sub_3F3C6+8r
			; sub_3F3C6:loc_3F3EBr
			; sub_3F3C6+4Er
			; idk_Load_NEWGAME_LBX+6r
			; idk_Load_NEWGAME_LBX+1Cr
			; sub_3F7D8+1Ar
			; sub_3F7D8+30r
			; sub_3F7D8:loc_3F823r
			; sub_3F7D8+6Fr
			; sub_3FBE0+50r
			; sub_3FBE0+66r
			; sub_3FBE0+7Dr
			; sub_3FBE0+94r
			; sub_3FBE0+ABr
			; sub_3FBE0:loc_3FCA6r
			; sub_4067D+2Er
			; sub_4067D+45r
			; sub_4067D+5Cr
			; sub_4067D:LOOP_x15r
			; sub_4067D+9Br
			; sub_4067D+B2r
			; sub_4067D+C9r
			; LBX_NewGame_s41A5F:loc_41A7Ar
			; LBX_NewGame_s41A5F:loc_41A90r
			; LBX_NewGame_s41A5F:loc_41AA7r
			; LBX_NewGame_s41A5F:loc_41ABEr
			; LBX_NewGame_s41A5F+76r
			; LBX_NewGame_s41A5F:loc_41AECr
			; LBX_NewGame_s41A5F:loc_41B03r
			; LBX_NewGame_s41A5F:loc_41B1Ar
			; LBX_NewGame_s41A5F:loc_41B35r
			; LBX_NewGame_s41A5F:loc_41B59r
			; LBX_NewGame_s41A5F+111r
			; LBX_NewGame_s41A5F:loc_41B87r
			; sub_4D5B0:loc_4D5D0r
			; sub_4D5B0:loc_4D5E6r
			; sub_4D5B0:loc_4D5FDr
			; sub_4D5B0:loc_4D614r
			; sub_4D8FA+Fr
			; sub_4D8FA+26r
			; sub_4D8FA+3Dr
			; sub_4D8FA+54r
			; sub_4DB4D+1Cr
			; sub_4DB4D+33r
			; sub_4DB4D+4Ar
			; sub_4DB4D+61r
			; sub_4DB4D+78r
			; sub_4DB4D+8Fr
			; sub_4DB4D+A6r
			; sub_4DB4D+BDr
			; sub_4DB4D+D4r
			; sub_4DB4D:loc_4DC38r
			; sub_4DB4D+102r
			; sub_4DB4D+119r
			; sub_4DB4D+130r
			; sub_4DB4D:loc_4DC98r
			; sub_4DB4D+169r
			; idk_ResourceLbx+9r
			; idk_ResourceLbx+21r
			; idk_ResourceLbx:loc_4E8A3r
			; idk_ResourceLbx+56r
			; idk_ResourceLbx+6Dr
			; idk_ResourceLbx:loc_4E8EBr
			; idk_ResourceLbx+9Er
			; idk_ResourceLbx+B5r
			; idk_ResourceLbx:loc_4E933r
			; idk_ResourceLbx+E6r
			; idk_ResourceLbx+FDr
			; idk_ResourceLbx:loc_4E97Ar
			; idk_ResourceLbx+12Dr
			; idk_ResourceLbx+144r
			; idk_ResourceLbx:loc_4E9C5r
			; sub_4F44D+C4r
			; sub_4F44D+D2r
			; sub_4F44D:loc_4F7A3r
			; sub_50356+12r
			; sub_50356+2Cr
			; sub_503A0+16r
			; sub_503A0+35r
			; idk_EmsPgNm_TileFigureCont_s553B0+45w
			; ST_LoadMusicSoundfxIntro+10r
			; ST_LoadMusicSoundfxIntro+27r
			; ST_LoadMusicSoundfxIntro+31r
			; ST_LoadMusicSoundfxIntro+17Br
			; ST_LoadMusicSoundfxIntro+185r
			; ST_LoadMusicSoundfxIntro+18Fr
			; ST_LoadMusicSoundfxIntro+1A6r
			; ST_LoadMusicSoundfxIntro:loc_559D0r
			; ST_LoadMusicSoundfxIntro+1FAr
			; ST_LoadMusicSoundfxIntro+204r
			; ST_LoadMusicSoundfxIntro+21Br
			; ST_LoadMusicSoundfxIntro+24Br
			; ST_LoadMusicSoundfxIntro+255r
			; ST_LoadMusicSoundfxIntro+25Fr
			; ST_LoadMusicSoundfxIntro+276r
			; ST_LoadMusicSoundfxIntro+2A7r
			; ST_LoadMusicSoundfxIntro+2B1r
			; ST_LoadMusicSoundfxIntro+2BBr
			; idk_OVR_LoadLbxHelp:loc_55CCBr
			; idk_OVR_LoadLbxHelp:loc_55CE7r
			; idk_OVR_LoadLbxHelp:loc_55D13r
			; idk_OVR_LoadLbxHelp:loc_55D3Er
			; idk_OVR_LoadLbxHelp:loc_55DB8r
			; idk_OVR_LoadLbxHelp+20Ar
			; idk_OVR_LoadLbxHelp:loc_55EC0r
			; idk_OVR_LoadLbxHelp:loc_56044r
			; idk_OVR_LoadLbxHelp+53Dr
			; idk_OVR_LoadLbxHelp+55Dr
			; sub_56413+13r
			; sub_56450+4Dr
word_37EC0 dw 0		; DATA XREF: sub_3CFC0+3A6w
align 8
dword_37EC8 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+33Br
			; ST_LoadSaveGamByNbr+352r
			; sub_5468B+3r
			; sub_5468B+Cr
			; sub_5468B+16r
			; sub_5468B+20r
			; sub_5468B+2Ar
			; sub_5468B+34r
			; sub_5468B+3Er
			; sub_5468B+48r
			; sub_5468B+52r
			; sub_5468B+5Cr
			; sub_5468B+66r
			; sub_5468B+70r
			; sub_5468B+7Ar
			; sub_5468B+84r
			; sub_5468B+8Er
			; sub_5468B+98r
			; sub_5468B+A2r
			; sub_5468B+ACr
			; sub_5468B+B6r
			; idk_EmsPgNm_TileFigureCont_s553B0+337w
			; OVR_SaveGame_MagicSet+337r
			; ST_LoadSaveGamByNbr+34Er
			; idk_EmsPgNm_TileFigureCont_s553B0+333w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_37EF2 db 0		; DATA XREF: sub_54DC9+2Bw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37F38 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37F68 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37F9C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37FA8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37FB4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37FC4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_37FEC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38000 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_3800B db 0		; DATA XREF: sub_54DC9+30w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38014 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38028 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3803C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38050 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38070 db	0
db    0
byte_38072 db 0		; DATA XREF: sub_54DC9+26w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38088 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_380A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_380C4 db 0		; DATA XREF: sub_54DC9:loc_54DCCw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_380E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38110 db	0
db    0
db    0
db    0
db    0
db    0
byte_38116 db 0		; DATA XREF: sub_54DC9+8w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3813A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38150 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3815E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_38168 db 0		; DATA XREF: sub_54DC9+1Cw
align 2
unk_3816A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_3817D db 0		; DATA XREF: sub_54DC9+21w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_38192 db 0		; DATA XREF: sub_54DC9+Dw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_381A7 db 0		; DATA XREF: sub_54DC9+12w
db    0
db    0
unk_381AA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_381B8 db	0
db    0
db    0
db    0
byte_381BC db 0		; DATA XREF: sub_54DC9+17w
align 2
idk_CfgMom_w381BE dw 0	; DATA XREF: _f010309_RUN+54w
			; _f010309_RUN+82w
			; _f010509_MainMenuScreen+46w
			; _f010509_MainMenuScreen+4Cr
			; _f010509_MainMenuScreen+487r
			; _f010509_MainMenuScreen+4A3w
			; _f010609_DrawMainMenuScreen+86r
			; sub_3DBA6+D6w
			; sub_3DBA6+EAw
			; sub_3DBA6+3A9r
			; sub_3E1DE+8w
			; sub_3E1DE+Er
			; sub_3E1DE+3FBr
dword_381C0 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+2A0r
			; ST_LoadSaveGamByNbr+2B7r
			; sub_5266E+Er
			; idk_EmsPgNm_TileFigureCont_s553B0+367w
			; OVR_SaveGame_MagicSet+29Cr
			; ST_LoadSaveGamByNbr+2B3r
			; idk_EmsPgNm_TileFigureCont_s553B0+363w
dword_381C4 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+385r
			; ST_LoadSaveGamByNbr+39Cr
			; sub_5266E:loc_52693r
			; idk_EmsPgNm_TileFigureCont_s553B0+37Fw
			; OVR_SaveGame_MagicSet+381r
			; ST_LoadSaveGamByNbr+398r
			; idk_EmsPgNm_TileFigureCont_s553B0+37Bw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_381E8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_381F2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38230 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38278 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3828A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_382B0 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+2BFw
word_382B2 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_5566Bw
align 8
unk_382B8 db	0
db    0
db    0
db    0
idk_SavGamDS_w382BC dw 0
			; DATA XREF: OVR_SaveGame_MagicSet+6Ar
			; ST_LoadSaveGamByNbr+81r
			; idk_EmsPgNm_TileFigureCont_s553B0+217w
idk_SavGamDS_w382BE dw 0
			; DATA XREF: OVR_SaveGame_MagicSet+66r
			; ST_LoadSaveGamByNbr+7Dr
			; idk_EmsPgNm_TileFigureCont_s553B0+213w
word_382C0 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+83r
			; ST_LoadSaveGamByNbr+9Ar
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_555DFw
word_382C2 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+7Fr
			; ST_LoadSaveGamByNbr+96r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_555DBw
word_382C4 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+9Cr
			; ST_LoadSaveGamByNbr+B3r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_555F7w
word_382C6 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+98r
			; ST_LoadSaveGamByNbr+AFr
			; idk_EmsPgNm_TileFigureCont_s553B0+243w
word_382C8 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+B5r
			; ST_LoadSaveGamByNbr+CCr
			; idk_EmsPgNm_TileFigureCont_s553B0+25Fw
word_382CA dw 0		; DATA XREF: OVR_SaveGame_MagicSet+B1r
			; ST_LoadSaveGamByNbr+C8r
			; idk_EmsPgNm_TileFigureCont_s553B0+25Bw
word_382CC dw 0		; DATA XREF: OVR_SaveGame_MagicSet+CEr
			; ST_LoadSaveGamByNbr:loc_3CCBDr
			; idk_EmsPgNm_TileFigureCont_s553B0+277w
word_382CE dw 0		; DATA XREF: OVR_SaveGame_MagicSet+CAr
			; ST_LoadSaveGamByNbr+E1r
			; idk_EmsPgNm_TileFigureCont_s553B0+273w
word_382D0 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+E7r
			; ST_LoadSaveGamByNbr+FEr
			; idk_EmsPgNm_TileFigureCont_s553B0+28Fw
word_382D2 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+E3r
			; ST_LoadSaveGamByNbr+FAr
			; idk_EmsPgNm_TileFigureCont_s553B0+28Bw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_382E8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
dword_3833C dd 0	; DATA XREF: LBX_SpellDat+28w
			; sub_4276F+302r
			; sub_4276F+3D5r
			; sub_4276F+58Dr
			; sub_4276F+660r
			; sub_4276F+818r
			; sub_4276F+8EBr
			; sub_526A6+68r
			; idk_EmsPgNm_TileFigureCont_s553B0+397w
			; LBX_SpellDat+24w
			; sub_4276F+308r
			; sub_4276F+3DBr
			; sub_4276F+593r
			; sub_4276F+666r
			; sub_4276F+81Er
			; sub_4276F:loc_43060r
			; idk_EmsPgNm_TileFigureCont_s553B0+393w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38360 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38368 db	0
db    0
db    0
db    0
unk_3836C db	0
db    0
unk_3836E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38390 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38398 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_383BA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_383D8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_383EA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_383F4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38408 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3841C db	0
db    0
db    0
db    0
unk_38420 db	0
db    0
dword_38422 dd 0	; DATA XREF: idk_BuildingWorlds+2Aw
			; sub_4A942+A04r
			; sub_4A942+A28r
			; sub_4A942+A6Br
			; sub_4A942+A97r
			; sub_4A942+AD7r
			; sub_4A942+B12r
			; sub_4A942+B3Er
			; idk_BuildingWorlds+26w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38438 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38450 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_38460 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+32w
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55412r
word_38462 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+187w
word_38464 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+5Fw
word_38466 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+6Ew
word_38468 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+36Co
			; ST_LoadSaveGamByNbr+383o
			; sub_5244A+8w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3847A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38490 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_384BA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_384EA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38506 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38510 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38540 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3856A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38580 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3859A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_385B0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_385CE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_385DA db	0
db    0
db    0
db    0
db    0
db    0
unk_385E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_38606 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+41Cw
dword_38608 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+2D2r
			; ST_LoadSaveGamByNbr+2E9r
			; sub_4CB55+18r
			; sub_4CB55+2Br
			; sub_4CB55+3Fr
			; sub_4CB55+53r
			; sub_4CB55+76r
			; sub_4CB55+87r
			; sub_4CB55+9Br
			; sub_4CB55+ADr
			; sub_4CB55+CEr
			; sub_4CB55+EEr
			; sub_4CB55+FFr
			; sub_4CB55+111r
			; sub_4CB55+123r
			; sub_4CB55+135r
			; sub_4CB55+147r
			; sub_4CB55+15Ar
			; sub_4CB55+16Cr
			; sub_4CB55+17Er
			; sub_4CB55+197r
			; sub_4CB55+1A9r
			; sub_4CB55+1BBr
			; sub_4CB55+1DEr
			; sub_4CB55+20Er
			; sub_4CB55+222r
			; sub_4CB55+249r
			; sub_4CB55+25Dr
			; sub_4CB55+26Fr
			; sub_4CB55+283r
			; sub_4CB55+297r
			; sub_4CB55+2BAr
			; sub_4CB55+2CEr
			; idk_EmsPgNm_TileFigureCont_s553B0+2A7w
			; OVR_SaveGame_MagicSet+2CEr
			; ST_LoadSaveGamByNbr+2E5r
			; idk_EmsPgNm_TileFigureCont_s553B0+2A3w
word_3860C dw 0		; DATA XREF: OVR_SaveGame_MagicSet+39Er
			; ST_LoadSaveGamByNbr+3B9r
			; ST_LoadSaveGamByNbr+3CFr
			; idk_EmsPgNm_TileFigureCont_s553B0+34Fw
word_3860E dw 0		; DATA XREF: OVR_SaveGame_MagicSet+39Ar
			; ST_LoadSaveGamByNbr+3B5r
			; ST_LoadSaveGamByNbr+3CBr
			; idk_EmsPgNm_TileFigureCont_s553B0+34Bw
byte_38610 db 0		; DATA XREF: OVR_SaveGame_MagicSet+1BFo
			; ST_LoadSaveGamByNbr+1D6o
			; sub_3F3C6+18Aw
			; sub_3F6BF+73r
			; sub_3F6BF+105r
			; sub_3FA0C+74r
			; sub_40037+D7r
			; sub_40EC0+8Cr
			; sub_4276F+14Br
			; sub_430A4+Bw
unk_38611 db	0	; DATA XREF: idk_Load_NEWGAME_LBX+7Eo
			; idk_Load_NEWGAME_LBX+D7o
			; idk_Load_NEWGAME_LBX+EAo
			; sub_3F6BF+ADo
			; sub_3F6BF+C1o
			; sub_3F6BF+E4o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_38625 db 0		; DATA XREF: sub_523A3+51w
byte_38626 db 0		; DATA XREF: sub_3F7D8:loc_3F98Bw
			; sub_3F7D8:loc_3F992w
			; sub_3F7D8:loc_3F999w
			; sub_3F7D8:loc_3F9A0w
			; sub_3F7D8:loc_3F9A7w
			; sub_5301E+1Fr
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3863A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3866A dw 0		; DATA XREF: sub_3FA0C:loc_3FB7Dr
			; sub_40037:loc_40223r
			; sub_4067D+344w
			; sub_40EC0+12Cr
			; sub_40EC0+26Er
			; sub_40EC0:loc_41154w
			; sub_40EC0:loc_41341r
			; sub_40EC0:loc_413EDr
			; sub_40EC0+631r
			; sub_424BB:loc_4264Er
			; sub_430A4+1Cw
			; sub_430A4+D0r
			; sub_4E9F4+52r
			; sub_4EF74+57r
			; sub_52792:loc_5279Fr
			; sub_52792+3Er
word_3866C dw 0		; DATA XREF: sub_3FA0C:loc_3FB54r
			; sub_40037:loc_401F7r
			; sub_4067D+34Aw
			; sub_40EC0+130r
			; sub_40EC0+2BFr
			; sub_40EC0:loc_411A5w
			; sub_40EC0:loc_41391r
			; sub_40EC0:loc_41400r
			; sub_40EC0+62Ar
			; sub_424BB:loc_42677r
			; sub_430A4+2Dw
			; sub_430A4:loc_431CCr
			; sub_4E9F4+68r
			; sub_4EF74+6Dr
word_3866E dw 0		; DATA XREF: sub_3FA0C:loc_3FBCFr
			; sub_40037:loc_4027Br
			; sub_4067D+350w
			; sub_40EC0+128r
			; sub_40EC0+21Cr
			; sub_40EC0:loc_41102w
			; sub_40EC0:loc_412F1r
			; sub_40EC0:loc_41413r
			; sub_40EC0:loc_414E3r
			; sub_424BB:loc_42625r
			; sub_430A4+3Ew
			; sub_430A4:loc_43224r
			; sub_4E9F4+26r
			; sub_4EF74+2Br
word_38670 dw 0		; DATA XREF: sub_3FA0C:loc_3FB2Br
			; sub_40037:loc_401CBr
			; sub_4067D+356w
			; sub_4067D+3E3r
			; sub_40EC0+120r
			; sub_40EC0+166r
			; sub_40EC0:loc_41055w
			; sub_40EC0:loc_4108Cr
			; sub_40EC0:loc_41251r
			; sub_40EC0:loc_41439r
			; sub_424BB:loc_425D3r
			; sub_430A4+4Fw
			; sub_430A4:loc_4327Cr
word_38672 dw 0		; DATA XREF: sub_3FA0C:loc_3FBA6r
			; sub_40037:loc_4024Fr
			; sub_4067D+35Cw
			; sub_4067D+3D3r
			; sub_40EC0+124r
			; sub_40EC0:loc_41031r
			; sub_40EC0+1C1r
			; sub_40EC0:loc_410B0w
			; sub_40EC0:loc_412A1r
			; sub_40EC0:loc_41426r
			; sub_424BB:loc_425FCr
			; sub_430A4+60w
			; sub_430A4:loc_432D4r
			; sub_4E9F4+3Cr
			; sub_4EF74+41r
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_38966 dw 0		; DATA XREF: sub_523A3+6Dw
			; sub_523A3+7Ew
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_389F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38AAE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_38AD4 dw 0		; DATA XREF: sub_52792+84w
word_38AD6 dw 0		; DATA XREF: sub_52792+8Aw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38B42 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38B6F db	0
unk_38B70 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38CBC db	0
db    0
unk_38CBE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38D10 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38D40 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38D80 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38DCE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38DFE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38E3E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38E60 db	0
db    0
unk_38E62 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38E92 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38EBC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38EC8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38ED2 db	0
db    0
unk_38ED4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38EE4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38F0C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38F1E db	0
db    0
unk_38F20 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38F34 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38F48 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38F5C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38F70 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38F90 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38FB2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38FC0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_38FDC db	0
db    0
unk_38FDE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3900C db	0
db    0
unk_3900E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3904C db	0
db    0
unk_3904E db	0
db    0
unk_39050 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3907E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39090 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_390C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_390E0 db	0
db    0
unk_390E2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3910E db	0
db    0
db    0
db    0
unk_39112 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3912C db	0
db    0
unk_3912E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39140 db	0
db    0
db    0
db    0
unk_39144 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3914E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39158 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39170 db	0
db    0
db    0
db    0
db    0
db    0
unk_39176 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3917E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_391A2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_391B0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_391E0 db	0
db    0
unk_391E2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_391FE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39210 db	0
db    0
unk_39212 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3922E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39240 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3925C db	0
db    0
unk_3925E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3926E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3928C db	0
db    0
unk_3928E db	0
db    0
db    0
db    0
unk_39292 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3929E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_392C2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_392CE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_392FE db	0
db    0
db    0
db    0
unk_39302 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39314 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3931C db	0
db    0
unk_3931E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39332 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3933C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39344 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3935C db	0
db    0
unk_3935E db	0
db    0
db    0
db    0
unk_39362 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39370 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3938C db	0
db    0
unk_3938E db	0
db    0
db    0
db    0
unk_39392 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3940C db	0
db    0
unk_3940E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39426 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3943C db	0
db    0
unk_3943E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3947C db	0
db    0
unk_3947E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_394AC db	0
db    0
unk_394AE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_394BF db	0
unk_394C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_394DC db	0
db    0
unk_394DE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_394EE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3950C db	0
db    0
unk_3950E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_397DF db	0
unk_397E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3980C db	0
db    0
db    0
unk_3980F db	0
unk_39810 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39818 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39824 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39834 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3984F db	0
unk_39850 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3985C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39870 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39884 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39898 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_398AC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_398C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_398E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39910 db	0	; DATA XREF: idk_MemAndVid_s1E0DA+100o
			; idk_VidLib_s1E2D0+48o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3992F db	0
unk_39930 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39A5F db	0
unk_39A60 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39A8F db	0
unk_39A90 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B1F db	0
unk_39B20 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B2C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B38 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B44 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B54 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B5C db	0
db    0
db    0
unk_39B5F db	0
unk_39B60 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B68 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B74 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B7C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B84 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B8F db	0
unk_39B90 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39B9C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39BA4 db	0
db    0
db    0
db    0
unk_39BA8 db	0
db    0
db    0
db    0
unk_39BAC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39BB4 db	0
db    0
db    0
db    0
unk_39BB8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39BC0 db	0
db    0
db    0
db    0
unk_39BC4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39BCC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39BD4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39BE0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39BE8 db	0
db    0
db    0
db    0
unk_39BEC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39BFC db	0
db    0
db    0
db    0
unk_39C00 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C0F db	0
unk_39C10 db	0
db    0
db    0
db    0
unk_39C14 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C28 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C30 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C3C db	0
db    0
db    0
unk_39C3F db	0
unk_39C40 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C50 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C64 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C70 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C7C db	0
db    0
db    0
unk_39C7F db	0
unk_39C80 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C88 db	0
db    0
db    0
db    0
unk_39C8C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39C94 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39CA4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39CAF db	0
unk_39CB0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39CC0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39CCC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39CDF db	0
unk_39CE0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39CF4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39D08 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39D0F db	0
unk_39D10 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39D1C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39D30 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39D50 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39D76 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39DAC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39DB8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39DC4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39DD4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39DDC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39DE8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39DF4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39DFC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E04 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E10 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E24 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E2C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E38 db	0
db    0
db    0
db    0
db    0
db    0
unk_39E3E db	0
db    0
word_39E40 dw 0		; DATA XREF: sub_522E0:loc_52399w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E4C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E54 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E60 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E68 db	0
db    0
db    0
db    0
unk_39E6C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E78 db	0
db    0
db    0
db    0
unk_39E7C db	0
db    0
db    0
db    0
unk_39E80 db	0
db    0
db    0
db    0
unk_39E84 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39E90 db	0
db    0
db    0
db    0
unk_39E94 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39EAC db	0
db    0
db    0
db    0
unk_39EB0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39EB8 db	0
db    0
db    0
db    0
unk_39EBC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39EC4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39ED0 db	0
db    0
db    0
db    0
unk_39ED4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39EDC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39EE4 db	0
db    0
db    0
db    0
unk_39EE8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39EF4 db	0
db    0
db    0
db    0
unk_39EF8 db	0
db    0
db    0
db    0
unk_39EFC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F04 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F0C db	0
db    0
db    0
db    0
unk_39F10 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F20 db	0
db    0
db    0
db    0
unk_39F24 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F2C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F38 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F40 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F4C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F54 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F5C db	0
db    0
db    0
db    0
unk_39F60 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F68 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F74 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F7C db	0
db    0
db    0
db    0
unk_39F80 db	0
db    0
db    0
db    0
unk_39F84 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F8C db	0
db    0
db    0
db    0
unk_39F90 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39F98 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39FA4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39FAC db	0
db    0
db    0
db    0
unk_39FB0 db	0
db    0
db    0
db    0
unk_39FB4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39FC0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39FCC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39FD4 db	0
db    0
db    0
db    0
unk_39FD8 db	0
db    0
db    0
db    0
unk_39FDC db	0
db    0
db    0
db    0
unk_39FE0 db	0
db    0
db    0
db    0
unk_39FE4 db	0
db    0
db    0
db    0
unk_39FE8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39FF0 db	0
db    0
db    0
db    0
unk_39FF4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_39FFC db	0
db    0
db    0
db    0
unk_3A000 db	0
db    0
db    0
db    0
unk_3A004 db	0
db    0
db    0
db    0
unk_3A008 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A010 db	0
db    0
db    0
db    0
unk_3A014 db	0
db    0
db    0
db    0
unk_3A018 db	0
db    0
db    0
db    0
unk_3A01C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A024 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A02C db	0
db    0
db    0
db    0
unk_3A030 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A038 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A040 db	0
db    0
db    0
db    0
unk_3A044 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A04C db	0
db    0
db    0
db    0
unk_3A050 db	0
db    0
db    0
db    0
unk_3A054 db	0
db    0
db    0
db    0
unk_3A058 db	0
db    0
db    0
db    0
unk_3A05C db	0
db    0
db    0
db    0
unk_3A060 db	0
db    0
db    0
db    0
unk_3A064 db	0
db    0
db    0
db    0
unk_3A068 db	0
db    0
db    0
db    0
unk_3A06C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A074 db	0
db    0
db    0
db    0
unk_3A078 db	0
db    0
db    0
db    0
unk_3A07C db	0
db    0
db    0
db    0
unk_3A080 db	0
db    0
db    0
db    0
unk_3A084 db	0
db    0
db    0
db    0
unk_3A088 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A090 db	0
db    0
db    0
db    0
db    0
db    0
unk_3A096 db	0
db    0
db    0
db    0
db    0
db    0
unk_3A09C db	0
db    0
db    0
db    0
unk_3A0A0 db	0
db    0
db    0
db    0
unk_3A0A4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A0AC db	0
db    0
db    0
db    0
unk_3A0B0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A0B8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A0C0 db	0
db    0
db    0
db    0
db    0
db    0
unk_3A0C6 db	0
db    0
db    0
db    0
db    0
db    0
unk_3A0CC db	0
db    0
db    0
db    0
unk_3A0D0 db	0
db    0
db    0
db    0
unk_3A0D4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A0E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A0E8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A0FC db	0
db    0
db    0
db    0
unk_3A100 db	0
db    0
db    0
db    0
unk_3A104 db	0
db    0
unk_3A106 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A110 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A130 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_3A14C db 0		; DATA XREF: sub_522E0:loc_52394w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A15E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A18E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A1CE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A1E6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A204 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A21C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A22C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A234 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A242 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A24C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A25C db	0
db    0
db    0
db    0
unk_3A260 db	0
db    0
db    0
db    0
unk_3A264 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A290 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A2AE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A2C0 dw 0		; DATA XREF: _f010509_MainMenuScreen+A8w
			; _f010509_MainMenuScreen+1A2w
			; _f010509_MainMenuScreen+3DCo
			; LBX_HelpEntry_s13EEE+Eo
			; LBX_HelpEntry_s13EEE:loc_13F14o
word_3A2C2 dw 0		; DATA XREF: _f010509_MainMenuScreen+1A8w
word_3A2C4 dw 0		; DATA XREF: _f010509_MainMenuScreen+1AEw
word_3A2C6 dw 0		; DATA XREF: _f010509_MainMenuScreen+1B4w
word_3A2C8 dw 0		; DATA XREF: _f010509_MainMenuScreen+1BAw
word_3A2CA dw 0		; DATA XREF: _f010509_MainMenuScreen+AEw
			; _f010509_MainMenuScreen+207w
word_3A2CC dw 0		; DATA XREF: _f010509_MainMenuScreen+20Dw
word_3A2CE dw 0		; DATA XREF: _f010509_MainMenuScreen+21Ew
word_3A2D0 dw 0		; DATA XREF: _f010509_MainMenuScreen+221w
word_3A2D2 dw 0		; DATA XREF: _f010509_MainMenuScreen+232w
word_3A2D4 dw 0		; DATA XREF: _f010509_MainMenuScreen+B4w
			; _f010509_MainMenuScreen+260w
word_3A2D6 dw 0		; DATA XREF: _f010509_MainMenuScreen+266w
word_3A2D8 dw 0		; DATA XREF: _f010509_MainMenuScreen+26Cw
word_3A2DA dw 0		; DATA XREF: _f010509_MainMenuScreen+272w
word_3A2DC dw 0		; DATA XREF: _f010509_MainMenuScreen+278w
word_3A2DE dw 0		; DATA XREF: _f010509_MainMenuScreen+BAw
			; _f010509_MainMenuScreen+2A1w
word_3A2E0 dw 0		; DATA XREF: _f010509_MainMenuScreen+2A7w
word_3A2E2 dw 0		; DATA XREF: _f010509_MainMenuScreen+2ADw
word_3A2E4 dw 0		; DATA XREF: _f010509_MainMenuScreen+2B3w
word_3A2E6 dw 0		; DATA XREF: _f010509_MainMenuScreen+2B9w
word_3A2E8 dw 0		; DATA XREF: _f010509_MainMenuScreen+C0w
			; _f010509_MainMenuScreen+2E2w
word_3A2EA dw 0		; DATA XREF: _f010509_MainMenuScreen+2E8w
word_3A2EC dw 0		; DATA XREF: _f010509_MainMenuScreen+2EEw
word_3A2EE dw 0		; DATA XREF: _f010509_MainMenuScreen+2F4w
word_3A2F0 dw 0		; DATA XREF: _f010509_MainMenuScreen+2FAw
align 4
unk_3A2F4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A304 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A316 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A320 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A32C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A334 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A346 db	0
db    0
db    0
db    0
db    0
db    0
word_3A34C dw 0		; DATA XREF: LBX_HelpEntry_s43484+28w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A35C db	0
db    0
db    0
db    0
unk_3A360 db	0
db    0
db    0
db    0
unk_3A364 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A390 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A3B4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A3D6 db	0
db    0
db    0
db    0
db    0
db    0
unk_3A3DC db	0
db    0
unk_3A3DE db	0
db    0
db    0
db    0
db    0
db    0
unk_3A3E4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A40C db	0
db    0
unk_3A40E db	0
db    0
unk_3A410 db	0
db    0
db    0
db    0
unk_3A414 db	0
db    0
unk_3A416 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A424 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A430 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A440 db	0
db    0
db    0
db    0
db    0
db    0
unk_3A446 db	0
db    0
db    0
db    0
db    0
db    0
unk_3A44C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A454 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A47C db	0
db    0
db    0
db    0
unk_3A480 db	0
db    0
db    0
db    0
unk_3A484 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A49E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A4A6 db	0
db    0
db    0
db    0
db    0
db    0
unk_3A4AC db	0
db    0
db    0
db    0
unk_3A4B0 db	0
db    0
db    0
db    0
arrConfigMomSettings struc_ConfigMom <0>
			; DATA XREF: _f010109_main+48o
			; _f010109_main+62r
			; _f010309_RUN+3Fo
			; _f010109_main+71r
			; _f010109_main+68r
			; _f010109_main:loc_132FCr
			; _f010109_main+105r
			; _f010109_main+F9r
			; _f010109_main+FFr
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A4D4 db	0	; DATA XREF: OVR_SaveGame_MagicSet+1A7o
			; ST_LoadSaveGamByNbr+1BEo
db    0
unk_3A4D6 db	0	; DATA XREF: OVR_SaveGame_MagicSet+18Fo
			; ST_LoadSaveGamByNbr+1A6o
			; sub_4D540:loc_4D546r
db    0
word_3A4D8 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+177o
			; ST_LoadSaveGamByNbr+18Eo
			; idk_BuildingWorlds+199w
			; sub_4CB55:loc_4CB66r
			; sub_4CB55+24r
			; sub_4CB55+38r
			; sub_4CB55+4Cr
			; sub_4CB55+6Er
			; sub_4CB55+80r
			; sub_4CB55+94r
			; sub_4CB55+A6r
			; sub_4CB55+C6r
			; sub_4CB55+E6r
			; sub_4CB55+F8r
			; sub_4CB55+10Ar
			; sub_4CB55+11Cr
			; sub_4CB55+12Er
			; sub_4CB55+140r
			; sub_4CB55+153r
			; sub_4CB55+165r
			; sub_4CB55+177r
			; sub_4CB55+190r
			; sub_4CB55+1A2r
			; sub_4CB55+1B4r
			; sub_4CB55+1D7r
			; sub_4CB55+207r
			; sub_4CB55:loc_4CD70r
			; sub_4CB55+242r
			; sub_4CB55+256r
			; sub_4CB55:loc_4CDBDr
			; sub_4CB55+27Cr
			; sub_4CB55+290r
			; sub_4CB55+2B3r
			; sub_4CB55+2C6r
			; sub_4CB55:loc_4CE2Dw
word_3A4DA dw 0		; DATA XREF: OVR_SaveGame_MagicSet+15Fo
			; ST_LoadSaveGamByNbr+176o
			; sub_43E4F:loc_44146w
			; sub_43E4F+30Br
			; sub_43E4F:loc_4419Fr
			; sub_43E4F:loc_441B4r
			; sub_43E4F:loc_441C9r
			; sub_43E4F:loc_441DEr
			; sub_43E4F:loc_441F3r
			; sub_43E4F:loc_4422Er
			; sub_43E4F:loc_44243r
			; sub_43E4F:loc_44258r
			; sub_43E4F:loc_4426Dr
			; sub_43E4F:loc_44282r
			; sub_43E4F:loc_442B6r
			; sub_43E4F:loc_442CCr
			; sub_43E4F:loc_442E2r
			; sub_43E4F:loc_442F7r
			; sub_43E4F:loc_4430Cr
			; sub_43E4F:loc_44321r
			; sub_43E4F:loc_44336r
			; sub_43E4F:loc_4434Br
			; sub_43E4F:loc_44360r
			; sub_43E4F:loc_44375r
			; sub_43E4F+564r
			; sub_43E4F+589r
			; sub_43E4F+5AEr
			; sub_43E4F+5C1r
			; sub_43E4F+5D6r
			; sub_43E4F+5E9r
			; sub_43E4F+5FCr
			; sub_43E4F+60Fr
			; sub_43E4F+623r
			; sub_43E4F+63Dr
			; sub_43E4F:loc_444A2r
			; sub_43E4F:loc_444B6r
			; sub_43E4F+67Ar
			; sub_43E4F+68Dr
			; sub_43E4F:loc_444EFr
			; sub_43E4F+6B3r
			; sub_43E4F+6C6r
			; sub_43E4F+6D9r
			; sub_43E4F+6ECr
			; sub_43E4F+6FFr
			; sub_43E4F+712r
			; sub_43E4F+725r
			; sub_43E4F+738r
			; sub_43E4F+74Br
			; sub_43E4F:loc_445ADr
			; sub_43E4F+771r
			; sub_43E4F+784r
			; sub_43E4F+797r
			; sub_43E4F+7AAr
			; sub_43E4F+7BDr
			; sub_43E4F+7D0r
			; sub_43E4F+7E3r
			; sub_43E4F+7F6r
			; sub_43E4F+809r
			; sub_43E4F+81Cr
			; sub_43E4F+82Fr
			; sub_43E4F+842r
			; sub_43E4F+855r
			; sub_43E4F:loc_446BBr
			; sub_43E4F+887r
			; sub_43E4F+89Ar
			; sub_43E4F+8ADr
			; sub_43E4F+8C0r
			; sub_43E4F+8D3r
			; sub_43E4F+8E6r
			; sub_43E4F+902w
			; sub_4A942:loc_4AB8Dr
			; sub_4A942:loc_4ACE9r
			; sub_4A942:loc_4ACFFr
			; sub_4A942:loc_4AD15r
			; sub_4A942+3EFr
			; sub_4A942:loc_4AD46r
			; sub_4A942:loc_4AD5Dr
			; sub_4A942:loc_4AD72r
			; sub_4A942:loc_4AD89r
			; sub_4A942:loc_4ADA3r
			; sub_4A942:loc_4ADB8r
			; sub_4A942:loc_4ADE9r
			; sub_4A942:loc_4ADFEr
			; sub_4A942:loc_4AE13r
			; sub_4A942:loc_4AE28r
			; sub_4A942:loc_4AE3Dr
			; sub_4A942+548r
			; sub_4A942:loc_4AE9Dr
			; sub_4A942+570r
			; sub_4A942+585r
			; sub_4A942+59Ar
			; sub_4A942+5C7r
			; sub_4A942+609r
			; sub_4A942:loc_4AF5Fr
			; sub_4A942+637r
			; sub_4A942+64Ar
			; sub_4A942+65Dr
			; sub_4A942+670r
			; sub_4A942+683r
			; sub_4A942+696r
			; sub_4A942+6A9r
			; sub_4A942+6BCr
			; sub_4A942+6CFr
			; sub_4A942+6E2r
			; sub_4A942+6F5r
			; sub_4A942+708r
			; sub_4A942+71Br
			; sub_4A942+72Er
			; sub_4A942+741r
			; sub_4A942+754r
			; sub_4A942+767r
			; sub_4A942+77Ar
			; sub_4A942+78Dr
			; sub_4A942+7A0r
			; sub_4A942+7B3r
			; sub_4A942+7C6r
			; sub_4A942+7D9r
			; sub_4A942+7ECr
			; sub_4A942+7FFr
			; sub_4A942+812r
			; sub_4A942+825r
			; sub_4A942+838r
			; sub_4A942+84Br
			; sub_4A942:loc_4B1A5r
			; sub_4A942+87Er
			; sub_4A942+891r
			; sub_4A942:loc_4B1FAr
			; sub_4A942:loc_4B20Dr
			; sub_4A942:loc_4B220r
			; sub_4A942:loc_4B233r
			; sub_4A942:loc_4B246r
			; sub_4A942:loc_4B259r
			; sub_4A942:loc_4B26Cr
			; sub_4A942:loc_4B27Fr
			; sub_4A942:loc_4B292r
			; sub_4A942:loc_4B2A5r
			; sub_4A942:loc_4B2BFr
			; sub_4A942+99Dr
			; sub_4A942:loc_4B2FCr
			; sub_4A942:loc_4B325r
			; sub_4A942+A11r
			; sub_4A942+A3Dr
			; sub_4A942:loc_4B396r
			; sub_4A942+A80r
			; sub_4A942:loc_4B3EEr
			; sub_4A942+AE4r
			; sub_4A942+AFBr
			; sub_4A942+B27r
			; sub_4A942+B74r
			; sub_4A942+BAFr
			; sub_4A942+BD7r
			; sub_4A942+C12r
			; sub_4A942+C3Ar
			; sub_4A942+CCAr
			; sub_4A942+D05r
			; sub_4A942+D2Dr
			; sub_4A942+D68r
			; sub_4A942+D90r
			; sub_4A942:loc_4B74Cr
			; sub_4A942+E0Er
			; sub_4A942+E22r
			; sub_4A942+E36r
			; sub_4A942:loc_4B79Cr
			; sub_4A942:loc_4B7C8r
			; sub_4A942+E8Ar
			; sub_4A942+E9Er
			; sub_4A942+EB2r
			; sub_4A942:loc_4B818r
			; sub_4A942:loc_4B840r
			; sub_4A942+F02r
			; sub_4A942+F16r
			; sub_4A942+F2Ar
			; sub_4A942:loc_4B890r
			; sub_4A942:loc_4B8B2r
			; sub_4A942+F83r
			; sub_4A942:loc_4B8E1w
			; LBX_Cityname_s4B973:loc_4BA29r
			; sub_4BA53+3B1r
			; sub_4BA53+3C0r
			; sub_4BA53+4C2r
			; sub_4BF93+19Ar
word_3A4DC dw 0		; DATA XREF: OVR_SaveGame_MagicSet+147o
			; ST_LoadSaveGamByNbr+15Eo
			; sub_3DA30+1Aw
			; sub_3E1DE+387w
			; sub_43E4F:loc_4420Br
			; sub_467A7+17r
			; sub_467A7+6C6r
			; sub_467A7+6CDr
			; sub_4A942+5B8r
			; sub_4A942+5DBr
			; sub_4A942+5FCr
			; sub_523A3:loc_52407r
			; sub_52792:loc_528D5r
			; sub_5301E+1A1r
			; sub_5301E:loc_53239r
			; sub_5301E:loc_53452r
			; sub_5301E:loc_5345Er
			; sub_5301E:loc_538C0r
word_3A4DE dw 0		; DATA XREF: OVR_SaveGame_MagicSet+12Fo
			; ST_LoadSaveGamByNbr+146o
			; sub_3DA30:loc_3DA3Ew
			; sub_3E1DE+37Aw
			; sub_46406+C8r
			; sub_46406+127r
word_3A4E0 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+117o
			; ST_LoadSaveGamByNbr+12Eo
			; sub_3DA30+8w
			; sub_3E1DE+374w
			; sub_45389+7Er
			; sub_45389:loc_454C4r
word_3A4E2 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+FFo
			; ST_LoadSaveGamByNbr+116o
			; sub_3DA30+14w
			; sub_3E1DE+381w
			; sub_43E4F+90Cr
			; sub_43E4F+9EAr
			; sub_43E4F+B13r
			; sub_4A942:loc_4AB29r
			; sub_522E0:loc_52386r
			; sub_523A3:loc_523F9r
			; sub_523A3:loc_52441r
			; sub_5244A:loc_52655r
			; sub_5244A:loc_5265Fr
			; sub_526A6:loc_52786r
			; sub_52792:loc_52C2Ar
			; sub_52C4D:loc_52C98r
			; sub_52C4D:loc_52CDBr
			; sub_52CE7:loc_5300Fr
			; sub_5301E:loc_530A7r
			; sub_5301E:loc_530DCr
			; sub_5301E:loc_5322Ar
			; sub_5301E:loc_5339Er
			; sub_5301E:loc_53887r
			; sub_5301E:loc_538AEr
			; sub_5301E+8A9r
			; sub_5301E:loc_539CFr
			; sub_53A06+C15r
; void MagSet_01
MagSet_01 dw 0		; DATA XREF: _f010109_main+25Ao
			; OVR_SaveGame_MagicSet+3DDo
			; sub_3CFC0+F7o
			; sub_3CFC0+2D5o
			; ST_MagicSet_ReadCreateWrite+4Do
			; ST_MagicSet_ReadCreateWrite+72o
			; ST_MagicSet_ReadCreateWrite+10Eo
			; ST_DefaultMagicSet+4w
			; ST_LoadMusicSoundfxIntro:loc_55941r
			; ST_LoadMusicSoundfxIntro+1BDr
			; ST_LoadMusicSoundfxIntro:loc_559B6r
			; ST_LoadMusicSoundfxIntro+232r
			; ST_LoadMusicSoundfxIntro+28Dr
			; ST_LoadMusicSoundfxIntro+2D2r
			; ST_LoadMusicSoundfxIntro+2ECr
			; ST_LoadMusicSoundfxIntro:loc_55AE6r
			; ST_LoadMusicSoundfxIntro+320r
MagSet_02 dw 0		; DATA XREF: _f010109_main+393r
			; ST_DefaultMagicSet+Aw
			; ST_LoadMusicSoundfxIntro+48r
MagSet_03 dw 0		; DATA XREF: ST_DefaultMagicSet+10w
MagSet_13 dw 0		; DATA XREF: ST_DefaultMagicSet+4Cw
MagSet_14 dw 0		; DATA XREF: ST_DefaultMagicSet+52w
MagSet_15 dw 0		; DATA XREF: ST_DefaultMagicSet+58w
MagSet_08 dw 0		; DATA XREF: ST_DefaultMagicSet+2Ew
MagSet_09 dw 0		; DATA XREF: ST_MagicSet_ReadCreateWrite:loc_3D886r
			; ST_MagicSet_ReadCreateWrite+A6w
			; ST_MagicSet_ReadCreateWrite:loc_3D893r
			; ST_MagicSet_ReadCreateWrite+B3w
			; ST_DefaultMagicSet+34w
MagSet_06 dw 0		; DATA XREF: ST_DefaultMagicSet+22w
MagSet_07 dw 0		; DATA XREF: ST_DefaultMagicSet+28w
MagSet_11 dw 0		; DATA XREF: ST_DefaultMagicSet+40w
MagSet_16 dw 0		; DATA XREF: ST_DefaultMagicSet+5Ew
MagSet_04 dw 0		; DATA XREF: ST_DefaultMagicSet+16w
MagSet_05 dw 0		; DATA XREF: ST_DefaultMagicSet+1Cw
MagSet_10 dw 0		; DATA XREF: ST_DefaultMagicSet+3Aw
MagSet_12 dw 0		; DATA XREF: ST_DefaultMagicSet+46w
MagSet_17 dw 0		; DATA XREF: ST_DefaultMagicSet+64w
MagSet_18 dw 0		; DATA XREF: ST_DefaultMagicSet+6Aw
			; sub_4F44D+3Er
; int LBX_FONTS_w3A508
LBX_FONTS_w3A508 dw 0	; DATA XREF: _f010109_main:loc_1339Er
			; _f010109_main+19Cr
			; _f010109_main:loc_133ACw
			; _f010109_main+295w
			; _f010109_main+2B3r
			; ST_DefaultMagicSet+94w
; int LBX_FONTS_w3A50A
LBX_FONTS_w3A50A dw 0	; DATA XREF: _f010109_main:loc_133B2w
			; _f010109_main+28Fw
			; _f010109_main+2B7r
			; ST_DefaultMagicSet+8Ew
MagSet_20 dw 0		; DATA XREF: ST_DefaultMagicSet+76w
			; sub_3E1DE:loc_3E353r
			; sub_3E1DE+17Cr
			; sub_3E1DE:loc_3E361w
			; sub_3E1DE+384r
			; sub_3E1DE+395w
			; sub_3E1DE+399r
			; sub_3E1DE+3A0w
			; sub_3E60E+174r
			; sub_3E60E+1A1r
			; sub_3E60E+1DBr
			; sub_3E60E+208r
			; sub_3EAD2+Er
			; sub_3EBA0+Ar
			; sub_3EBA0+173r
			; sub_3EDD1+221r
			; sub_3EDD1+38Cr
MagSet_21 dw 0		; DATA XREF: ST_DefaultMagicSet+7Cw
			; sub_3E1DE:loc_3E367r
			; sub_3E1DE+190r
			; sub_3E1DE:loc_3E375w
			; sub_3E1DE+37Dr
			; sub_3E1DE+3ACw
			; sub_3E1DE+3B0r
			; sub_3E1DE+3B7w
			; sub_3E60E+252r
			; sub_3E60E+27Fr
			; sub_3E60E+2B9r
			; sub_3E60E+2E6r
			; sub_3EAD2+9r
MagSet_23 dw 0		; DATA XREF: _f010109_main+232o
			; ST_DefaultMagicSet+88w
			; sub_3E1DE:loc_3E37Br
			; sub_3E1DE+1A4r
			; sub_3E1DE:loc_3E389w
			; sub_3E1DE+371r
			; sub_3E1DE+3C3w
			; sub_3E1DE+3C7r
			; sub_3E1DE+3CEw
			; sub_3E60E+330r
			; sub_3E60E+35Dr
			; sub_3E60E+397r
			; sub_3E60E+3C4r
			; sub_3EAD2+11r
MagSet_22 dw 0		; DATA XREF: _f010109_main+1BCr
			; _f010109_main+220w
			; ST_DefaultMagicSet+82w
			; sub_3E1DE:loc_3E38Fr
			; sub_3E1DE+1B8r
			; sub_3E1DE:loc_3E39Dw
			; sub_3E1DE+377r
			; sub_3E1DE+3DAw
			; sub_3E1DE+3DEr
			; sub_3E1DE+3E5w
			; sub_3E60E+40Er
			; sub_3E60E+43Br
			; sub_3E60E+475r
			; sub_3E60E+4A2r
			; sub_3EAD2+6r
idk_MagSet_w3A514 dw 0	; DATA XREF: OVR_SaveGame_MagicSet+3BAw
			; ST_DefaultMagicSet+A2w
db    0
db    0
unk_3A518 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A536 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A54E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A566 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A58E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A596 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A5BE db	0
db    0
db    0
db    0
db    0
db    0
MagSet_19 dw 0		; DATA XREF: sub_3CFC0+35Br
			; sub_3CFC0:loc_3D31Fw
			; sub_3D378+22Fr
			; ST_MagicSet_ReadCreateWrite+85r
			; ST_MagicSet_ReadCreateWrite+8Cw
			; ST_MagicSet_ReadCreateWrite:loc_3D879r
			; ST_MagicSet_ReadCreateWrite+99w
			; ST_DefaultMagicSet+70w
tmpMagicSet db	  0	; DATA XREF: ST_MagicSet_ReadCreateWrite+E3o
			; ST_DefaultMagicSet+D1o
			; idk_HoF_s565F2+1A3o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A5E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A5EE db	0
db    0
db    0
db    0
db    0
db    0
unk_3A5F4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A5FD db	0	; DATA XREF: sub_4F808+1Fo
unk_3A5FE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A62E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A641 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A65E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A68E dw 0		; DATA XREF: ST_MagicSet_ReadCreateWrite:loc_3D8A0r
			; ST_MagicSet_ReadCreateWrite+C8w
			; ST_DefaultMagicSet+B6w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A69A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A6A2 dw 0		; DATA XREF: ST_MagicSet_ReadCreateWrite+D2w
			; ST_DefaultMagicSet+C0w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A6B6 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_555AFw
word_3A6B8 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+1FBw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A6C2 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+1E7w
word_3A6C4 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0:loc_55593w
word_3A6C6 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+1CFw
word_3A6C8 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+1CBw
word_3A6CA dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+19Fw
word_3A6CC dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+19Bw
db    0
db    0
db    0
db    0
dword_3A6D2 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+322r
			; ST_LoadSaveGamByNbr+339r
			; sub_4BF24+25r
			; sub_4BF24:loc_4BF79r
			; sub_4C79C+46r
			; sub_4C79C+79r
			; sub_4C79C+A9r
			; sub_4C79C+DCr
			; sub_4C79C+10Fr
			; sub_4C79C+142r
			; sub_4C79C+1A1r
			; sub_4C79C+1C1r
			; sub_4C79C+1DFr
			; sub_4C79C+1FFr
			; sub_4C79C+21Fr
			; sub_4C79C+242r
			; sub_4C79C+262r
			; sub_4C79C+280r
			; sub_4C79C+2A0r
			; sub_4C79C+2C0r
			; sub_4C79C+2E0r
			; idk_EmsPgNm_TileFigureCont_s553B0+1B7w
			; OVR_SaveGame_MagicSet+31Er
			; ST_LoadSaveGamByNbr+335r
			; sub_4BF24+2Fr
			; sub_4BF24+5Fr
			; idk_EmsPgNm_TileFigureCont_s553B0+1B3w
dword_3A6D6 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+304r
			; ST_LoadSaveGamByNbr+31Br
			; sub_4C4FA+1Fr
			; sub_4C75E+24r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_554EFw
			; OVR_SaveGame_MagicSet:loc_3CAE0r
			; ST_LoadSaveGamByNbr+317r
			; idk_EmsPgNm_TileFigureCont_s553B0+13Bw
dword_3A6DA dd 0	; DATA XREF: OVR_SaveGame_MagicSet+354r
			; ST_LoadSaveGamByNbr+36Br
			; sub_4BA53+21r
			; sub_4BA53+322r
			; sub_4BA53+342r
			; sub_4BA53+365r
			; sub_4BA53+385r
			; sub_4BA53+3E9r
			; sub_4BA53+43Er
			; sub_4BA53+485r
			; sub_4BA53+4A5r
			; sub_4BF93+35r
			; sub_4C79C+175r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_554D5w
			; OVR_SaveGame_MagicSet+350r
			; ST_LoadSaveGamByNbr+367r
			; idk_EmsPgNm_TileFigureCont_s553B0+121w
dword_3A6DE dd 0	; DATA XREF: OVR_SaveGame_MagicSet+2EBr
			; ST_LoadSaveGamByNbr+302r
			; sub_48C63+33r
			; sub_48C63+263r
			; sub_4BF93+18r
			; sub_4BF93+1A8r
			; sub_4BF93+2CBr
			; sub_4BF93+304r
			; sub_4BF93+33Dr
			; sub_4BF93+36Cr
			; sub_4BF93+3A5r
			; idk_EmsPgNm_TileFigureCont_s553B0+10Bw
			; OVR_SaveGame_MagicSet+2E7r
			; ST_LoadSaveGamByNbr+2FEr
			; idk_EmsPgNm_TileFigureCont_s553B0+107w
dword_3A6E2 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+2B9r
			; ST_LoadSaveGamByNbr+2D0r
			; sub_43E4F+313r
			; sub_43E4F+358r
			; sub_43E4F+36Dr
			; sub_43E4F+382r
			; sub_43E4F+397r
			; sub_43E4F+3ACr
			; sub_43E4F+3E7r
			; sub_43E4F+3FCr
			; sub_43E4F+411r
			; sub_43E4F+426r
			; sub_43E4F+43Br
			; sub_43E4F+46Fr
			; sub_43E4F+485r
			; sub_43E4F+49Br
			; sub_43E4F+4B0r
			; sub_43E4F+4C5r
			; sub_43E4F+4DAr
			; sub_43E4F+4EFr
			; sub_43E4F+504r
			; sub_43E4F+519r
			; sub_43E4F+52Er
			; sub_43E4F+56Cr
			; sub_43E4F+591r
			; sub_43E4F+5B6r
			; sub_43E4F+5C9r
			; sub_43E4F+5DEr
			; sub_43E4F+5F1r
			; sub_43E4F+604r
			; sub_43E4F+617r
			; sub_43E4F+62Br
			; sub_43E4F+645r
			; sub_43E4F+65Br
			; sub_43E4F+66Fr
			; sub_43E4F+682r
			; sub_43E4F+695r
			; sub_43E4F+6A8r
			; sub_43E4F+6BBr
			; sub_43E4F+6CEr
			; sub_43E4F+6E1r
			; sub_43E4F+6F4r
			; sub_43E4F+707r
			; sub_43E4F+71Ar
			; sub_43E4F+72Dr
			; sub_43E4F+740r
			; sub_43E4F+753r
			; sub_43E4F+766r
			; sub_43E4F+779r
			; sub_43E4F+78Cr
			; sub_43E4F+79Fr
			; sub_43E4F+7B2r
			; sub_43E4F+7C5r
			; sub_43E4F+7D8r
			; sub_43E4F+7EBr
			; sub_43E4F+7FEr
			; sub_43E4F+811r
			; sub_43E4F+824r
			; sub_43E4F+837r
			; sub_43E4F+84Ar
			; sub_43E4F+85Dr
			; sub_43E4F+874r
			; sub_43E4F+88Fr
			; sub_43E4F+8A2r
			; sub_43E4F+8B5r
			; sub_43E4F+8C8r
			; sub_43E4F+8DBr
			; sub_43E4F+8EEr
			; sub_43E4F+925r
			; sub_43E4F+98Cr
			; sub_43E4F+9A4r
			; sub_43E4F+9B8r
			; sub_43E4F+9CCr
			; sub_43E4F+A03r
			; sub_43E4F+A6Ar
			; sub_43E4F+A82r
			; sub_43E4F+A96r
			; sub_43E4F+AAAr
			; sub_43E4F+ACDr
			; sub_43E4F+AE1r
			; sub_43E4F+AF5r
			; sub_4A942+1F8r
			; sub_4A942+213r
			; sub_4A942+226r
			; sub_4A942+3AFr
			; sub_4A942+3C5r
			; sub_4A942+3DBr
			; sub_4A942+3F7r
			; sub_4A942+40Cr
			; sub_4A942+423r
			; sub_4A942:loc_4AD7Ar
			; sub_4A942+44Fr
			; sub_4A942+469r
			; sub_4A942+47Er
			; sub_4A942+4AFr
			; sub_4A942+4C4r
			; sub_4A942+4D9r
			; sub_4A942+4EEr
			; sub_4A942+503r
			; sub_4A942+550r
			; sub_4A942+563r
			; sub_4A942+578r
			; sub_4A942+58Dr
			; sub_4A942+5A2r
			; sub_4A942+5D0r
			; sub_4A942+612r
			; sub_4A942+625r
			; sub_4A942+63Fr
			; sub_4A942+652r
			; sub_4A942+665r
			; sub_4A942+678r
			; sub_4A942+68Br
			; sub_4A942+69Er
			; sub_4A942+6B1r
			; sub_4A942+6C4r
			; sub_4A942+6D7r
			; sub_4A942+6EAr
			; sub_4A942+6FDr
			; sub_4A942+710r
			; sub_4A942+723r
			; sub_4A942+736r
			; sub_4A942+749r
			; sub_4A942+75Cr
			; sub_4A942+76Fr
			; sub_4A942+782r
			; sub_4A942+795r
			; sub_4A942+7A8r
			; sub_4A942+7BBr
			; sub_4A942+7CEr
			; sub_4A942+7E1r
			; sub_4A942+7F4r
			; sub_4A942+807r
			; sub_4A942+81Ar
			; sub_4A942+82Dr
			; sub_4A942+840r
			; sub_4A942+853r
			; sub_4A942+86Br
			; sub_4A942+886r
			; sub_4A942+899r
			; sub_4A942+8C0r
			; sub_4A942+8D3r
			; sub_4A942+8E6r
			; sub_4A942+8F9r
			; sub_4A942+90Cr
			; sub_4A942+91Fr
			; sub_4A942+932r
			; sub_4A942+945r
			; sub_4A942+958r
			; sub_4A942+96Br
			; sub_4A942+985r
			; sub_4A942+9A5r
			; sub_4A942+9C2r
			; sub_4A942+9EBr
			; sub_4A942+A19r
			; sub_4A942+A45r
			; sub_4A942+A5Cr
			; sub_4A942+A88r
			; sub_4A942+AB4r
			; sub_4A942+AECr
			; sub_4A942+B03r
			; sub_4A942+B2Fr
			; sub_4A942+B7Cr
			; sub_4A942+BB7r
			; sub_4A942+BDFr
			; sub_4A942+C1Ar
			; sub_4A942+C42r
			; sub_4A942+CD2r
			; sub_4A942+D0Dr
			; sub_4A942+D35r
			; sub_4A942+D70r
			; sub_4A942+D98r
			; sub_4A942+E16r
			; sub_4A942+E2Ar
			; sub_4A942+E3Er
			; sub_4A942+E62r
			; sub_4A942+E92r
			; sub_4A942+EA6r
			; sub_4A942+EBAr
			; sub_4A942+EDEr
			; sub_4A942+F0Ar
			; sub_4A942+F1Er
			; sub_4A942+F32r
			; sub_4A942+F56r
			; sub_4A942+F78r
			; sub_4A942+F8Br
			; LBX_Cityname_s4B973+50r
			; sub_4BA53+5Ar
			; sub_4BA53+70r
			; sub_4BA53+90r
			; sub_4BA53+A6r
			; sub_4BA53+BCr
			; sub_4BA53+D6r
			; sub_4BA53+F0r
			; sub_4BA53+108r
			; sub_4BA53+3D9r
			; sub_4BA53+3F8r
			; sub_4BA53+412r
			; sub_4BA53+42Er
			; sub_4BA53+44Dr
			; sub_4BA53+467r
			; sub_4BF93+151r
			; sub_4BF93+169r
			; sub_4BF93+180r
			; sub_4CB55+1FAr
			; sub_4CB55+235r
			; sub_523A3:loc_523DFr
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55439w
			; OVR_SaveGame_MagicSet+2B5r
			; ST_LoadSaveGamByNbr+2CCr
			; sub_43E4F+8E1r
			; sub_4A942+F7Er
			; LBX_Cityname_s4B973+56r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55435w
dword_3A6E6 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+287r
			; ST_LoadSaveGamByNbr+29Er
			; sub_43839+Fr
			; sub_43839+21r
			; sub_43839+3Ar
			; sub_43839+4Cr
			; sub_43839+5Er
			; sub_43839+77r
			; sub_43E4F+1DAr
			; sub_43E4F+1F5r
			; sub_43E4F+208r
			; sub_46406+73r
			; sub_46406+85r
			; sub_46406+9Fr
			; sub_46406+1F6r
			; sub_46406+20Ar
			; sub_46406+2EAr
			; sub_46406+2FEr
			; sub_46406+385r
			; sub_467A7+35r
			; sub_467A7+48r
			; sub_467A7+5Cr
			; sub_467A7+70r
			; sub_467A7+91r
			; sub_467A7+A5r
			; sub_467A7+B9r
			; sub_467A7+CDr
			; sub_467A7+EEr
			; sub_467A7+102r
			; sub_467A7+115r
			; sub_467A7+128r
			; sub_467A7+13Ar
			; sub_467A7+14Cr
			; sub_467A7+15Er
			; sub_467A7+170r
			; sub_467A7+182r
			; sub_467A7+194r
			; sub_467A7+217r
			; sub_467A7+22Br
			; sub_467A7+23Fr
			; sub_467A7+366r
			; sub_467A7+37Ar
			; sub_467A7+39Dr
			; sub_467A7+3AFr
			; sub_467A7+3D2r
			; sub_467A7+3E6r
			; sub_467A7+3F8r
			; sub_467A7+40Cr
			; sub_467A7+41Er
			; sub_467A7+43Dr
			; sub_467A7+45Dr
			; sub_467A7+474r
			; sub_467A7+48Br
			; sub_467A7+511r
			; sub_467A7+56Ar
			; sub_467A7+57Er
			; sub_467A7+5A1r
			; sub_467A7:loc_46D5Ar
			; sub_467A7+5C7r
			; sub_467A7+5E2r
			; sub_467A7+5F6r
			; sub_467A7+608r
			; sub_467A7+61Cr
			; sub_467A7:loc_46DD5r
			; sub_467A7+642r
			; sub_467A7+654r
			; sub_467A7+673r
			; sub_467A7+68Cr
			; sub_467A7+6ABr
			; sub_467A7+764r
			; sub_467A7+7C6r
			; sub_467A7:loc_46FB3r
			; sub_467A7+823r
			; sub_467A7+874r
			; sub_467A7+889r
			; sub_467A7+8A0r
			; sub_467A7:loc_4705Br
			; sub_467A7+8CFr
			; sub_467A7+8E3r
			; sub_467A7+918r
			; sub_467A7+939r
			; sub_467A7+94Er
			; sub_467A7+960r
			; sub_467A7+974r
			; sub_467A7+9A1r
			; sub_467A7+9BFr
			; sub_467A7:loc_47184r
			; sub_467A7+9FDr
			; sub_467A7+A11r
			; sub_467A7+A24r
			; sub_467A7+A37r
			; sub_467A7+A49r
			; sub_4A942+2FFr
			; sub_4A942+316r
			; sub_4A942+329r
			; sub_4BF93+B7r
			; sub_4BF93+CFr
			; sub_4BF93+E5r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_556CFw
			; OVR_SaveGame_MagicSet+283r
			; ST_LoadSaveGamByNbr+29Ar
			; sub_46406+79r
			; sub_46406+8Br
			; idk_EmsPgNm_TileFigureCont_s553B0+31Bw
dword_3A6EA dd 0	; DATA XREF: OVR_SaveGame_MagicSet+26Er
			; ST_LoadSaveGamByNbr+285r
			; sub_438C4+4Ar
			; sub_438C4+60r
			; sub_43C95+9Br
			; sub_43C95+ADr
			; sub_43C95+122r
			; sub_43C95+134r
			; sub_43C95+147r
			; sub_43E4F:loc_43FDAr
			; sub_43E4F+19Dr
			; sub_46406+31r
			; sub_46406+43r
			; sub_4A942+2B9r
			; sub_4A942+2CBr
			; sub_4BF93+110r
			; sub_4BF93+125r
			; sub_4CFE8+Dr
			; sub_4CFE8+22r
			; idk_EmsPgNm_TileFigureCont_s553B0+307w
			; OVR_SaveGame_MagicSet+26Ar
			; ST_LoadSaveGamByNbr+281r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_556B3w
dword_3A6EE dd 0	; DATA XREF: OVR_SaveGame_MagicSet+255r
			; ST_LoadSaveGamByNbr+26Cr
			; sub_43E4F+C1r
			; sub_43E4F+DBr
			; sub_43E4F+EDr
			; sub_43E4F+288r
			; sub_43E4F+29Br
			; sub_43E4F+2AFr
			; sub_43E4F+2C3r
			; sub_43E4F+55Ar
			; sub_43E4F+57Er
			; sub_43E4F+5A3r
			; sub_4A942+1B1r
			; sub_4A942+1C3r
			; sub_4C4FA+49r
			; sub_4C4FA+55r
			; sub_4C4FA+5Fr
			; sub_526A6+Fr
			; sub_526A6+2Fr
			; sub_526A6+4Er
			; idk_EmsPgNm_TileFigureCont_s553B0+2EFw
			; OVR_SaveGame_MagicSet+251r
			; ST_LoadSaveGamByNbr+268r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5569Bw
dword_3A6F2 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+23Cr
			; ST_LoadSaveGamByNbr+253r
			; sub_43C95+E2r
			; sub_43C95+F5r
			; sub_43E4F+121r
			; sub_43E4F+13Cr
			; sub_43E4F+14Fr
			; sub_44A0E+26r
			; sub_44A0E+3Er
			; sub_44A0E:loc_44B24r
			; sub_44A0E+130r
			; sub_44A0E+147r
			; sub_44A0E+159r
			; sub_44A0E+183r
			; sub_44A0E+19Er
			; sub_44A0E+1B1r
			; sub_44A0E+1EAr
			; sub_44A0E+204r
			; sub_44A0E+21Br
			; sub_44A0E+22Dr
			; sub_44A0E+257r
			; sub_44A0E+272r
			; sub_44A0E+285r
			; sub_45645+EDr
			; sub_45645+100r
			; sub_45645+12Dr
			; sub_45645+140r
			; sub_45645+154r
			; sub_45645+166r
			; sub_45645:loc_457BDr
			; sub_45645+197r
			; sub_45645+1AFr
			; sub_45645+1C4r
			; sub_45645+1D9r
			; sub_45645+203r
			; sub_45645+218r
			; sub_45645+22Br
			; sub_45645+240r
			; sub_45645+255r
			; sub_45645+35Ar
			; sub_45645+372r
			; sub_45645+385r
			; sub_45645+3B2r
			; sub_45645+3C5r
			; sub_45645+3D9r
			; sub_45645:loc_45A30r
			; sub_45645+3FDr
			; sub_45645+41Cr
			; sub_45645+434r
			; sub_45645+449r
			; sub_45645+45Er
			; sub_45645+488r
			; sub_45645+49Dr
			; sub_45645+4B0r
			; sub_45645+4C5r
			; sub_45645+4DAr
			; sub_45CDF+10r
			; sub_45CDF+2Ar
			; sub_45CDF+4Ar
			; sub_45CDF+87r
			; sub_45CDF:loc_45D88r
			; sub_45CDF+CBr
			; sub_46406+BCr
			; sub_46406+F1r
			; sub_46406+104r
			; sub_46406+13Br
			; sub_46406+150r
			; sub_46406+163r
			; sub_46406+175r
			; sub_4A942+25Cr
			; sub_4A942+273r
			; sub_4A942+286r
			; sub_4CF8C+Er
			; sub_4CF8C:loc_4CFB0r
			; sub_4CF8C+3Br
			; idk_EmsPgNm_TileFigureCont_s553B0+2D7w
			; OVR_SaveGame_MagicSet+238r
			; ST_LoadSaveGamByNbr+24Fr
			; sub_45645+1B8r
			; sub_45645+1CDr
			; sub_45645+20Cr
			; sub_45645+234r
			; sub_45645+249r
			; sub_45645+43Dr
			; sub_45645+452r
			; sub_45645+491r
			; sub_45645+4B9r
			; sub_45645+4CEr
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55683w
dword_3A6F6 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+223r
			; ST_LoadSaveGamByNbr+23Ar
			; sub_449D0+1Ar
			; sub_46029+1Cr
			; sub_46029+3Br
			; sub_46029+65r
			; sub_46029+86r
			; sub_46029+B2r
			; sub_46029+D2r
			; sub_46029+FDr
			; sub_46029+11Er
			; sub_46029+14Ar
			; sub_46029+16Ar
			; sub_46029+195r
			; sub_46029+1B5r
			; sub_46029+1E0r
			; sub_46029+201r
			; sub_46029+22Dr
			; sub_46029+24Dr
			; sub_46029+278r
			; sub_46029+299r
			; sub_46029+2C9r
			; sub_46029+35Er
			; sub_46029:loc_463ABr
			; sub_46029+3BFr
			; LBX_Terrtype_s472C7+81r
			; LBX_Terrtype_s472C7+A6r
			; LBX_Terrtype_s472C7+C9r
			; sub_4A942+527r
			; sub_4BA53+11Fr
			; sub_4BA53+13Dr
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_554A1w
			; OVR_SaveGame_MagicSet+21Fr
			; ST_LoadSaveGamByNbr+236r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5549Dw
word_3A6FA dw 0		; DATA XREF: OVR_SaveGame_MagicSet+20Ar
			; ST_LoadSaveGamByNbr+221r
			; sub_4BF24+43r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55487w
word_3A6FC dw 0		; DATA XREF: OVR_SaveGame_MagicSet+206r
			; ST_LoadSaveGamByNbr+21Dr
			; sub_4BF24+49r
			; idk_EmsPgNm_TileFigureCont_s553B0+D3w
word_3A6FE dw 0		; DATA XREF: OVR_SaveGame_MagicSet+1F1r
			; ST_LoadSaveGamByNbr+208r
			; sub_4BF24+13r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5546Dw
word_3A700 dw 0		; DATA XREF: OVR_SaveGame_MagicSet+1EDr
			; ST_LoadSaveGamByNbr+204r
			; sub_4BF24+19r
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_55469w
dword_3A702 dd 0	; DATA XREF: OVR_SaveGame_MagicSet+1D8r
			; ST_LoadSaveGamByNbr+1EFr
			; sub_438C4+1Cr
			; sub_438C4+1BAr
			; sub_438C4+1E4r
			; sub_438C4+225r
			; sub_438C4+24Fr
			; sub_438C4+294r
			; sub_438C4+2BEr
			; sub_438C4+2F9r
			; sub_438C4+323r
			; sub_438C4+378r
			; sub_43C95+4Cr
			; sub_43C95+67r
			; sub_43C95+17Dr
			; sub_43C95+197r
			; sub_43E4F+95r
			; sub_44A0E:loc_44B80r
			; sub_44A0E+246r
			; sub_44CBB+1Br
			; sub_44CBB+3Fr
			; sub_44CBB+74r
			; sub_44CBB:loc_44D51r
			; sub_44CBB+BDr
			; sub_44CBB+F5r
			; sub_44CBB+154r
			; sub_44CBB+17Ar
			; sub_44CBB+23Fr
			; sub_44CBB+264r
			; sub_44CBB+2E2r
			; sub_44CBB+308r
			; sub_44CBB+3CDr
			; sub_44CBB+3F3r
			; sub_450F6+1Fr
			; sub_450F6+45r
			; sub_450F6+6Br
			; sub_450F6+8Er
			; sub_450F6+B1r
			; sub_450F6+D5r
			; sub_450F6+FAr
			; sub_450F6+11Dr
			; sub_450F6+150r
			; sub_450F6+174r
			; sub_450F6+1B0r
			; sub_450F6+1C8r
			; sub_450F6+205r
			; sub_450F6+259r
			; sub_45389+18r
			; sub_45389+1ACr
			; sub_45389+1D4r
			; sub_45645+B9r
			; sub_45645+32Ar
			; sub_45DC9+33r
			; sub_45DC9+6Br
			; sub_45DC9+A1r
			; sub_45DC9+DAr
			; sub_45DC9+110r
			; sub_45DC9+187r
			; sub_45DC9+1E4r
			; sub_45DC9+21Dr
			; LBX_Terrtype_s472C7+4Cr
			; LBX_Terrtype_s472C7+128r
			; LBX_Terrtype_s472C7+14Fr
			; LBX_Terrtype_s472C7+173r
			; LBX_Terrtype_s472C7+197r
			; LBX_Terrtype_s472C7:loc_47482r
			; LBX_Terrtype_s472C7+317r
			; LBX_Terrtype_s472C7+33Ar
			; LBX_Terrtype_s4763F+4Fr
			; LBX_Terrtype_s4763F+8Cr
			; LBX_Terrtype_s4763F+B2r
			; LBX_Terrtype_s4763F+E0r
			; LBX_Terrtype_s4763F+106r
			; LBX_Terrtype_s4763F+146r
			; LBX_Terrtype_s4763F+16Cr
			; LBX_Terrtype_s4763F+1ACr
			; LBX_Terrtype_s4763F+1D1r
			; LBX_Terrtype_s4763F+20Br
			; LBX_Terrtype_s4763F+231r
			; LBX_Terrtype_s4763F+260r
			; LBX_Terrtype_s4763F+286r
			; LBX_Terrtype_s4763F:loc_47905r
			; LBX_Terrtype_s4763F+2ECr
			; LBX_Terrtype_s4763F:loc_4796Br
			; LBX_Terrtype_s4763F+351r
			; LBX_Terrtype_s4763F+381r
			; LBX_Terrtype_s4763F+3E4r
			; LBX_Terrtype_s4763F+411r
			; LBX_Terrtype_s4763F+438r
			; LBX_Terrtype_s4763F+45Fr
			; LBX_Terrtype_s4763F+494r
			; LBX_Terrtype_s4763F+4BAr
			; LBX_Terrtype_s4763F+4E0r
			; LBX_Terrtype_s4763F+50Fr
			; LBX_Terrtype_s4763F+536r
			; LBX_Terrtype_s4763F+55Dr
			; LBX_Terrtype_s4763F+596r
			; LBX_Terrtype_s4763F+5BCr
			; LBX_Terrtype_s4763F+5E2r
			; LBX_Terrtype_s4763F+615r
			; LBX_Terrtype_s4763F+63Cr
			; LBX_Terrtype_s4763F+663r
			; LBX_Terrtype_s4763F+69Cr
			; LBX_Terrtype_s4763F+6C2r
			; LBX_Terrtype_s4763F+6E8r
			; LBX_Terrtype_s4763F+717r
			; LBX_Terrtype_s4763F+73Er
			; LBX_Terrtype_s4763F+765r
			; LBX_Terrtype_s4763F+79Br
			; LBX_Terrtype_s4763F+7C1r
			; LBX_Terrtype_s4763F+7E7r
			; LBX_Terrtype_s4763F:loc_47E5Dr
			; LBX_Terrtype_s4763F+883r
			; LBX_Terrtype_s4763F+8C1r
			; LBX_Terrtype_s4763F+8E7r
			; LBX_Terrtype_s4763F+90Dr
			; LBX_Terrtype_s4763F+93Br
			; LBX_Terrtype_s4763F+961r
			; LBX_Terrtype_s4763F+987r
			; LBX_Terrtype_s4763F+9C7r
			; LBX_Terrtype_s4763F:loc_4802Cr
			; LBX_Terrtype_s4763F+A13r
			; LBX_Terrtype_s4763F+A53r
			; LBX_Terrtype_s4763F+A78r
			; LBX_Terrtype_s4763F:loc_480DCr
			; LBX_Terrtype_s4763F+AE0r
			; LBX_Terrtype_s4763F+B06r
			; LBX_Terrtype_s4763F+B2Cr
			; LBX_Terrtype_s4763F+B5Br
			; LBX_Terrtype_s4763F+B81r
			; LBX_Terrtype_s4763F+BA7r
			; LBX_Terrtype_s4763F+BE7r
			; LBX_Terrtype_s4763F+C0Dr
			; LBX_Terrtype_s4763F:loc_48272r
			; LBX_Terrtype_s4763F+C73r
			; LBX_Terrtype_s4763F+C98r
			; LBX_Terrtype_s4763F+CBDr
			; LBX_Terrtype_s4763F+CFDr
			; LBX_Terrtype_s4763F+D55r
			; LBX_Terrtype_s4763F+D82r
			; LBX_Terrtype_s4763F+DA9r
			; LBX_Terrtype_s4763F+DD0r
			; LBX_Terrtype_s4763F+E05r
			; LBX_Terrtype_s4763F+E2Br
			; LBX_Terrtype_s4763F+E51r
			; LBX_Terrtype_s4763F+E80r
			; LBX_Terrtype_s4763F+EA7r
			; LBX_Terrtype_s4763F+ECEr
			; LBX_Terrtype_s4763F+F07r
			; LBX_Terrtype_s4763F+F2Dr
			; LBX_Terrtype_s4763F+F53r
			; LBX_Terrtype_s4763F+F86r
			; LBX_Terrtype_s4763F+FADr
			; LBX_Terrtype_s4763F+FD4r
			; LBX_Terrtype_s4763F+100Dr
			; LBX_Terrtype_s4763F+1033r
			; LBX_Terrtype_s4763F+1059r
			; LBX_Terrtype_s4763F+1088r
			; LBX_Terrtype_s4763F+10AFr
			; LBX_Terrtype_s4763F+10D6r
			; LBX_Terrtype_s4763F:loc_4874Br
			; LBX_Terrtype_s4763F+1132r
			; LBX_Terrtype_s4763F+1158r
			; LBX_Terrtype_s4763F:loc_487E0r
			; LBX_Terrtype_s48821+4Cr
			; LBX_Terrtype_s48821+93r
			; LBX_Terrtype_s48821+B7r
			; LBX_Terrtype_s48821+DBr
			; LBX_Terrtype_s48821+FFr
			; LBX_Terrtype_s48821+123r
			; LBX_Terrtype_s48821+16Br
			; LBX_Terrtype_s48821+18Fr
			; LBX_Terrtype_s48821+1B3r
			; LBX_Terrtype_s48821+1D7r
			; LBX_Terrtype_s48821+21Er
			; LBX_Terrtype_s48821+242r
			; LBX_Terrtype_s48821+266r
			; LBX_Terrtype_s48821+28Ar
			; LBX_Terrtype_s48821+2AEr
			; LBX_Terrtype_s48821+2F6r
			; LBX_Terrtype_s48821+31Ar
			; LBX_Terrtype_s48821+33Er
			; LBX_Terrtype_s48821+362r
			; LBX_Terrtype_s48821+3AAr
			; LBX_Terrtype_s48821+3CEr
			; LBX_Terrtype_s48821+3F2r
			; sub_48C63+477r
			; sub_4910F+1Ar
			; sub_4910F+134r
			; sub_4910F+1D8r
			; sub_4910F+1FDr
			; sub_4910F+222r
			; sub_4910F+247r
			; sub_4910F+269r
			; sub_4910F+290r
			; sub_4910F+2B5r
			; sub_4910F+2D7r
			; sub_4910F+2F3r
			; sub_4910F+318r
			; sub_4910F+33Ar
			; sub_4910F+360r
			; sub_4910F+385r
			; sub_4910F+3A7r
			; sub_4910F+3C4r
			; sub_4910F+3E9r
			; sub_4910F+40Br
			; sub_4910F+431r
			; sub_4910F+456r
			; sub_4910F+478r
			; sub_4910F+494r
			; sub_4910F+4B6r
			; sub_4910F+4D9r
			; sub_4910F+4F6r
			; sub_4910F+518r
			; sub_4910F+53Br
			; sub_4910F+55Er
			; sub_4910F+5AEr
			; sub_4910F+5D9r
			; sub_4910F+604r
			; sub_4910F+62Fr
			; sub_4910F+65Ar
			; sub_4910F+685r
			; sub_4910F+6B0r
			; sub_4910F+6DBr
			; sub_4910F+706r
			; sub_4910F+731r
			; sub_4910F+75Cr
			; sub_4910F+787r
			; sub_4910F+7B2r
			; sub_4910F+7DCr
			; sub_4910F+806r
			; sub_4910F+830r
			; sub_4910F+884r
			; sub_4910F+8ACr
			; sub_4910F+8D4r
			; sub_4910F+8FFr
			; sub_4910F+927r
			; sub_4910F+94Fr
			; sub_4910F+97Ar
			; sub_4910F+9A2r
			; sub_4910F+9CAr
			; sub_4910F+9F5r
			; sub_4910F+A1Dr
			; sub_4910F+A45r
			; sub_4910F+A70r
			; sub_4910F+A98r
			; sub_4910F+AC0r
			; sub_4910F+AEBr
			; sub_4910F+B13r
			; sub_4910F+B3Br
			; sub_4910F+B66r
			; sub_4910F+B8Er
			; sub_4910F+BB6r
			; sub_4910F+BE1r
			; sub_4910F+C09r
			; sub_4910F+C31r
			; sub_4910F+C5Cr
			; sub_4910F+C84r
			; sub_4910F+CACr
			; sub_4910F+CD7r
			; sub_4910F+CFFr
			; sub_4910F+D27r
			; sub_4910F+D52r
			; sub_4910F+D7Ar
			; sub_4910F+DA2r
			; sub_4910F+DCDr
			; sub_4910F+DF5r
			; sub_4910F+E1Dr
			; sub_4910F+E48r
			; sub_4910F+E70r
			; sub_4910F+E98r
			; sub_4910F+EC3r
			; sub_4910F+EEBr
			; sub_4910F+F13r
			; sub_4910F+F3Er
			; sub_4910F+F66r
			; sub_4910F+F8Er
			; sub_4910F+FB8r
			; sub_4910F+FE0r
			; sub_4910F+1008r
			; sub_4910F+104Er
			; sub_4910F+107Fr
			; sub_4910F+10AFr
			; sub_4910F+10D0r
			; sub_4910F+1114r
			; sub_4910F+1145r
			; sub_4910F+1175r
			; sub_4910F+1196r
			; sub_4910F+11F2r
			; sub_4910F+122Dr
			; sub_4910F+124Er
			; sub_4910F+127Ar
			; sub_4910F+12A4r
			; sub_4910F+12C5r
			; sub_4910F+12E8r
			; sub_4910F+1344r
			; sub_4910F+137Fr
			; sub_4910F+13A0r
			; sub_4910F+13CEr
			; sub_4910F+13EFr
			; sub_4910F+141Br
			; sub_4910F+143Cr
			; sub_4910F+145Fr
			; sub_4910F+14BDr
			; sub_4910F+14F8r
			; sub_4910F+1519r
			; sub_4910F+1547r
			; sub_4910F+1568r
			; sub_4910F+1594r
			; sub_4910F+15B5r
			; sub_4910F+15D8r
			; sub_4910F+1636r
			; sub_4910F+1671r
			; sub_4910F+1692r
			; sub_4910F+16B6r
			; sub_4910F+16E8r
			; sub_4910F+1709r
			; sub_4910F+172Cr
			; sub_4A942+135r
			; sub_4A942+15Fr
			; sub_4A942+184r
			; sub_4BA53+1CAr
			; sub_4BA53+1EEr
			; sub_4BA53+218r
			; sub_4BA53+241r
			; sub_4BA53+266r
			; sub_4BA53+290r
			; sub_4BA53+2B5r
			; sub_4BF93+245r
			; sub_4BF93+271r
			; sub_4BF93+295r
			; sub_4C79C+22r
			; sub_4CAAF+Br
			; sub_4CE35+21r
			; sub_4CE35+53r
			; sub_4CE35+75r
			; sub_4CE35+A8r
			; sub_4CF1C+Br
			; sub_4D02B+Br
			; sub_4D076+Br
			; sub_4D0DF+Br
			; sub_4D140+Br
			; sub_4D1AE+Br
			; sub_4D1F9+Br
			; sub_4D244+Br
			; sub_4D28F+Br
			; sub_4D2EC+Br
			; sub_4D342+Er
			; idk_EmsPgNm_TileFigureCont_s553B0+A3w
			; OVR_SaveGame_MagicSet+1D4r
			; ST_LoadSaveGamByNbr+1EBr
			; idk_EmsPgNm_TileFigureCont_s553B0:loc_5544Fw
db    0
db    0
db    0
db    0
db    0
db    0
word_3A70C dw 0		; DATA XREF: sub_3CFC0+B6w
db    0
db    0
db    0
db    0
word_3A712 dw 0		; DATA XREF: sub_3CFC0+8Ew
			; sub_3D378:loc_3D5AEr
align 8
word_3A718 dw 0		; DATA XREF: sub_3CFC0+66w
			; sub_3D378:loc_3D5B4r
db    0
db    0
db    0
db    0
word_3A71E dw 0		; DATA XREF: sub_3CFC0:loc_3D0CCw
			; sub_3CFC0:loc_3D2C7r
			; sub_3CFC0+316r
			; sub_3CFC0+326r
			; sub_3D378+68r
			; sub_3D378+BEr
			; sub_3D378+109r
			; sub_3D378:loc_3D4BEr
			; sub_3D378+18Er
			; sub_3D378+1E4r
db    0
db    0
unk_3A722 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A736 dw 0		; DATA XREF: sub_3CFC0+153w
			; sub_3CFC0+2B2r
			; sub_3D378+253r
db    0
db    0
db    0
db    0
db    0
db    0
word_3A73E dw 0		; DATA XREF: sub_3CFC0+273w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
idk_LoadLbx_w3A74A dw 0	; DATA XREF: sub_3CFC0+45w
			; sub_3D378+259r
			; sub_3D378:loc_3D5DEr
align 8
idk_LoadLbx_w3A750 dw 0	; DATA XREF: sub_3CFC0+2Ew
			; sub_3D378:loc_3D395r
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A76A dw 0		; DATA XREF: sub_430A4+125w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A784 dw 0		; DATA XREF: sub_430A4+17Dw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A79E dw 0		; DATA XREF: sub_430A4+1D5w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A7B8 dw 0		; DATA XREF: sub_430A4+22Dw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3A7D2 dw 0		; DATA XREF: sub_430A4+285w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A950 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A9B4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A9C8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3A9E6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3AA5E dw 0		; DATA XREF: sub_4067D+436r
			; sub_4067D+45Cr
			; sub_4067D:loc_40AEDr
			; sub_4067D:loc_40B06r
			; sub_4067D+4AAr
			; sub_4067D:loc_40B9Br
			; sub_4067D+53Ar
			; sub_4067D+571r
			; sub_4067D+598r
			; sub_4067D+5B5r
			; sub_4067D:loc_40C7Er
			; sub_4067D+63Br
			; sub_40EC0:loc_41646w
			; sub_40EC0+9ACw
word_3AA60 dw 0		; DATA XREF: sub_4067D+15Bw
			; sub_4067D:loc_40A67w
			; sub_4067D:loc_40A6Dr
			; sub_4067D:loc_40A77r
			; sub_4067D+6FDw
			; sub_4067D+74Dw
			; sub_4067D+773w
			; sub_4067D+7A8w
			; sub_4067D:loc_40E56w
			; sub_40EC0:loc_411E5w
			; sub_40EC0+527w
			; sub_40EC0:loc_4162Fw
			; sub_40EC0+99Ew
			; LBX_NewGame_s41A5F:loc_41BA4w
			; LBX_NewGame_s41A5F+48Bw
			; LBX_NewGame_s41A5F+59Dw
			; LBX_NewGame_s41A5F+6AFw
			; LBX_NewGame_s41A5F:loc_4212Cr
			; LBX_NewGame_s41A5F+6D4r
			; LBX_NewGame_s41A5F+720w
			; sub_424BB+212w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3AAE6 dw 0		; DATA XREF: sub_3F7D8+83w
			; idk_BuildingWorlds+46r
word_3AAE8 dw 0		; DATA XREF: sub_4067D+155w
			; sub_40EC0:loc_41198r
			; sub_40EC0+2E9r
word_3AAEA dw 0		; DATA XREF: sub_4067D+14Fw
			; sub_40EC0:loc_41147r
			; sub_40EC0+298r
word_3AAEC dw 0		; DATA XREF: sub_4067D+149w
			; sub_40EC0:loc_410F5r
			; sub_40EC0+246r
word_3AAEE dw 0		; DATA XREF: sub_4067D+143w
			; sub_40EC0:loc_410A3r
			; sub_40EC0+1F4r
word_3AAF0 dw 0		; DATA XREF: sub_4067D+13Dw
			; sub_40EC0:loc_41048r
			; sub_40EC0+199r
word_3AAF2 dw 0		; DATA XREF: sub_3EBA0+C7w
			; sub_3EDD1+80r
			; sub_3EDD1+21Ar
			; sub_3EDD1:loc_3F157r
			; sub_3EDD1:loc_3F290r
			; sub_3EDD1:loc_3F324r
			; sub_3F3C6+83w
			; sub_3F6BF:loc_3F7B7r
			; sub_3F6BF:loc_3F7BEw
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3AB14 dw 0		; DATA XREF: sub_3E1DE+2C1w
			; sub_3E1DE:loc_3E59Br
			; sub_3E60E+307r
word_3AB16 dw 0		; DATA XREF: sub_3E1DE+2E4w
			; sub_3E1DE:loc_3E5B2r
			; sub_3E60E+3E5r
word_3AB18 dw 0		; DATA XREF: sub_3E1DE+29Ew
			; sub_3E1DE:loc_3E584r
			; sub_3E60E:loc_3E837r
word_3AB1A dw 0		; DATA XREF: sub_3E1DE+27Bw
			; sub_3E1DE:loc_3E56Dr
			; sub_3E60E+14Br
word_3AB1C dw 0		; DATA XREF: sub_3F7D8:loc_3F899w
			; sub_4067D+1B0w
			; sub_4067D+3CDr
word_3AB1E dw 0		; DATA XREF: sub_3F7D8+E4w
			; sub_4067D+1E5w
			; sub_4067D+3DDr
word_3AB20 dw 0		; DATA XREF: sub_3F7D8+107w
			; sub_4067D+21Aw
word_3AB22 dw 0		; DATA XREF: sub_3F7D8+12Aw
			; sub_4067D+24Fw
word_3AB24 dw 0		; DATA XREF: sub_3F7D8+14Dw
			; sub_4067D+284w
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3AB38 dw 0		; DATA XREF: sub_3EBA0+CDw
			; sub_3EBA0+1DEr
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3AB58 dw 0		; DATA XREF: sub_3EBA0+C1w
			; sub_3EDD1+48w
			; sub_3EDD1:loc_3F014r
			; sub_3EDD1+24Ar
			; sub_3EDD1:loc_3F27Cr
			; sub_3EDD1:loc_3F29Ar
			; sub_3EDD1+4EFr
			; sub_3EDD1+55Ar
			; sub_3EDD1:loc_3F335r
			; sub_3EDD1+58Cr
			; sub_3EDD1+5A8r
			; sub_3EDD1+5D3r
			; sub_3F3C6+7Dw
			; sub_4067D+108w
idk_LBX_w3AB5A dw 0	; DATA XREF: sub_3E1DE+D3w
			; sub_3E60E+151r
			; sub_3E60E:loc_3E7C6r
			; sub_3FBE0+91w
			; sub_40037+A0r
			; LBX_NewGame_s41A5F:loc_41ABBw
idk_LBX_w3AB5C dw 0	; DATA XREF: sub_3E1DE+EAw
			; sub_3E60E+22Fr
			; sub_3E60E:loc_3E8A4r
			; LBX_NewGame_s41A5F:loc_41AD2w
idk_LBX_w3AB5E dw 0	; DATA XREF: sub_3E1DE+101w
			; sub_3E60E+30Dr
			; sub_3E60E:loc_3E982r
			; LBX_NewGame_s41A5F+8Aw
idk_LBX_w3AB60 dw 0	; DATA XREF: sub_3E1DE+118w
			; sub_3E60E+3EBr
			; sub_3E60E:loc_3EA60r
			; LBX_NewGame_s41A5F+A1w
			; sub_424BB+5Ar
align 10h
unk_3AB70 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
idk_LBX_w3AB78 dw 0	; DATA XREF: sub_3E1DE+8Ew
			; sub_3E60E+11Er
			; sub_3EBA0+78w
			; sub_3EDD1+5Dr
			; sub_3F3C6+62w
			; idk_Load_NEWGAME_LBX+30w
			; sub_3F6BF+3Cr
			; sub_3F7D8:loc_3F81Cw
			; sub_3FA0C:loc_3FA4Ar
			; sub_3FBE0+7Aw
			; sub_40037+8Cr
			; LBX_NewGame_s41A5F:loc_41AA4w
			; sub_424BB+46r
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
idk_LBX_w3AB9E dw 0	; DATA XREF: sub_3DBA6+32w
			; sub_3DF8C+170r
			; sub_3DF8C:loc_3E109r
			; sub_3E1DE+BCw
			; sub_3E1DE+240r
word_3ABA0 dw 0		; DATA XREF: sub_3DBA6+49w
			; sub_3DF8C+1CBr
			; sub_3DF8C:loc_3E164r
word_3ABA2 dw 0		; DATA XREF: sub_3DBA6+1BDw
			; sub_3E1DE+235w
			; sub_3E1DE:loc_3E50Dr
			; sub_4067D+13Aw
			; sub_4067D+39Cr
			; sub_40EC0+4E1r
			; sub_40EC0+521r
			; LBX_NewGame_s41A5F+20Ew
			; LBX_NewGame_s41A5F+367r
			; sub_424BB+1CCr
			; sub_424BB+20Cr
; int word_3ABA4
word_3ABA4 dw 0		; DATA XREF: sub_4067D+10Ew
			; sub_4067D:loc_40DBAr
			; sub_4067D+76Cr
			; sub_4067D+7A1r
			; sub_40EC0:loc_40FF4w
			; sub_40EC0+137r
			; sub_40EC0:loc_41023r
			; sub_40EC0+16Aw
			; sub_40EC0:loc_4103Ar
			; sub_40EC0:loc_41043w
			; sub_40EC0+1A6r
			; sub_40EC0+1AEr
			; sub_40EC0+1B5w
			; sub_40EC0:loc_4107Er
			; sub_40EC0+1C5w
			; sub_40EC0:loc_41095r
			; sub_40EC0:loc_4109Ew
			; sub_40EC0+201r
			; sub_40EC0+209r
			; sub_40EC0+210w
			; sub_40EC0:loc_410D9r
			; sub_40EC0+220w
			; sub_40EC0:loc_410E7r
			; sub_40EC0:loc_410F0w
			; sub_40EC0+253r
			; sub_40EC0+25Br
			; sub_40EC0+262w
			; sub_40EC0:loc_4112Br
			; sub_40EC0+272w
			; sub_40EC0:loc_41139r
			; sub_40EC0:loc_41142w
			; sub_40EC0+2A5r
			; sub_40EC0+2ADr
			; sub_40EC0+2B4w
			; sub_40EC0:loc_4117Cr
			; sub_40EC0+2C3w
			; sub_40EC0:loc_4118Ar
			; sub_40EC0:loc_41193w
			; sub_40EC0+2F6r
			; sub_40EC0:loc_411BEr
			; sub_40EC0+305w
			; sub_40EC0:loc_411CDr
			; sub_40EC0+317r
			; sub_40EC0:loc_411EBr
			; sub_40EC0+332w
			; sub_40EC0:loc_414AFr
			; sub_40EC0+618r
			; sub_40EC0:loc_4154Ar
			; sub_40EC0+7BDr
			; sub_40EC0:loc_417AFr
			; sub_40EC0+9CBr
			; sub_40EC0:loc_4195Dr
			; sub_40EC0+AB8r
			; LBX_NewGame_s41A5F:loc_41B9Ew
			; sub_424BB+220r
			; sub_424BB+23Br
			; sub_4276F+17Fw
			; sub_4276F+217w
			; sub_4276F+3B9w
			; sub_4276F+492w
			; sub_4276F+644w
			; sub_4276F+71Dw
			; sub_4276F+8CFw
word_3ABA6 dw 0		; DATA XREF: sub_3DBA6+D3w
			; sub_3DF8C+EFr
			; sub_4067D+DDw
			; sub_40EC0+71Ar
			; sub_40EC0+968r
			; LBX_NewGame_s41A5F+13Cw
			; sub_4276F+393r
			; sub_4276F+61Er
			; sub_4276F+8A9r
word_3ABA8 dw 0		; DATA XREF: sub_3DBA6+2D8w
			; sub_3DBA6+32Fw
			; sub_3DBA6+367r
			; sub_3DBA6+373r
			; sub_3DF8C+CBr
			; sub_3DF8C+1BBr
			; sub_4067D+161w
			; sub_40EC0+31Dr
			; sub_40EC0:loc_41204w
align 4
word_3ABAC dw 0		; DATA XREF: LBX_NewGame_s41A5F:loc_41C32w
			; LBX_NewGame_s41A5F:loc_41C84r
			; LBX_NewGame_s41A5F+244r
			; LBX_NewGame_s41A5F:loc_41CB9r
			; LBX_NewGame_s41A5F:loc_41CCFr
			; LBX_NewGame_s41A5F:loc_41CE5r
			; LBX_NewGame_s41A5F:loc_41CFBr
			; LBX_NewGame_s41A5F:loc_41D11r
			; sub_421DA+2Cr
			; sub_421DA:loc_42212r
			; sub_421DA:loc_4221Er
			; sub_421DA:loc_4222Ar
			; sub_421DA:loc_42236r
			; sub_421DA:loc_42242r
			; sub_4276F+64r
			; sub_4276F:loc_427E8r
			; sub_4276F:loc_427FDr
			; sub_4276F:loc_42812r
			; sub_4276F:loc_42827r
			; sub_4276F+167r
word_3ABAE dw 0		; DATA XREF: sub_3DBA6+2D5w
			; sub_3DBA6+382r
			; sub_3DF8C+194r
word_3ABB0 dw 0		; DATA XREF: sub_3DBA6+BCw
			; sub_3DF8C+19Ar
			; sub_3DF8C:loc_3E133r
word_3ABB2 dw 0		; DATA XREF: sub_3DBA6+A5w
			; sub_3DF8C:loc_3E031r
word_3ABB4 dw 0		; DATA XREF: sub_3FBE0+1EDw
			; sub_3FBE0+221w
			; sub_3FBE0+2C7r
			; sub_3FBE0+373r
			; sub_43E4F+319r
db    0
db    0
db    0
db    0
word_3ABBA dw 0		; DATA XREF: sub_4067D+114w
			; sub_4067D:loc_40A1Fr
			; sub_40EC0+4D7r
			; sub_40EC0+ABFw
			; sub_40EC0:loc_41987w
			; LBX_NewGame_s41A5F:loc_41C35w
			; LBX_NewGame_s41A5F+36Dr
			; sub_424BB+1C2r
			; sub_424BB+242w
			; sub_424BB:loc_42705w
word_3ABBC dw 0		; DATA XREF: sub_3DBA6+8Ew
			; sub_3DF8C:loc_3E18Er
			; sub_4067D+70w
			; sub_40EC0:loc_413CAr
			; LBX_NewGame_s41A5F+CFw
			; sub_424BB:loc_426B0r
word_3ABBE dw 0		; DATA XREF: sub_3DBA6+77w
			; sub_3DF8C+216r
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AC70 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3ACA0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3ACD4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3ACE0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3ACE8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AD04 db	0
db    0
unk_3AD06 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AD18 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AD36 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AD44 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3AD50 dw 0		; DATA XREF: sub_449D0+4w
			; sub_46029+2DBr
			; sub_46029+2E1w
align 8
unk_3AD58 db	0
db    0
db    0
db    0
word_3AD5C dw 0		; DATA XREF: sub_4D540:loc_4D59Dw
FLAG_w3AD5E dw 0	; DATA XREF: sub_4F44D+Bw
			; sub_4F44D+2D6r
			; sub_4F7B3+3r
word_3AD60 dw 0		; DATA XREF: sub_4F44D+3Bw
			; sub_4F7B3+3Br
word_3AD62 dw 0		; DATA XREF: sub_4F44D+35w
			; sub_4F7B3+3Fr
word_3AD64 dw 0		; DATA XREF: sub_4F44D+2Fw
			; sub_4F7B3+43r
word_3AD66 dw 0		; DATA XREF: sub_4F44D+29w
			; sub_4F7B3+47r
word_3AD68 dw 0		; DATA XREF: sub_4F44D+23w
			; sub_4F7B3+2Br
word_3AD6A dw 0		; DATA XREF: sub_4F44D+1Dw
			; sub_4F7B3+2Fr
word_3AD6C dw 0		; DATA XREF: sub_4F44D+17w
			; sub_4F7B3+33r
word_3AD6E dw 0		; DATA XREF: sub_4F44D+11w
			; sub_4F7B3+37r
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AD76 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
; int word_3AD84
word_3AD84 dw 0		; DATA XREF: sub_4DB4D+1CBw
			; sub_4E031+5C5r
			; sub_4E031+5FFr
word_3AD86 dw 0		; DATA XREF: sub_4DB4D+1C5w
			; sub_4DB4D:loc_4DD2Ar
			; sub_4E031+670r
			; sub_4E031+6C4r
word_3AD88 dw 0		; DATA XREF: sub_4DB4D+1BFw
			; sub_4DB4D:loc_4DDABr
			; sub_4DB4D:loc_4DF05r
			; sub_4E031+12r
			; sub_4E031:loc_4E199r
			; sub_4E031:loc_4E1A4r
			; sub_4E031+1BBr
			; sub_4E031+1FEr
			; sub_4E031:loc_4E33Ar
			; sub_4E031:loc_4E345r
			; sub_4E031+35Cr
			; sub_4E031+3ADr
			; sub_4E031:loc_4E73Er
word_3AD8A dw 0		; DATA XREF: sub_4DB4D+1CEw
			; sub_4DB4D+256r
			; sub_4DB4D+26Fw
			; sub_4DB4D+278w
			; sub_4DB4D:loc_4DF1Er
			; sub_4DB4D:loc_4DF68r
			; sub_4E031:loc_4E69Br
			; sub_4E031+6BEr
word_3AD8C dw 0		; DATA XREF: sub_4DB4D+1D4w
			; sub_4E031+21w
			; sub_4E031:loc_4E0D1r
			; sub_4E031+177r
			; sub_4E031:loc_4E264r
			; sub_4E031+318r
			; sub_4E031:loc_4E669r
align 4
word_3AD90 dw 0		; DATA XREF: sub_4DB4D+441r
			; sub_4DB4D+480r
			; sub_4E031+29r
			; sub_4E031+76r
			; sub_4E031+461r
			; sub_4E031+4D1r
			; sub_4E031+4F1r
			; sub_4E031+517r
			; sub_4E031+546r
			; sub_4E031+58Ar
			; sub_4E751+10Aw
word_3AD92 dw 0		; DATA XREF: sub_4DB4D+2EFr
			; sub_4DB4D+36Er
			; sub_4DB4D+484r
			; sub_4E031+2Dr
			; sub_4E031+7Ar
			; sub_4E031+157r
			; sub_4E031+224r
			; sub_4E031+2F8r
			; sub_4E031+3D3r
			; sub_4E031+4F5r
			; sub_4E031+56Cr
			; sub_4E031+59Cr
			; sub_4E031+5D3r
			; sub_4E031+60Dr
			; sub_4E751+100w
word_3AD94 dw 0		; DATA XREF: sub_4DB4D+2DAr
			; sub_4DB4D+300r
			; sub_4DB4D+359r
			; sub_4DB4D+37Fr
			; sub_4DB4D+3F2r
			; sub_4DB4D+488r
			; sub_4E031+31r
			; sub_4E031+45r
			; sub_4E031+59r
			; sub_4E031+81r
			; sub_4E031+F4r
			; sub_4E031+136r
			; sub_4E031+1CDr
			; sub_4E031+210r
			; sub_4E031+287r
			; sub_4E031+2D7r
			; sub_4E031+36Er
			; sub_4E031+3BFr
			; sub_4E031+3F1r
			; sub_4E031+42Dr
			; sub_4E031+4A3r
			; sub_4E031+4F9r
			; sub_4E031+55Er
			; sub_4E031+5C9r
			; sub_4E031+603r
			; sub_4E031+682r
			; sub_4E031+6D6r
			; sub_4E751+F6w
			; sub_4E751+103r
word_3AD96 dw 0		; DATA XREF: sub_4DB4D+321r
			; sub_4DB4D+3A0r
			; sub_4DB4D+406r
			; sub_4DB4D+463r
			; sub_4DB4D+48Cr
			; sub_4E031+35r
			; sub_4E031+49r
			; sub_4E031+67r
			; sub_4E031+85r
			; sub_4E031+115r
			; sub_4E031+1E1r
			; sub_4E031+2A8r
			; sub_4E031+382r
			; sub_4E031+410r
			; sub_4E031+441r
			; sub_4E031+483r
			; sub_4E031+4B4r
			; sub_4E031+4E2r
			; sub_4E031+4FDr
			; sub_4E031+529r
			; sub_4E031+54Er
			; sub_4E031+5D0r
			; sub_4E031+60Ar
			; sub_4E031+6A6r
			; sub_4E031+6FAr
			; sub_4E751:loc_4E839w
			; sub_4E751+F9r
word_3AD98 dw 0		; DATA XREF: sub_4DB4D+1B9w
			; sub_4DB4D:loc_4DDFBr
			; sub_4DB4D:loc_4DF14r
			; sub_4E031+91r
			; sub_4E031+661r
			; sub_4E751+68r
word_3AD9A dw 0		; DATA XREF: sub_4DB4D:loc_4DDB1r
			; sub_4DB4D+3BEr
			; sub_4DB4D:loc_4DF6Er
			; sub_4E031+Cr
			; sub_4E031+713r
			; sub_4E751+8w
			; sub_4E751:loc_4E761w
			; sub_4E751:loc_4E765r
			; sub_4E751:loc_4E7B3r
word_3AD9C dw 0		; DATA XREF: sub_4D5B0:loc_4D628w
			; sub_4D5B0+105r
word_3AD9E dw 0		; DATA XREF: sub_4D5B0:loc_4D611w
			; sub_4D5B0+DAr
word_3ADA0 dw 0		; DATA XREF: sub_4D5B0:loc_4D5FAw
			; sub_4D7A1+62r
word_3ADA2 dw 0		; DATA XREF: sub_4D5B0:loc_4D5E3w
			; sub_4D7A1+49r
word_3ADA4 dw 0		; DATA XREF: sub_4E9F4+11Cw
			; sub_4EC17+1B6r
			; sub_4EF74+121w
			; sub_4F1AB+173r
word_3ADA6 dw 0		; DATA XREF: sub_4E9F4+122w
			; sub_4EC17+1ACr
			; sub_4EF74+127w
			; sub_4F1AB+16Er
word_3ADA8 dw 0		; DATA XREF: sub_4E9F4+116w
			; sub_4EC17+173r
			; sub_4EF74+11Bw
			; sub_4F1AB+13Ar
word_3ADAA dw 0		; DATA XREF: sub_4E9F4+110w
			; sub_4EC17+17Dr
			; sub_4EF74+115w
			; sub_4F1AB+141r
word_3ADAC dw 0		; DATA XREF: sub_4E9F4+10Aw
			; sub_4EC17+122r
			; sub_4EF74+10Fw
			; sub_4F1AB+F0r
word_3ADAE dw 0		; DATA XREF: sub_4E9F4+100w
			; sub_4EC17:loc_4EDA6r
			; sub_4EC17+19Ar
			; sub_4EF74+105w
			; sub_4F1AB:loc_4F2FCr
			; sub_4F1AB+15Cr
word_3ADB0 dw 0		; DATA XREF: sub_4E9F4+F9w
			; sub_4EC17+156r
			; sub_4EC17+161r
			; sub_4EF74+FEw
			; sub_4F1AB+11Dr
			; sub_4F1AB+128r
word_3ADB2 dw 0		; DATA XREF: sub_4E9F4+103w
			; sub_4E9F4+17Cr
			; sub_4EC17+5r
			; sub_4EC17+B0r
			; sub_4EC17+CAr
			; sub_4EC17+129r
			; sub_4EC17:loc_4ED4Cr
			; sub_4EC17:loc_4EDDFr
			; sub_4EC17:loc_4EE73r
			; sub_4EC17+2CDr
			; sub_4EF74+108w
			; sub_4EF74+192r
			; sub_4F1AB+80r
			; sub_4F1AB+F7r
			; sub_4F1AB:loc_4F2AEr
			; sub_4F1AB:loc_4F32Fr
			; sub_4F1AB+200r
db    0
db    0
word_3ADB6 dw 0		; DATA XREF: idk_ResourceLbx+81w
word_3ADB8 dw 0		; DATA XREF: idk_ResourceLbx+C9w
word_3ADBA dw 0		; DATA XREF: idk_ResourceLbx+111w
word_3ADBC dw 0		; DATA XREF: idk_ResourceLbx+158w
word_3ADBE dw 0		; DATA XREF: idk_ResourceLbx+6Aw
word_3ADC0 dw 0		; DATA XREF: idk_ResourceLbx+B2w
word_3ADC2 dw 0		; DATA XREF: idk_ResourceLbx+FAw
word_3ADC4 dw 0		; DATA XREF: idk_ResourceLbx+141w
word_3ADC6 dw 0		; DATA XREF: idk_ResourceLbx+53w
			; sub_4E9F4+182r
word_3ADC8 dw 0		; DATA XREF: idk_ResourceLbx+9Bw
word_3ADCA dw 0		; DATA XREF: idk_ResourceLbx+E3w
word_3ADCC dw 0		; DATA XREF: idk_ResourceLbx+12Aw
word_3ADCE dw 0		; DATA XREF: sub_4E9F4+AFw
			; sub_4EC17:loc_4EC2Ar
			; sub_4EC17:loc_4EC53r
			; sub_4EC17+307r
			; sub_4EC17:loc_4EF47r
			; sub_4EF74+B4w
			; sub_4F1AB+5r
			; sub_4F1AB+23Fr
word_3ADD0 dw 0		; DATA XREF: sub_4E9F4+B2w
			; sub_4E9F4+125w
			; sub_4EC17+1Ar
			; sub_4EC17+2Er
			; sub_4EC17+38w
			; sub_4EC17+43r
			; sub_4EC17+57r
			; sub_4EC17+61w
			; sub_4EC17+30Er
			; sub_4EC17+322r
			; sub_4EC17+32Cw
			; sub_4EC17+337r
			; sub_4EC17+34Br
			; sub_4EC17+355w
			; sub_4EF74+B7w
			; sub_4EF74+12Aw
			; sub_4F1AB+Cr
			; sub_4F1AB+20r
			; sub_4F1AB+2Aw
			; sub_4F1AB+246r
			; sub_4F1AB+25Ar
			; sub_4F1AB+264w
word_3ADD2 dw 0		; DATA XREF: sub_4D8FA+68w
			; sub_4DA02:loc_4DB31r
word_3ADD4 dw 0		; DATA XREF: sub_4D8FA+51w
			; sub_4DA02:loc_4DA58r
word_3ADD6 dw 0		; DATA XREF: sub_3FBE0+BFw
			; sub_4067D+C6w
			; LBX_NewGame_s41A5F:loc_41B84w
			; sub_4D8FA+3Aw
			; sub_4DA02+129r
word_3ADD8 dw 0		; DATA XREF: sub_3FBE0+A8w
			; sub_4067D+AFw
			; LBX_NewGame_s41A5F+10Ew
			; sub_4D8FA+23w
			; sub_4DA02+50r
word_3ADDA dw 0		; DATA XREF: sub_4DB4D+144w
			; sub_4E031+453r
			; sub_4E031+46Br
word_3ADDC dw 0		; DATA XREF: sub_4DB4D+12Dw
			; sub_4E031+41Fr
word_3ADDE dw 0		; DATA XREF: sub_4DB4D+116w
			; sub_4E031+4C3r
word_3ADE0 dw 0		; DATA XREF: sub_4DB4D+FFw
			; sub_4E031+3F8r
			; sub_4E031+495r
word_3ADE2 dw 0		; DATA XREF: sub_4DB4D+E8w
			; sub_4DB4D+42Fr
			; sub_4DB4D+44Br
word_3ADE4 dw 0		; DATA XREF: sub_4DB4D+D1w
			; sub_4DB4D:loc_4DF2Dr
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3ADF8 dw 0		; DATA XREF: sub_4E031+1A2r
			; sub_4E031+1F0r
			; sub_4E031+343r
			; sub_4E031+39Fr
word_3ADFA dw 0		; DATA XREF: sub_4DB4D+2C0r
			; sub_4DB4D+307r
			; sub_4DB4D+33Fr
			; sub_4DB4D+386r
			; sub_4E031+FBr
			; sub_4E031+13Dr
			; sub_4E031:loc_4E1E2r
			; sub_4E031+1F4r
			; sub_4E031+28Er
			; sub_4E031+2DEr
			; sub_4E031+352r
			; sub_4E031+3A3r
			; sub_4E031+689r
			; sub_4E031+6DDr
			; sub_4E751+B1r
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3AE0C dw 0		; DATA XREF: sub_4E031+181r
			; sub_4E031+194r
			; sub_4E031+1ADr
			; sub_4E031+322r
			; sub_4E031+335r
			; sub_4E031+34Er
word_3AE0E dw 0		; DATA XREF: sub_4DB4D+BAw
			; sub_4DB4D+328r
			; sub_4E031+2AFr
			; sub_4E031+389r
			; sub_4E031+3E3r
			; sub_4E031+6ADr
			; sub_4E751+6Fr
word_3AE10 dw 0		; DATA XREF: sub_4DB4D+A3w
			; sub_4E031:loc_4E5ADr
			; sub_4E031+580r
			; sub_4E031+592r
word_3AE12 dw 0		; DATA XREF: sub_4DB4D+8Cw
			; sub_4DB4D+2E5r
			; sub_4DB4D:loc_4DEB1r
			; sub_4E031+14Dr
			; sub_4E031+21Ar
			; sub_4E031+2EEr
			; sub_4E031+3C9r
			; sub_4E031+55Ar
			; sub_4E031+562r
			; sub_4E751+A1r
word_3AE14 dw 0		; DATA XREF: sub_4DB4D+75w
			; sub_4DB4D+437r
			; sub_4E031+457r
			; sub_4E031+4C7r
			; sub_4E031+509r
			; sub_4E031:loc_4E53Er
			; sub_4E751+CDr
word_3AE16 dw 0		; DATA XREF: sub_4DB4D+5Ew
			; sub_4DB4D+2D0r
			; sub_4DB4D+2F6r
			; sub_4DB4D+34Fr
			; sub_4DB4D+375r
			; sub_4DB4D+3E8r
			; sub_4E031+55r
			; sub_4E031+EAr
			; sub_4E031+12Cr
			; sub_4E031+1C3r
			; sub_4E031+206r
			; sub_4E031+27Dr
			; sub_4E031+2CDr
			; sub_4E031+364r
			; sub_4E031+3B5r
			; sub_4E031+3E7r
			; sub_4E031+423r
			; sub_4E031+499r
			; sub_4E031+678r
			; sub_4E031+6CCr
			; sub_4E751+BFr
word_3AE18 dw 0		; DATA XREF: sub_4DB4D+47w
			; sub_4E031+538r
			; sub_4E031:loc_4E56Dr
word_3AE1A dw 0		; DATA XREF: sub_4DB4D+30w
			; sub_4DB4D+317r
			; sub_4DB4D+396r
			; sub_4DB4D+3FCr
			; sub_4DB4D+459r
			; sub_4E031+41r
			; sub_4E031+5Dr
			; sub_4E031+10Br
			; sub_4E031+1D7r
			; sub_4E031+29Er
			; sub_4E031+378r
			; sub_4E031+406r
			; sub_4E031+437r
			; sub_4E031+479r
			; sub_4E031+4AAr
			; sub_4E031+4D8r
			; sub_4E031+51Fr
			; sub_4E031+69Cr
			; sub_4E031+6F0r
			; sub_4E751+92r
word_3AE1C dw 0		; DATA XREF: sub_4E9F4+16w
			; sub_4E9F4+1Cr
			; sub_4E9F4+2Cw
			; sub_4E9F4:loc_4EA26r
			; sub_4E9F4+42w
			; sub_4E9F4:loc_4EA3Cr
			; sub_4E9F4+58w
			; sub_4E9F4:loc_4EA52r
			; sub_4E9F4+6Ew
			; sub_4E9F4:loc_4EA68r
			; sub_4E9F4:loc_4EA78w
			; sub_4E9F4:loc_4EA80w
			; sub_4E9F4:loc_4EA88w
			; sub_4E9F4:loc_4EA90w
			; sub_4E9F4:loc_4EA98w
			; sub_4EC17+D1r
			; sub_4EF74+1Bw
			; sub_4EF74+21r
			; sub_4EF74+31w
			; sub_4EF74:loc_4EFABr
			; sub_4EF74+47w
			; sub_4EF74:loc_4EFC1r
			; sub_4EF74+5Dw
			; sub_4EF74:loc_4EFD7r
			; sub_4EF74+73w
			; sub_4EF74:loc_4EFEDr
			; sub_4EF74:loc_4EFFDw
			; sub_4EF74:loc_4F005w
			; sub_4EF74:loc_4F00Dw
			; sub_4EF74:loc_4F015w
			; sub_4EF74:loc_4F01Dw
			; sub_4EF74+153r
			; sub_4EF74+160r
			; sub_4F1AB+56r
			; sub_4F1AB+9Ar
			; sub_4F1AB+A4r
			; sub_4F1AB+B2r
			; sub_4F1AB+1C1r
			; sub_4F1AB+1EAr
			; sub_4F1AB+229r
word_3AE1E dw 0		; DATA XREF: sub_4D5B0+83w
			; sub_4D7A1+18r
			; sub_4D7A1:loc_4D842r
			; sub_4D7A1+C2r
			; sub_4D7A1:loc_4D8B1r
			; sub_4D8FA+88w
			; sub_4DA02:loc_4DA1Ar
			; sub_4DA02+A2r
			; sub_4DA02+C4r
			; sub_4DA02+104r
			; sub_4E9F4+F6w
			; sub_4EC17+7Br
			; sub_4EC17+1F8r
			; sub_4EC17+21Br
			; sub_4EC17+28Ar
			; sub_4EC17+2ADr
			; sub_4EC17+2E7r
			; sub_4EF74+FBw
			; sub_4F1AB+44r
			; sub_4F1AB+1B2r
			; sub_4F1AB+1DBr
			; sub_4F1AB+21Ar
word_3AE20 dw 0		; DATA XREF: sub_4D5B0+CAw
			; sub_4D5B0:loc_4D692r
			; sub_4D5B0+10Dr
			; sub_4D5B0+130r
			; sub_4D5B0:loc_4D6EEr
			; sub_4D7A1:loc_4D7CFr
			; sub_4D7A1+4Dr
			; sub_4D7A1+66r
			; sub_4D7A1:loc_4D84Ar
			; sub_4D7A1+CAr
			; sub_4D7A1:loc_4D8B9r
			; sub_4D8FA+C9w
			; sub_4DA02+2Er
			; sub_4DA02:loc_4DA5Cr
			; sub_4DA02+AAr
			; sub_4DA02+CCr
			; sub_4DA02+10Cr
			; sub_4DA02:loc_4DB35r
			; sub_4E9F4+165w
			; sub_4EC17+BAr
			; sub_4EC17+DBr
			; sub_4EC17+F9r
			; sub_4EC17+10Br
			; sub_4EC17:loc_4ED56r
			; sub_4EC17+170r
			; sub_4EC17+1A9r
			; sub_4EC17+200r
			; sub_4EC17+223r
			; sub_4EC17+292r
			; sub_4EC17+2B5r
			; sub_4EC17+2EFr
			; sub_4EF74+17Bw
			; sub_4F1AB+8Ar
			; sub_4F1AB+AAr
			; sub_4F1AB+D1r
			; sub_4F1AB+DEr
			; sub_4F1AB:loc_4F2B8r
			; sub_4F1AB+137r
			; sub_4F1AB+16Br
			; sub_4F1AB+1BAr
			; sub_4F1AB+1E3r
			; sub_4F1AB+222r
word_3AE22 dw 0		; DATA XREF: sub_4D5B0:loc_4D668w
			; sub_4D5B0:loc_4D69Br
			; sub_4D5B0:loc_4D6C6r
			; sub_4D5B0+137r
			; sub_4D5B0+142r
			; sub_4D7A1+51r
			; sub_4D7A1+6Fr
			; sub_4D7A1+B0r
			; sub_4D7A1+D1r
			; sub_4D7A1+11Fr
			; sub_4D8FA+B8w
			; sub_4DA02+5Er
			; sub_4DA02+B1r
			; sub_4DA02+D3r
			; sub_4DA02+113r
			; sub_4DA02+13Cr
			; sub_4E9F4+15Ew
			; sub_4EC17+98r
			; sub_4EC17+BEr
			; sub_4EC17+E2r
			; sub_4EC17+100r
			; sub_4EC17+10Fr
			; sub_4EC17+143r
			; sub_4EC17+178r
			; sub_4EC17+1B1r
			; sub_4EC17+207r
			; sub_4EC17+22Ar
			; sub_4EC17+299r
			; sub_4EC17+2BCr
			; sub_4EC17+2F6r
			; sub_4EF74+16Dw
			; sub_4EF74:loc_4F0E6w
			; sub_4F1AB+5Er
			; sub_4F1AB+8Er
			; sub_4F1AB+B8r
			; sub_4F1AB+1C7r
			; sub_4F1AB+1F0r
			; sub_4F1AB+22Fr
word_3AE24 dw 0		; DATA XREF: sub_4D8D2+3w
			; sub_4D8E6+3w
			; sub_4DA02+49r
			; sub_4DA02+6Fr
			; sub_4DA02+122r
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AE38 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AE56 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AEF0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AF20 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AF54 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AF68 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AF84 db	0
db    0
unk_3AF86 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AF98 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AFB0 db	0
db    0
db    0
db    0
db    0
db    0
unk_3AFB6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AFD2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3AFF0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B014 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B020 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B028 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B046 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B054 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B068 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B084 db	0
db    0
unk_3B086 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B098 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B0A0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B0B6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B0D0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B104 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B110 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B118 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B134 db	0
db    0
unk_3B136 db	0
db    0
db    0
db    0
db    0
db    0
unk_3B13C db	0
db    0
db    0
db    0
unk_3B140 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B148 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B162 db	0
db    0
db    0
db    0
unk_3B166 db	0
db    0
db    0
db    0
db    0
db    0
unk_3B16C db	0
db    0
db    0
db    0
unk_3B170 db	0
db    0
db    0
db    0
unk_3B174 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B188 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_3B194 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+2Fw
word_3B196 dw 0		; DATA XREF: idk_EmsPgNm_TileFigureCont_s553B0+18w
db    0
db    0
; int word_3B19A
word_3B19A dw 0		; DATA XREF: idk_OVR_LoadLbxHelp:loc_55D5Bw
			; idk_OVR_LoadLbxHelp:loc_55D81r
			; idk_OVR_LoadLbxHelp:loc_55D95r
			; idk_OVR_LoadLbxHelp:loc_55DABr
			; idk_OVR_LoadLbxHelp:loc_55DBCr
			; idk_OVR_LoadLbxHelp+123r
			; idk_OVR_LoadLbxHelp+25Cr
			; idk_OVR_LoadLbxHelp+270r
			; idk_OVR_LoadLbxHelp:loc_55F24r
			; idk_OVR_LoadLbxHelp:loc_55F40r
			; idk_OVR_LoadLbxHelp+368r
			; idk_OVR_LoadLbxHelp+37Cr
			; idk_OVR_LoadLbxHelp+3A8r
			; idk_OVR_LoadLbxHelp+3AFr
			; idk_OVR_LoadLbxHelp+45Ar
			; idk_OVR_LoadLbxHelp+48Br
			; idk_OVR_LoadLbxHelp+4A6r
			; idk_OVR_LoadLbxHelp:loc_56155r
word_3B19C dw 0		; DATA XREF: sub_56240:loc_562ACr
			; sub_56240:loc_56339r
			; sub_56240:loc_5637Er
			; sub_56240:loc_56398r
			; sub_56240:loc_563F4r
			; sub_56413+1Ew
			; sub_56413+21r
idl_OVL_w3B19E dw 0	; DATA XREF: sub_14787:loc_1478Dw
			; sub_14792+3r
			; sub_1479D:loc_147A6w
			; EMM_CheckAllocation+29w
; char idk_EmmRsrvExcdErrMsg
idk_EmmRsrvExcdErrMsg dw 0
			; DATA XREF: EMM_CheckAllocation+2Co
			; sub_147E5:loc_14814o
			; EXIT_AllocationError+7o
			; EXIT_AllocationError+29o
			; EXIT_AllocationError:loc_1485Fo
			; EMM_Allocate+112o
			; EMM_Allocate+121o
			; EMM_Allocate+130o
			; EMM_Allocate+13Co
			; EMM_Allocate+14Bo
			; EMM_Allocate+156o
			; EMM_Allocate+1C3o
			; EMM_Allocate+1D2o
			; EMM_Allocate+1E1o
			; EMM_Allocate+1F0o
			; EMM_Allocate+1FFo
			; EMM_Allocate+20Eo
			; EMM_Allocate+21Do
			; EMM_Allocate+228o
align 4
unk_3B1A4 db	0
db    0
unk_3B1A6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B1B8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B1D4 db	0
db    0
unk_3B1D6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B1E8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
; char idk_ItoAbuf_w3B204
idk_ItoAbuf_w3B204 dw 0	; DATA XREF: EXIT_AllocationError:loc_14837o
			; EXIT_AllocationError:loc_14846o
			; EMM_Allocate+184o
			; EMM_Allocate:loc_17943o
unk_3B206 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
; char idk_EmsErrStr_w3B218
idk_EmsErrStr_w3B218 dw	0
			; DATA XREF: EMM_Allocate+1A2o
			; EMM_Allocate+1FBo
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
; char idk_EmsErrStr_w3B236
idk_EmsErrStr_w3B236 dw	0
			; DATA XREF: EMM_Allocate+1B3o
			; EMM_Allocate+219o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B350 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B3C6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B3E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B438 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B450 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B46E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B4C0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B500 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B50E db	0
db    0
db    0
db    0
db    0
db    0
unk_3B514 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B51E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B54F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B561 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B5BA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B7E0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B810 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B850 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3B930 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BA60 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BA8C db	0
db    0
db    0
db    0
unk_3BA90 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BAB2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BABC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BB20 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BB60 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BB90 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BC10 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BC40 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BC50 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BC80 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BCA0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BCB0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BCE0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BD10 db	0
db    0
db    0
db    0
db    0
db    0
unk_3BD16 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BD30 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BD88 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BDAC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BDBE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BDD2 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BDDC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BE02 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BE0C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BE1C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BE42 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BE4C db	0
db    0
db    0
db    0
unk_3BE50 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BE5E db	0
db    0
db    0
db    0
db    0
db    0
unk_3BE64 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BE6E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BEB1 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BEFC db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BF0A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BF22 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BF2C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BFC0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3BFF0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C02C db	0
db    0
db    0
db    0
unk_3C030 db	0
db    0
db    0
db    0
db    0
db    0
unk_3C036 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C050 db	0
db    0
unk_3C052 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C05C db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C066 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
; void far *g_FarHeapAllocOffset
g_FarHeapAllocOffset dw	0
			; DATA XREF: ST_AllocateSpace+28w
			; ST_AllocateSpace+2Br
			; ST_FarMalloc+25w
			; ST_FarMalloc+28r
			; malloc_s14954+25w
			; malloc_s14954+28r
			; CALL_farfree+Aw
			; CALL_farfree+14r
g_FarHeapAllocSegment dw 0
			; DATA XREF: ST_AllocateSpace+24w
			; ST_AllocateSpace+2Er
			; ST_AllocateSpace:NOT_NULLr
			; ST_FarMalloc+21w
			; ST_FarMalloc+2Br
			; ST_FarMalloc:loc_1493Fr
			; malloc_s14954+21w
			; malloc_s14954+2Br
			; malloc_s14954:loc_14989r
			; CALL_farfree+7w
			; CALL_farfree+10r
; int g_RequiredMEM_583B
g_RequiredMEM_583B dw 0	; DATA XREF: MemBlocksErrorExit+2Cr
			; LBX_Load_ErrorHandler+9Br
			; ST_SetRequiredMEM+6w
g_CurrentLbxEntryCount dw 0
			; DATA XREF: LBX_Load_Entry+1C6w
			; LBX_Load_Entry:CheckEntryCountr
			; LBX_Load_s15453+1BEw
			; LBX_Load_s15453:TEST_ENTRY_COUNTr
			; LBX_Load_HelpNewTerrCity+1A3w
			; LBX_Load_HelpNewTerrCity:loc_15AC1r
			; LBX_Load_Entry_4bytes+1A7w
			; LBX_Load_Entry_4bytes:CHECK_ENTRYCOUNTr
g_CurrentLbxFilePosition dw 0
			; DATA XREF: LBX_Load_Entry:idk_AlreadyReadHeaderr
			; LBX_Load_Entry+9Ew
			; LBX_Load_Entry:SUCCESS_FILE_OPENr
			; LBX_Load_s15453+83r
			; LBX_Load_s15453+91w
			; LBX_Load_HelpNewTerrCity+80r
			; LBX_Load_HelpNewTerrCity+8Ew
			; LBX_Load_Entry_4bytes:REQUESTED_LBX_IS_GLOBAL_LBXr
			; LBX_Load_Entry_4bytes+7Fw
			; LBX_Load_Entry_4bytes:SUCCESS_OPEN_FILEr
; char *g_ptrBufferReadFile
g_ptrBufferReadFile dw 0
			; DATA XREF: LBX_Load_Entry+37w
			; LBX_Load_Entry+18Ar
			; LBX_Load_Entry+19Ar
			; LBX_Load_Entry+1BBr
			; LBX_Load_Entry+1ECr
			; LBX_Load_Entry+204r
			; LBX_Load_s15453+38w
			; LBX_Load_s15453+182r
			; LBX_Load_s15453+192r
			; LBX_Load_s15453+1B3r
			; LBX_Load_s15453+1E4r
			; LBX_Load_s15453+1FCr
			; LBX_Load_HelpNewTerrCity+38w
			; LBX_Load_HelpNewTerrCity+167r
			; LBX_Load_HelpNewTerrCity+177r
			; LBX_Load_HelpNewTerrCity+198r
			; LBX_Load_HelpNewTerrCity+1C9r
			; LBX_Load_HelpNewTerrCity+1E1r
			; LBX_Load_Entry_4bytes+37w
			; LBX_Load_Entry_4bytes+16Br
			; LBX_Load_Entry_4bytes+17Br
			; LBX_Load_Entry_4bytes+19Cr
			; LBX_Load_Entry_4bytes+1CDr
			; LBX_Load_Entry_4bytes+1E7r
; char g_CurrentLbxFileNameBase[]
g_CurrentLbxFileNameBase dw 0
			; DATA XREF: LBX_Load_Entry:idk_CurrentFileOpeno
			; LBX_Load_Entry+B3o
			; LBX_Load_Entry+242o
			; LBX_Load_s15453+73o
			; LBX_Load_s15453+A6o
			; LBX_Load_s15453+23Ao
			; LBX_Load_s15453+281o
			; LBX_Load_s15453:loc_156F0o
			; LBX_Load_s15453+2DFo
			; LBX_Load_HelpNewTerrCity+70o
			; LBX_Load_HelpNewTerrCity+21Fo
			; LBX_Load_HelpNewTerrCity+266o
			; LBX_Load_HelpNewTerrCity+282o
			; LBX_Load_HelpNewTerrCity+2C7o
			; LBX_Load_Entry_4bytes+61o
			; LBX_Load_Entry_4bytes+94o
unk_3C2DE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C2E6 db	0
db    0
db    0
db    0
db    0
db    0
SvGm_NbrBytWrt dw 0	; DATA XREF: DOS_ReadFromFile_0:loc_160FDw
			; DOS_ReadFromFile_0+1Cr
			; OVR_DOS_WriteToFileWithHandle+9w
			; OVR_DOS_WriteToFileWithHandle+1Cr
ptrDosFileHandle dw 0	; DATA XREF: DOS_OpenFileModeCheck+2Fw
			; DOS_OpenFileModeCheck+5Fw
			; DOS_OpenFileModeCheck+6Cw
			; DOS_OpenFileModeCheck:loc_160ECr
			; DOS_ReadFromFile_0:loc_1610Cr
			; OVR_DOS_WriteToFileWithHandle+18r
			; DOS_MoveFilePointer+8r
			; DOS_CloseFileHandle:loc_1616Dr
word_3C2F0 dw 0		; DATA XREF: sub_17BA2+6w
			; sub_17BAD+3r
word_3C2F2 dw 0		; DATA XREF: Chk_RelMemHandle:loc_17628r
			; Chk_RelMemHandle:loc_1762Fr
word_3C2F4 dw 0		; DATA XREF: idk_Setup_EMM+18Ew
			; sub_17A50+Bw
			; sub_17A50+14r
			; sub_17A50+26r
			; sub_17A50+9Bw
			; sub_17AFA+12r
			; sub_17AFA:loc_17B1Er
			; sub_17AFA+99w
			; sub_17BA2+3r
			; sub_17BAD+6w
EmsHndl_w3C2F6 dw 0	; DATA XREF: idk_Setup_EMM+18Bw
			; CALL_DOS_MapMemory+6r
db    0
db    0
; int idk_AddrEmsHandle
idk_AddrEmsHandle dw 0	; DATA XREF: idk_Setup_EMM+174w
			; sub_179A3+3r
			; sub_179C5+3r
			; sub_179E7+Br
			; sub_17A12:loc_17A1Dr
			; sub_1D40D:loc_1D445r
			; sub_1D40D:loc_1D45Fr
			; sub_1D40D+7Cr
			; sub_1D40D+96r
			; LBX_Intro_MemAndReadAndMem+2Fr
			; LBX_Intro_MemAndReadAndMem+4Cr
			; LBX_Load_IntroLbx_s21977:loc_219EAr
			; LBX_Load_IntroLbx_s21977+96r
			; LBX_Load_IntroLbx_s21977+F7r
			; LBX_Load_IntroLbx_s21977+145r
			; LBX_MemAndRead+8r
			; LBX_MemAndRead+114r
			; LBX_MemAndRead+153r
			; sub_4F44D+B3r
			; sub_56220+3r
idk_LBX_w3C2FC dw 0	; DATA XREF: LBX_EmsMapMem:GOT_varMemCntOrHandler
			; Emm_PgCnt_s175B1+3Fw
			; sub_17671:loc_176D7r
; int idk_EMM_w3C2FE
idk_EMM_w3C2FE dw 0	; DATA XREF: idk_Setup_EMM+1Bw
			; idk_Setup_EMM:loc_16480w
			; idk_Setup_EMM+53r
			; idk_Setup_EMM:loc_16497r
			; idk_Setup_EMM+7Aw
			; idk_Setup_EMM+ADr
			; idk_Setup_EMM:TEST_HANDLEr
			; idk_Setup_EMM:loc_16515r
word_3C300 dw 0		; DATA XREF: idk_Setup_EMM:loc_1650Fw
			; LBX_LoadFileMemory:loc_1668Br
			; LBX_AllocMem:loc_168E0r
			; LBX_s16A80:loc_16B0Er
			; sub_1775C:loc_1775Fr
Emm_PgCnt_w3C302 dw 0	; DATA XREF: idk_Setup_EMM+8Bo
			; idk_Setup_EMM+117o
			; LBX_AllocMem+5Ao
			; Emm_PgCnt_s175B1+15o
			; sub_17671+95o
			; EMM_Allocate+29o
			; EMM_Allocate+5Do
			; EMM_Allocate:loc_177DEr
			; EMM_Allocate+8Aw
			; EMM_Allocate:loc_177FCo
			; EMM_Allocate+B6o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
idk_LBX_b3C30B db 0	; DATA XREF: idk_Setup_EMM+A0w
			; idk_Setup_EMM:loc_1653Dw
			; Emm_PgCnt_s175B1+3Ar
			; sub_17671+D4w
			; EMM_Allocate+CEw
idk_LBX_w3C30C dw 0	; DATA XREF: idk_Setup_EMM+B3w
			; idk_Setup_EMM+12Cw
			; Emm_PgCnt_s175B1+2Dr
			; sub_17671+B8w
			; EMM_Allocate:loc_17842w
			; EMM_Allocate+16Dr
			; EMM_Allocate+192r
idk_LBX_w3C30E db    0	; DATA XREF: sub_17671+8Ao
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
idk_LBX_b3C317 db 0	; DATA XREF: sub_17671+C5r
idk_LBX_w3C318 dw 0	; DATA XREF: sub_17671+A9r
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C321 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C328 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C340 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C358 db	0
db    0
db    0
db    0
db    0
db    0
unk_3C35E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C370 db	0
db    0
db    0
db    0
db    0
db    0
unk_3C376 db	0
db    0
db    0
db    0
unk_3C37A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C38E db	0
db    0
unk_3C390 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C3B6 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C3D0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C3E6 db	0
db    0
unk_3C3E8 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C3F0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C3FE db	0
db    0
unk_3C400 db	0
db    0
db    0
db    0
unk_3C404 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C40E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C41E db	0
db    0
unk_3C420 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C428 db	0
db    0
db    0
db    0
db    0
db    0
unk_3C42E db	0
db    0
db    0
db    0
db    0
db    0
unk_3C434 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C43E db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C451 db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C458 db	0
db    0
db    0
db    0
db    0
db    0
unk_3C45E db	0
db    0
unk_3C460 db	0
db    0
db    0
db    0
db    0
db    0
unk_3C466 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C46F db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C480 db	0
unk_3C481 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C48E db	0
db    0
unk_3C490 db	0
db    0
db    0
db    0
db    0
db    0
unk_3C496 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C4AA db	0
db    0
db    0
db    0
db    0
db    0
unk_3C4B0 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C4BE db	0
db    0
unk_3C4C0 db	0
db    0
db    0
db    0
unk_3C4C4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C4CE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C4D6 db	0
db    0
unk_3C4D8 db	0
db    0
unk_3C4DA db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
; int nRequiredEMS_2700
nRequiredEMS_2700 dw 0	; DATA XREF: setRequiredEMS+6w
			; fncBldMsgInsuffEMS+12r
; char *idk_FontsLbx1_32B
idk_FontsLbx1_32B dw 0	; DATA XREF: LBX_Load_FontsStyleData+78w
			; LBX_Intro_MemAndReadAndMem+3Dr
			; LBX_Intro_MemAndReadAndMem+54r
			; LBX_Intro_MemAndReadAndMem+67r
			; LBX_Load_IntroLbx_s21977+Cr
			; LBX_Load_IntroLbx_s21977+22r
			; LBX_Load_IntroLbx_s21977+35r
			; LBX_Load_IntroLbx_s21977+48r
			; LBX_Load_IntroLbx_s21977+58r
			; LBX_Load_IntroLbx_s21977+68r
			; LBX_Load_IntroLbx_s21977+133r
			; sub_21C58+7r
			; sub_21C58+20r
idk_FontsLbx1_1024_@48 dw 0
			; DATA XREF: LBX_Load_FontsStyleData+51w
			; LBX_Load_FontsStyleData+B1r
			; idk_Set_FontsLbx1_256arr_to_1+Er
			; idk_Set_FontsLbx1_256arr_to_0+Dr
ptrFontsLbx2_@336 dw 0	; DATA XREF: ILSe_prepare_palette+43w
			; sub_1BF79+30r
			; sub_1BF79+42r
			; sub_1BF79+52r
			; sub_1BF79+5Fr
			; sub_1BFF7+52r
			; sub_1BFF7+64r
			; sub_1BFF7+74r
			; sub_1BFF7+81r
idk_FontsLbx1_6144B dw 0
			; DATA XREF: LBX_Load_FontsStyleData+6Bw
			; sub_18BA2:loc_18C67r
			; idk_PAL_s1C8D5+77r
			; idk_PAL_s1C8D5+17Dr
			; idk_PAL_s1C8D5+1A1r
			; idk_VidLib_s1E2D0+EEr
			; idk_VidLib_s1E2D0:loc_1E436r
			; idk_VidLib_s1E2D0:loc_1E490r
			; sub_1E8AC+E9r
			; sub_1E8AC+165r
			; sub_1E8AC+1BFr
			; sub_1EC88+EEr
			; sub_1EC88+166r
			; sub_1EC88:loc_1EE48r
			; sub_223C9:loc_2255Ar
			; sub_223C9+2A3r
			; sub_223C9:loc_22697r
			; sub_229E6:loc_22B7Er
			; sub_229E6:loc_22C90r
			; sub_229E6:loc_22CBBr
			; sub_22FE1+7Er
			; sub_23CF1+145r
; int idk_FontsLbx1_768B
idk_FontsLbx1_768B dw 0	; DATA XREF: LBX_Load_FontsStyleData+5Ew
			; idk_PAL_s1C111+Er
			; sub_1C130+7r
; int idk_FontsLbx1_1024B
idk_FontsLbx1_1024B dw 0
			; DATA XREF: LBX_Load_FontsStyleData+48w
			; LBX_Load_FontsStyleData+4Br
			; LBX_Load_FontsStyleData+95r
			; idk_VidPalFnt_s18D9F+13r
			; ILSe_prepare_palette+83r
			; sub_1C0DC+25r
			; idk_PAL_s1C111+7r
			; sub_1C130+Er
			; sub_1C15C:loc_1C17Dr
			; sub_1C40F+64r
			; sub_1C40F+78r
			; sub_1C40F+8Er
			; idk_SetPalette_s1C4F4+4r
			; idk_VGA_PAL_s1C554+1Er
			; idk_VGA_PAL_s1C554:loc_1C5DCr
			; idk_VGA_PAL_s1C638+6Er
			; idk_VGA_PAL_s1C638:loc_1C70Br
			; idk_VGA_PAL_s1C76E:loc_1C7B7r
			; idk_VGA_PAL_s1C840+2Fr
			; idk_PAL_s1C8D5+7Er
			; idk_PAL_s1C8D5+1A8r
			; idk_Font_s1CB05:loc_1CB12r
			; sub_23160+3Fr
			; sub_23527:loc_2353Ar
			; sub_235A9+13r
			; sub_2362F+13r
; char g_FontsFileName[]
g_FontsFileName	dw 0	; DATA XREF: LBX_Load_FontsStyleData+9o
			; ILSe_prepare_palette+13o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C4FE db	0
db    0
idk_FontsLbx1_e_96 dw 0	; DATA XREF: LBX_Load_FontsStyleData+85w
			; idk_VidPalFnt_s18D9F+Er
			; idk_VidPalFnt_s18D9F+F6r
			; sub_23527+Er
			; sub_23527+48r
			; sub_235A9:loc_235B7r
			; sub_235A9+4Cr
			; sub_2362F+Er
			; sub_2362F:loc_2367Br
ptrFontsLbx2 dw	0	; DATA XREF: ILSe_prepare_palette+1Fw
			; ILSe_prepare_palette+22r
			; ILSe_prepare_palette+80r
; int idk_FontsLbx1_5568
idk_FontsLbx1_5568 dw 0	; DATA XREF: LBX_Load_FontsStyleData+3Bw
			; ILSe_prepare_palette+8r
unk_3C506 db	0
db    0
unk_3C508 db	0
db    0
db    0
db    0
db    0
db    0
unk_3C50E db	0
db    0
db    0
unk_3C511 db	0
db    0
db    0
db    0
db    0
byte_3C516 db 0		; DATA XREF: sub_19454+32w
			; sub_194C2+27r
byte_3C517 db 0		; DATA XREF: sub_19454+44w
			; sub_194C2+3Br
byte_3C518 db 0		; DATA XREF: sub_19454+56w
			; sub_194C2+50r
byte_3C519 db 0		; DATA XREF: sub_19454+68w
			; sub_194C2:loc_19527r
word_3C51A dw 0		; DATA XREF: sub_1A510:loc_1A516r
			; idk_PalFnt_s1AB64+60w
word_3C51C dw 0		; DATA XREF: sub_1A4FB+6r
			; idk_PalFnt_s1AB64+5Aw
idk_w3C51E dw 0		; DATA XREF: sub_19DD1+2Br
			; sub_19F94:loc_19FEEr
			; sub_1A4E6+6r
			; idk_PalFnt_s1AB64+54w
idk_w3C520 dw 0		; DATA XREF: sub_19DD1+25r
			; sub_19F94+54r
			; sub_1A4D1+6r
			; idk_PalFnt_s1AB64+4Ew
word_3C522 dw 0		; DATA XREF: ILSe_display_text+1Cw
			; ILSe_display_text+10Ew
			; ILSe_display_text+141r
			; ILSe_display_text+153r
			; sub_1A296:loc_1A2B0w
			; sub_1A296+C1r
			; sub_1A7FF:loc_1A81Bw
			; sub_1A7FF+109w
			; sub_1A7FF+138r
word_3C524 dw 0		; DATA XREF: ILSe_display_text:loc_19B5Fw
			; ILSe_display_text+115w
			; ILSe_display_text+129w
			; ILSe_display_text:loc_19C7Br
			; ILSe_display_text+145r
			; ILSe_display_text+157r
			; ILSe_display_text+163w
			; ILSe_display_text+173w
			; ILSe_display_text:loc_19CC8w
			; sub_1A296+13w
			; sub_1A296+C5r
			; sub_1A296+D1w
			; sub_1A296:loc_1A37Fr
			; sub_1A7FF:loc_1A815w
			; sub_1A7FF+110w
			; sub_1A7FF:loc_1A923w
			; sub_1A7FF:loc_1A92Cr
			; sub_1A7FF+13Cr
			; sub_1A7FF+148w
			; sub_1A7FF+158w
			; sub_1A7FF+164w
; char *bufFontsLbxEntry0
bufFontsLbxEntry0 dw 0	; DATA XREF: LBX_Load_FontsStyleData+1Fw
			; sub_1922A+1Fr
			; sub_19257:loc_19276r
			; sub_19284:loc_192A3r
			; sub_192B1:loc_192D0r
			; sub_192DE:loc_192FDr
			; sub_19316:loc_1931Dr
			; sub_19316+1Ar
			; sub_1933E:loc_19348r
			; sub_19356:loc_19360r
			; sub_1936E:loc_19384r
			; sub_193DD:loc_1940Fr
			; sub_193DD:loc_19420r
			; sub_193DD+54r
			; sub_193DD+65r
			; sub_19454+27r
			; sub_19454:loc_1948Dr
			; sub_19454:loc_1949Fr
			; sub_19454:loc_194B1r
			; sub_194C2:loc_194F1r
			; sub_194C2:loc_19506r
			; sub_194C2+59r
			; sub_194C2:loc_19530r
			; sub_19958+12r
			; sub_19958+37r
			; sub_19958+1BFr
			; ILSe_display_text+103r
			; sub_19D2A:loc_19D31r
			; sub_19D51:loc_19D58r
			; sub_19D78+21r
			; sub_19D78:loc_19DA6r
			; sub_19D78+47r
			; sub_19F94:loc_1A00Dr
			; sub_19F94:loc_1A064r
			; sub_1A0DC:loc_1A0EEr
			; sub_1A0DC+37r
			; sub_1A0DC+192r
			; sub_1A296+21r
			; sub_1A3AF+29r
			; sub_1A542+Ar
			; sub_1A542:loc_1A55Cr
			; sub_1A5F1+12r
			; sub_1A5F1+37r
			; sub_1A5F1+1E0r
			; sub_1A7FF+FEr
			; idk_PalFnt_s1AB64+63r
			; sub_1ACAA+31r
			; sub_1AD1E:loc_1AD4Fr
			; sub_1AD92+49r
			; sub_1AF46:loc_1AF50r
			; sub_1AF9B:loc_1AFBAr
			; sub_1AF9B+43r
			; sub_1B341+8r
			; sub_1B341+22r
			; sub_1B341+34r
			; sub_1B654+18r
			; sub_1B654+32r
			; sub_1B654+44r
			; sub_1B654+56r
			; sub_1B984+Er
			; sub_1BBF9+Ar
			; sub_1BC1A+14r
			; sub_1BC1A:loc_1BC4Er
bufFontsLbxEntry1 dw 0	; DATA XREF: LBX_Load_FontsStyleData+2Ew
ptrFontsLbx2_@80 dw 0	; DATA XREF: ILSe_prepare_palette+3Aw
			; ILSe_prepare_palette+3Dr
			; sub_24AC0+25r
			; sub_24B91+25r
ptrFontsLbx2_@64 dw 0	; DATA XREF: ILSe_prepare_palette+31w
			; ILSe_prepare_palette+34r
ptrFontsLbx2_@48 dw 0	; DATA XREF: sub_19399+1Fr
			; sub_193DD:loc_193F9r
			; sub_19454+Fr
			; sub_194C2+15r
			; idk_PalFnt_s1AB64+6Er
			; ILSe_prepare_palette+28w
			; ILSe_prepare_palette+2Br
dword_3C530 dd 0	; DATA XREF: sub_1B0AD:loc_1B0E2r
			; sub_1B0AD:loc_1B11Ar
			; sub_1B0AD:loc_1B14Er
			; sub_1B0AD+10Cr
			; sub_1B0AD+140r
			; sub_1B241+37r
			; sub_1B241+6Er
			; sub_1B241+A2r
			; sub_1B341+71r
			; sub_1B341:loc_1B488r
			; sub_1B341+1D4r
			; sub_1B654:loc_1B879r
			; sub_1B654+2DBr
			; sub_1B9E2+2Er
			; sub_1BC65+37r
			; sub_1BC65+72r
			; sub_1BC65+A9r
			; sub_1BC65+117r
			; sub_1BC65+14Er
			; hrmLotsOfFarMallocStoreSW:loc_1BE74w
			; hrmLotsOfFarMallocStoreSW:loc_1BE70w
dword_3C534 dd 0	; DATA XREF: sub_1B0AD:loc_1B0F2r
			; sub_1B0AD:loc_1B12Ar
			; sub_1B0AD:loc_1B15Er
			; sub_1B0AD+11Cr
			; sub_1B0AD:loc_1B1FDr
			; sub_1B241+47r
			; sub_1B241:loc_1B2BFr
			; sub_1B241+B2r
			; sub_1B341+2A4r
			; sub_1B341+2C0r
			; sub_1B654+214r
			; sub_1B654+2CAr
			; sub_1B984+3Er
			; sub_1BC65+47r
			; sub_1BC65+82r
			; sub_1BC65+B9r
			; sub_1BC65+127r
			; sub_1BC65+15Er
			; hrmLotsOfFarMallocStoreSW+55w
			; hrmLotsOfFarMallocStoreSW+51w
dword_3C538 dd 0	; DATA XREF: sub_1B0AD:loc_1B137r
			; sub_1B0AD+CBr
			; sub_1B0AD:loc_1B19Er
			; sub_1B241+8Br
			; sub_1B241+CCr
			; sub_1B341:loc_1B404r
			; sub_1B341+E2r
			; sub_1B341+116r
			; sub_1B654+203r
			; sub_1B654+2B9r
			; sub_1B9E2:loc_1BA54r
			; sub_1B9E2:loc_1BA6Er
			; sub_1B9E2+DCr
			; sub_1BC65+8Fr
			; sub_1BC65+D3r
			; sub_1BC65+FCr
			; hrmLotsOfFarMallocStoreSW+3Bw
			; hrmLotsOfFarMallocStoreSW+37w
dword_3C53C dd 0	; DATA XREF: sub_1B0AD:loc_1B0FFr
			; sub_1B0AD:loc_1B16Br
			; sub_1B0AD+FEr
			; sub_1B0AD:loc_1B1D6r
			; sub_1B0AD:loc_1B20Ar
			; sub_1B241:loc_1B295r
			; sub_1B241+BFr
			; sub_1B341:loc_1B3F1r
			; sub_1B341+D5r
			; sub_1B341+106r
			; sub_1B654+1F2r
			; sub_1B654:loc_1B8FCr
			; sub_1B9E2+5Br
			; sub_1B9E2:loc_1BA7Br
			; sub_1B9E2+CFr
			; sub_1BC65+54r
			; sub_1BC65+C6r
			; sub_1BC65:loc_1BD6Er
			; sub_1BC65+134r
			; sub_1BC65+16Br
			; hrmLotsOfFarMallocStoreSW+21w
			; hrmLotsOfFarMallocStoreSW+1Dw
word_3C540 dw 0		; DATA XREF: sub_1B0AD:loc_1B192r
			; sub_1B0AD:loc_1B21Er
			; sub_1B241:loc_1B327r
			; sub_1B341:loc_1B3C8r
			; sub_1B341:loc_1B634r
			; sub_1B654+Dw
			; sub_1B654+150w
			; sub_1B654:loc_1B841r
			; sub_1B654+1FEr
			; sub_1B654+20Fr
			; sub_1B654:loc_1B874r
			; sub_1B654+231w
			; sub_1B654:loc_1B8F7r
			; sub_1B654+2B4r
			; sub_1B654+2C5r
			; sub_1B654+2D6r
			; sub_1B654+2E7w
			; sub_1B984+2Dr
			; sub_1B984:loc_1B9BCr
			; sub_1B9E2:loc_1BAE0r
			; sub_1BC65:loc_1BD52r
			; sub_1BC65:loc_1BDE4r
word_3C542 dw 0		; DATA XREF: sub_1B654+B5r
			; sub_1B654+D8r
db    0
db    0
db    0
db    0
unk_3C548 db	0
db    0
word_3C54A dw 0		; DATA XREF: sub_1B654+E2r
			; sub_1B654:loc_1B76Br
db    0
db    0
db    0
db    0
unk_3C550 db	0
unk_3C551 db	0
word_3C552 dw 0		; DATA XREF: sub_1B654:loc_1B6FCr
			; sub_1B654:loc_1B71Cr
db    0
db    0
db    0
db    0
db    0
db    0
word_3C55A dw 0		; DATA XREF: sub_1B654+EFr
			; sub_1B654:loc_1B750r
			; sub_1B654:loc_1B75Dr
db    0
db    0
db    0
db    0
db    0
db    0
word_3C562 dw 0		; DATA XREF: idk_SetDacReg_s1C1AF+46w
			; sub_1C37B+18r
			; sub_1C37B:loc_1C3B0r
			; sub_1C37B+58r
			; sub_1C37B:loc_1C3F0r
idk_PalNbr_w3C564 dw 0	; DATA XREF: idk_SetDacReg_s1C1AF:loc_1C23Ew
			; idk_SetDacReg_s1C1AF:loc_1C264r
			; idk_SetDacReg_s1C1AF:loc_1C270r
			; idk_SetDacReg_s1C1AF+DFr
			; idk_SetDacReg_s1C1AF:loc_1C2A9r
			; idk_SetDacReg_s1C1AF+106r
			; idk_SetDacReg_s1C1AF+124r
			; idk_SetDacReg_s1C1AF:loc_1C2E4r
			; idk_SetDacReg_s1C1AF+141r
			; idk_SetDacReg_s1C1AF+15Fr
			; sub_1C37B+1Bw
			; sub_1C37B:loc_1C39Cr
			; sub_1C37B+2Aw
			; sub_1C37B:loc_1C3B3w
			; sub_1C37B+3Er
			; sub_1C37B:loc_1C3C2w
			; sub_1C37B+5Bw
			; sub_1C37B:loc_1C3DCr
			; sub_1C37B+6Aw
			; sub_1C37B:loc_1C3F3w
			; sub_1C37B+7Er
			; sub_1C37B:loc_1C402w
; char g_IntroLbxFileName[]
g_IntroLbxFileName dw 0	; DATA XREF: LBX_Intro_MemAndReadAndMem+6o
			; LBX_Load_IntroLbx_s21977+E1o
			; LBX_MemAndRead+16o
			; LBX_MemAndRead+31o
db    0
db    0
unk_3C56A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
; int g_IntroLbxEntryNumber
g_IntroLbxEntryNumber dw 0
			; DATA XREF: LBX_Intro_MemAndReadAndMem+14w
			; LBX_Load_IntroLbx_s21977:loc_21A50r
			; LBX_MemAndRead+2Dr
			; LBX_MemAndRead:loc_21B4Ar
			; LBX_MemAndRead:FAILURE_DOS_SEEKr
idk_Flag_w3C578	dw 0	; DATA XREF: idk_SetThreeFlagsOrValues_s25E72+6w
			; idk_SetThreeFlags_s25E89+Fw
			; sub_25EA0:loc_25EDCr
			; sub_25EA0+4Cr
			; sub_25EA0+60r
			; sub_25EA0+74r
			; sub_25EA0+88r
			; sub_25EA0+99r
			; sub_2BA41+13A1r
			; sub_2BA41+13BAr
			; sub_2BA41+13C9r
			; sub_2BA41+13D8r
			; sub_2BA41+13E5r
			; sub_2BA41+1400r
			; sub_2BA41+140Dr
			; sub_2BA41+141Cr
			; sub_2BA41+1429r
			; sub_2BA41+1444r
			; sub_2BA41+1453r
			; sub_2BA41+1462r
			; sub_2BA41+146Fr
			; sub_2BA41+148Ar
			; sub_2BA41+1499r
			; sub_2BA41+14A8r
			; sub_2BA41+14B7r
word_3C57A dw 0		; DATA XREF: sub_24DAE+9E9w
			; sub_24DAE+E24w
			; sub_26012+3r
word_3C57C dw 0		; DATA XREF: sub_24DAE+9E3w
			; sub_24DAE+E1Ew
			; sub_26008+3r
word_3C57E dw 0		; DATA XREF: sub_24DAE:loc_2578Bw
			; sub_24DAE+E18w
			; sub_25FFE+3r
			; sub_26026:loc_26398r
; char idk2_b3C580[30]
idk2_b3C580 db 1Eh dup(0)
			; DATA XREF: sub_24DAE+38Ao
			; sub_24DAE+445o
			; sub_24DAE+CF8o
			; sub_24DAE+D37o
			; sub_24DAE:loc_25B3Eo
			; sub_26026:loc_263A0w
			; sub_26026+37Fo
word_3C59E dw 0		; DATA XREF: idk_Mouse_s2B8B1+B1w
			; sub_2B97A+4r
			; sub_2B97A+Bw
			; sub_2B97A:loc_2B98Fr
			; sub_2B97A+1Cw
			; sub_2B9C4+6w
			; seg034:6C3Cr
idk_MousePosX_w3C5A0 dw	0 ; DATA XREF: sub_26026+Er
			; sub_26026:loc_2603Fr
			; sub_26026+28r
			; sub_26026+10Dr
			; sub_26026+196w
			; sub_26026:loc_261D4r
			; sub_26026:loc_261DBr
			; sub_26026+1C0w
			; sub_26026:loc_261E9r
			; sub_26026+2A1r
			; sub_26026+3DDr
			; sub_26026+667w
			; rschKBD_s2669B+265w
			; rschKBD_s2669B+270r
			; rschKBD_s2669B:loc_26913r
			; rschKBD_s2669B+299r
			; rschKBD_s2669B+2A0w
			; rschKBD_s2669B+2A3r
			; rschKBD_s2669B+2B7r
			; rschKBD_s2669B+2C6r
			; sub_27913+B2w
			; sub_27913+B5r
			; sub_27913+D6r
			; sub_27913+DDw
			; sub_27913+E0r
			; sub_27913+F4r
			; sub_27913+103r
			; sub_27E4B+A6r
			; sub_27E4B+226w
			; sub_27E4B:loc_28088r
			; sub_27E4B+244r
			; sub_27E4B+24Cr
			; sub_27E4B+26Dr
			; sub_27E4B+274w
			; sub_27E4B+27Cr
			; sub_27E4B+28Br
			; sub_27E4B+29Ar
			; sub_27E4B+2B7w
			; sub_2B470+372w
			; sub_2B470+385r
			; sub_2B470+393r
			; sub_2B470+3B4r
			; sub_2B470+3BBw
			; sub_2B470+3C3r
			; sub_2B470+3D2r
			; sub_2B470+3E1r
			; idk_Mouse_s2B8B1+3Fw
			; idk_Mouse_s2B8B1+7Fw
idk_MousePosX_w3C5A2 dw	0
			; DATA XREF: sub_26026:loc_2602Er
			; sub_26026+1Dr
			; sub_26026+2Cr
			; sub_26026:loc_2612Dr
			; sub_26026+152w
			; sub_26026+199r
			; sub_26026+1A0r
			; sub_26026+1ABw
			; sub_26026+1C7r
			; sub_26026:loc_262C1r
			; sub_26026+3E1r
			; sub_26026+65Fw
			; rschKBD_s2669B+224w
			; rschKBD_s2669B+268r
			; rschKBD_s2669B+27Cr
			; rschKBD_s2669B+28Fr
			; rschKBD_s2669B+296w
			; rschKBD_s2669B+2A7r
			; rschKBD_s2669B+2BBr
			; rschKBD_s2669B+2CAr
			; sub_27913+ABw
			; sub_27913+B9r
			; sub_27913+CCr
			; sub_27913+D3w
			; sub_27913+E4r
			; sub_27913+F8r
			; sub_27913+107r
			; sub_27E4B:loc_27EEBr
			; sub_27E4B+1E5w
			; sub_27E4B+22Er
			; sub_27E4B+235r
			; sub_27E4B:loc_2809Br
			; sub_27E4B:loc_280AEr
			; sub_27E4B:loc_280B5w
			; sub_27E4B+280r
			; sub_27E4B+28Fr
			; sub_27E4B+29Er
			; sub_27E4B:loc_280FCw
			; sub_2B470+331w
			; sub_2B470+37Ar
			; sub_2B470+397r
			; sub_2B470+3AAr
			; sub_2B470+3B1w
			; sub_2B470+3C7r
			; sub_2B470+3D6r
			; sub_2B470+3E5r
			; idk_Mouse_s2B8B1+39w
			; idk_Mouse_s2B8B1+79w
idk_Mouse_w3C5A4 dw 0	; DATA XREF: sub_24DAE+33w
			; sub_24DAE+7A9w
			; sub_24DAE:loc_255B2r
			; sub_24DAE:loc_255BEr
			; sub_24DAE+81Cr
			; sub_24DAE+828r
			; sub_24DAE+B59w
			; sub_26026+49w
			; rschKBD_s2669B+28Cw
			; rschKBD_s2669B+292r
			; rschKBD_s2669B+29Cr
			; sub_27913+C9w
			; sub_27913+CFr
			; sub_27913+D9r
			; sub_27A2B+2Cw
			; sub_27A2B+86r
			; sub_27A2B+91r
			; sub_27A2B+9Dr
			; sub_27A2B+A9r
			; sub_27AFB+2Bw
			; sub_27E4B:loc_27F2Cr
			; sub_27E4B+FBr
			; sub_27E4B:loc_27F60r
			; sub_27E4B:loc_27F79r
			; sub_27E4B+260w
			; sub_27E4B:loc_280B1r
			; sub_27E4B:loc_280BBr
			; sub_2A235+4Dr
			; sub_2A235+13Br
			; sub_2B470+3A7w
			; sub_2B470+3ADr
			; sub_2B470+3B7r
word_3C5A6 dw 0		; DATA XREF: sub_27CC0+13w
			; sub_27CC0:loc_27E2Br
idk_Mouse_w3C5A8 dw 0	; DATA XREF: sub_24DAE:loc_25379r
			; sub_24DAE:loc_255E9r
			; sub_25F63:loc_25F76r
			; sub_25FB0:loc_25FC3r
			; sub_26026:loc_26538r
			; rschKBD_s2669B+16r
			; rschKBD_s2669B+7Dr
			; rschKBD_s2669B:loc_2671Er
			; rschKBD_s2669B:loc_26722r
			; rschKBD_s2669B:loc_267ADr
			; rschKBD_s2669B:loc_267B3r
			; rschKBD_s2669B:loc_26835r
			; rschKBD_s2669B+1A9r
			; rschKBD_s2669B+47Dr
			; sub_26B67:loc_26BF4r
			; sub_26B67+BBr
			; sub_26B67:loc_26DCEr
			; sub_26B67+286r
			; sub_26B67:loc_27019r
			; sub_26B67+4D8r
			; sub_26B67:loc_271EEr
			; sub_26B67+6A6r
			; sub_26B67:loc_2743Er
			; sub_26B67:loc_27464r
			; sub_26B67:loc_2769Fr
			; sub_26B67+B5Er
			; sub_26B67:loc_278FEr
			; sub_27A2B:loc_27AE7r
			; sub_27CC0+10r
			; sub_27CC0+16w
			; sub_27CC0+16Ew
			; sub_27E4B+B1r
			; sub_28D4A+8r
			; sub_28D4A+19r
			; sub_28D4A+34r
			; sub_28D4A+4Dr
			; sub_28D4A+66r
			; sub_28D4A:loc_28DC3r
			; sub_28D4A+9Ar
			; sub_28D4A+AEr
			; sub_28D4A+C3r
			; sub_28D4A+DAr
			; sub_28D4A+EFr
			; sub_28D4A:loc_28E4Er
			; sub_28D4A+119r
			; sub_28D4A:loc_28E76r
			; sub_28D4A+141r
			; sub_28D4A:loc_28EA0r
			; sub_28D4A+16Br
			; sub_28D4A+180r
			; sub_28D4A+195r
			; sub_28D4A+1AAr
			; sub_28D4A+1BEr
			; sub_28D4A+1C2w
			; sub_28D4A+1C5r
			; sub_28F19:loc_28F24r
			; sub_28F19+1Cr
			; sub_28F19+34r
			; sub_28F19+4Dr
			; sub_28F19:loc_28F7Fr
			; sub_28F19+79r
			; sub_28F19+99r
			; sub_28F19+ADr
			; sub_28F19+C2r
			; sub_28F19+D5r
			; sub_28F19+EAr
			; sub_28F19+FFr
			; sub_28F19+114r
			; sub_28F19+129r
			; sub_28F19+13Er
			; sub_28F19+152r
			; sub_28F19+156w
			; sub_28F19+159r
			; sub_290A9+8r
			; sub_290A9+19r
			; sub_290A9+35r
			; sub_290A9:loc_290F7r
			; sub_290A9+67r
			; sub_290A9+7Ar
			; sub_290A9:loc_29145r
			; sub_290A9+B0r
			; sub_290A9+C5r
			; sub_290A9+DCr
			; sub_290A9+F1r
			; sub_290A9:loc_291AFr
			; sub_290A9+11Br
			; sub_290A9+130r
			; sub_290A9:loc_291ECr
			; sub_290A9+158r
			; sub_290A9+16Dr
			; sub_290A9+182r
			; sub_290A9+197r
			; sub_290A9+1ACr
			; sub_290A9+1C1r
			; sub_290A9+1D6r
			; sub_290A9+1EBr
			; sub_290A9+1FFr
			; sub_290A9+203w
			; sub_290A9:loc_292AFr
			; sub_292B9:loc_292E0r
			; sub_292B9+3Ar
			; sub_292B9+4Er
			; sub_292B9+62r
			; sub_292B9+76r
			; sub_292B9+8Ar
			; sub_292B9+9Er
			; sub_292B9+B0r
			; sub_292B9+C4r
			; sub_292B9+D6r
			; sub_292B9+EBr
			; sub_292B9+100r
			; sub_292B9+115r
			; sub_292B9+12Ar
			; sub_292B9:loc_293F6r
			; sub_292B9+141w
			; sub_292B9+144r
			; sub_29409+8r
			; sub_29409+1Cr
			; sub_29409+39r
			; sub_29409+4Er
			; sub_29409+69r
			; sub_29409+7Fr
			; sub_29409+92r
			; sub_29409+A7r
			; sub_29409+B9r
			; sub_29409+CDr
			; sub_29409+E4r
			; sub_29409+F9r
			; sub_29409+10Er
			; sub_29409+123r
			; sub_29409:loc_2953Fr
			; sub_29409+13Aw
			; sub_29409+13Dr
			; sub_29550+5Br
			; sub_29550:loc_295BEr
			; sub_29550+8Br
			; sub_29550:loc_295EEr
			; sub_29550+BCr
			; sub_29550:loc_2961Fr
			; sub_29550+EDr
			; sub_29550:loc_29650r
			; sub_29550+115r
			; sub_29550+12Ar
			; sub_29550+13Fr
			; sub_29550+153r
			; sub_29550+16Ar
			; sub_29550+17Fr
			; sub_29550+194r
			; sub_29550+1A9r
			; sub_29550:loc_2970Cr
			; sub_29550+1C0w
			; sub_29550+1C3r
			; sub_29731+8r
			; sub_29731+1Cr
			; sub_29731+31r
			; sub_29731:loc_2977Fr
			; sub_29731+64r
			; sub_29731+7Fr
			; sub_29731+96r
			; sub_29731+AFr
			; sub_29731+C8r
			; sub_29731:loc_2980Cr
			; sub_29731+F0r
			; sub_29731+10Ar
			; sub_29731+11Dr
			; sub_29731+134r
			; sub_29731+149r
			; sub_29731+15Er
			; sub_29731+173r
			; sub_298BB+1Cr
			; sub_298BB+30r
			; sub_298BB+34w
			; sub_298BB+37r
			; sub_298FA+1Cr
			; sub_298FA+30r
			; sub_298FA+45r
			; sub_298FA+49w
			; sub_298FA+4Cr
			; sub_2994E+1Cr
			; sub_2994E:loc_2997Er
			; sub_2994E+45r
			; sub_2994E+49w
			; sub_2994E+4Cr
			; sub_299A2+1Cr
			; sub_299A2+30r
			; sub_299A2+45r
			; sub_299A2+5Ar
			; sub_299A2+5Ew
			; sub_299A2+61r
			; idk_Mouse_s29A0B+8r
			; idk_Mouse_s29A0B+1Cr
			; idk_Mouse_s29A0B+31r
			; idk_Mouse_s29A0B+46r
			; idk_Mouse_s29A0B+5Br
			; idk_Mouse_s29A0B+6Fr
			; idk_Mouse_s29A0B+84r
			; idk_Mouse_s29A0B+98r
			; idk_Mouse_s29A0B+ADr
			; idk_Mouse_s29A0B:loc_29ACDr
			; idk_Mouse_s29A0B+D7r
			; idk_Mouse_s29A0B:loc_29AF5r
			; idk_Mouse_s29A0B+EEw
			; idk_Mouse_s29A0B+F1r
			; sub_29B06+37r
			; sub_29B06:loc_29B50r
			; sub_29B06+67r
			; sub_29B06:loc_29B80r
			; sub_29B06+95r
			; sub_29B06:loc_29BAFr
			; sub_29B06+C7r
			; sub_29B06:loc_29BE0r
			; sub_29B06+EFr
			; sub_29B06+103r
			; sub_29B06+118r
			; sub_29B06+12Fr
			; sub_29B06+144r
			; sub_29B06+159r
			; sub_29B06+16Er
			; sub_29B06:loc_29C87r
			; sub_29B06+185w
			; sub_29B06+188r
			; idk_Mouse_s29C99+8r
			; idk_Mouse_s29C99+1Br
			; idk_Mouse_s29C99+2Fr
			; idk_Mouse_s29C99+43r
			; idk_Mouse_s29C99+57r
			; idk_Mouse_s29C99+6Br
			; idk_Mouse_s29C99+7Fr
			; idk_Mouse_s29C99+93r
			; idk_Mouse_s29C99+A8r
			; idk_Mouse_s29C99+BDr
			; idk_Mouse_s29C99+D2r
			; idk_Mouse_s29C99:loc_29D7Er
			; idk_Mouse_s29C99+E9w
			; idk_Mouse_s29C99+ECr
			; sub_29D8F+8r
			; sub_29D8F+1Cr
			; sub_29D8F+31r
			; sub_29D8F+46r
			; sub_29D8F+5Br
			; sub_29D8F+70r
			; sub_29D8F+84r
			; sub_29D8F:loc_29E28r
			; sub_29D8F+AEr
			; sub_29D8F+C3r
			; sub_29D8F+D7r
			; sub_29D8F+ECr
			; sub_29D8F+101r
			; sub_29D8F+116r
			; sub_29D8F:loc_29EB8r
			; sub_29D8F+12Dw
			; sub_29D8F+130r
			; sub_29EC9+Er
			; sub_29EC9+1Fr
			; sub_29EC9+3Br
			; sub_29EC9+5Ar
			; sub_29EC9+6Er
			; sub_29EC9+83r
			; sub_29EC9+97r
			; sub_29EC9+A9r
			; sub_29EC9+BEr
			; sub_29EC9:loc_29F9Ar
			; sub_29EC9+E6r
			; sub_29EC9+FBr
			; sub_29EC9+110r
			; sub_29EC9+125r
			; sub_29EC9+13Ar
			; sub_29EC9:loc_2A016r
			; sub_29EC9+151w
			; sub_29EC9+154r
			; sub_2A058:loc_2A06Er
			; sub_2A058+2Ar
			; sub_2A058+3Fr
			; sub_2A058+53r
			; sub_2A058+66r
			; sub_2A058+7Br
			; sub_2A058+8Er
			; sub_2A058+A3r
			; sub_2A058+B8r
			; sub_2A058+CDr
			; sub_2A058+E2r
			; sub_2A058+FBr
			; sub_2A058:loc_2A169r
			; sub_2A058:loc_2A17Dr
			; sub_2A058+139r
			; sub_2A058+14Er
			; sub_2A058+163r
			; sub_2A058+17Ar
			; sub_2A058+18Fr
			; sub_2A058+1A4r
			; sub_2A058+1B9r
			; sub_2A058:loc_2A224r
			; sub_2A058+1D0w
			; sub_2A058+1D3r
			; setFlagsMaybeMouseEGA+3w
			; sub_2B470+39r
			; sub_2B470:loc_2B4C5r
			; sub_2B470+92r
			; sub_2B470:loc_2B50Ar
			; sub_2B470:loc_2B541r
			; sub_2B470:loc_2B597r
			; sub_2B470+18Fr
			; sub_2B470+1BDr
			; sub_2B470:loc_2B649r
			; sub_2B470:loc_2B672r
			; sub_2B470+224r
			; sub_2B470:loc_2B69Cr
			; sub_2B470:loc_2B6C4r
			; sub_2B470+27Dr
			; sub_2B470:loc_2B73Fr
			; sub_2B470+2D8r
			; sub_2B470+2E4r
			; seg034:6AFCw
			; sub_2B8A7+3r
			; sub_2B97A:loc_2B99Cr
			; sub_2BA41:loc_2CDB3r
			; idk_OVR_LoadLbxHelp:loc_55D03r
			; idk_OVR_LoadLbxHelp:loc_55D09w
			; idk_OVR_LoadLbxHelp+572w
word_3C5AA dw 0		; DATA XREF: sub_2E22B+Dw
			; sub_2E23E+6r
word_3C5AC dw 0		; DATA XREF: sub_2E22B+Aw
			; sub_2E23E+3r
dword_3C5AE dd 0	; DATA XREF: sub_2E1FB+Fw
			; sub_2E22B+6r
			; sub_2E23E+Dw
			; sub_2E26D+Ar
			; sub_2E1FB+Cw
			; sub_2E22B:loc_2E22Er
			; sub_2E23E+Aw
idk2_dw3C5B2 dd	0	; DATA XREF: sub_24DAE+11Dr
			; sub_24DAE+143r
			; sub_24DAE+15Dr
			; sub_24DAE+17Er
			; sub_24DAE+191r
			; sub_24DAE+1A9r
			; sub_24DAE:loc_24F6Er
			; sub_24DAE:loc_24F81r
			; sub_24DAE:loc_24F9Ar
			; sub_24DAE+21Ar
			; sub_24DAE+23Er
			; sub_24DAE+255r
			; sub_24DAE+27Ar
			; sub_24DAE+291r
			; sub_24DAE+2A9r
			; sub_24DAE+2EBr
			; sub_24DAE+327r
			; sub_24DAE+345r
			; sub_24DAE:loc_2512Er
			; sub_24DAE+3BAr
			; sub_24DAE+3EAr
			; sub_24DAE+40Br
			; sub_24DAE:loc_251DAr
			; sub_24DAE+451r
			; sub_24DAE+482r
			; sub_24DAE+496r
			; sub_24DAE+4BEr
			; sub_24DAE+4E1r
			; sub_24DAE+4F7r
			; sub_24DAE+51Er
			; sub_24DAE+534r
			; sub_24DAE+54Br
			; sub_24DAE+57Fr
			; sub_24DAE+593r
			; sub_24DAE+5A7r
			; sub_24DAE+5BBr
			; sub_24DAE+5EFr
			; sub_24DAE+69Br
			; sub_24DAE+6B2r
			; sub_24DAE+6FDr
			; sub_24DAE+7B9r
			; sub_24DAE+7CCr
			; sub_24DAE:loc_2558Er
			; sub_24DAE:loc_255A2r
			; sub_24DAE:loc_25600r
			; sub_24DAE+88Cr
			; sub_24DAE+8ABr
			; sub_24DAE:loc_25699r
			; sub_24DAE+928r
			; sub_24DAE:loc_25707r
			; sub_24DAE+987r
			; sub_24DAE+9ACr
			; sub_24DAE+9FDr
			; sub_24DAE+A1Fr
			; sub_24DAE+A36r
			; sub_24DAE+A6Cr
			; sub_24DAE:loc_25839r
			; sub_24DAE+AA2r
			; sub_24DAE+ABAr
			; sub_24DAE:loc_2593Br
			; sub_24DAE+BA7r
			; sub_24DAE:loc_2596Ar
			; sub_24DAE:loc_2597Fr
			; sub_24DAE+C4Cr
			; sub_24DAE+C61r
			; sub_24DAE+C7Dr
			; sub_24DAE+C92r
			; sub_24DAE+CA7r
			; sub_24DAE+CD2r
			; sub_24DAE+CEEr
			; sub_24DAE+D2Dr
			; sub_24DAE+D77r
			; sub_24DAE:loc_25B4Ar
			; sub_24DAE+DEAr
			; sub_24DAE:loc_25BDDr
			; sub_24DAE+E51r
			; sub_24DAE+E68r
			; sub_24DAE+EC1r
			; sub_24DAE+ED6r
			; sub_24DAE+EEDr
			; sub_24DAE+F05r
			; sub_25F63+24r
			; sub_25F63:loc_25F99r
			; sub_25FB0+24r
			; sub_25FB0+36r
			; sub_26026+E3r
			; sub_26026+11Br
			; sub_26026+12Er
			; sub_26026+146r
			; sub_26026+15Dr
			; sub_26026+170r
			; sub_26026:loc_261AFr
			; sub_26026+1DEr
			; sub_26026+202r
			; sub_26026+219r
			; sub_26026+242r
			; sub_26026+259r
			; sub_26026+271r
			; sub_26026:loc_262E2r
			; sub_26026+2D7r
			; sub_26026:loc_26337r
			; sub_26026+346r
			; sub_26026+366r
			; sub_26026+38Br
			; sub_26026+3BCr
			; sub_26026:loc_263F6r
			; sub_26026:loc_2641Br
			; sub_26026+418r
			; sub_26026+42Er
			; sub_26026+44Ar
			; sub_26026+45Fr
			; sub_26026+475r
			; sub_26026+48Cr
			; sub_26026:loc_264E6r
			; sub_26026+4D4r
			; sub_26026:loc_2650Er
			; sub_26026+4FCr
			; sub_26026+536r
			; sub_26026+5DAr
			; sub_26026+5F1r
			; sub_26026+63Cr
			; rschKBD_s2669B+5Cr
			; rschKBD_s2669B:loc_26740r
			; rschKBD_s2669B+C1r
			; rschKBD_s2669B:loc_2678Ar
			; rschKBD_s2669B:loc_267A0r
			; rschKBD_s2669B+12Dr
			; rschKBD_s2669B+149r
			; rschKBD_s2669B:loc_26812r
			; rschKBD_s2669B:loc_26828r
			; rschKBD_s2669B+1BBr
			; rschKBD_s2669B+1D2r
			; rschKBD_s2669B+1EFr
			; rschKBD_s2669B:loc_2689Cr
			; rschKBD_s2669B+218r
			; rschKBD_s2669B:loc_268C9r
			; rschKBD_s2669B+240r
			; rschKBD_s2669B:loc_268F3r
			; rschKBD_s2669B+2E1r
			; rschKBD_s2669B:loc_26993r
			; rschKBD_s2669B+314r
			; rschKBD_s2669B+325r
			; rschKBD_s2669B:loc_269D2r
			; rschKBD_s2669B+34Br
			; rschKBD_s2669B+35Er
			; rschKBD_s2669B:loc_26A15r
			; rschKBD_s2669B+393r
			; rschKBD_s2669B+424r
			; rschKBD_s2669B+439r
			; rschKBD_s2669B:loc_26AF1r
			; rschKBD_s2669B+46Ar
			; rschKBD_s2669B+48Ar
			; sub_26B67+3Br
			; sub_26B67+4Fr
			; sub_26B67+63r
			; sub_26B67+7Cr
			; sub_26B67+D9r
			; sub_26B67:loc_26C54r
			; sub_26B67+101r
			; sub_26B67:loc_26C7Cr
			; sub_26B67+144r
			; sub_26B67+156r
			; sub_26B67+16Er
			; sub_26B67+187r
			; sub_26B67:loc_26D00r
			; sub_26B67+1B1r
			; sub_26B67:loc_26D30r
			; sub_26B67+1DBr
			; sub_26B67:loc_26D59r
			; sub_26B67+208r
			; sub_26B67+21Dr
			; sub_26B67+2A4r
			; sub_26B67+2B8r
			; sub_26B67+2CCr
			; sub_26B67:loc_26E47r
			; sub_26B67+30Fr
			; sub_26B67:loc_26E88r
			; sub_26B67+339r
			; sub_26B67+352r
			; sub_26B67+364r
			; sub_26B67+37Cr
			; sub_26B67+394r
			; sub_26B67:loc_26F0Dr
			; sub_26B67+3BDr
			; sub_26B67:loc_26F3Ar
			; sub_26B67+3E8r
			; sub_26B67+4F6r
			; sub_26B67:loc_27071r
			; sub_26B67+51Er
			; sub_26B67+532r
			; sub_26B67+561r
			; sub_26B67+573r
			; sub_26B67+58Ar
			; sub_26B67+5A2r
			; sub_26B67:loc_2711Br
			; sub_26B67+5CBr
			; sub_26B67+5E3r
			; sub_26B67+5F5r
			; sub_26B67+60Dr
			; sub_26B67+625r
			; sub_26B67:loc_271A2r
			; sub_26B67+6C4r
			; sub_26B67:loc_2723Fr
			; sub_26B67+6ECr
			; sub_26B67+700r
			; sub_26B67+72Fr
			; sub_26B67+741r
			; sub_26B67+758r
			; sub_26B67+770r
			; sub_26B67+782r
			; sub_26B67+799r
			; sub_26B67+7B1r
			; sub_26B67:loc_2732Ar
			; sub_26B67+7DBr
			; sub_26B67+7F3r
			; sub_26B67+809r
			; sub_26B67+91Br
			; sub_26B67+92Fr
			; sub_26B67+943r
			; sub_26B67+957r
			; sub_26B67+986r
			; sub_26B67+998r
			; sub_26B67+9AFr
			; sub_26B67:loc_2752Er
			; sub_26B67:loc_27540r
			; sub_26B67+9F0r
			; sub_26B67+A08r
			; sub_26B67+A1Ar
			; sub_26B67:loc_2759Er
			; sub_26B67+B7Cr
			; sub_26B67+B90r
			; sub_26B67+BA4r
			; sub_26B67+BB8r
			; sub_26B67:loc_2774Er
			; sub_26B67+BF9r
			; sub_26B67+C10r
			; sub_26B67:loc_2778Fr
			; sub_26B67+C3Ar
			; sub_26B67+C51r
			; sub_26B67+C69r
			; sub_26B67:loc_277E2r
			; sub_26B67+C93r
			; sub_27913+1Cr
			; sub_27913:loc_27941r
			; sub_27913+45r
			; sub_27913+5Ar
			; sub_27913:loc_2797Fr
			; sub_27913+84r
			; sub_27A2B+3Cr
			; sub_27A2B:loc_27A7Ar
			; sub_27A2B:loc_27A8Er
			; sub_27A2B+77r
			; sub_27AFB+3Br
			; sub_27AFB+4Fr
			; sub_27AFB+61r
			; sub_27AFB+75r
			; sub_27AFB+8Cr
			; sub_27AFB:loc_27B9Br
			; sub_27AFB+B8r
			; sub_27AFB:loc_27BD2r
			; sub_27AFB+F4r
			; sub_27AFB+106r
			; sub_27AFB+11Ar
			; sub_27AFB:loc_27C2Fr
			; sub_27AFB+147r
			; sub_27AFB+15Br
			; sub_27E4B+C1r
			; sub_27E4B+D8r
			; sub_27E4B+F2r
			; sub_27E4B+10Cr
			; sub_27E4B:loc_27F70r
			; sub_27E4B+13Fr
			; sub_27E4B+158r
			; sub_27E4B:loc_27FFBr
			; sub_27E4B+1C2r
			; sub_27E4B:loc_28024r
			; sub_27E4B+1EFr
			; sub_27E4B+201r
			; sub_27E4B+219r
			; sub_28141+38r
			; sub_28141+4Dr
			; sub_28141+60r
			; sub_28141+85r
			; sub_28141+97r
			; sub_28141+A9r
			; sub_28141+C3r
			; sub_28141+11Ar
			; sub_28141+3E0r
			; sub_28963+20r
			; sub_28963+51r
			; sub_28963+64r
			; sub_28963+7Br
			; sub_28963+8Cr
			; sub_28963+9Dr
			; sub_28963+BFr
			; sub_28963+D3r
			; sub_28963+E4r
			; sub_28963+F5r
			; sub_28963:loc_28A69r
			; sub_28963:loc_28A7Ar
			; sub_28963+135r
			; sub_28963+17Ar
			; sub_28963+1C8r
			; sub_28963+249r
			; sub_28963+266r
			; sub_28963+2B6r
			; sub_28963:loc_28C83r
			; sub_28963+365r
			; sub_28963+376r
			; sub_28963+387r
			; sub_28963+3AAr
			; sub_28963:loc_28D1Fr
			; sub_28D4A+10r
			; sub_28D4A:loc_28D6Br
			; sub_28D4A+3Cr
			; sub_28D4A:loc_28D9Fr
			; sub_28D4A+6Er
			; sub_28D4A+81r
			; sub_28D4A+A3r
			; sub_28D4A+B6r
			; sub_28D4A+CBr
			; sub_28D4A+E2r
			; sub_28D4A:loc_28E41r
			; sub_28D4A+10Cr
			; sub_28D4A+121r
			; sub_28D4A:loc_28E7Er
			; sub_28D4A+149r
			; sub_28D4A:loc_28EA8r
			; sub_28D4A+173r
			; sub_28D4A+188r
			; sub_28D4A+19Dr
			; sub_28D4A+1B2r
			; sub_28F19+13r
			; sub_28F19+24r
			; sub_28F19+3Cr
			; sub_28F19+55r
			; sub_28F19+6Er
			; sub_28F19+81r
			; sub_28F19+A2r
			; sub_28F19+B5r
			; sub_28F19:loc_28FE3r
			; sub_28F19:loc_28FF6r
			; sub_28F19+F2r
			; sub_28F19+107r
			; sub_28F19+11Cr
			; sub_28F19+131r
			; sub_28F19+146r
			; sub_2907C+Dr
			; sub_2907C:loc_2909Cr
			; sub_290A9+10r
			; sub_290A9:loc_290CAr
			; sub_290A9+3Dr
			; sub_290A9:loc_290FFr
			; sub_290A9+6Fr
			; sub_290A9+82r
			; sub_290A9:loc_2914Er
			; sub_290A9:loc_29161r
			; sub_290A9+CDr
			; sub_290A9:loc_2918Dr
			; sub_290A9+F9r
			; sub_290A9+10Er
			; sub_290A9+123r
			; sub_290A9+138r
			; sub_290A9+14Br
			; sub_290A9+160r
			; sub_290A9+175r
			; sub_290A9+18Ar
			; sub_290A9+19Fr
			; sub_290A9+1B4r
			; sub_290A9+1C9r
			; sub_290A9+1DEr
			; sub_290A9+1F3r
			; sub_292B9+2Fr
			; sub_292B9+42r
			; sub_292B9+56r
			; sub_292B9+6Ar
			; sub_292B9+7Er
			; sub_292B9+92r
			; sub_292B9+A6r
			; sub_292B9+B8r
			; sub_292B9+CCr
			; sub_292B9+DEr
			; sub_292B9+F3r
			; sub_292B9+108r
			; sub_292B9+11Dr
			; sub_292B9+132r
			; sub_29409+10r
			; sub_29409+24r
			; sub_29409+41r
			; sub_29409:loc_2945Fr
			; sub_29409+71r
			; sub_29409+87r
			; sub_29409+9Ar
			; sub_29409+AFr
			; sub_29409+C1r
			; sub_29409+D5r
			; sub_29409+ECr
			; sub_29409+101r
			; sub_29409:loc_2951Fr
			; sub_29409+12Br
			; sub_29550+63r
			; sub_29550+76r
			; sub_29550+93r
			; sub_29550+A6r
			; sub_29550+C4r
			; sub_29550:loc_29627r
			; sub_29550+F5r
			; sub_29550+108r
			; sub_29550+11Dr
			; sub_29550+132r
			; sub_29550+147r
			; sub_29550+15Br
			; sub_29550+172r
			; sub_29550+187r
			; sub_29550+19Cr
			; sub_29550+1B1r
			; sub_29731+10r
			; sub_29731+24r
			; sub_29731+39r
			; sub_29731+56r
			; sub_29731+6Cr
			; sub_29731+87r
			; sub_29731+9Er
			; sub_29731+B7r
			; sub_29731:loc_29801r
			; sub_29731:loc_29814r
			; sub_29731+F8r
			; sub_29731+112r
			; sub_29731+125r
			; sub_29731+13Cr
			; sub_29731+151r
			; sub_29731+166r
			; sub_29731+17Br
			; sub_298BB+24r
			; sub_298FA+24r
			; sub_298FA+38r
			; sub_2994E+24r
			; sub_2994E+38r
			; sub_299A2+24r
			; sub_299A2+38r
			; sub_299A2+4Dr
			; idk_Mouse_s29A0B+10r
			; idk_Mouse_s29A0B+24r
			; idk_Mouse_s29A0B+39r
			; idk_Mouse_s29A0B+4Er
			; idk_Mouse_s29A0B+63r
			; idk_Mouse_s29A0B+77r
			; idk_Mouse_s29A0B+8Cr
			; idk_Mouse_s29A0B+A0r
			; idk_Mouse_s29A0B+B5r
			; idk_Mouse_s29A0B+CAr
			; idk_Mouse_s29A0B+DFr
			; sub_29B06:loc_29B45r
			; sub_29B06:loc_29B58r
			; sub_29B06+6Fr
			; sub_29B06+82r
			; sub_29B06+9Dr
			; sub_29B06+B1r
			; sub_29B06+CFr
			; sub_29B06+E2r
			; sub_29B06+F7r
			; sub_29B06+10Br
			; sub_29B06+120r
			; sub_29B06+137r
			; sub_29B06+14Cr
			; sub_29B06+161r
			; sub_29B06+176r
			; idk_Mouse_s29C99+10r
			; idk_Mouse_s29C99+23r
			; idk_Mouse_s29C99+37r
			; idk_Mouse_s29C99+4Br
			; idk_Mouse_s29C99+5Fr
			; idk_Mouse_s29C99+73r
			; idk_Mouse_s29C99+87r
			; idk_Mouse_s29C99+9Br
			; idk_Mouse_s29C99+B0r
			; idk_Mouse_s29C99+C5r
			; idk_Mouse_s29C99+DAr
			; sub_29D8F+10r
			; sub_29D8F+24r
			; sub_29D8F+39r
			; sub_29D8F+4Er
			; sub_29D8F+63r
			; sub_29D8F+78r
			; sub_29D8F+8Cr
			; sub_29D8F+A1r
			; sub_29D8F+B6r
			; sub_29D8F+CBr
			; sub_29D8F+DFr
			; sub_29D8F+F4r
			; sub_29D8F:loc_29E98r
			; sub_29D8F:loc_29EADr
			; sub_29EC9+16r
			; sub_29EC9+27r
			; sub_29EC9+44r
			; sub_29EC9+63r
			; sub_29EC9+76r
			; sub_29EC9+8Br
			; sub_29EC9+9Fr
			; sub_29EC9+B1r
			; sub_29EC9+C6r
			; sub_29EC9+D9r
			; sub_29EC9+EEr
			; sub_29EC9+103r
			; sub_29EC9+118r
			; sub_29EC9+12Dr
			; sub_29EC9+142r
			; sub_2A058+1Er
			; sub_2A058+32r
			; sub_2A058:loc_2A09Fr
			; sub_2A058+5Br
			; sub_2A058+6Er
			; sub_2A058+83r
			; sub_2A058+96r
			; sub_2A058+ABr
			; sub_2A058+C0r
			; sub_2A058+D5r
			; sub_2A058+EAr
			; sub_2A058+103r
			; sub_2A058+119r
			; sub_2A058+12Dr
			; sub_2A058+141r
			; sub_2A058+156r
			; sub_2A058+16Br
			; sub_2A058+182r
			; sub_2A058+197r
			; sub_2A058+1ACr
			; sub_2A058+1C1r
			; sub_2A235+12r
			; sub_2A235+29r
			; sub_2A235+3Br
			; sub_2A235+60r
			; sub_2A235+75r
			; sub_2A235:loc_2A2BCr
			; sub_2A235+AEr
			; sub_2A235+C1r
			; sub_2A235+D7r
			; sub_2A235+E9r
			; sub_2A235+FCr
			; sub_2A235+116r
			; sub_2A235+128r
			; sub_2A235+14Er
			; sub_2A235+164r
			; sub_2A235+176r
			; sub_2A235+19Dr
			; sub_2A235+1B0r
			; sub_2A235+1C6r
			; sub_2A235+1D9r
			; sub_2A235+1F2r
			; sub_2A235+208r
			; sub_2A235+21Cr
			; sub_2A235+232r
			; sub_2A235+246r
			; sub_2A235:loc_2A48Fr
			; sub_2A4B2+12r
			; sub_2A4B2:loc_2A4D8r
			; sub_2A4B2+4Ar
			; sub_2A4B2+5Cr
			; sub_2A4B2+77r
			; sub_2A4B2+ABr
			; sub_2A4B2+E2r
			; sub_2A4B2+F9r
			; sub_2A4B2+10Fr
			; sub_2A5E4+12r
			; sub_2A5E4+26r
			; sub_2A5E4+4Ar
			; sub_2A5E4+5Cr
			; sub_2A5E4+77r
			; sub_2A5E4+AAr
			; sub_2A5E4+E1r
			; sub_2A5E4+F8r
			; sub_2A5E4+10Er
			; sub_2A755:loc_2AA07r
			; sub_2A755+688r
			; sub_2A755+7B7r
			; sub_2A755+7CAr
			; sub_2A755+969r
			; sub_2B1F9+183r
			; sub_2B1F9:loc_2B3FEr
			; sub_2B470:loc_2B499r
			; sub_2B470+48r
			; sub_2B470+64r
			; sub_2B470:loc_2B4F5r
			; sub_2B470+E3r
			; sub_2B470+FDr
			; sub_2B470+139r
			; sub_2B470+154r
			; sub_2B470:loc_2B5DEr
			; sub_2B470:loc_2B5EEr
			; sub_2B470+1ADr
			; sub_2B470+1CCr
			; sub_2B470+1E6r
			; sub_2B470:loc_2B687r
			; sub_2B470+265r
			; sub_2B470+28Fr
			; sub_2B470+2B7r
			; sub_2B470+2FCr
			; sub_2B470+30Er
			; sub_2B470+325r
			; sub_2B470+33Br
			; sub_2B470+34Dr
			; sub_2B470+365r
			; sub_2B470+3F7r
			; sub_2B470+409r
			; idk_Mouse_s2B8B1+18w
			; seg034:6C50r
			; seg034:6C64r
			; seg034:6C7Fr
			; seg034:6C93r
			; sub_2BA41+3Dr
			; sub_2BA41+51r
			; sub_2BA41+74r
			; sub_2BA41+94r
			; sub_2BA41:loc_2BAEFr
			; sub_2BA41+BFr
			; sub_2BA41+D0r
			; sub_2BA41:loc_2BB29r
			; sub_2BA41+F9r
			; sub_2BA41:loc_2BB60r
			; sub_2BA41+130r
			; sub_2BA41+142r
			; sub_2BA41+15Ar
			; sub_2BA41+172r
			; sub_2BA41+184r
			; sub_2BA41+19Br
			; sub_2BA41+1BAr
			; sub_2BA41+1D3r
			; sub_2BA41+1EDr
			; sub_2BA41+1FEr
			; sub_2BA41+20Fr
			; sub_2BA41+227r
			; sub_2BA41+238r
			; sub_2BA41+25Er
			; sub_2BA41+26Fr
			; sub_2BA41+281r
			; sub_2BA41+299r
			; sub_2BA41+2B1r
			; sub_2BA41+2C3r
			; sub_2BA41+2DAr
			; sub_2BA41+2F0r
			; sub_2BA41+304r
			; sub_2BA41+31Er
			; sub_2BA41+32Fr
			; sub_2BA41+340r
			; sub_2BA41+35Er
			; sub_2BA41+376r
			; sub_2BA41+387r
			; sub_2BA41+398r
			; sub_2BA41+3B0r
			; sub_2BA41+3C1r
			; sub_2BA41+3E7r
			; sub_2BA41+3F8r
			; sub_2BA41+40Ar
			; sub_2BA41+422r
			; sub_2BA41+43Er
			; sub_2BA41+450r
			; sub_2BA41+467r
			; sub_2BA41+48Ar
			; sub_2BA41:loc_2BEE4r
			; sub_2BA41+4BDr
			; sub_2BA41+4CEr
			; sub_2BA41+4DFr
			; sub_2BA41+4F7r
			; sub_2BA41+508r
			; sub_2BA41+52Er
			; sub_2BA41+53Fr
			; sub_2BA41+551r
			; sub_2BA41+569r
			; sub_2BA41+581r
			; sub_2BA41+593r
			; sub_2BA41+5AAr
			; sub_2BA41+5C0r
			; sub_2BA41+5D4r
			; sub_2BA41+5EEr
			; sub_2BA41+5FFr
			; sub_2BA41+610r
			; sub_2BA41+62Er
			; sub_2BA41+646r
			; sub_2BA41+657r
			; sub_2BA41+668r
			; sub_2BA41+680r
			; sub_2BA41+691r
			; sub_2BA41+6B7r
			; sub_2BA41+6C8r
			; sub_2BA41+6DAr
			; sub_2BA41+6F2r
			; sub_2BA41+70Er
			; sub_2BA41+720r
			; sub_2BA41+737r
			; sub_2BA41+75Ar
			; sub_2BA41+76Er
			; sub_2BA41+785r
			; sub_2BA41+79Cr
			; sub_2BA41+7ADr
			; sub_2BA41+7BEr
			; sub_2BA41+7D6r
			; sub_2BA41:loc_2C228r
			; sub_2BA41+80Dr
			; sub_2BA41+81Er
			; sub_2BA41+830r
			; sub_2BA41+848r
			; sub_2BA41+860r
			; sub_2BA41+872r
			; sub_2BA41+889r
			; sub_2BA41+89Fr
			; sub_2BA41+8B3r
			; sub_2BA41+8CDr
			; sub_2BA41+8DEr
			; sub_2BA41+8EFr
			; sub_2BA41+90Dr
			; sub_2BA41+925r
			; sub_2BA41+936r
			; sub_2BA41+947r
			; sub_2BA41+95Fr
			; sub_2BA41+970r
			; sub_2BA41+996r
			; sub_2BA41+9A7r
			; sub_2BA41+9B9r
			; sub_2BA41+9D1r
			; sub_2BA41+9EDr
			; sub_2BA41+9FFr
			; sub_2BA41+A16r
			; sub_2BA41+A3Dr
			; sub_2BA41+A4Er
			; sub_2BA41+A87r
			; sub_2BA41+A9Br
			; sub_2BA41+AB2r
			; sub_2BA41+ACCr
			; sub_2BA41+ADDr
			; sub_2BA41+AF6r
			; sub_2BA41+B07r
			; sub_2BA41+B1Ar
			; sub_2BA41+B35r
			; sub_2BA41+B46r
			; sub_2BA41+B57r
			; sub_2BA41:loc_2C5A9r
			; sub_2BA41+B79r
			; sub_2BA41+B8Ar
			; sub_2BA41+BA0r
			; sub_2BA41+BB1r
			; sub_2BA41+BC7r
			; sub_2BA41+BE1r
			; sub_2BA41+BF2r
			; sub_2BA41+C05r
			; sub_2BA41+C29r
			; sub_2BA41+C3Ar
			; sub_2BA41+C4Br
			; sub_2BA41+C64r
			; sub_2BA41+C78r
			; sub_2BA41+C89r
			; sub_2BA41+C9Ar
			; sub_2BA41+CABr
			; sub_2BA41+CBCr
			; sub_2BA41+CD6r
			; sub_2BA41+CEAr
			; sub_2BA41+CFBr
			; sub_2BA41+D0Cr
			; sub_2BA41+D23r
			; sub_2BA41+D34r
			; sub_2BA41:loc_2C786r
			; sub_2BA41+D61r
			; sub_2BA41+D75r
			; sub_2BA41+D99r
			; sub_2BA41+DAFr
			; sub_2BA41+DC3r
			; sub_2BA41+DD9r
			; sub_2BA41+E09r
			; sub_2BA41+E2Er
			; sub_2BA41+E3Fr
			; sub_2BA41+E50r
			; sub_2BA41+E6Br
			; sub_2BA41+E7Cr
			; sub_2BA41+E8Dr
			; sub_2BA41+EA5r
			; sub_2BA41+EB6r
			; sub_2BA41+EC7r
			; sub_2BA41+EE2r
			; sub_2BA41+EF6r
			; sub_2BA41+F07r
			; sub_2BA41+F18r
			; sub_2BA41+F29r
			; sub_2BA41+F3Ar
			; sub_2BA41+F54r
			; sub_2BA41+F65r
			; sub_2BA41+F76r
			; sub_2BA41:loc_2C9D6r
			; sub_2BA41+FBAr
			; sub_2BA41+FCBr
			; sub_2BA41+FDCr
			; sub_2BA41+FF7r
			; sub_2BA41+1008r
			; sub_2BA41+1019r
			; sub_2BA41+1031r
			; sub_2BA41+1042r
			; sub_2BA41+1053r
			; sub_2BA41+1073r
			; sub_2BA41+1087r
			; sub_2BA41+1098r
			; sub_2BA41+10A9r
			; sub_2BA41+10BAr
			; sub_2BA41+10CBr
			; sub_2BA41+1132r
			; sub_2BA41+1158r
			; sub_2BA41+116Er
			; sub_2BA41+1193r
			; sub_2BA41+11A7r
			; sub_2BA41+11B8r
			; sub_2BA41+11C9r
			; sub_2BA41+11E5r
			; sub_2BA41+11F6r
			; sub_2BA41:loc_2CC66r
			; sub_2BA41+1240r
			; sub_2BA41+1251r
			; sub_2BA41+1262r
			; sub_2BA41+1273r
			; sub_2BA41:loc_2CCD0r
			; sub_2BA41+12A0r
			; sub_2BA41+12B0r
			; sub_2BA41+12C1r
			; sub_2BA41+12DDr
			; sub_2BA41+12EEr
			; sub_2BA41+12FFr
			; sub_2BA41+1310r
			; sub_2BA41+132Cr
			; sub_2BA41+133Dr
			; sub_2BA41+134Er
			; sub_2BA41:loc_2CDA0r
			; sub_2CF44+12r
			; sub_2CF44+3Br
			; sub_2CF44+55r
			; sub_2CF44+66r
			; sub_2CF44+77r
			; sub_2CF44+8Fr
			; sub_2CF44+A0r
			; sub_2CF44+C6r
			; sub_2CF44+D7r
			; sub_2CF44+E9r
			; sub_2CF44+101r
			; sub_2CF44:loc_2D05Dr
			; sub_2CF44+12Br
			; sub_2CF44+142r
			; sub_2CF44+158r
			; sub_2CF44+16Cr
			; sub_2CF44+186r
			; sub_2CF44+197r
			; sub_2CF44:loc_2D0ECr
			; sub_2CF44+1C6r
			; sub_2CF44+1E1r
			; sub_2CF44+1F2r
			; sub_2CF44+203r
			; sub_2CF44+21Br
			; sub_2CF44+22Cr
			; sub_2CF44+252r
			; sub_2CF44+263r
			; sub_2CF44+275r
			; sub_2CF44+28Dr
			; sub_2CF44+2A9r
			; sub_2CF44+2BBr
			; sub_2CF44+2D2r
			; sub_2CF44+2FBr
			; sub_2CF44+314r
			; sub_2CF44+32Er
			; sub_2CF44+33Fr
			; sub_2CF44+350r
			; sub_2CF44+368r
			; sub_2CF44+379r
			; sub_2CF44+39Fr
			; sub_2CF44+3B0r
			; sub_2CF44+3C2r
			; sub_2CF44+3DAr
			; sub_2CF44+3F2r
			; sub_2CF44+404r
			; sub_2CF44:loc_2D35Fr
			; sub_2CF44+431r
			; sub_2CF44+445r
			; sub_2CF44+45Fr
			; sub_2CF44+470r
			; sub_2CF44+481r
			; sub_2CF44+49Fr
			; sub_2CF44+4BAr
			; sub_2CF44+4CBr
			; sub_2CF44+4DCr
			; sub_2CF44+4F4r
			; sub_2CF44+505r
			; sub_2CF44+52Br
			; sub_2CF44+53Cr
			; sub_2CF44+54Er
			; sub_2CF44+566r
			; sub_2CF44+582r
			; sub_2CF44+594r
			; sub_2CF44+5ABr
			; sub_2CF44+5CEr
			; sub_2CF44+5F0r
			; sub_2CF44+60Ar
			; sub_2CF44+61Br
			; sub_2CF44+62Cr
			; sub_2CF44+644r
			; sub_2CF44+655r
			; sub_2CF44+67Br
			; sub_2CF44+68Cr
			; sub_2CF44+69Er
			; sub_2CF44+6B6r
			; sub_2CF44+6CEr
			; sub_2CF44+6E0r
			; sub_2CF44+6F7r
			; sub_2CF44+70Dr
			; sub_2CF44+721r
			; sub_2CF44+73Br
			; sub_2CF44+74Cr
			; sub_2CF44+75Dr
			; sub_2CF44:loc_2D6BFr
			; sub_2CF44+796r
			; sub_2CF44+7A7r
			; sub_2CF44+7B8r
			; sub_2CF44+7D0r
			; sub_2CF44+7E1r
			; sub_2CF44+807r
			; sub_2CF44+818r
			; sub_2CF44+82Ar
			; sub_2CF44+842r
			; sub_2CF44:loc_2D7A2r
			; sub_2CF44+870r
			; sub_2CF44+887r
			; sub_2CF44+8B0r
			; sub_2CF44+8C7r
			; sub_2CF44+8D9r
			; sub_2CF44+8EFr
			; sub_2CF44+903r
			; sub_2CF44+91Ar
			; sub_2CF44+931r
			; sub_2CF44+942r
			; sub_2CF44+953r
			; sub_2CF44+96Br
			; sub_2CF44+97Cr
			; sub_2CF44+9A2r
			; sub_2CF44+9B3r
			; sub_2CF44+9C5r
			; sub_2CF44+9DDr
			; sub_2CF44+9F5r
			; sub_2CF44+A07r
			; sub_2CF44+A1Er
			; sub_2CF44+A34r
			; sub_2CF44+A48r
			; sub_2CF44+A62r
			; sub_2CF44+A73r
			; sub_2CF44+A84r
			; sub_2CF44+AA2r
			; sub_2CF44+ABAr
			; sub_2CF44+ACBr
			; sub_2CF44+ADCr
			; sub_2CF44+AF4r
			; sub_2CF44+B05r
			; sub_2CF44+B2Br
			; sub_2CF44+B3Cr
			; sub_2CF44+B4Er
			; sub_2CF44+B66r
			; sub_2CF44+B82r
			; sub_2CF44+B94r
			; sub_2CF44+BABr
			; sub_2CF44+BD4r
			; sub_2CF44+BEBr
			; sub_2CF44+BFFr
			; sub_2CF44+C11r
			; sub_2CF44+C2Br
			; sub_2CF44+C3Cr
			; sub_2CF44+C75r
			; sub_2CF44+C89r
			; sub_2CF44+CA0r
			; sub_2CF44+CB4r
			; sub_2CF44+CC5r
			; sub_2CF44+CD8r
			; sub_2CF44+CF6r
			; sub_2CF44+D07r
			; sub_2CF44+D20r
			; sub_2CF44+D31r
			; sub_2CF44+D44r
			; sub_2CF44+D64r
			; sub_2CF44+D75r
			; sub_2CF44+D86r
			; sub_2CF44+D97r
			; sub_2CF44+DA8r
			; sub_2CF44+DB9r
			; sub_2CF44+DCFr
			; sub_2CF44+DE0r
			; sub_2CF44:loc_2DD3Ar
			; sub_2CF44:loc_2DD54r
			; sub_2CF44+E21r
			; sub_2CF44+E34r
			; sub_2CF44+E5Er
			; sub_2CF44+E70r
			; sub_2CF44+E84r
			; sub_2CF44+E9Er
			; sub_2CF44+EB1r
			; sub_2CF44+EC5r
			; sub_2CF44+ED9r
			; sub_2CF44+EEBr
			; sub_2CF44+EFDr
			; sub_2CF44:loc_2DE55r
			; sub_2CF44+F27r
			; sub_2CF44+F39r
			; sub_2CF44+F4Br
			; sub_2CF44+F5Fr
			; sub_2CF44+F73r
			; sub_2CF44+F85r
			; sub_2CF44+F98r
			; sub_2CF44+FACr
			; sub_2CF44+FC2r
			; sub_2CF44+FD4r
			; sub_2CF44+FE7r
			; sub_2CF44+FFBr
			; sub_2CF44+100Fr
			; sub_2CF44+1025r
			; sub_2CF44:loc_2DF7Er
			; sub_2CF44:loc_2DF94r
			; sub_2CF44+107Br
			; sub_2CF44+108Dr
			; sub_2E00A+68r
			; sub_2E00A+BEr
			; sub_2E00A:loc_2E0DCr
			; sub_2E00A+E7r
			; sub_2E00A+FBr
			; sub_2E00A+10Fr
			; sub_2E00A+14Er
			; idk_Mouse_s2B8B1+14w
word_3C5B6 dw 0		; DATA XREF: idk_DosReadFromFileHAndle_s2FC56+7Do
			; idk_DosReadFromFileHAndle_s2FC56+8Dr
			; idk_DosReadFromFileHAndle_s2FC56+98r
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C5BE db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
itr_tokens_AIDT	dw 0	; DATA XREF: idk_Env_BLASTER_s3095D:loc_30A7Cr
			; idk_Env_BLASTER_s3095D:loc_30A86r
			; idk_Env_BLASTER_s3095D+130w
			; idk_Env_BLASTER_s3095D:loc_30A93r
byte_3C5D2 db 0		; DATA XREF: idk_DosReadFromFileHAndle_s2FC56+4Er
byte_3C5D3 db 0		; DATA XREF: idk_DosReadFromFileHAndle_s2FC56+3Cr
			; idk_DosReadFromFileHAndle_s2FC56:loc_2FC9Br
word_3C5D4 dw 0		; DATA XREF: idk_DosReadFromFileHAndle_s2FC56+61r
word_3C5D6 dw 0		; DATA XREF: idk_DosReadFromFileHAndle_s2FC56+5Dr
idk_FAT_FileExtension_w3C5D8 dw	0
			; DATA XREF: ST_LoadSoundDrivers+5ACo
			; ST_LoadSoundDrivers+5B8o
unk_3C5DA db	0
db    0
db    0
db    0
unk_3C5DE db	0
db    0
db    0
db    0
db    0
db    0
unk_3C5E4 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
dword_3C5EE dd 0	; DATA XREF: idk_DosReadFromFileHAndle_s2FC56+89r
			; idk_DosReadFromFileHAndle_s2FC56+9Fr
			; idk_DosReadFromFileHAndle_s2FC56+B6r
			; ST_LoadSoundDrivers+638w
			; idk_DosReadFromFileHAndle_s2FC56+A5r
			; idk_DosReadFromFileHAndle_s2FC56+B2r
			; ST_LoadSoundDrivers+634w
word_3C5F2 dw 0		; DATA XREF: ST_LoadSound+116w
			; ST_LoadSound+119r
			; ST_LoadSound+126r
word_3C5F4 dw 0		; DATA XREF: ST_LoadSound+112w
			; ST_LoadSound+11Cr
			; ST_LoadSound+122r
; void far *AIL_driver_base_addr2a
AIL_driver_base_addr2a dw 0
			; DATA XREF: ST_LoadSoundDrivers+17Dw
			; ST_LoadSoundDrivers+1A9r
AIL_driver_base_addr2b dw 0
			; DATA XREF: ST_LoadSoundDrivers+179w
			; ST_LoadSoundDrivers+1A5r
; void far *AIL_driver_base_addr1a
AIL_driver_base_addr1a dw 0
			; DATA XREF: ST_LoadSoundDrivers+155w
			; ST_LoadSoundDrivers+190r
AIL_driver_base_addr1b dw 0
			; DATA XREF: ST_LoadSoundDrivers+151w
			; ST_LoadSoundDrivers+18Cr
idk_AIL_DrvDesc2_d3C5FE	dd 0
			; DATA XREF: ST_LoadSoundDrivers:loc_2FF4Fw
			; ST_LoadSoundDrivers:loc_2FF81r
			; ST_LoadSoundDrivers+301r
			; ST_LoadSoundDrivers+30Cr
			; ST_LoadSoundDrivers+31Dr
			; ST_LoadSoundDrivers+328r
			; ST_LoadSoundDrivers+339r
			; ST_LoadSoundDrivers+344r
			; ST_LoadSoundDrivers:loc_3013Er
			; ST_LoadSoundDrivers+431r
			; ST_LoadSoundDrivers+439r
			; ST_LoadSoundDrivers+441r
			; ST_LoadSoundDrivers+462r
			; ST_LoadSoundDrivers+46Dr
			; ST_LoadSoundDrivers+478r
			; ST_LoadSoundDrivers+483r
			; ST_LoadSoundDrivers+48Br
			; ST_LoadSoundDrivers+493r
			; ST_LoadSoundDrivers+49Br
			; ST_LoadSoundDrivers+4F6r
			; ST_LoadSoundDrivers+4FEr
			; ST_LoadSoundDrivers+506r
			; ST_LoadSoundDrivers+50Er
			; ST_LoadSoundDrivers+236w
idk_AIL_DrvDesc1_d3C602	dd 0
			; DATA XREF: ST_LoadSoundDrivers+222w
			; ST_LoadSoundDrivers:loc_2FF52r
			; ST_LoadSoundDrivers+2A7r
			; ST_LoadSoundDrivers+2B2r
			; ST_LoadSoundDrivers+2C3r
			; ST_LoadSoundDrivers+2CEr
			; ST_LoadSoundDrivers+2DFr
			; ST_LoadSoundDrivers+2EAr
			; ST_LoadSoundDrivers:loc_3006Er
			; ST_LoadSoundDrivers+361r
			; ST_LoadSoundDrivers+369r
			; ST_LoadSoundDrivers+371r
			; ST_LoadSoundDrivers+392r
			; ST_LoadSoundDrivers+39Dr
			; ST_LoadSoundDrivers:loc_300BDr
			; ST_LoadSoundDrivers+3B3r
			; ST_LoadSoundDrivers+3BBr
			; ST_LoadSoundDrivers+3C3r
			; ST_LoadSoundDrivers+3CBr
			; ST_LoadSoundDrivers+529r
			; ST_LoadSoundDrivers+531r
			; ST_LoadSoundDrivers+539r
			; ST_LoadSoundDrivers+541r
			; ST_LoadSoundDrivers+59Er
			; ST_LoadSoundDrivers+21Ew
			; ST_LoadSoundDrivers+5A4r
LdSndDrv_w3C606	dw 0	; DATA XREF: ST_LoadSound+1B5w
			; ST_LoadSound+1B8r
			; ST_LoadSound+220r
			; ST_LoadSound+238r
			; ST_LoadSound+2BAw
			; ST_LoadSound+2BDr
			; ST_LoadSound+311r
			; ST_LoadSound+33Dr
LdSndDrv_w3C608	dw 0	; DATA XREF: ST_LoadSound+1B1w
			; ST_LoadSound+1BBr
			; ST_LoadSound+21Cr
			; ST_LoadSound+234r
			; ST_LoadSound+2B6w
			; ST_LoadSound+2C0r
			; ST_LoadSound+30Dr
			; ST_LoadSound+339r
word_3C60A dw 0		; DATA XREF: ST_LoadSound+80w
			; ST_LoadSound+83r
			; ST_LoadSound+B8r
word_3C60C dw 0		; DATA XREF: ST_LoadSound+7Cw
			; ST_LoadSound+86r
			; ST_LoadSound+B4r
; char idk_FileName_w3C60E
idk_FileName_w3C60E dw 0
			; DATA XREF: ST_LoadSoundDrivers+593o
			; ST_LoadSoundDrivers+5BCo
			; ST_LoadSound+E8o
unk_3C610 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
idk_DosFileHandle_w3C61E dw 0
			; DATA XREF: ST_LoadSound+F3w
			; ST_LoadSound+107r
			; ST_LoadSound+175r
			; ST_LoadSound+17Cr
_atexittbl dw 0, 0	; DATA XREF: _atexit+21w
			; __exit_2of2+19r
			; _atexit+1Dw
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
dw 0, 0
unk_3C6A0 db	0
unk_3C6A1 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C6AE db	0	; DATA XREF: sub_10C20:loc_10C3Ao
			; sub_10C20+8Ao
db    0
db    0
db    0
db    0
db    0
unk_3C6B4 db	0	; DATA XREF: sub_10C20+1Eo
			; sub_10C20+86o
			; sub_10C20+B2o
			; sub_10C20+D7o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
byte_3C6BE db 0		; DATA XREF: sub_10C20+22o
			; sub_10C20+82o
			; sub_10C20+AEo
			; sub_10C20+D3o
			; sub_10C20+13Fr
			; sub_10C20:loc_10D69w
byte_3C6BF db 0		; DATA XREF: sub_10C20+14Ew
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C6CA db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C6D1 db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C6FA db	0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C701 db	0	; DATA XREF: sub_10C20+26o
			; sub_10C20+7Eo
			; sub_10C20+AAo
			; sub_10C20+CFo
db    0
db    0
db    0
unk_3C705 db	0	; DATA XREF: sub_10C20+8o
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
unk_3C72A db	0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
dw 0
db    0
db    0
fgetc_b3C756 db	0	; DATA XREF: _fgetc:loc_1258Fr
			; _fgetc+A7r
align 2
fputc_b3C758 db	0	; DATA XREF: _fputc+Bw
			; _fputc:loc_128A8r
			; _fputc+2Er
			; _fputc+8Br
			; _fputc:loc_1291Br
			; _fputc+A1r
			; _fputc:loc_12962r
			; _fputc:loc_129AEr
align 2
ends dseg


; Segment type:	Pure data
segment	seg054 byte stack 'STACK' use16
assume cs:seg054
byte_3C760 db 80h dup(0)
ends seg054


; Segment type:	Pure code
segment	ovr048 para public 'OVERLAY' use16
assume cs:ovr048
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

; int __fastcall __far OVR_SaveGame_MagicSet(int, int, int, int)
proc OVR_SaveGame_MagicSet far
			; CODE XREF: j_OVR_SaveGame_MagicSetJ

argPtrCharArr= byte ptr	-2Ah
asczFileName= byte ptr -16h
argFileStream= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2Ah		; Integer Subtraction
push	si
push	di		; argConversionBase
mov	di, [bp+arg_0]
mov	ax, 10
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	ax, di
inc	ax		; Increment by 1
push	ax		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, offset strSAVEGAMr2_1 ; "SAVE"
push	ax
lea	ax, [bp+asczFileName] ;	Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+asczFileName] ;	Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strSAVEGAMr2_2 ; ".GAM"
push	ax
lea	ax, [bp+asczFileName] ;	Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strWBr2 ; "wb"
push	ax
lea	ax, [bp+asczFileName] ;	int
push	ax		; asczFileName
call	DOS_OpenFileModeCheck ;	Call Procedure
pop	cx
pop	cx
mov	si, ax
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[idk_SavGamDS_w382BE]
push	[idk_SavGamDS_w382BC]
call	OVR_DOS_WriteToFileWithHandle ;
			; argWriteBuffer_DX
			; argWriteBuffer_DS
			; argByteCount
			; argWriteCount
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382C2]
push	[word_382C0]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382C6]
push	[word_382C4]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382CA]
push	[word_382C8]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382CE]
push	[word_382CC]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382D2]
push	[word_382D0]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4E2
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4E0
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 10		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4DE
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4DC
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4DA
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4D8
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 10		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset unk_3A4D6
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset unk_3A4D4
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 6
push	ax
mov	ax, 1224
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset byte_38610
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 4800
push	ax
push	[word ptr dword_3A702+2]
push	[word ptr dword_3A702]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 10		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 96
push	ax
push	[word_3A700]
push	[word_3A6FE]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 10		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 96
push	ax
push	[word_3A6FC]
push	[word_3A6FA]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 10		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 2400
push	ax
push	[word ptr dword_3A6F6+2]
push	[word ptr dword_3A6F6]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 30
push	ax
mov	ax, 48
push	ax
push	[word ptr dword_3A6F2+2]
push	[word ptr dword_3A6F2]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 10		; Add
push	si
mov	ax, 6
push	ax
mov	ax, 4
push	ax
push	[word ptr dword_3A6EE+2]
push	[word ptr dword_3A6EE]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 6
push	ax
mov	ax, 4
push	ax
push	[word ptr dword_3A6EA+2]
push	[word ptr dword_3A6EA]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 102
push	ax
mov	ax, 24
push	ax
push	[word ptr dword_3A6E6+2]
push	[word ptr dword_3A6E6]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 138
push	ax
mov	ax, 50
push	ax
push	[word ptr dword_381C0+2]
push	[word ptr dword_381C0]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 100
push	ax
mov	ax, 114
push	ax
push	[word ptr dword_3A6E2+2]
push	[word ptr dword_3A6E2]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 1009
push	ax
mov	ax, 32
push	ax
push	[word ptr dword_38608+2]
push	[word ptr dword_38608]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 2400
push	ax
push	[word ptr dword_3A6DE+2]
push	[word ptr dword_3A6DE]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 2400
push	ax

loc_3CAE0:
push	[word ptr dword_3A6D6+2]
push	[word ptr dword_3A6D6]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
call	CALL_DOS_MapMemory ; Call Procedure
push	si
mov	ax, 2
push	ax
mov	ax, offset unk_35550
push	ax
push	[word ptr dword_3A6D2+2]
push	[word ptr dword_3A6D2]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 10		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 100
push	ax
push	[word ptr dword_37EC8+2]
push	[word ptr dword_37EC8]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 10		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 2400
push	ax
push	[word ptr dword_3A6DA+2]
push	[word ptr dword_3A6DA]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_38468
push	ax
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 250
push	ax
mov	ax, 1
push	ax
push	[word ptr dword_381C4+2]
push	[word ptr dword_381C4]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 16
push	ax
push	[word_3860E]
push	[word_3860C]
call	OVR_DOS_WriteToFileWithHandle ;	Call Procedure
add	sp, 0Ah		; Add
push	si
call	DOS_CloseFileHandle ; Call Procedure
pop	cx
cmp	di, FILE.buffer	; Compare Two Operands
jge	short loc_3CBD2	; Jump if Greater or Equal (SF=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	[idk_MagSet_w3A514+bx],	1 ;
			;
			;
			;
mov	ax, offset strWBr2 ; "wb"
push	ax
mov	ax, offset strMAGIC_SETr2 ; "MAGIC.SET"
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	[bp+argFileStream], ax
push	[bp+argFileStream] ; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 466		; SizeOF(MAGIC.SET)
push	ax
mov	ax, offset MagSet_01
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
push	[bp+argFileStream] ; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx

loc_3CBD2:		; CODE XREF: OVR_SaveGame_MagicSet+3B4j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp OVR_SaveGame_MagicSet ; sp-analysis failed



; Attributes: bp-based frame

; int __fastcall __far ST_LoadSaveGamByNbr(int,	int, int, int argSaveGamNbr)
proc ST_LoadSaveGamByNbr far
			; CODE XREF: j_ST_LoadSaveGamByNbrJ

argPtrCharArr= byte ptr	-28h
argFileName= byte ptr -14h
argSaveGamNbr= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 28h		; Integer Subtraction
push	si
push	di
mov	ax, 10
push	ax		; argConversionBase
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	ax, [bp+argSaveGamNbr]
inc	ax		; Increment by 1
push	ax		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, offset strSAVEGAMr2_1 ; "SAVE"
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strSAVEGAMr2_2 ; ".GAM"
push	ax
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
xor	di, di		; Logical Exclusive OR
lea	ax, [bp+argFileName] ; Load Effective Address
push	ax		; argFileName
call	DOS_FindFirst	; char *argFileName {AX	= FileSize DX =	FileName}
pop	cx
cmp	dx, 1		; Compare Two Operands
jnz	short loc_3CC38	; Jump if Not Zero (ZF=0)
cmp	ax, 0E1A4h	; Compare Two Operands
jz	short loc_3CC3B	; Jump if Zero (ZF=1)

loc_3CC38:		; CODE XREF: ST_LoadSaveGamByNbr+59j
mov	di, 1

loc_3CC3B:		; CODE XREF: ST_LoadSaveGamByNbr+5Ej
mov	ax, offset strRBr2 ; "rb"
push	ax
lea	ax, [bp+argFileName] ; int
push	ax		; asczFileName
call	DOS_OpenFileModeCheck ;	Call Procedure
pop	cx
pop	cx
mov	si, ax

loc_3CC4C:
push	si

loc_3CC4D:
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[idk_SavGamDS_w382BE]
push	[idk_SavGamDS_w382BC]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 10		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382C2]
push	[word_382C0]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 10		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382C6]
push	[word_382C4]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 10		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382CA]
push	[word_382C8]

loc_3CCA8:		;
call	DOS_ReadFromFile_0 ;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 10		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382CE]

loc_3CCBD:
push	[word_382CC]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 10		; Add
push	si
mov	ax, 35
push	ax
mov	ax, 12
push	ax
push	[word_382D2]
push	[word_382D0]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4E2
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4E0
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4DE
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4DC
push	ax

loc_3CD3A:		;
call	DOS_ReadFromFile_0 ;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4DA
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_3A4D8
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset unk_3A4D6
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset unk_3A4D4
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 6
push	ax
mov	ax, 1224
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset byte_38610
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 4800
push	ax
push	[word ptr dword_3A702+2]
push	[word ptr dword_3A702]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 96
push	ax
push	[word_3A700]
push	[word_3A6FE]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 96
push	ax
push	[word_3A6FC]
push	[word_3A6FA]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 2400
push	ax
push	[word ptr dword_3A6F6+2]
push	[word ptr dword_3A6F6]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1Eh
push	ax
mov	ax, 48
push	ax
push	[word ptr dword_3A6F2+2]
push	[word ptr dword_3A6F2]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 6
push	ax
mov	ax, 4
push	ax
push	[word ptr dword_3A6EE+2]
push	[word ptr dword_3A6EE]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 6
push	ax
mov	ax, 4
push	ax
push	[word ptr dword_3A6EA+2]
push	[word ptr dword_3A6EA]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 102
push	ax
mov	ax, 24
push	ax
push	[word ptr dword_3A6E6+2]
push	[word ptr dword_3A6E6]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 138
push	ax
mov	ax, 50
push	ax
push	[word ptr dword_381C0+2]
push	[word ptr dword_381C0]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 100
push	ax
mov	ax, 114
push	ax
push	[word ptr dword_3A6E2+2]
push	[word ptr dword_3A6E2]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1009
push	ax
mov	ax, 32
push	ax
push	[word ptr dword_38608+2]
push	[word ptr dword_38608]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 2400
push	ax
push	[word ptr dword_3A6DE+2]
push	[word ptr dword_3A6DE]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 2400
push	ax
push	[word ptr dword_3A6D6+2]
push	[word ptr dword_3A6D6]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
call	CALL_DOS_MapMemory ; Call Procedure
push	si
mov	ax, 2
push	ax
mov	ax, 14400
push	ax
push	[word ptr dword_3A6D2+2]
push	[word ptr dword_3A6D2]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 100
push	ax
push	[word ptr dword_37EC8+2]
push	[word ptr dword_37EC8]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 2
push	ax
mov	ax, 2400
push	ax
push	[word ptr dword_3A6DA+2]
push	[word ptr dword_3A6DA]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 1
push	ax
mov	ax, 2
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset word_38468
push	ax
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
push	si
mov	ax, 250
push	ax
mov	ax, 1
push	ax
push	[word ptr dword_381C4+2]
push	[word ptr dword_381C4]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
or	di, di		; Logical Inclusive OR
jnz	short loc_3CF9F	; Jump if Not Zero (ZF=0)
push	si
mov	ax, 35
push	ax
mov	ax, 16
push	ax
push	[word_3860E]
push	[word_3860C]
call	DOS_ReadFromFile_0 ;
			;   arg_0=
			;   arg_2=
			;   arg_4=
			;   arg_6=
			;
add	sp, 0Ah		; Add
jmp	short loc_3CFB3	; Jump

loc_3CF9F:		; CODE XREF: ST_LoadSaveGamByNbr+3AAj
mov	ax, 545
push	ax
push	[word_3860E]
push	[word_3860C]
call	sub_1CF4E	; Call Procedure
add	sp, 6		; Add

loc_3CFB3:		; CODE XREF: ST_LoadSaveGamByNbr+3C5j
push	si
call	DOS_CloseFileHandle ; Call Procedure
pop	cx
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_LoadSaveGamByNbr ; sp-analysis failed

ends ovr048


; Segment type:	Pure code
segment	ovr049 para public 'OVERLAY' use16
assume cs:ovr049
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_3CFC0 far	; CODE XREF: sub_31835J

var_68=	word ptr -68h
var_4A=	word ptr -4Ah
var_34=	word ptr -34h
var_32=	word ptr -32h
var_30=	word ptr -30h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_14=	word ptr -14h
var_C= word ptr	-0Ch
argFileStream= word ptr	-0Ah
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 68h		; Integer Subtraction

loc_3CFC6:
push	si
push	di		; argDestination
lea	ax, [bp+var_4A]	; Load Effective Address
push	ss
push	ax
mov	ax, offset a5	; "5"
push	ds
push	ax
mov	cx, 26
call	SCOPY@		; Call Procedure


push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
mov	ax, 11
push	ax		; argEntryNumber
mov	ax, offset strLOAD_LBX ; "LOAD.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LoadLbx_w3A750], ax


push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 4
push	ax		; argFileName
mov	ax, offset strLOAD_LBX ; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LoadLbx_w3A74A], ax


xor	si, si		; Logical Exclusive OR
jmp	short loc_3D02B	; Jump

loc_3D00C:		; CODE XREF: sub_3CFC0+6Ej
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 13		; Add
push	ax		; argFileName
mov	ax, offset strLOAD_LBX ; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word_3A718+bx], ax
inc	si		; Increment by 1

loc_3D02B:		; CODE XREF: sub_3CFC0+4Aj
cmp	si, 3		; Compare Two Operands
jl	short loc_3D00C	; Jump if Less (SF!=OF)

loc_3D030:		; Logical Exclusive OR
xor	si, si
jmp	short loc_3D053	; Jump

loc_3D034:		; CODE XREF: sub_3CFC0+96j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 16		; Add
push	ax		; argFileName
mov	ax, offset strLOAD_LBX ; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word_3A712+bx], ax
inc	si		; Increment by 1

loc_3D053:		; CODE XREF: sub_3CFC0+72j
cmp	si, 3		; Compare Two Operands
jl	short loc_3D034	; Jump if Less (SF!=OF)

loc_3D058:		; Logical Exclusive OR
xor	si, si
jmp	short loc_3D07B	; Jump

loc_3D05C:		; CODE XREF: sub_3CFC0+BEj
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 19		; Add
push	ax		; argFileName
mov	ax, offset strLOAD_LBX ; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word_3A70C+bx], ax
inc	si		; Increment by 1

loc_3D07B:		; CODE XREF: sub_3CFC0+9Aj
cmp	si, 2		; Compare Two Operands
jl	short loc_3D05C	; Jump if Less (SF!=OF)

loc_3D080:		; Load Effective Address
lea	ax, [bp+var_68]
push	ax
mov	ax, offset strMAGIC_SETr3 ; "MAGIC.SET"
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short Read_MagicSet ; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr ST_DefaultMagicSet ; Call Procedure
jmp	short loc_3D0CC	; Jump

Read_MagicSet:		; CODE XREF: sub_3CFC0+D1j
mov	ax, offset strRBr3 ; "rb"
push	ax
mov	ax, offset strMAGIC_SETr3 ; "MAGIC.SET"
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	[bp+argFileStream], ax
push	[bp+argFileStream] ; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 466
push	ax
mov	ax, offset MagSet_01
push	ax		; argPtrReadBuffer
call	_fread		; argPtrReadBuffer,argSize,argNumber,argPtrFileStream
add	sp, 8		; Add
push	[bp+argFileStream] ; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx

loc_3D0CC:		; CODE XREF: sub_3CFC0+D8j
mov	[word_3A71E], 87D4h
mov	ax, 28FEh
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure

loc_3D0DF:
pop	cx
pop	cx

loc_3D0E1:		;
call	setFlagsMaybeMouseEGA ;	mov	word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh

loc_3D0E6:
mov	ax, 2940h
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
mov	[bp+var_6], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 2942h
push	ax
mov	ax, 0BDh ; ''
push	ax

loc_3D0FF:
mov	ax, 132h
push	ax
mov	ax, 0AFh ; ''
push	ax
mov	ax, 109h
push	ax

loc_3D10B:		; Call Procedure
call	idk_Mouse_s29A0B
add	sp, 0Ch		; Add
mov	[word_3A736], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_3D162	; Jump

loc_3D11A:		; CODE XREF: sub_3CFC0+1A5j
mov	di, si

loc_3D11C:		; Compare Two Operands
cmp	di, 7

loc_3D11F:		; Jump if Not Zero (ZF=0)
jnz	short loc_3D124
mov	di, 8

loc_3D124:		; CODE XREF: sub_3CFC0:loc_3D11Fj
mov	ax, 0FFFFh
push	ax
mov	ax, 2932h
push	ax
mov	bx, di
shl	bx, 1		; Shift	Logical	Left

loc_3D130:		; Load Effective Address
lea	ax, [bp+var_4A]
add	bx, ax		; Add
mov	ax, [bx]
add	ax, 9		; Add
push	ax
mov	ax, 0AFh ; ''
push	ax

loc_3D13F:
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_4A]	; Load Effective Address

loc_3D146:		; Add
add	bx, ax
push	[word ptr bx]
mov	ax, 1Fh
push	ax

loc_3D14E:		; Call Procedure
call	idk_Mouse_s29A0B
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_30]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	si		; Increment by 1

loc_3D162:		; CODE XREF: sub_3CFC0+158j
cmp	si, 8		; Compare Two Operands
jl	short loc_3D11A	; Jump if Less (SF!=OF)
mov	ax, 0FFFFh
push	ax
mov	ax, 2932h
push	ax

loc_3D16F:
mov	ax, [bp+var_34]
add	ax, 9		; Add
push	ax
mov	ax, 0AFh ; ''
push	ax
push	[bp+var_34]
mov	ax, 1Fh
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_20], ax
mov	ax, 0FFFFh
push	ax

loc_3D190:
mov	ax, 2932h
push	ax
mov	ax, [bp+var_32]
add	ax, 9		; Add
push	ax
mov	ax, 0AFh ; ''
push	ax
push	[bp+var_32]
mov	ax, 1Fh

loc_3D1A5:
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_1E], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_3D201	; Jump

loc_3D1B5:		; CODE XREF: sub_3CFC0+244j
mov	di, si
cmp	si, 5		; Compare Two Operands
jle	short loc_3D1BD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
inc	di		; Increment by 1

loc_3D1BD:		; CODE XREF: sub_3CFC0+1FAj
cmp	si, 1		; Compare Two Operands

loc_3D1C0:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_3D1C3
inc	di		; Increment by 1

loc_3D1C3:		; CODE XREF: sub_3CFC0:loc_3D1C0j
mov	ax, 0FFFFh
push	ax
mov	ax, 2932h
push	ax
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
add	ax, 9		; Add
push	ax
mov	ax, 136h
push	ax
mov	bx, di

loc_3D1E0:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, 0C0h ; ''

loc_3D1EC:
push	ax

loc_3D1ED:		; Call Procedure
call	idk_Mouse_s29A0B
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_1C]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	si		; Increment by 1

loc_3D201:		; CODE XREF: sub_3CFC0+1F3j
cmp	si, 8		; Compare Two Operands
jl	short loc_3D1B5	; Jump if Less (SF!=OF)

loc_3D206:
mov	ax, 0FFFFh
push	ax
mov	ax, 2932h
push	ax
mov	ax, 53h	; 'S'
push	ax
mov	ax, 136h
push	ax
mov	ax, 4Ah	; 'J'
push	ax
mov	ax, 0C0h ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_C], ax
mov	[bp+var_2], 0

loc_3D22E:
mov	[word ptr bp-8], 0
mov	[word_3A73E], 0
mov	ax, 1
push	ax

loc_3D23D:
mov	ax, seg	stub049
push	ax
mov	ax, 20h	; ' '
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
nop			; No Operation
push	cs
call	near ptr LBX_HelpEntry_s3D9F3 ;	Call Procedure
jmp	loc_3D34C	; Jump

loc_3D255:		; CODE XREF: sub_3CFC0+392j
call	sub_2B97A	; Call Procedure
mov	[bp+var_4], ax

loc_3D25D:		; Call Procedure
call	_f020105_bios_timeofday
mov	ax, [bp+var_4]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_3D26F	; Jump if Not Zero (ZF=0)

loc_3D26A:
mov	[bp+var_2], 1

loc_3D26F:		; CODE XREF: sub_3CFC0+2A8j
mov	ax, [bp+var_4]
cmp	ax, [word_3A736] ; Compare Two Operands
jnz	short loc_3D2AF	; Jump if Not Zero (ZF=0)

Write_MagicSet:
mov	ax, offset strWBr3
push	ax
mov	ax, offset strMAGIC_SETr3 ; "MAGIC.SET"
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	[bp+argFileStream], ax
push	[bp+argFileStream] ; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 466
push	ax
mov	ax, offset MagSet_01
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
push	[bp+argFileStream] ; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx
mov	[bp+var_2], 1

loc_3D2AF:		; CODE XREF: sub_3CFC0+2B6j
xor	si, si		; Logical Exclusive OR
jmp	short loc_3D30B	; Jump

loc_3D2B3:		; CODE XREF: sub_3CFC0+34Ej
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_30]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]

loc_3D2BE:		; Compare Two Operands
cmp	ax, [bp+var_4]

loc_3D2C1:		; Jump if Not Zero (ZF=0)
jnz	short loc_3D2F0
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_3D2C7:
mov	bx, [word_3A71E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_3D2E2	; Jump if Not Zero (ZF=0)
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [word_3A71E]
add	bx, ax		; Add
mov	[word ptr bx], 1
jmp	short loc_3D2F0	; Jump

loc_3D2E2:		; CODE XREF: sub_3CFC0+310j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [word_3A71E]
add	bx, ax		; Add
mov	[word ptr bx], 0

loc_3D2F0:		; CODE XREF: sub_3CFC0:loc_3D2C1j
			; sub_3CFC0+320j
mov	ax, [bp+var_4]
cmp	ax, [bp+var_14]	; Compare Two Operands
jnz	short loc_3D30A	; Jump if Not Zero (ZF=0)
mov	[word_3797C], 0
mov	[word_3797A], 0
mov	[word_37978], 0

loc_3D30A:		; CODE XREF: sub_3CFC0+336j
inc	si		; Increment by 1

loc_3D30B:		; CODE XREF: sub_3CFC0+2F1j
cmp	si, 12h		; Compare Two Operands
jl	short loc_3D2B3	; Jump if Less (SF!=OF)
mov	ax, [bp+var_4]
cmp	ax, [bp+var_C]	; Compare Two Operands
jnz	short loc_3D322	; Jump if Not Zero (ZF=0)
mov	ax, 1
sub	ax, [MagSet_19]	; Integer Subtraction

loc_3D31F:
mov	[MagSet_19], ax

loc_3D322:		; CODE XREF: sub_3CFC0+356j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_3D34C	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_3D378 ; Call Procedure
call	sub_2E303	; Call Procedure
cmp	[word ptr bp-8], 0 ; Compare Two Operands
jnz	short loc_3D342	; Jump if Not Zero (ZF=0)
call	sub_1E525	; Call Procedure
mov	[word ptr bp-8], 1

loc_3D342:		; CODE XREF: sub_3CFC0+376j
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_3D34C:		; CODE XREF: sub_3CFC0+292j
			; sub_3CFC0+366j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_3D355	; Jump if Not Zero (ZF=0)
jmp	loc_3D255	; Jump

loc_3D355:		; CODE XREF: sub_3CFC0+390j
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure

loc_3D35F:		; Compare Two Operands
cmp	[word_3461A], 2
jnz	short loc_3D36C	; Jump if Not Zero (ZF=0)
mov	[word_37EC0], 1

loc_3D36C:		; CODE XREF: sub_3CFC0+3A4j
mov	[word_3461A], 3
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3CFC0



; Attributes: bp-based frame

proc sub_3D378 far	; CODE XREF: sub_31830J
			; sub_3CFC0+36Ap

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
mov	ax, [word_34638]

loc_3D383:
mov	dx, [word_34636]
mov	[bp+var_4], ax
mov	[bp+var_6], dx

loc_3D38D:		; Call Procedure
call	sub_2601C
mov	[bp+var_2], ax

loc_3D395:
push	[idk_LoadLbx_w3A750]

loc_3D399:		; Logical Exclusive OR
xor	ax, ax
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_3D3A7:		; Logical Exclusive OR
xor	ax, ax
push	ax
mov	ax, 0BDh ; ''
push	ax
mov	ax, 132h

loc_3D3B1:
push	ax
mov	ax, 0AFh ; ''
push	ax
mov	ax, 109h
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
mov	ax, 2Dh	; '-'
push	ax
mov	ax, 2
push	ax
mov	ax, 2
push	ax
call	sub_1922A	; Call Procedure
add	sp, 6		; Add
xor	di, di		; Logical Exclusive OR
xor	si, si		; Logical Exclusive OR
jmp	short loc_3D426	; Jump

loc_3D3DC:		; CODE XREF: sub_3D378+B1j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [word_3A71E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_3D3FD	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75FEh]
jmp	short loc_3D40D	; Jump

loc_3D3FD:		; CODE XREF: sub_3D378+71j
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75F8h]

loc_3D40D:		; CODE XREF: sub_3D378+83j
mov	ax, si

loc_3D40F:
mov	dx, 0Bh
imul	dx		; Signed Multiply

loc_3D414:		; Add
add	ax, 34h	; '4'
push	ax
mov	ax, 1Fh
push	ax

loc_3D41C:		; Call Procedure
call	sub_1F655
add	sp, 6		; Add
inc	di		; Increment by 1
inc	si		; Increment by 1

loc_3D426:		; CODE XREF: sub_3D378+62j
cmp	si, 3		; Compare Two Operands
jl	short loc_3D3DC	; Jump if Less (SF!=OF)

loc_3D42B:		; Logical Exclusive OR
xor	si, si

loc_3D42D:		; Jump
jmp	short loc_3D47C

loc_3D42F:		; CODE XREF: sub_3D378:loc_3D47Fj
mov	ax, si
add	ax, 3		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [word_3A71E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands

loc_3D43F:		; Jump if Not Zero (ZF=0)
jnz	short loc_3D453
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75FEh]
jmp	short loc_3D463	; Jump

loc_3D453:		; CODE XREF: sub_3D378:loc_3D43Fj
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx

loc_3D45F:
push	[word ptr bx-75F8h]

loc_3D463:		; CODE XREF: sub_3D378+D9j
mov	ax, si
mov	dx, 0Bh
imul	dx		; Signed Multiply
add	ax, 65h	; 'e'   ; Add
push	ax
mov	ax, 1Fh
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
inc	di		; Increment by 1
inc	si		; Increment by 1

loc_3D47C:		; CODE XREF: sub_3D378:loc_3D42Dj
cmp	si, 5		; Compare Two Operands

loc_3D47F:		; Jump if Less (SF!=OF)
jl	short loc_3D42F
mov	bx, [word_3A71E]

loc_3D485:		; Compare Two Operands
cmp	[word ptr bx+10h], 0
jnz	short loc_3D49D	; Jump if Not Zero (ZF=0)
mov	ax, di

loc_3D48D:
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75FEh]
jmp	short loc_3D4AD	; Jump

loc_3D49D:		; CODE XREF: sub_3D378+111j
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75F8h]

loc_3D4AD:		; CODE XREF: sub_3D378+123j
mov	ax, 0A3h ; ''

loc_3D4B0:
push	ax
mov	ax, 1Fh
push	ax
call	sub_1F655	; Call Procedure

loc_3D4BA:		; Add
add	sp, 6
inc	di		; Increment by 1

loc_3D4BE:
mov	bx, [word_3A71E]
cmp	[word ptr bx+12h], 0 ; Compare Two Operands
jnz	short loc_3D4DA	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75FEh]
jmp	short loc_3D4EA	; Jump

loc_3D4DA:		; CODE XREF: sub_3D378+14Ej
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)

loc_3D4E0:		; Signed Divide
idiv	bx
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75F8h]

loc_3D4EA:		; CODE XREF: sub_3D378+160j
mov	ax, 0AEh ; ''
push	ax
mov	ax, 1Fh
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
inc	di		; Increment by 1
xor	si, si		; Logical Exclusive OR
jmp	short loc_3D54C	; Jump

loc_3D4FF:		; CODE XREF: sub_3D378+1D7j
mov	ax, si
add	ax, 0Ah		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [word_3A71E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands

loc_3D50F:		; Jump if Not Zero (ZF=0)
jnz	short loc_3D523
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75FEh]
jmp	short loc_3D533	; Jump

loc_3D523:		; CODE XREF: sub_3D378:loc_3D50Fj
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75F8h]

loc_3D533:		; CODE XREF: sub_3D378+1A9j
mov	ax, si
mov	dx, 0Bh
imul	dx		; Signed Multiply

loc_3D53A:		; Add
add	ax, 34h	; '4'
push	ax

loc_3D53E:
mov	ax, 0C0h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
inc	di		; Increment by 1
inc	si		; Increment by 1

loc_3D54C:		; CODE XREF: sub_3D378+185j
cmp	si, 2		; Compare Two Operands
jl	short loc_3D4FF	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3D5A2	; Jump

loc_3D555:		; CODE XREF: sub_3D378+22Dj
mov	ax, si
add	ax, 0Ch		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [word_3A71E]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_3D579	; Jump if Not Zero (ZF=0)

loc_3D567:
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75FEh]
jmp	short loc_3D589	; Jump

loc_3D579:		; CODE XREF: sub_3D378+1EDj
mov	ax, di
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)

loc_3D57F:		; Signed Divide
idiv	bx
shl	dx, 1		; Shift	Logical	Left
mov	bx, dx
push	[word ptr bx-75F8h]

loc_3D589:		; CODE XREF: sub_3D378+1FFj
mov	ax, si
mov	dx, 0Bh
imul	dx		; Signed Multiply
add	ax, 65h	; 'e'   ; Add
push	ax
mov	ax, 0C0h ; ''
push	ax

loc_3D598:		; Call Procedure
call	sub_1F655
add	sp, 6		; Add
inc	di		; Increment by 1
inc	si		; Increment by 1

loc_3D5A2:		; CODE XREF: sub_3D378+1DBj
cmp	si, 6		; Compare Two Operands
jl	short loc_3D555	; Jump if Less (SF!=OF)
cmp	[MagSet_19], 0	; Compare Two Operands
jnz	short loc_3D5B4	; Jump if Not Zero (ZF=0)

loc_3D5AE:
push	[word_3A712]
jmp	short loc_3D5B8	; Jump

loc_3D5B4:		; CODE XREF: sub_3D378+234j
push	[word_3A718]

loc_3D5B8:		; CODE XREF: sub_3D378+23Aj
mov	ax, 4Ah	; 'J'
push	ax
mov	ax, 0C0h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_2]
cmp	ax, [word_3A736] ; Compare Two Operands
jnz	short loc_3D5DE	; Jump if Not Zero (ZF=0)
push	[idk_LoadLbx_w3A74A]
mov	ax, 0B1h ; ''
push	ax
mov	ax, 10Bh
jmp	short loc_3D5E9	; Jump

loc_3D5DE:		; CODE XREF: sub_3D378+257j
push	[idk_LoadLbx_w3A74A]
mov	ax, 0B0h ; ''
push	ax

loc_3D5E6:
mov	ax, 10Ah

loc_3D5E9:		; CODE XREF: sub_3D378+264j
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 2947h
push	ax
mov	ax, 36h	; '6'
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2955h
push	ax
mov	ax, 41h	; 'A'
push	ax

loc_3D60E:
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2966h
push	ax
mov	ax, 4Ch	; 'L'
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2972h
push	ax
mov	ax, 67h	; 'g'
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2984h
push	ax
mov	ax, 72h	; 'r'

loc_3D649:
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 299Ah
push	ax
mov	ax, 7Dh	; '}'
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure

loc_3D667:		; Add
add	sp, 6
mov	ax, 29ABh
push	ax
mov	ax, 88h	; ''
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 29BFh
push	ax
mov	ax, 93h	; ''
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 29C9h
push	ax
mov	ax, 0A5h ; ''
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 29D7h
push	ax
mov	ax, 0B0h ; ''
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 29E8h
push	ax
mov	ax, 36h	; '6'
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 29FEh
push	ax
mov	ax, 41h	; 'A'
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A14h
push	ax
mov	ax, 4Ch	; 'L'

loc_3D6E9:
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A28h
push	ax
mov	ax, 67h	; 'g'
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A34h
push	ax
mov	ax, 72h	; 'r'
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A41h
push	ax
mov	ax, 7Dh	; '}'
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A55h
push	ax
mov	ax, 88h	; ''
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A66h
push	ax
mov	ax, 93h	; ''
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A77h
push	ax

loc_3D75E:
mov	ax, 9Eh	; ''
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_6]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 2Dh	; '-'
push	ax
mov	ax, 0Fh
push	ax
mov	ax, 3
push	ax
call	sub_1922A	; Call Procedure

loc_3D78E:		; Add
add	sp, 6
mov	ax, 2A86h
push	ax
mov	ax, 2Ah	; '*'
push	ax
mov	ax, 1Fh
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A96h
push	ax
mov	ax, 5Ch	; '\'

loc_3D7AC:
push	ax
mov	ax, 1Fh
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2A9Fh
push	ax
mov	ax, 2Ah	; '*'

loc_3D7C0:
push	ax
mov	ax, 0C0h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	ax, 2AA6h
push	ax
mov	ax, 5Ch	; '\'
push	ax
mov	ax, 0C0h ; ''
push	ax
call	sub_1993F	; Call Procedure

loc_3D7DE:		; Add
add	sp, 6
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3D378



; Attributes: bp-based frame

proc ST_MagicSet_ReadCreateWrite far
			; CODE XREF: j_ST_MagicSet_ReadCreateWriteJ

varDest= byte ptr -1Eh

push	bp
mov	bp, sp
sub	sp, 1Eh		; Integer Subtraction
push	si
push	di		; argDestination
lea	ax, [bp+varDest] ; Load	Effective Address
push	ax
mov	ax, offset strMAGIC_SETr3 ; "MAGIC.SET"
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jz	short DNE_MAGIC_SET ; Jump if Zero (ZF=1)
mov	ax, offset strMAGIC_SETr3 ; "MAGIC.SET"
push	ax		; argFileName
call	DOS_FindFirst	; char *argFileName {AX	= FileSize DX =	FileName}
pop	cx
or	dx, dx		; If (DX == 0) Then Set	(ZF = 1)
jnz	short DNE_MAGIC_SET ; Jump if Not Zero (ZF=0)

CHECK_SIZE:		; Compare Two Operands
cmp	ax, 466
jz	short SIZE_GOOD	; Jump if Zero (ZF=1)

DNE_MAGIC_SET:		; CODE XREF: ST_MagicSet_ReadCreateWrite+19j
			; ST_MagicSet_ReadCreateWrite+27j
nop			; No Operation
push	cs
call	near ptr ST_DefaultMagicSet ; Call Procedure
mov	ax, offset strWBr3
push	ax
mov	ax, offset strMAGIC_SETr3 ; "MAGIC.SET"
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	si, ax
push	si		; argPtrFileStream
mov	ax, 1
push	ax		; argSize
mov	ax, 466
push	ax		; argNumber
mov	ax, offset MagSet_01
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
jmp	short loc_3D862	; Jump

SIZE_GOOD:		; CODE XREF: ST_MagicSet_ReadCreateWrite+2Cj
mov	ax, offset strRBr3 ; "rb"
push	ax
mov	ax, offset strMAGIC_SETr3 ; "MAGIC.SET"
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	si, ax
push	si		; argPtrFileStream
mov	ax, 1
push	ax		; argSize
mov	ax, 466
push	ax		; argNumber
mov	ax, offset MagSet_01
push	ax		; argPtrReadBuffer
call	_fread		; argPtrReadBuffer,argSize,argNumber,argPtrFileStream

loc_3D862:		; CODE XREF: ST_MagicSet_ReadCreateWrite+56j
add	sp, 8		; Add
push	si		; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx
cmp	[MagSet_19], 1	; Compare Two Operands
jle	short loc_3D879	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[MagSet_19], 1

loc_3D879:		; CODE XREF: ST_MagicSet_ReadCreateWrite+8Aj
cmp	[MagSet_19], 0	; Compare Two Operands
jge	short loc_3D886	; Jump if Greater or Equal (SF=OF)
mov	[MagSet_19], 1

loc_3D886:		; CODE XREF: ST_MagicSet_ReadCreateWrite+97j
cmp	[MagSet_09], 1	; Compare Two Operands
jle	short loc_3D893	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[MagSet_09], 1

loc_3D893:		; CODE XREF: ST_MagicSet_ReadCreateWrite+A4j
cmp	[MagSet_09], 0	; Compare Two Operands
jge	short loc_3D8A0	; Jump if Greater or Equal (SF=OF)
mov	[MagSet_09], 1

loc_3D8A0:		; CODE XREF: ST_MagicSet_ReadCreateWrite+B1j
cmp	[word_3A68E], 0	; Compare Two Operands
jnz	short loc_3D908	; Jump if Not Zero (ZF=0)
xor	di, di		; DI = 0
jmp	short LOOP_x10	; Jump

loc_3D8AB:		; CODE XREF: ST_MagicSet_ReadCreateWrite+F2j
mov	bx, di
shl	bx, 1		; BX = BX / 2
mov	[word_3A68E+bx], 0
mov	bx, di
shl	bx, 1		; BX = BX / 2
mov	[word_3A6A2+bx], 0
mov	ax, (offset strLOAD_LBX+8)
push	ax		; argSrc
mov	ax, di
mov	dx, 20
imul	dx		; Signed Multiply
add	ax, offset tmpMagicSet ; Add
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
inc	di		; Increment by 1

LOOP_x10:		; CODE XREF: ST_MagicSet_ReadCreateWrite+C2j
cmp	di, 10		; Compare Two Operands
jl	short loc_3D8AB	; Jump if Less (SF!=OF)
mov	ax, offset strWBr3
push	ax
mov	ax, offset strMAGIC_SETr3 ; "MAGIC.SET"
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	si, ax		; argFileStream
push	si		; argNumber
mov	ax, 1		; argNumber
push	ax		; argSize
mov	ax, 466		; argSize
push	ax
mov	ax, offset MagSet_01 ; argPointer
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
push	si		; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx

loc_3D908:		; CODE XREF: ST_MagicSet_ReadCreateWrite+BEj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_MagicSet_ReadCreateWrite



; Attributes: bp-based frame

proc ST_DefaultMagicSet	far
			; CODE XREF: j_hrmSetFlagsJ
			; sub_3CFC0+D5p
			; ST_MagicSet_ReadCreateWrite+30p
push	bp
mov	bp, sp
push	si		; argSrc
mov	[MagSet_01], 1
mov	[MagSet_02], 1
mov	[MagSet_03], 1
mov	[MagSet_04], 1
mov	[MagSet_05], 1
mov	[MagSet_06], 1
mov	[MagSet_07], 1
mov	[MagSet_08], 1
mov	[MagSet_09], 1
mov	[MagSet_10], 1
mov	[MagSet_11], 0
mov	[MagSet_12], 1
mov	[MagSet_13], 1
mov	[MagSet_14], 1
mov	[MagSet_15], 1
mov	[MagSet_16], 1
mov	[MagSet_17], 1
mov	[MagSet_18], 1
mov	[MagSet_19], 1
mov	[MagSet_20], 0
mov	[MagSet_21], 4
mov	[MagSet_22], 1
mov	[MagSet_23], 1
mov	[LBX_FONTS_w3A50A], 1
mov	[LBX_FONTS_w3A508], 2
xor	si, si		; SI = 0
jmp	short LOOP_x8	; Jump

loc_3D9AC:		; CODE XREF: ST_DefaultMagicSet+ACj
mov	bx, si
shl	bx, 1		; BX = BX / 2
mov	[idk_MagSet_w3A514+bx],	0
inc	si		; Increment by 1

LOOP_x8:		; CODE XREF: ST_DefaultMagicSet+9Cj
cmp	si, 8		; Compare Two Operands
jl	short loc_3D9AC	; Jump if Less (SF!=OF)
xor	si, si		; SI = 0
jmp	short LOOP_x10	; Jump

loc_3D9C0:		; CODE XREF: ST_DefaultMagicSet+E0j
mov	bx, si		; {0,1,2,3,4, 5, 6, 7, 8, 9}
shl	bx, 1		; {0,2,4,6,8,10,12,14,16,18}
mov	[word_3A68E+bx], 0
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word_3A6A2+bx], 0
mov	ax, (offset strLOAD_LBX+8)
push	ax		; argSrc
			;
mov	ax, si
mov	dx, 20
imul	dx		; AX = AX * DX
			; {1,2,3,4,5,6,7,8,9,10} * 20
add	ax, offset tmpMagicSet ; Add
push	ax		; argDest
			;
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
inc	si		; Increment by 1

LOOP_x10:		; CODE XREF: ST_DefaultMagicSet+B0j
cmp	si, 10		; Compare Two Operands
jl	short loc_3D9C0	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp ST_DefaultMagicSet



; Attributes: bp-based frame

proc LBX_HelpEntry_s3D9F3 far
			; CODE XREF: j_LBX_HelpEntry_s3D9F3J
			; sub_3CFC0+28Fp
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 15h
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 85B0h
push	ax		; int
mov	ax, 22h	; '"'
push	ax		; int
mov	ax, offset aHlpentry_lbx ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	ax, 15h
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_HelpEntry_s3D9F3 ; sp-analysis	failed

ends ovr049


; Segment type:	Pure code
segment	ovr050 para public 'OVERLAY' use16
assume cs:ovr050
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_3DA30 far	; CODE XREF: sub_3189DJ

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction

loc_3DA36:
push	si
push	di
mov	[word_3A4E0], 1

loc_3DA3E:
mov	[word_3A4DE], 1
mov	[word_3A4E2], 1
mov	[word_3A4DC], 1
xor	si, si		; Logical Exclusive OR
mov	[bp+var_2], 0
jmp	loc_3DB05	; default

loc_3DA5A:		; CODE XREF: sub_3DA30+DBj
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	[bp+var_4], si
mov	cx, 0Ah		; switch 10 cases
mov	bx, offset word_3DB37

loc_3DA68:		; CODE XREF: sub_3DA30:loc_3DA73j
mov	ax, [cs:bx]
cmp	ax, [bp+var_4]	; Compare Two Operands
jz	short loc_3DA78	; Jump if Zero (ZF=1)

loc_3DA70:		; Add
add	bx, 2

loc_3DA73:		; Loop while CX	!= 0
loop	loc_3DA68

loc_3DA75:		; default
jmp	loc_3DB05

loc_3DA78:		; CODE XREF: sub_3DA30+3Ej
jmp	[word ptr cs:bx+14h] ; switch jump

loc_3DA7C:		; DATA XREF: ovr050:off_3DB4Bo
xor	ax, ax		; case 0xFFFF

loc_3DA7E:		; Jump
jmp	loc_3DB31

loc_3DA81:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
nop			; case 0x0

loc_3DA82:
push	cs
call	near ptr sub_3E1DE ; Call Procedure

loc_3DA86:		; CODE XREF: sub_3DA30:loc_3DAA4j
			; sub_3DA30+A4j
			; sub_3DA30:loc_3DADBj
			; sub_3DA30:loc_3DAFCj
mov	si, ax

loc_3DA88:		; default
jmp	short loc_3DB05

loc_3DA8A:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
nop			; case 0x1
push	cs

loc_3DA8C:		; Call Procedure
call	near ptr sub_3EBA0

loc_3DA8F:
mov	si, ax

loc_3DA91:		; Compare Two Operands
cmp	si, 2

loc_3DA94:		; Jump if Not Zero (ZF=0)
jnz	short loc_3DA9B

loc_3DA96:
mov	di, 1

loc_3DA99:		; Jump
jmp	short loc_3DA9D

loc_3DA9B:		; CODE XREF: sub_3DA30:loc_3DA94j
xor	di, di		; Logical Exclusive OR

loc_3DA9D:		; CODE XREF: sub_3DA30:loc_3DA99j
jmp	short loc_3DB05	; default

loc_3DA9F:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
nop			; case 0x2

loc_3DAA0:
push	cs

loc_3DAA1:		; Call Procedure
call	near ptr sub_3F3C6

loc_3DAA4:		; Jump
jmp	short loc_3DA86

loc_3DAA6:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
nop			; case 0x3
push	cs

loc_3DAA8:		; Call Procedure
call	near ptr idk_Load_NEWGAME_LBX
mov	si, ax
or	di, di		; Logical Inclusive OR

loc_3DAAF:		; Jump if Zero (ZF=1)
jz	short loc_3DAC0
db 83h,0FEh,0FFh ; <BAD>cmp	si, 0FFFFh ; Compare Two Operands
jnz	short loc_3DABB	; Jump if Not Zero (ZF=0)
mov	si, 2

loc_3DAB9:		; Jump
jmp	short loc_3DABE

loc_3DABB:		; CODE XREF: sub_3DA30+84j
mov	si, 4

loc_3DABE:		; CODE XREF: sub_3DA30:loc_3DAB9j
jmp	short loc_3DACD	; Jump

loc_3DAC0:		; CODE XREF: sub_3DA30:loc_3DAAFj
db 83h,0FEh,0FFh ; <BAD>cmp	si, 0FFFFh ; Compare Two Operands
jnz	short loc_3DACA	; Jump if Not Zero (ZF=0)

loc_3DAC5:
mov	si, 1

loc_3DAC8:		; Jump
jmp	short loc_3DACD

loc_3DACA:		; CODE XREF: sub_3DA30+93j
mov	si, 6

loc_3DACD:		; CODE XREF: sub_3DA30:loc_3DABEj
			; sub_3DA30:loc_3DAC8j
jmp	short loc_3DB05	; default

loc_3DACF:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
nop			; case 0x4

loc_3DAD0:
push	cs
call	near ptr sub_4067D ; Call Procedure
jmp	short loc_3DA86	; Jump

loc_3DAD6:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
nop			; case 0x5
push	cs

loc_3DAD8:		; Call Procedure
call	near ptr LBX_NewGame_s41A5F

loc_3DADB:		; Jump
jmp	short loc_3DA86

loc_3DADD:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
nop			; case 0x6

loc_3DADE:
push	cs
call	near ptr sub_3FBE0 ; Call Procedure
mov	si, ax

loc_3DAE4:		; Compare Two Operands
db 83h,0FEh,0FFh ; <BAD>cmp	si, 0FFFFh
jnz	short loc_3DAF5	; Jump if Not Zero (ZF=0)

loc_3DAE9:		; Logical Inclusive OR
or	di, di

loc_3DAEB:		; Jump if Zero (ZF=1)
jz	short loc_3DAF2

loc_3DAED:
mov	si, 5

loc_3DAF0:		; Jump
jmp	short loc_3DAF5

loc_3DAF2:		; CODE XREF: sub_3DA30:loc_3DAEBj
mov	si, 3

loc_3DAF5:		; CODE XREF: sub_3DA30+B7j
			; sub_3DA30:loc_3DAF0j
jmp	short loc_3DB05	; default

loc_3DAF7:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
nop			; case 0x7

loc_3DAF8:
push	cs
call	near ptr sub_3F7D8 ; Call Procedure

loc_3DAFC:		; Jump
jmp	short loc_3DA86

loc_3DAFE:		; CODE XREF: sub_3DA30:loc_3DA78j
			; DATA XREF: ovr050:off_3DB4Bo
mov	[bp+var_2], 0FFFFh ; case 0x63
jmp	short $+2	; Jump

loc_3DB05:		; CODE XREF: sub_3DA30+27j
			; sub_3DA30:loc_3DA75j
			; sub_3DA30:loc_3DA88j
			; sub_3DA30:loc_3DA9Dj
			; sub_3DA30:loc_3DACDj
			; sub_3DA30:loc_3DAF5j
cmp	[bp+var_2], 0	; default
jnz	short loc_3DB0E	; Jump if Not Zero (ZF=0)
jmp	loc_3DA5A	; Jump

loc_3DB0E:		; CODE XREF: sub_3DA30+D9j
call	j_idk_BuildingWorlds ; Call Procedure
call	sub_31BDD	; Call Procedure
call	sub_31BB5	; Call Procedure
mov	ax, 8		; int
push	ax		; int
call	j_OVR_SaveGame_MagicSet	; Call Procedure
pop	cx
mov	ax, 8
push	ax
nop			; No Operation
push	cs
call	near ptr sub_3DB5F ; Call Procedure
db  59h	; Y

loc_3DB31:		; CODE XREF: sub_3DA30:loc_3DA7Ej
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3DA30

word_3DB37 dw 0FFFFh,	  0,	 1,	2
			; DATA XREF: sub_3DA30+35o
dw	3,     4,     5,     6 ; value table for switch	statement
dw	7,   63h
off_3DB4B dw offset loc_3DA7C ;	jump table for switch statement
dw offset loc_3DA81
dw offset loc_3DA8A
dw offset loc_3DA9F
dw offset loc_3DAA6
dw offset loc_3DACF
dw offset loc_3DAD6
dw offset loc_3DADD
dw offset loc_3DAF7
dw offset loc_3DAFE


; Attributes: noreturn bp-based	frame

proc sub_3DB5F far	; CODE XREF: sub_318CAJ
			; sub_3DA30+FDp
			; sub_3DBA6+378p

argSaveGamNbr= word ptr	 6

push	bp
mov	bp, sp
push	si
mov	si, [bp+argSaveGamNbr]
nop			; No Operation
push	cs
call	near ptr sub_43349 ; Call Procedure
call	AIL_someSequence ; Call	Procedure
call	Call_AIL_shutdown ; Call Procedure
cmp	si, 8		; Compare Two Operands
jz	short loc_3DB8B	; Jump if Zero (ZF=1)
push	si		; argSaveGamNbr
call	j_ST_LoadSaveGamByNbr ;	Call Procedure
pop	cx
mov	ax, 8		; int
push	ax		; int
call	j_OVR_SaveGame_MagicSet	; Call Procedure
pop	cx

loc_3DB8B:		; CODE XREF: sub_3DB5F+19j
mov	ax, (offset strWIZARDSEXE+0Bh)
push	ax		; argExeFileName
mov	ax, offset arg0	; "JENNY"
push	ax
mov	ax, offset arg0	; "JENNY"
push	ax		; arg0
mov	ax, offset strWIZARDSEXE ; int
push	ax		; int
call	ST_execl_WizardsExe ; Call Procedure
db  83h	; 
db 0C4h	; 
db    8
db  5Eh	; ^
db  5Dh	; ]
db 0CBh	; 
endp sub_3DB5F ; sp-analysis failed



; Attributes: bp-based frame

proc sub_3DBA6 far	; CODE XREF: sub_318D4J

var_50=	byte ptr -50h
argPtrCharArr= byte ptr	-3Ch
argCharPtrFileName= byte ptr -2Ch
var_1C=	byte ptr -1Ch
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 50h		; Integer Subtraction
push	si
push	di		; argConversionBase
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
xor	ax, ax		; Logical Exclusive OR
push	ax		; argEntryNumber
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w36FC8], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2
push	ax		; argFileName
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB9E], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 1
push	ax		; argFileName
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ABA0], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 5
push	ax		; argFileName
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_37008], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 7
push	ax		; argFileName
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ABBE], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 8
push	ax		; argFileName
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ABBC], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 9
push	ax		; argFileName
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ABB2], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 12
push	ax		; argFileName
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ABB0], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 10
push	ax		; argFileName
mov	ax, offset strLOADLBXr2	; "LOAD.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ABA6], ax
mov	[idk_CfgMom_w381BE], 0
xor	di, di		; Logical Exclusive OR
mov	[bp+var_C], 0
cmp	[word_3461A], 3	; Compare Two Operands
jz	short loc_3DCE6	; Jump if Zero (ZF=1)
mov	[idk_CfgMom_w381BE], 1
nop			; No Operation
push	cs


call	near ptr sub_43349 ; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add


call	idk_VGA_s1E4BA	; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure


mov	ax, -1
push	ax		; argColorIndex
mov	ax, 1
push	ax		; argPaletteNumber
call	ILSe_prepare_palette ; Call Procedure
pop	cx
pop	cx

loc_3DCE6:		; CODE XREF: sub_3DBA6+E8j
mov	[bp+var_4], 2Bh	; '+'

loc_3DCEB:
mov	[bp+var_6], 0ABh ; ''
mov	ax, offset unk_347CC
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh


mov	ax, offset asc_34D69 ; "\x1B"
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx

loc_3DD0E:
mov	[bp+var_8], ax
mov	ax, 0FFFFh
push	ax
mov	ax, offset asc_34D69 ; "\x1B"
push	ax
mov	ax, [bp+var_6]

loc_3DD1C:		; Add
add	ax, 0Dh
push	ax
mov	ax, [bp+var_4]
add	ax, 27h	; '''   ; Add
push	ax
push	[bp+var_6]
push	[bp+var_4]

loc_3DD2D:		; Call Procedure
call	idk_Mouse_s29A0B

loc_3DD32:		; Add
add	sp, 0Ch
mov	[word_36FD0], ax

loc_3DD38:
mov	ax, 0FFFFh
push	ax
mov	ax, 305Bh
push	ax
mov	ax, [bp+var_6]
add	ax, 0Dh		; Add
push	ax
mov	ax, [bp+var_4]
add	ax, 4Eh	; 'N'   ; Add
push	ax
push	[bp+var_6]
mov	ax, [bp+var_4]
add	ax, 28h	; '('   ; Add
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_36FC6], ax
mov	[word_3ABA2], 0FC18h
mov	[word_3700E], 0
mov	si, 1
jmp	short loc_3DDE5	; Jump

loc_3DD74:		; CODE XREF: sub_3DBA6+242j
mov	ax, offset strSAVEGAMr3_1 ; "SAVE"
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
push	si		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strSAVEGAMr3_2 ; ".GAM"
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+var_50]	; Load Effective Address
push	ax
lea	ax, [bp+argCharPtrFileName] ; Load Effective Address
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_3DDD8	; Jump if Zero (ZF=1)

loc_3DDC5:
mov	bx, [word_3700E]
shl	bx, 1		; Shift	Logical	Left
mov	ax, si
dec	ax		; Decrement by 1
mov	[bx-75EEh], ax
inc	[word_3700E]	; Increment by 1
jmp	short loc_3DDE4	; Jump

loc_3DDD8:		; CODE XREF: sub_3DBA6+21Dj
mov	bx, [word_3700E]
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-75EEh], 0FFFFh

loc_3DDE4:		; CODE XREF: sub_3DBA6+230j
inc	si		; Increment by 1

loc_3DDE5:		; CODE XREF: sub_3DBA6+1CCj
cmp	si, 9		; Compare Two Operands
jl	short loc_3DD74	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3DDFC	; Jump

loc_3DDEE:		; CODE XREF: sub_3DBA6+259j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_3DDF2:		; Load Effective Address
lea	ax, [bp+var_1C]

loc_3DDF5:		; Add
add	bx, ax
mov	[word ptr bx], 0FC18h
inc	si		; Increment by 1

loc_3DDFC:		; CODE XREF: sub_3DBA6+246j
cmp	si, 8		; Compare Two Operands
jl	short loc_3DDEE	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3DE53	; Jump

loc_3DE05:		; CODE XREF: sub_3DBA6+2B1j
mov	ax, 0FFFFh
push	ax

loc_3DE09:
mov	ax, (offset strWIZARDSEXE+0Bh)
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-75EEh]
mov	dx, 0Fh

loc_3DE18:		; Signed Multiply
imul	dx
add	ax, 38h	; '8'   ; Add
push	ax
mov	ax, [bp+var_4]

loc_3DE21:		; Add
add	ax, 0DCh ; ''
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-75EEh]
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, 2Fh	; '/'   ; Add
push	ax
push	[bp+var_4]
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-75EEh]
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_1C]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	si		; Increment by 1

loc_3DE53:		; CODE XREF: sub_3DBA6+25Dj
cmp	si, [word_3700E] ; Compare Two Operands
jl	short loc_3DE05	; Jump if Less (SF!=OF)
mov	ax, 65535
push	ax
mov	ax, (offset strWIZARDSEXE+0Bh)
push	ax
mov	ax, [bp+var_6]
add	ax, 13		; Add
push	ax
mov	ax, 229
push	ax
push	[bp+var_6]
mov	ax, 172
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_3ABAE], ax
mov	[word_3ABA8], 0FFFFh
xor	di, di		; Logical Exclusive OR
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 25h	; '%'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
nop			; No Operation
push	cs

loc_3DE9C:		; Call Procedure
call	near ptr LBX_HelpEntry_s433B8
jmp	loc_3DF75	; Jump

loc_3DEA2:		; CODE XREF: sub_3DBA6+3D3j
call	sub_2B97A	; Call Procedure
mov	[bp+var_A], ax
call	_f020105_bios_timeofday	; Call Procedure
xor	si, si		; Logical Exclusive OR
jmp	short loc_3DEE6	; Jump

loc_3DEB3:		; CODE XREF: sub_3DBA6+343j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1C]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_A]	; Compare Two Operands
jnz	short loc_3DEE5	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 0

loc_3DEC8:		; Jump
jmp	short loc_3DEDC

loc_3DECA:		; CODE XREF: sub_3DBA6+33Dj
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
cmp	[bx-75EEh], si	; Compare Two Operands
jnz	short loc_3DED9	; Jump if Not Zero (ZF=0)
mov	[word_3ABA8], si

loc_3DED9:		; CODE XREF: sub_3DBA6+32Dj
inc	[bp+var_2]	; Increment by 1

loc_3DEDC:		; CODE XREF: sub_3DBA6:loc_3DEC8j
mov	ax, [bp+var_2]
cmp	ax, [word_3700E] ; Compare Two Operands
jl	short loc_3DECA	; Jump if Less (SF!=OF)

loc_3DEE5:		; CODE XREF: sub_3DBA6+31Bj
inc	si		; Increment by 1

loc_3DEE6:		; CODE XREF: sub_3DBA6+30Bj
cmp	si, 8		; Compare Two Operands
jl	short loc_3DEB3	; Jump if Less (SF!=OF)
mov	ax, [bp+var_A]
cmp	ax, [word_36FD0] ; Compare Two Operands
jz	short loc_3DEFC	; Jump if Zero (ZF=1)
mov	ax, [bp+var_A]

loc_3DEF7:		; Compare Two Operands
cmp	ax, [bp+var_8]
jnz	short loc_3DF04	; Jump if Not Zero (ZF=0)

loc_3DEFC:		; CODE XREF: sub_3DBA6+34Cj
mov	di, 1
call	@filebuf@terminate$qv ;	filebuf::terminate(void)

loc_3DF04:		; CODE XREF: sub_3DBA6+354j
mov	ax, [bp+var_A]
cmp	ax, [word_36FC6] ; Compare Two Operands
jnz	short loc_3DF25	; Jump if Not Zero (ZF=0)
cmp	[word_3ABA8], 0	; Compare Two Operands
jl	short loc_3DF25	; Jump if Less (SF!=OF)
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
push	[word_3ABA8]
push	cs
call	near ptr sub_3DB5F ; Call Procedure
db  59h	; Y
db 0BFh	; 
db    1
db    0

loc_3DF25:		; CODE XREF: sub_3DBA6+365j
			; sub_3DBA6+36Cj
mov	ax, [bp+var_A]
cmp	ax, [word_3ABAE] ; Compare Two Operands
jnz	short loc_3DF41	; Jump if Not Zero (ZF=0)
call	idk_SetThreeFlags_s25E89 ; Call	Procedure

loc_3DF33:		; Call Procedure
call	sub_31835
mov	[idk_CfgMom_w3700C], 1
mov	di, 1

loc_3DF41:		; CODE XREF: sub_3DBA6+386j
or	di, di		; Logical Inclusive OR
jnz	short loc_3DF75	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_3DF8C ; Call Procedure
call	sub_2E303	; Call Procedure
cmp	[idk_CfgMom_w381BE], 0 ; Compare Two Operands
jz	short loc_3DF6B	; Jump if Zero (ZF=1)
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_3DF6B	; Jump if Not Zero (ZF=0)
call	sub_1E525	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_43381 ; Call Procedure
mov	[bp+var_C], 1

loc_3DF6B:		; CODE XREF: sub_3DBA6+3AEj
			; sub_3DBA6+3B4j
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_3DF75:		; CODE XREF: sub_3DBA6+2F9j
			; sub_3DBA6+39Dj
or	di, di		; Logical Inclusive OR
jnz	short loc_3DF7C	; Jump if Not Zero (ZF=0)
jmp	loc_3DEA2	; Jump

loc_3DF7C:		; CODE XREF: sub_3DBA6+3D1j
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3DBA6



; Attributes: bp-based frame

proc sub_3DF8C far	; CODE XREF: sub_31875J
			; sub_3DBA6+3A1p

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
mov	ax, [word_34B1E]
mov	dx, [word_34B1C]
mov	[bp+var_2], ax
mov	[bp+var_4], dx
mov	ax, [word_34B22]
mov	dx, [word_34B20]
mov	[bp+var_6], ax
mov	[bp+var_8], dx
mov	[byte ptr bp+var_C], 22h ; '"'

loc_3DFB2:
mov	[byte ptr bp+var_C+1], 2Bh ; '+'
call	sub_2601C	; Call Procedure
mov	[word_36FD4], ax

loc_3DFBE:
mov	di, 2Bh	; '+'
mov	[bp+var_A], 0ABh ; ''
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
push	[idk_LBX_w36FC8]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_3DFEE:		; Call Procedure
call	sub_1F655
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0B8h ; ''
push	ax
mov	ax, 7Bh	; '{'
push	ax
mov	ax, 0AAh ; ''
push	ax
mov	ax, 2Ah	; '*'
push	ax

loc_3E009:		; Call Procedure
call	idk_VGA_ScData_s186BC
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0B8h ; ''
push	ax
mov	ax, 10Fh
push	ax
mov	ax, 0AAh ; ''
push	ax
mov	ax, 0ABh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	si, si		; Logical Exclusive OR
jmp	loc_3E0EA	; Jump

loc_3E031:		; CODE XREF: sub_3DF8C+164j
push	[word_3ABB2]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-75EEh]
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, 2Fh	; '/'   ; Add
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-75EEh]
cmp	ax, [word_3ABA8] ; Compare Two Operands
jnz	short loc_3E09B	; Jump if Not Zero (ZF=0)
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax
mov	ax, 3
push	ax
call	sub_19257	; Call Procedure
pop	cx
pop	cx
push	[word_3ABA6]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-75EEh]
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, 2Eh	; '.'   ; Add
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
jmp	short loc_3E0B9	; Jump

loc_3E09B:		; CODE XREF: sub_3DF8C+CFj
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax

loc_3E0AE:
mov	ax, 3
push	ax
call	sub_19257	; Call Procedure
pop	cx
pop	cx

loc_3E0B9:		; CODE XREF: sub_3DF8C+10Dj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-75EEh]
mov	dx, 14h
imul	dx		; Signed Multiply
add	ax, 8814h	; Add
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-75EEh]
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, 2Fh	; '/'   ; Add
push	ax
mov	ax, di
add	ax, 0Ah		; Add
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
inc	si		; Increment by 1

loc_3E0EA:		; CODE XREF: sub_3DF8C+A2j
cmp	si, [word_3700E] ; Compare Two Operands
jge	short loc_3E0F3	; Jump if Greater or Equal (SF=OF)
jmp	loc_3E031	; Jump

loc_3E0F3:		; CODE XREF: sub_3DF8C+162j
mov	ax, [word_36FD4]
cmp	ax, [word_36FD0] ; Compare Two Operands
jnz	short loc_3E109	; Jump if Not Zero (ZF=0)
push	[idk_LBX_w3AB9E]
mov	ax, 0ACh ; ''
push	ax
mov	ax, 2Ch	; ','
jmp	short loc_3E114	; Jump

loc_3E109:		; CODE XREF: sub_3DF8C+16Ej
push	[idk_LBX_w3AB9E]
mov	ax, 0ABh ; ''
push	ax
mov	ax, 2Bh	; '+'

loc_3E114:		; CODE XREF: sub_3DF8C+17Bj
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, [word_36FD4]
cmp	ax, [word_3ABAE] ; Compare Two Operands
jnz	short loc_3E133	; Jump if Not Zero (ZF=0)
push	[word_3ABB0]
mov	ax, 0ACh ; ''
push	ax
mov	ax, 0ADh ; ''
jmp	short loc_3E13E	; Jump

loc_3E133:		; CODE XREF: sub_3DF8C+198j
push	[word_3ABB0]
mov	ax, 0ABh ; ''
push	ax
mov	ax, 0ACh ; ''

loc_3E13E:		; CODE XREF: sub_3DF8C+1A5j
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
cmp	[word_3ABA8], 0	; Compare Two Operands
jl	short loc_3E17A	; Jump if Less (SF!=OF)
mov	ax, [word_36FD4]
cmp	ax, [word_36FC6] ; Compare Two Operands
jnz	short loc_3E164	; Jump if Not Zero (ZF=0)
push	[word_3ABA0]
mov	ax, 0ACh ; ''
push	ax
mov	ax, 54h	; 'T'
jmp	short loc_3E16F	; Jump

loc_3E164:		; CODE XREF: sub_3DF8C+1C9j
push	[word_3ABA0]
mov	ax, 0ABh ; ''
push	ax
mov	ax, 53h	; 'S'

loc_3E16F:		; CODE XREF: sub_3DF8C+1D6j
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
jmp	short loc_3E18E	; Jump

loc_3E17A:		; CODE XREF: sub_3DF8C+1C0j
push	[word_37008]
mov	ax, 0ABh ; ''
push	ax
mov	ax, 53h	; 'S'
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_3E18E:		; CODE XREF: sub_3DF8C+1ECj
push	[word_3ABBC]
mov	ax, 0ABh ; ''
push	ax
mov	ax, 0E7h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
push	[word_3ABBE]
mov	ax, 0ABh ; ''
push	ax
mov	ax, 7Ah	; 'z'
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_C]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 3067h
push	ax		; int
mov	ax, 0C1h ; ''
push	ax		; int
mov	ax, 0A0h ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3DF8C



; Attributes: bp-based frame

proc sub_3E1DE far	; CODE XREF: sub_318A2J
			; sub_3DA30+53p

var_22=	word ptr -22h
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 22h		; Integer Subtraction
push	si
push	di		; argDestination
mov	[idk_CfgMom_w381BE], 1
cmp	[idk_CfgMom_w381BE], 0 ; Compare Two Operands
jz	short loc_3E1F8	; Jump if Zero (ZF=1)
nop			; No Operation
push	cs
call	near ptr sub_43349 ; Call Procedure

loc_3E1F8:		; CODE XREF: sub_3E1DE+13j
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add


call	idk_VGA_s1E4BA	; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add


call	VGA_MathThenSetVarToVgaLoc ; Call Procedure


mov	ax, -1
push	ax		; argColorIndex
xor	ax, ax		; Logical Exclusive OR
push	ax		; argPaletteNumber
call	ILSe_prepare_palette ; Call Procedure
pop	cx
pop	cx


push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
xor	ax, ax		; Logical Exclusive OR
push	ax		; argEntryNumber
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w36FC8], ax


push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 1
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB78], ax


push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w379C0], ax


push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 3
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB9E], ax


push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 4
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB5A], ax


push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 5
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB5C], ax


push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 6
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB5E], ax


push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 7
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB60], ax


lea	ax, [bp+var_22]	; Load Effective Address
push	ax
mov	ax, offset strMAGICSETr4 ; "MAGIC.SET"
push	ax		; argCharPtrFileName
call	_f040101_DosFindFile ; char *argFileName,char *argDestination
			; Return
			;   -1 SUCCESS
			;    0 FAILURE
			; Sets FLAG_w3609E = 0,	while its working
			;
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_3E31F	; Jump if Zero (ZF=1)
mov	ax, offset strMAGICSETr4 ; "MAGIC.SET"
push	ax		; argFileName
call	DOS_FindFirst	; char *argFileName {AX	= FileSize DX =	FileName}
pop	cx
or	dx, dx		; Logical Inclusive OR
jnz	short loc_3E31F	; Jump if Not Zero (ZF=0)
cmp	ax, 466		; Compare Two Operands
jz	short loc_3E326	; Jump if Zero (ZF=1)

loc_3E31F:		; CODE XREF: sub_3E1DE+12Cj
			; sub_3E1DE+13Aj
call	j_hrmSetFlags	; Call Procedure
jmp	short loc_3E353	; Jump

loc_3E326:		; CODE XREF: sub_3E1DE+13Fj
mov	ax, offset strRBr4 ; "rb"
push	ax
mov	ax, offset strMAGICSETr4 ; "MAGIC.SET"
push	ax		; argPathFileName

loc_3E32E:		; argPathFileName,argMode
call	_fopen
pop	cx
pop	cx
mov	di, ax
push	di		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 466
push	ax
mov	ax, 87D4h
push	ax		; argPtrReadBuffer
call	_fread		; argPtrReadBuffer,argSize,argNumber,argPtrFileStream
add	sp, 8		; Add
push	di		; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx

loc_3E353:		; CODE XREF: sub_3E1DE+146j
cmp	[MagSet_20], 0	; Compare Two Operands
jl	short loc_3E361	; Jump if Less (SF!=OF)
cmp	[MagSet_20], 4	; Compare Two Operands
jle	short loc_3E367	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_3E361:		; CODE XREF: sub_3E1DE+17Aj
mov	[MagSet_20], 0

loc_3E367:		; CODE XREF: sub_3E1DE+181j
cmp	[MagSet_21], 1	; Compare Two Operands

loc_3E36C:		; Jump if Less (SF!=OF)
jl	short loc_3E375
cmp	[MagSet_21], 4	; Compare Two Operands
jle	short loc_3E37B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_3E375:		; CODE XREF: sub_3E1DE:loc_3E36Cj
mov	[MagSet_21], 1

loc_3E37B:		; CODE XREF: sub_3E1DE+195j
cmp	[MagSet_23], 0	; Compare Two Operands
jl	short loc_3E389	; Jump if Less (SF!=OF)
cmp	[MagSet_23], 2	; Compare Two Operands
jle	short loc_3E38F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_3E389:		; CODE XREF: sub_3E1DE+1A2j
mov	[MagSet_23], 0

loc_3E38F:		; CODE XREF: sub_3E1DE+1A9j
cmp	[MagSet_22], 0	; Compare Two Operands
jl	short loc_3E39D	; Jump if Less (SF!=OF)
cmp	[MagSet_22], 2	; Compare Two Operands
jle	short loc_3E3A3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_3E39D:		; CODE XREF: sub_3E1DE+1B6j
mov	[MagSet_22], 0

loc_3E3A3:		; CODE XREF: sub_3E1DE+1BDj
mov	ax, offset unk_347CC
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
call	idk_VGA_s1E4BA	; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_3E3EB:		; Call Procedure
call	idk_VGA_ScData_s186BC
add	sp, 0Ah		; Add
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
push	[idk_LBX_w379C0]
mov	ax, 3049h
push	ax
mov	ax, 0B3h ; ''
push	ax
mov	ax, 0FCh ; ''
push	ax
call	sub_298BB	; Call Procedure
add	sp, 0Ch		; Add
mov	[word_3ABA2], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3059h
push	ax
push	[idk_LBX_w3AB9E]
mov	ax, 3049h
push	ax
mov	ax, 0B3h ; ''
push	ax
mov	ax, 0ABh ; ''
push	ax
call	sub_298BB	; Call Procedure
add	sp, 0Ch		; Add
mov	[word_36FD0], ax
mov	ax, 0FFFFh
push	ax

loc_3E43D:
mov	ax, 3049h
push	ax
mov	ax, 36h	; '6'
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 26h	; '&'
push	ax
mov	ax, 0FAh ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_3AB1A], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 51h	; 'Q'
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 41h	; 'A'
push	ax
mov	ax, 0FAh ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_3AB18], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 6Ch	; 'l'
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 5Ch	; '\'
push	ax
mov	ax, 0FAh ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_3AB14], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 87h	; ''
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 77h	; 'w'
push	ax
mov	ax, 0FAh ; ''
push	ax

loc_3E4BA:		; Call Procedure
call	idk_Mouse_s29A0B
add	sp, 0Ch		; Add
mov	[word_3AB16], ax
mov	[bp+var_4], 0
mov	[bp+var_2], 0
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 2Ah	; '*'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
nop			; No Operation
push	cs
call	near ptr LBX_HelpEntry_s433EB ;	Call Procedure
jmp	loc_3E5FF	; Jump

loc_3E4EB:		; CODE XREF: sub_3E1DE+427j
call	sub_2B97A	; Call Procedure
mov	si, ax
call	_f020105_bios_timeofday	; Call Procedure
cmp	si, [word_36FD0] ; Compare Two Operands
jnz	short loc_3E50D	; Jump if Not Zero (ZF=0)
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	ax, 0FFFFh

loc_3E50A:		; CODE XREF: sub_3E1DE+38Dj
jmp	loc_3E608	; Jump

loc_3E50D:		; CODE XREF: sub_3E1DE+31Dj
cmp	si, [word_3ABA2] ; Compare Two Operands
jnz	short loc_3E56D	; Jump if Not Zero (ZF=0)
mov	ax, offset strWBr4 ; "wb"
push	ax
mov	ax, offset strMAGICSETr4 ; "MAGIC.SET"
push	ax		; argPathFileName
call	_fopen		; argPathFileName,argMode
pop	cx
pop	cx
mov	di, ax
push	di		; argNumber
mov	ax, 1
push	ax		; argSize
mov	ax, 1D2h
push	ax
mov	ax, 87D4h
push	ax		; argPtrWriteBuffer
call	_fwrite		; argPtrBuffer,argSize,argNumber,argPtrFile
add	sp, 8		; Add
push	di		; argFileStream
call	_fclose		; FILE *argFileStream
pop	cx
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
nop			; No Operation
push	cs
call	near ptr sub_3EAD2 ; Call Procedure
mov	ax, [MagSet_23]
mov	[word_3A4E0], ax
mov	ax, [MagSet_22]
mov	[word_3A4DE], ax
mov	ax, [MagSet_21]
inc	ax		; Increment by 1
mov	[word_3A4E2], ax
mov	ax, [MagSet_20]
mov	[word_3A4DC], ax
mov	ax, 1
jmp	short loc_3E50A	; Jump

loc_3E56D:		; CODE XREF: sub_3E1DE+333j
cmp	si, [word_3AB1A] ; Compare Two Operands
jnz	short loc_3E584	; Jump if Not Zero (ZF=0)
inc	[MagSet_20]	; Increment by 1
cmp	[MagSet_20], 4	; Compare Two Operands
jle	short loc_3E584	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[MagSet_20], 0

loc_3E584:		; CODE XREF: sub_3E1DE+393j
			; sub_3E1DE+39Ej
cmp	si, [word_3AB18] ; Compare Two Operands
jnz	short loc_3E59B	; Jump if Not Zero (ZF=0)
inc	[MagSet_21]	; Increment by 1
cmp	[MagSet_21], 4	; Compare Two Operands
jle	short loc_3E59B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[MagSet_21], 1

loc_3E59B:		; CODE XREF: sub_3E1DE+3AAj
			; sub_3E1DE+3B5j
cmp	si, [word_3AB14] ; Compare Two Operands
jnz	short loc_3E5B2	; Jump if Not Zero (ZF=0)
inc	[MagSet_23]	; Increment by 1
cmp	[MagSet_23], 2	; Compare Two Operands
jle	short loc_3E5B2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[MagSet_23], 0

loc_3E5B2:		; CODE XREF: sub_3E1DE+3C1j
			; sub_3E1DE+3CCj
cmp	si, [word_3AB16] ; Compare Two Operands
jnz	short loc_3E5C9	; Jump if Not Zero (ZF=0)
inc	[MagSet_22]	; Increment by 1
cmp	[MagSet_22], 2	; Compare Two Operands
jle	short loc_3E5C9	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[MagSet_22], 0

loc_3E5C9:		; CODE XREF: sub_3E1DE+3D8j
			; sub_3E1DE+3E3j
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_3E5FF	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_3E60E ; Call Procedure
call	sub_2E303	; Call Procedure
cmp	[idk_CfgMom_w381BE], 0 ; Compare Two Operands
jz	short loc_3E5F5	; Jump if Zero (ZF=1)
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_3E5F5	; Jump if Not Zero (ZF=0)
call	sub_1E525	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_43381 ; Call Procedure
mov	[bp+var_2], 1

loc_3E5F5:		; CODE XREF: sub_3E1DE+400j
			; sub_3E1DE+406j
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_3E5FF:		; CODE XREF: sub_3E1DE+30Aj
			; sub_3E1DE+3EFj
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_3E608	; Jump if Not Zero (ZF=0)
jmp	loc_3E4EB	; Jump

loc_3E608:		; CODE XREF: sub_3E1DE:loc_3E50Aj
			; sub_3E1DE+425j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3E1DE



; Attributes: bp-based frame

proc sub_3E60E far	; CODE XREF: sub_3187AJ
			; sub_3E1DE+3F3p

var_9A=	byte ptr -9Ah
var_92=	byte ptr -92h
var_72=	byte ptr -72h
var_56=	byte ptr -56h
var_40=	byte ptr -40h
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 92h		; Integer Subtraction
mov	ax, [word_34B26]
mov	dx, [word_34B24]
mov	[bp+var_2], ax
mov	[bp+var_4], dx
mov	ax, [word_34B2A]
mov	dx, [word_34B28]
mov	[bp+var_6], ax
mov	[bp+var_8], dx
lea	ax, [bp+var_40]	; Load Effective Address
push	ss
push	ax
mov	ax, 2E1Ch
push	ds
push	ax
mov	cx, 37h	; '7'
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_56]	; Load Effective Address
push	ss
push	ax
mov	ax, 2E53h
push	ds
push	ax
mov	cx, 15h
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_72]	; Load Effective Address
push	ss
push	ax
mov	ax, 2E68h
push	ds
push	ax
mov	cx, 1Bh
call	SCOPY@		; Call Procedure

loc_3E665:		; Load Effective Address
lea	ax, [bp+var_92]
push	ss
push	ax
mov	ax, 2E83h
push	ds
push	ax
mov	cx, 20h	; ' '
call	SCOPY@		; Call Procedure
push	[idk_LBX_w36FC8]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 36h	; '6'
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 26h	; '&'
push	ax
mov	ax, 0FAh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 52h	; 'R'
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 41h	; 'A'
push	ax
mov	ax, 0FAh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add

loc_3E6C0:		; Logical Exclusive OR
xor	ax, ax
push	ax
mov	ax, 6Bh	; 'k'
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 5Ch	; '\'
push	ax
mov	ax, 0FAh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 86h	; ''
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 77h	; 'w'
push	ax
mov	ax, 0FAh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0C1h ; ''
push	ax
mov	ax, 13Bh
push	ax
mov	ax, 0B2h ; ''
push	ax
mov	ax, 0FBh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0C1h ; ''
push	ax
mov	ax, 0EAh ; ''
push	ax
mov	ax, 0B2h ; ''
push	ax
mov	ax, 0AAh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
push	[idk_LBX_w3AB78]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0A5h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_3E73F:		; Call Procedure
call	sub_2601C
mov	[word_36FD4], ax
mov	ax, 0Fh
push	ax		; int
mov	ax, 3
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
mov	ax, [word_36FD4]
cmp	ax, [word_3AB1A] ; Compare Two Operands
jz	short loc_3E7C6	; Jump if Zero (ZF=1)
push	[idk_LBX_w3AB5A]
mov	ax, 27h	; '''
push	ax
mov	ax, 0FBh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_20]
mov	dx, 0Bh
imul	dx		; Signed Multiply

loc_3E78A:		; Load Effective Address
lea	dx, [bp+var_40]
add	ax, dx		; Add
push	ax		; int
mov	ax, 2Bh	; '+'
push	ax		; int

loc_3E794:
mov	ax, 11Bh
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_20]
mov	dx, 0Bh
imul	dx		; Signed Multiply
lea	dx, [bp+var_40]	; Load Effective Address
add	ax, dx		; Add
push	ax
mov	ax, 2Ah	; '*'
push	ax
mov	ax, 11Ah
jmp	short loc_3E82B	; Jump

loc_3E7C6:		; CODE XREF: sub_3E60E+14Fj
push	[idk_LBX_w3AB5A]
mov	ax, 28h	; '('
push	ax
mov	ax, 0FCh ; ''
push	ax
call	sub_1F655	; Call Procedure

loc_3E7D7:		; Add
add	sp, 6
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_20]
mov	dx, 0Bh
imul	dx		; Signed Multiply
lea	dx, [bp+var_40]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 2Ch	; ','
push	ax		; int
mov	ax, 11Ch
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_20]
mov	dx, 0Bh
imul	dx		; Signed Multiply
lea	dx, [bp+var_40]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 2Bh	; '+'
push	ax		; int
mov	ax, 11Bh

loc_3E82B:		; CODE XREF: sub_3E60E+1B6j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, [word_36FD4]

loc_3E837:		; Compare Two Operands
cmp	ax, [word_3AB18]
jz	short loc_3E8A4	; Jump if Zero (ZF=1)
push	[idk_LBX_w3AB5C]
mov	ax, 42h	; 'B'
push	ax
mov	ax, 0FBh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_4]	; Load Effective Address
push	ax

loc_3E855:
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_21]
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
lea	dx, [bp+var_9A]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 47h	; 'G'
push	ax		; int
mov	ax, 11Bh
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_21]
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
lea	dx, [bp+var_9A]	; Load Effective Address
add	ax, dx		; Add
push	ax
mov	ax, 46h	; 'F'
push	ax
mov	ax, 11Ah
jmp	short loc_3E909	; Jump

loc_3E8A4:		; CODE XREF: sub_3E60E+22Dj
push	[idk_LBX_w3AB5C]
mov	ax, 43h	; 'C'
push	ax
mov	ax, 0FCh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_21]
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
lea	dx, [bp+var_9A]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 48h	; 'H'
push	ax		; int
mov	ax, 11Ch
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_21]
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
lea	dx, [bp+var_9A]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 47h	; 'G'
push	ax		; int
mov	ax, 11Bh

loc_3E909:		; CODE XREF: sub_3E60E+294j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, [word_36FD4]
cmp	ax, [word_3AB14] ; Compare Two Operands
jz	short loc_3E982	; Jump if Zero (ZF=1)
push	[idk_LBX_w3AB5E]
mov	ax, 5Dh	; ']'
push	ax
mov	ax, 0FBh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
mov	ax, 3
push	ax

loc_3E937:		; Call Procedure
call	sub_19399
pop	cx
pop	cx
mov	ax, [MagSet_23]
mov	dx, 7
imul	dx		; Signed Multiply
lea	dx, [bp+var_56]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 61h	; 'a'
push	ax		; int
mov	ax, 11Bh
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_23]
mov	dx, 7
imul	dx		; Signed Multiply
lea	dx, [bp+var_56]	; Load Effective Address
add	ax, dx		; Add
push	ax

loc_3E979:
mov	ax, 60h	; '`'
push	ax
mov	ax, 11Ah
jmp	short loc_3E9E7	; Jump

loc_3E982:		; CODE XREF: sub_3E60E+30Bj
push	[idk_LBX_w3AB5E]
mov	ax, 5Eh	; '^'
push	ax
mov	ax, 0FCh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_23]
mov	dx, 7
imul	dx		; Signed Multiply
lea	dx, [bp+var_56]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 62h	; 'b'
push	ax		; int
mov	ax, 11Ch
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_23]
mov	dx, 7
imul	dx		; Signed Multiply
lea	dx, [bp+var_56]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 61h	; 'a'
push	ax		; int
mov	ax, 11Bh

loc_3E9E7:		; CODE XREF: sub_3E60E+372j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, [word_36FD4]
cmp	ax, [word_3AB16] ; Compare Two Operands
jz	short loc_3EA60	; Jump if Zero (ZF=1)
push	[idk_LBX_w3AB60]
mov	ax, 78h	; 'x'
push	ax
mov	ax, 0FBh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_22]
mov	dx, 9
imul	dx		; Signed Multiply
lea	dx, [bp+var_72]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 7Ch	; '|'
push	ax		; int

loc_3EA2E:
mov	ax, 11Bh
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_22]
mov	dx, 9
imul	dx		; Signed Multiply
lea	dx, [bp+var_72]	; Load Effective Address
add	ax, dx		; Add
push	ax
mov	ax, 7Bh	; '{'
push	ax
mov	ax, 11Ah
jmp	short loc_3EAC5	; Jump

loc_3EA60:		; CODE XREF: sub_3E60E+3E9j
push	[idk_LBX_w3AB60]
mov	ax, 79h	; 'y'
push	ax
mov	ax, 0FCh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_22]
mov	dx, 9
imul	dx		; Signed Multiply
lea	dx, [bp+var_72]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 7Dh	; '}'
push	ax		; int
mov	ax, 11Ch
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [MagSet_22]
mov	dx, 9
imul	dx		; Signed Multiply
lea	dx, [bp+var_72]	; Load Effective Address
add	ax, dx		; Add
push	ax		; int
mov	ax, 7Ch	; '|'
push	ax		; int
mov	ax, 11Bh

loc_3EAC5:		; CODE XREF: sub_3E60E+450j
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3E60E



; Attributes: bp-based frame

proc sub_3EAD2 far	; CODE XREF: sub_318E8J
			; sub_3E1DE+36Ep

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction
mov	ax, [MagSet_22]
imul	[MagSet_21]	; Signed Multiply
push	ax
mov	ax, [MagSet_20]
imul	[MagSet_23]	; Signed Multiply
mov	dx, ax
pop	ax
imul	dx		; Signed Multiply
mov	dx, 7Bh	; '{'
imul	dx		; Signed Multiply
add	ax, 4D2h	; Add
cwd			; AX ->	DX:AX (with sign)
mov	[bp+var_2], dx
mov	[bp+var_4], ax
mov	[bp+var_6], 0
mov	[bp+var_8], 0
jmp	loc_3EB88	; Jump

loc_3EB08:		; CODE XREF: sub_3EAD2+BCj
			; sub_3EAD2+C7j
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7240h], ax

loc_3EB1C:
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7256h], ax
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-726Ch], ax
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7298h], ax
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7282h], ax
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-72AEh], ax
add	[bp+var_8], 1	; Add
adc	[bp+var_6], 0	; Add with Carry

loc_3EB88:		; CODE XREF: sub_3EAD2+33j
cmp	[bp+var_6], 0	; Compare Two Operands
jge	short loc_3EB91	; Jump if Greater or Equal (SF=OF)
jmp	loc_3EB08	; Jump

loc_3EB91:		; CODE XREF: sub_3EAD2+BAj
jnz	short loc_3EB9C	; Jump if Not Zero (ZF=0)
cmp	[bp+var_8], 0Bh	; Compare Two Operands
jnb	short loc_3EB9C	; Jump if Not Below (CF=0)
jmp	loc_3EB08	; Jump

loc_3EB9C:		; CODE XREF: sub_3EAD2:loc_3EB91j
			; sub_3EAD2+C5j
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3EAD2



; Attributes: bp-based frame

proc sub_3EBA0 far	; CODE XREF: sub_318A7J
			; sub_3DA30:loc_3DA8Cp

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction
push	si
push	di
xor	di, di		; Logical Exclusive OR
cmp	[MagSet_20], 1	; Compare Two Operands
jge	short loc_3EBB6	; Jump if Greater or Equal (SF=OF)
mov	di, 7
jmp	short loc_3EBB9	; Jump

loc_3EBB6:		; CODE XREF: sub_3EBA0+Fj
mov	di, 8

loc_3EBB9:		; CODE XREF: sub_3EBA0+14j
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
xor	ax, ax		; Logical Exclusive OR
push	ax		; argEntryNumber
mov	ax, 3090h
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add

loc_3EBCC:
mov	[idk_LBX_w36FC8], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_3EBF2	; Jump

loc_3EBD3:		; CODE XREF: sub_3EBA0+55j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 9		; Add
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71B6h], ax
inc	si		; Increment by 1

loc_3EBF2:		; CODE XREF: sub_3EBA0+31j
cmp	si, 0Fh		; Compare Two Operands
jl	short loc_3EBD3	; Jump if Less (SF!=OF)
or	di, di		; Logical Inclusive OR
jnz	short loc_3EC04	; Jump if Not Zero (ZF=0)
push	[idk_LBX_w37EBE]
mov	ax, 8
jmp	short loc_3EC0B	; Jump

loc_3EC04:		; CODE XREF: sub_3EBA0+59j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 27h	; '''

loc_3EC0B:		; CODE XREF: sub_3EBA0+62j
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB78], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_3EC3E	; Jump

loc_3EC1F:		; CODE XREF: sub_3EBA0+A1j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 18h		; Add
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-721Ah], ax
inc	si		; Increment by 1

loc_3EC3E:		; CODE XREF: sub_3EBA0+7Dj
cmp	si, 0Fh		; Compare Two Operands
jl	short loc_3EC1F	; Jump if Less (SF!=OF)
mov	ax, 2ABCh
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	[bp+var_4], 0
mov	[bp+var_2], 0
mov	[word_3AB58], 0
mov	[word_3AAF2], 8
mov	[word_3AB38], 0FC18h
xor	si, si		; Logical Exclusive OR
jmp	short loc_3ECAE	; Jump

loc_3EC77:		; CODE XREF: sub_3EBA0+111j
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2Ah	; '*'   ; Add
push	ax
mov	ax, 0EDh ; ''
push	ax
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Ah		; Add
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71F4h], ax
inc	si		; Increment by 1

loc_3ECAE:		; CODE XREF: sub_3EBA0+D5j
cmp	si, 7		; Compare Two Operands
jl	short loc_3EC77	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3ECEE	; Jump

loc_3ECB7:		; CODE XREF: sub_3EBA0:loc_3ECF0j
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2Ah	; '*'   ; Add
push	ax
mov	ax, 139h
push	ax
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Ah		; Add
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71E6h], ax
inc	si		; Increment by 1

loc_3ECEE:		; CODE XREF: sub_3EBA0+115j
cmp	si, di		; Compare Two Operands

loc_3ECF0:		; Jump if Less (SF!=OF)
jl	short loc_3ECB7
mov	ax, 3059h
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
mov	[bp+var_8], ax
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
cmp	[MagSet_20], 1	; Compare Two Operands
jge	short loc_3ED1E	; Jump if Greater or Equal (SF=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_3ED21	; Jump

loc_3ED1E:		; CODE XREF: sub_3EBA0+178j
mov	ax, 1

loc_3ED21:		; CODE XREF: sub_3EBA0+17Cj
push	ax
nop			; No Operation
push	cs
call	near ptr LBX_HelpEntry_s43484 ;	Call Procedure
pop	cx

loc_3ED28:
mov	ax, 2
push	ax
call	sub_2B9C4	; Call Procedure
pop	cx
jmp	loc_3EDC2	; Jump

loc_3ED35:		; CODE XREF: sub_3EBA0+228j
call	sub_2B97A	; Call Procedure
mov	[bp+var_6], ax
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, [bp+var_6]
cmp	ax, [bp+var_8]	; Compare Two Operands
jnz	short loc_3ED4E	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR

loc_3ED4C:		; CODE XREF: sub_3EBA0+1D3j
			; sub_3EBA0+1F1j
jmp	short loc_3EDCB	; Jump

loc_3ED4E:		; CODE XREF: sub_3EBA0+1A8j
xor	si, si		; Logical Exclusive OR
jmp	short loc_3ED76	; Jump

loc_3ED52:		; CODE XREF: sub_3EBA0+1D9j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_3ED75	; Jump if Not Zero (ZF=0)
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
push	si		; char
nop			; No Operation
push	cs
call	near ptr sub_430A4 ; Call Procedure
pop	cx
mov	ax, 3
jmp	short loc_3ED4C	; Jump

loc_3ED75:		; CODE XREF: sub_3EBA0+1BDj
inc	si		; Increment by 1

loc_3ED76:		; CODE XREF: sub_3EBA0+1B0j
cmp	si, 0Eh		; Compare Two Operands
jl	short loc_3ED52	; Jump if Less (SF!=OF)
mov	ax, [bp+var_6]
cmp	ax, [word_3AB38] ; Compare Two Operands
jnz	short loc_3ED93	; Jump if Not Zero (ZF=0)
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	ax, 2
jmp	short loc_3ED4C	; Jump

loc_3ED93:		; CODE XREF: sub_3EBA0+1E2j
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_3EDC2	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_3EDD1 ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_2E303	; Call Procedure
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_3EDB8	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 1
call	sub_1E525	; Call Procedure

loc_3EDB8:		; CODE XREF: sub_3EBA0+20Cj
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_3EDC2:		; CODE XREF: sub_3EBA0+192j
			; sub_3EBA0+1F7j
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_3EDCB	; Jump if Not Zero (ZF=0)
jmp	loc_3ED35	; Jump

loc_3EDCB:		; CODE XREF: sub_3EBA0:loc_3ED4Cj
			; sub_3EBA0+226j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3EBA0 ; sp-analysis failed



; Attributes: bp-based frame

proc sub_3EDD1 far	; CODE XREF: sub_3187FJ
			; sub_3EBA0+1FBp
			; sub_3F3C6+1B5p

argDst=	byte ptr -32h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_A= word ptr	-0Ah
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 32h		; Integer Subtraction
push	si
push	di		; argSrc
lea	ax, [bp+var_A]	; Load Effective Address
push	ss
push	ax
mov	ax, 2EA3h
push	ds
push	ax
mov	cx, 8
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_12]	; Load Effective Address
push	ss
push	ax
mov	ax, 2EABh
push	ds
push	ax
mov	cx, 8
call	SCOPY@		; Call Procedure
mov	ax, [word_34BC3]
mov	[bp+var_14], ax
call	sub_2601C	; Call Procedure
mov	di, ax
call	sub_27AFB	; Call Procedure
or	ax, ax		; Logical Inclusive OR
jz	short loc_3EE1C	; Jump if Zero (ZF=1)
call	sub_27AFB	; Call Procedure
dec	ax		; Decrement by 1
mov	[word_3AB58], ax

loc_3EE1C:		; CODE XREF: sub_3EDD1+40j
push	[idk_LBX_w36FC8]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
push	[idk_LBX_w3AB78]
mov	ax, 11h
push	ax
mov	ax, 0A5h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 5
push	ax
mov	ax, 5
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
cmp	[word_3AAF2], 8	; Compare Two Operands
jnz	short loc_3EE5D	; Jump if Not Zero (ZF=0)
mov	ax, 30ACh
jmp	short loc_3EE60	; Jump

loc_3EE5D:		; CODE XREF: sub_3EDD1+85j
mov	ax, 30BAh

loc_3EE60:		; CODE XREF: sub_3EDD1+8Aj
push	ax		; int
mov	ax, 1
push	ax		; int
mov	ax, 0F2h ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 2Ah	; '*'
push	ax
mov	ax, 0EDh ; ''
push	ax
mov	ax, 1Bh
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 40h	; '@'
push	ax
mov	ax, 0EDh ; ''
push	ax
mov	ax, 30h	; '0'
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 56h	; 'V'
push	ax
mov	ax, 0EDh ; ''
push	ax
mov	ax, 46h	; 'F'
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 6Ch	; 'l'
push	ax
mov	ax, 0EDh ; ''
push	ax
mov	ax, 5Ch	; '\'
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 82h	; ''
push	ax
mov	ax, 0EDh ; ''
push	ax
mov	ax, 72h	; 'r'
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 98h	; ''
push	ax
mov	ax, 0EDh ; ''
push	ax
mov	ax, 88h	; ''
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0AEh ; ''
push	ax
mov	ax, 0EDh ; ''
push	ax

loc_3EF1E:
mov	ax, 9Eh	; ''
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 2Ah	; '*'
push	ax
mov	ax, 139h
push	ax
mov	ax, 1Ah
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 40h	; '@'
push	ax
mov	ax, 139h
push	ax
mov	ax, 30h	; '0'
push	ax
mov	ax, 0F4h ; ''
push	ax

loc_3EF5C:		; Call Procedure
call	idk_VGA_ScData_s186BC
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 56h	; 'V'

loc_3EF6A:
push	ax
mov	ax, 139h
push	ax
mov	ax, 46h	; 'F'
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 6Ch	; 'l'
push	ax
mov	ax, 139h
push	ax
mov	ax, 5Ch	; '\'
push	ax
mov	ax, 0F4h ; ''
push	ax

loc_3EF92:		; Call Procedure
call	idk_VGA_ScData_s186BC

loc_3EF97:		; Add
add	sp, 0Ah
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 82h	; ''
push	ax
mov	ax, 139h
push	ax
mov	ax, 72h	; 'r'
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 98h	; ''
push	ax
mov	ax, 139h
push	ax
mov	ax, 88h	; ''

loc_3EFC3:
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add

loc_3EFD0:		; Logical Exclusive OR
xor	ax, ax
push	ax
mov	ax, 0AEh ; ''
push	ax
mov	ax, 139h

loc_3EFDA:
push	ax
mov	ax, 9Eh	; ''
push	ax

loc_3EFDF:
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure

loc_3EFE8:		; Add
add	sp, 0Ah
cmp	[word_3AAF2], 8	; Compare Two Operands
jnz	short loc_3F014	; Jump if Not Zero (ZF=0)
cmp	[MagSet_20], 0	; Compare Two Operands
jle	short loc_3F014	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0C4h ; ''
push	ax
mov	ax, 139h
push	ax
mov	ax, 0B4h ; ''
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add

loc_3F014:		; CODE XREF: sub_3EDD1+21Fj
			; sub_3EDD1+226j
cmp	[word_3AB58], 0Eh ; Compare Two	Operands

loc_3F019:		; Jump if Greater or Equal (SF=OF)
jge	short loc_3F035
mov	bx, [word_3AB58]

loc_3F01F:		; Shift	Logical	Left
shl	bx, 1
push	[word ptr bx+52C6h]
mov	ax, 0Ah
push	ax
mov	ax, 18h
push	ax
call	sub_1F655	; Call Procedure

loc_3F032:		; Add
add	sp, 6

loc_3F035:		; CODE XREF: sub_3EDD1:loc_3F019j
mov	ax, 0Fh
push	ax		; int
mov	ax, 3
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx

loc_3F043:
pop	cx

loc_3F044:		; Logical Exclusive OR
xor	si, si
jmp	loc_3F14F	; Jump

loc_3F049:		; CODE XREF: sub_3EDD1+383j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_3F04D:		; Compare Two Operands
cmp	[bx-71F4h], di

loc_3F051:		; Jump if Zero (ZF=1)
jz	short loc_3F0CD
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_3F057:
push	[word ptr bx-71B6h]
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Bh		; Add
push	ax
mov	ax, 0A9h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_A]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax		; int
mov	ax, si
mov	dx, 16h

loc_3F091:		; Signed Multiply
imul	dx

loc_3F093:		; Add
add	ax, 1Fh
push	ax		; int
mov	ax, 0CBh ; ''
push	ax		; int

loc_3F09B:		; Call Procedure
call	sub_196ED
add	sp, 6		; Add
lea	ax, [bp+var_12]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_3F0B2:
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply

loc_3F0C4:		; Add
add	ax, 1Eh
push	ax

loc_3F0C8:
mov	ax, 0CAh ; ''
jmp	short loc_3F145	; Jump

loc_3F0CD:		; CODE XREF: sub_3EDD1:loc_3F051j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_3F0D1:
push	[word ptr bx-71B6h]
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Ch		; Add
push	ax
mov	ax, 0AAh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_A]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax		; int
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 20h	; ' '   ; Add
push	ax		; int

loc_3F111:
mov	ax, 0CCh ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_12]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax		; int
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Fh		; Add
push	ax		; int
mov	ax, 0CBh ; ''

loc_3F145:		; CODE XREF: sub_3EDD1+2FAj
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
inc	si		; Increment by 1

loc_3F14F:		; CODE XREF: sub_3EDD1+275j
cmp	si, 7		; Compare Two Operands
jge	short loc_3F157	; Jump if Greater or Equal (SF=OF)
jmp	loc_3F049	; Jump

loc_3F157:		; CODE XREF: sub_3EDD1+381j
mov	ax, [word_3AAF2]
mov	[bp+var_2], ax
cmp	[MagSet_20], 1	; Compare Two Operands
jge	short loc_3F169	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_2], 7

loc_3F169:		; CODE XREF: sub_3EDD1+391j
xor	si, si		; Logical Exclusive OR
jmp	loc_3F274	; Jump

loc_3F16E:		; CODE XREF: sub_3EDD1+4A8j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
cmp	[bx-71E6h], di	; Compare Two Operands
jz	short loc_3F1F2	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-71A8h]
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Bh		; Add
push	ax
mov	ax, 0F5h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_A]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2B6Ah	; Add
push	ax		; int
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Fh		; Add
push	ax		; int
mov	ax, 117h
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_12]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2B6Ah	; Add
push	ax
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Eh		; Add
push	ax
mov	ax, 116h
jmp	short loc_3F26A	; Jump

loc_3F1F2:		; CODE XREF: sub_3EDD1+3A5j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-71A8h]
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Ch		; Add

loc_3F204:
push	ax
mov	ax, 0F6h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_A]	; Load Effective Address
push	ax
mov	ax, 3
push	ax

loc_3F219:		; Call Procedure
call	sub_19399
pop	cx
pop	cx
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2B6Ah	; Add
push	ax		; int
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 20h	; ' '   ; Add
push	ax		; int
mov	ax, 118h
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_12]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2B6Ah	; Add
push	ax		; int
mov	ax, si
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Fh		; Add
push	ax		; int
mov	ax, 117h

loc_3F26A:		; CODE XREF: sub_3EDD1+41Fj
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
inc	si		; Increment by 1

loc_3F274:		; CODE XREF: sub_3EDD1+39Aj
cmp	si, [bp+var_2]	; Compare Two Operands
jge	short loc_3F27C	; Jump if Greater or Equal (SF=OF)
jmp	loc_3F16E	; Jump

loc_3F27C:		; CODE XREF: sub_3EDD1+4A6j
mov	ax, [word_3AB58]
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
db 83h,0BFh,0E4h,2Ah,0FFh ; <BAD>cmp	 [word ptr bx+2AE4h], 0FFFFh ; Compare Two Operands
jnz	short loc_3F290	; Jump if Not Zero (ZF=0)
jmp	loc_3F324	; Jump

loc_3F290:		; CODE XREF: sub_3EDD1+4BAj
cmp	[word_3AAF2], 8	; Compare Two Operands
jz	short loc_3F29A	; Jump if Zero (ZF=1)
jmp	loc_3F324	; Jump

loc_3F29A:		; CODE XREF: sub_3EDD1+4C4j
cmp	[word_3AB58], 0Eh ; Compare Two	Operands
jl	short loc_3F2A4	; Jump if Less (SF!=OF)
jmp	loc_3F324	; Jump

loc_3F2A4:		; CODE XREF: sub_3EDD1+4CEj
mov	ax, 0Fh
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_12]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [word_3AB58]
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax

loc_3F2CA:
mov	bx, [bx+2AE4h]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+1F96h]
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 30C9h
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
mov	ax, 0B5h ; ''
push	ax
mov	ax, 0Dh
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_14]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
mov	ax, 0B4h ; ''
push	ax
mov	ax, 0Ch
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add

loc_3F324:		; CODE XREF: sub_3EDD1+4BCj
			; sub_3EDD1+4C6j
			; sub_3EDD1+4D0j
cmp	[word_3AAF2], 8	; Compare Two Operands
jnz	short loc_3F335	; Jump if Not Zero (ZF=0)
push	[word_3AB58]
nop			; No Operation
push	cs
call	near ptr sub_40584 ; Call Procedure
pop	cx

loc_3F335:		; CODE XREF: sub_3EDD1+558j
cmp	[word_3AB58], 0Eh ; Compare Two	Operands
jl	short loc_3F33F	; Jump if Less (SF!=OF)
jmp	loc_3F3C0	; Jump

loc_3F33F:		; CODE XREF: sub_3EDD1+569j
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_A]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [word_3AB58]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Eh	; 'N'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, [word_3AB58]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_12]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [word_3AB58]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax		; int
mov	ax, 77h	; 'w'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add

loc_3F3C0:		; CODE XREF: sub_3EDD1+56Bj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3EDD1



; Attributes: bp-based frame

proc sub_3F3C6 far	; CODE XREF: sub_318ACJ
			; sub_3DA30:loc_3DAA1p

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di		; argSrc
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
xor	ax, ax		; Logical Exclusive OR
push	ax		; argEntryNumber
mov	ax, 3090h
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w36FC8], ax
mov	[bp+var_4], 0
jmp	short loc_3F40E	; Jump

loc_3F3EB:		; CODE XREF: sub_3F3C6+4Cj
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, [bp+var_4]
add	ax, 9		; Add
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71B6h], ax
inc	[bp+var_4]	; Increment by 1

loc_3F40E:		; CODE XREF: sub_3F3C6+23j
cmp	[bp+var_4], 0Fh	; Compare Two Operands
jl	short loc_3F3EB	; Jump if Less (SF!=OF)
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 27h	; '''
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB78], ax
mov	ax, 2ABCh
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
xor	si, si		; Logical Exclusive OR
xor	di, di		; Logical Exclusive OR
mov	[word_3AB58], 0
mov	[word_3AAF2], 7
mov	[bp+var_4], 0
jmp	short loc_3F492	; Jump

loc_3F456:		; CODE XREF: sub_3F3C6+D0j
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, [bp+var_4]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2Ah	; '*'   ; Add
push	ax
mov	ax, 0EDh ; ''
push	ax
mov	ax, [bp+var_4]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Ah		; Add
push	ax
mov	ax, 0A8h ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71F4h], ax
inc	[bp+var_4]	; Increment by 1

loc_3F492:		; CODE XREF: sub_3F3C6+8Ej
cmp	[bp+var_4], 7	; Compare Two Operands
jl	short loc_3F456	; Jump if Less (SF!=OF)
mov	[bp+var_4], 0
jmp	short loc_3F4DB	; Jump

loc_3F49F:		; CODE XREF: sub_3F3C6+119j
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, [bp+var_4]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2Ah	; '*'   ; Add
push	ax
mov	ax, 139h
push	ax
mov	ax, [bp+var_4]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 1Ah		; Add
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71E6h], ax
inc	[bp+var_4]	; Increment by 1

loc_3F4DB:		; CODE XREF: sub_3F3C6+D7j
cmp	[bp+var_4], 7	; Compare Two Operands
jl	short loc_3F49F	; Jump if Less (SF!=OF)
mov	ax, 3059h
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
mov	[bp+var_6], ax
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 2Fh	; '/'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
nop			; No Operation
push	cs
call	near ptr LBX_HelpEntry_s43451 ;	Call Procedure
mov	ax, 2
push	ax
call	sub_2B9C4	; Call Procedure
pop	cx
jmp	loc_3F59E	; Jump

loc_3F514:		; CODE XREF: sub_3F3C6+1DCj
call	sub_2B97A	; Call Procedure
mov	[bp+var_2], ax
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, [bp+var_2]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_3F52E	; Jump if Not Zero (ZF=0)
mov	ax, 1

loc_3F52C:		; CODE XREF: sub_3F3C6+1E2j
jmp	short loc_3F5AA	; Jump

loc_3F52E:		; CODE XREF: sub_3F3C6+161j
mov	[bp+var_4], 0
jmp	short loc_3F570	; Jump

loc_3F535:		; CODE XREF: sub_3F3C6+1AEj
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_2]	; Compare Two Operands
jnz	short loc_3F56D	; Jump if Not Zero (ZF=0)
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	al, [byte ptr bp+var_4]
mov	[byte_38610], al
mov	ax, [bp+var_4]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax
mov	ax, 6901h
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	si, 1

loc_3F56D:		; CODE XREF: sub_3F3C6+17Bj
inc	[bp+var_4]	; Increment by 1

loc_3F570:		; CODE XREF: sub_3F3C6+16Dj
cmp	[bp+var_4], 0Eh	; Compare Two Operands
jl	short loc_3F535	; Jump if Less (SF!=OF)
or	si, si		; Logical Inclusive OR
jnz	short loc_3F59E	; Jump if Not Zero (ZF=0)
push	cs
call	near ptr sub_3EDD1 ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_2E303	; Call Procedure
or	di, di		; Logical Inclusive OR
jnz	short loc_3F594	; Jump if Not Zero (ZF=0)
mov	di, 1
call	sub_1E525	; Call Procedure

loc_3F594:		; CODE XREF: sub_3F3C6+1C4j
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_3F59E:		; CODE XREF: sub_3F3C6+14Bj
			; sub_3F3C6+1B2j
or	si, si		; Logical Inclusive OR
jnz	short loc_3F5A5	; Jump if Not Zero (ZF=0)
jmp	loc_3F514	; Jump

loc_3F5A5:		; CODE XREF: sub_3F3C6+1DAj
mov	ax, 3
jmp	short loc_3F52C	; Jump

loc_3F5AA:		; CODE XREF: sub_3F3C6:loc_3F52Cj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3F3C6



; call LBX_PreLoadEntry_0_1
; idk_LBX_w37EBE,  0, "NEWGAME.LBX"
;
; call LBX_PreLoadEntry_0_2
; idk_LBX_w37EBE, 40, "NEWGAME.LBX"
;
; Attributes: bp-based frame

proc idk_Load_NEWGAME_LBX far
			; CODE XREF: j_idk_Load_NEWGAME_LBXJ
			; sub_3DA30:loc_3DAA8p

argDest= byte ptr -12h
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 12h		; argSrc
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
xor	ax, ax		; Logical Exclusive OR
push	ax		; argEntryNumber
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; LBX_Load_Entry_0_1(0,"NEWGAME.LBX")
add	sp, 6		; Add
mov	[idk_LBX_w36FC8], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 40
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; LBX_Load_Entry_0_2(40,"NEWGAME.LBX")
add	sp, 6		; Add
mov	[idk_LBX_w3AB78], ax
mov	ax, offset unk_347CC
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 34h
push	ax
call	sub_2E1FB	; ? settings an	indirect call function ?
			; ? stub050:0034 ?
add	sp, 6		; Add
nop			; No Operation
push	cs
call	near ptr sub_3F6BF ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_2E303	; Call Procedure
mov	ax, 8
push	ax		; int
mov	ax, 8
push	ax		; int
mov	ax, 3
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, offset unk_38611
push	ax
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 0FFFFh
push	ax		; int
mov	ax, offset unk_347D8
push	ax		; int
mov	ax, 1
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 10
push	ax		; int
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; int
mov	ax, 80
push	ax		; int
mov	ax, 36
push	ax		; int
mov	ax, 195		; int
push	ax		; int
call	sub_28583	; Call Procedure
add	sp, 14h		; Add
mov	[bp+var_2], ax
lea	ax, [bp+argDest] ; int
push	ax		; dest
call	sub_1A576	; Call Procedure
pop	cx
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; s
call	_strlen		; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jge	short loc_3F696	; Jump if Greater or Equal (SF=OF)
mov	ax, offset unk_38611
push	ax
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_3F696:		; CODE XREF: idk_Load_NEWGAME_LBX+D5j
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
mov	ax, offset unk_38611
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
call	sub_2E257	; Call Procedure
db 83h,7Eh,0FEh,0FFh ; <BAD>cmp	    [bp+var_2],	0FFFFh ; Compare Two Operands
jnz	short loc_3F6B7	; Jump if Not Zero (ZF=0)
mov	ax, -1

loc_3F6B3:		; CODE XREF: idk_Load_NEWGAME_LBX+109j
jmp	short loc_3F6BB	; Jump
jmp	short loc_3F6BB	; Jump

loc_3F6B7:		; CODE XREF: idk_Load_NEWGAME_LBX+FEj
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_3F6B3	; Jump

loc_3F6BB:		; CODE XREF: idk_Load_NEWGAME_LBX:loc_3F6B3j
			; idk_Load_NEWGAME_LBX+105j
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_Load_NEWGAME_LBX ; sp-analysis	failed



; Attributes: bp-based frame

proc sub_3F6BF far	; CODE XREF: sub_31884J
			; idk_Load_NEWGAME_LBX+5Dp

var_10=	byte ptr -10h
var_8= byte ptr	-8

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
lea	ax, [bp+var_8]	; Load Effective Address
push	ss
push	ax
mov	ax, offset unk_34BC5
push	ds
push	ax
mov	cx, 8
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_10]	; Load Effective Address
push	ss
push	ax
mov	ax, offset unk_34BCD
push	ds
push	ax
mov	cx, 8
call	SCOPY@		; Call Procedure
push	[idk_LBX_w36FC8]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
push	[idk_LBX_w3AB78]
mov	ax, 11h
push	ax
mov	ax, 0B5h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 5
push	ax
mov	ax, 5
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
mov	ax, offset aWizardSName	; "Wizard's Name"
push	ax		; int
mov	ax, 1
push	ax		; int
mov	ax, 0F2h ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	al, [byte_38610]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax

loc_3F73A:
push	[word_36FD6+bx]
mov	ax, 0Ah
push	ax
mov	ax, 18h
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_8]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, offset unk_38611
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Eh	; 'N'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, offset unk_38611
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_10]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, offset unk_38611
push	ax		; int

loc_3F7A7:
mov	ax, 77h	; 'w'

loc_3F7AA:		; int
push	ax
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add

loc_3F7B7:		; Compare Two Operands
cmp	[word_3AAF2], 7

loc_3F7BC:		; Jump if Zero (ZF=1)
jz	short loc_3F7D4

loc_3F7BE:
mov	[word_3AAF2], 0
mov	al, [byte_38610]
cbw			; AL ->	AX (with sign)
push	ax
nop			; No Operation

loc_3F7CA:
push	cs
call	near ptr sub_40584 ; Call Procedure
pop	cx
nop			; No Operation
push	cs
call	near ptr sub_4043A ; Call Procedure

loc_3F7D4:		; CODE XREF: sub_3F6BF:loc_3F7BCj
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3F6BF



; Attributes: bp-based frame

proc sub_3F7D8 far	; CODE XREF: sub_318C5J
			; sub_3DA30+C9p

var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0Eh		; Integer Subtraction
push	si
push	di
lea	ax, [bp+var_C]	; Load Effective Address
push	ss
push	ax
mov	ax, 2EC5h
push	ds
push	ax
mov	cx, 8
call	SCOPY@		; Call Procedure
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS

loc_3F7F6:		; Logical Exclusive OR
xor	ax, ax
push	ax		; argEntryNumber

loc_3F7F9:
mov	ax, 3090h
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w36FC8], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Eh	; '.'
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add

loc_3F81C:
mov	[idk_LBX_w3AB78], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_3F842	; Jump

loc_3F823:		; CODE XREF: sub_3F7D8+6Dj
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si

loc_3F829:		; Add
add	ax, 18h
push	ax		; argFileName
mov	ax, 3090h

loc_3F830:		; argEntryNumber
push	ax
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add

loc_3F839:
mov	bx, si

loc_3F83B:		; Shift	Logical	Left
shl	bx, 1

loc_3F83D:
mov	[bx-721Ah], ax
inc	si		; Increment by 1

loc_3F842:		; CODE XREF: sub_3F7D8+49j
cmp	si, 0Fh		; Compare Two Operands
jl	short loc_3F823	; Jump if Less (SF!=OF)
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 35h	; '5'
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3AAE6], ax
mov	ax, 2ABCh
push	ax
mov	ax, 1
push	ax

loc_3F866:		; Call Procedure
call	wtf_s23F3E
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
xor	di, di		; Logical Exclusive OR
mov	[bp+var_2], 0
mov	ax, 0FFFFh
push	ax

loc_3F87D:
mov	ax, 3049h
push	ax
mov	ax, 37h	; '7'
push	ax
mov	ax, 139h
push	ax
mov	ax, 15h
push	ax
mov	ax, 0AFh ; ''
push	ax

loc_3F891:		; Call Procedure
call	idk_Mouse_s29A0B
add	sp, 0Ch		; Add

loc_3F899:
mov	[word_3AB1C], ax

loc_3F89C:
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax

loc_3F8A4:
mov	ax, 5Dh	; ']'
push	ax

loc_3F8A8:
mov	ax, 139h
push	ax

loc_3F8AC:
mov	ax, 38h	; '8'
push	ax

loc_3F8B0:
mov	ax, 0AFh ; ''
push	ax

loc_3F8B4:		; Call Procedure
call	idk_Mouse_s29A0B
add	sp, 0Ch		; Add
mov	[word_3AB1E], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 80h	; ''
push	ax
mov	ax, 139h
push	ax
mov	ax, 5Eh	; '^'
push	ax
mov	ax, 0AFh ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_3AB20], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h

loc_3F8E9:
push	ax
mov	ax, 0A2h ; ''
push	ax
mov	ax, 139h
push	ax

loc_3F8F2:
mov	ax, 81h	; ''
push	ax
mov	ax, 0AFh ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_3AB22], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 0C7h ; ''
push	ax

loc_3F911:
mov	ax, 139h
push	ax
mov	ax, 0A3h ; ''
push	ax
mov	ax, 0AFh ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_3AB24], ax

loc_3F928:
mov	ax, 3059h
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure

loc_3F931:
pop	cx

loc_3F932:
mov	[bp+var_E], ax

loc_3F935:
mov	ax, 1

loc_3F938:
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 43h	; 'C'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
nop			; No Operation
push	cs
call	near ptr LBX_HelpEntry_s4341E ;	Call Procedure
jmp	loc_3F9E4	; Jump

loc_3F951:		; CODE XREF: sub_3F7D8+210j
call	_f020105_bios_timeofday	; Call Procedure
call	sub_2B97A	; Call Procedure
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
cmp	ax, [bp+var_E]	; Compare Two Operands
jnz	short loc_3F96C	; Jump if Not Zero (ZF=0)
mov	ax, 6

loc_3F969:		; CODE XREF: sub_3F7D8+220j
jmp	loc_3F9FB	; Jump

loc_3F96C:		; CODE XREF: sub_3F7D8+18Cj
xor	si, si		; Logical Exclusive OR
jmp	short loc_3F9B2	; Jump

loc_3F970:		; CODE XREF: sub_3F7D8+1DDj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_3F9B1	; Jump if Not Zero (ZF=0)
mov	bx, si
cmp	bx, 4		; switch 5 cases
ja	short loc_3F9AE	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_3FA02+bx] ; switch jump

loc_3F98B:		; DATA XREF: ovr050:off_3FA02o
mov	[byte_38626], 1	; case 0x0

loc_3F990:		; default
jmp	short loc_3F9AE

loc_3F992:		; CODE XREF: sub_3F7D8+1AEj
			; DATA XREF: ovr050:off_3FA02o
mov	[byte_38626], 0	; case 0x1
jmp	short loc_3F9AE	; default

loc_3F999:		; CODE XREF: sub_3F7D8+1AEj
			; DATA XREF: ovr050:off_3FA02o
mov	[byte_38626], 3	; case 0x2
jmp	short loc_3F9AE	; default

loc_3F9A0:		; CODE XREF: sub_3F7D8+1AEj
			; DATA XREF: ovr050:off_3FA02o
mov	[byte_38626], 2	; case 0x3
jmp	short loc_3F9AE	; default

loc_3F9A7:		; CODE XREF: sub_3F7D8+1AEj
			; DATA XREF: ovr050:off_3FA02o
mov	[byte_38626], 4	; case 0x4
jmp	short $+2	; Jump

loc_3F9AE:		; CODE XREF: sub_3F7D8+1AAj
			; sub_3F7D8:loc_3F990j
			; sub_3F7D8+1BFj
			; sub_3F7D8+1C6j
			; sub_3F7D8+1CDj
mov	di, 1		; default

loc_3F9B1:		; CODE XREF: sub_3F7D8+1A3j
inc	si		; Increment by 1

loc_3F9B2:		; CODE XREF: sub_3F7D8+196j
cmp	si, 5		; Compare Two Operands
jl	short loc_3F970	; Jump if Less (SF!=OF)
or	di, di		; Logical Inclusive OR
jnz	short loc_3F9E4	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_3FA0C ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_2E303	; Call Procedure
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_3F9DA	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 1
call	sub_1E525	; Call Procedure

loc_3F9DA:		; CODE XREF: sub_3F7D8+1F6j
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_3F9E4:		; CODE XREF: sub_3F7D8+176j
			; sub_3F7D8+1E1j
or	di, di		; Logical Inclusive OR
jnz	short loc_3F9EB	; Jump if Not Zero (ZF=0)
jmp	loc_3F951	; Jump

loc_3F9EB:		; CODE XREF: sub_3F7D8+20Ej
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	ax, 63h	; 'c'
jmp	loc_3F969	; Jump

loc_3F9FB:		; CODE XREF: sub_3F7D8:loc_3F969j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3F7D8

align 2
off_3FA02 dw offset loc_3F98B
			; DATA XREF: sub_3F7D8+1AEr
dw offset loc_3F992	; jump table for switch	statement
dw offset loc_3F999
dw offset loc_3F9A0
dw offset loc_3F9A7


; Attributes: bp-based frame

proc sub_3FA0C far	; CODE XREF: sub_31893J
			; sub_3F7D8+1E5p

var_C= word ptr	-0Ch
var_6= word ptr	-6

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
lea	ax, [bp+var_6]	; Load Effective Address
push	ss
push	ax

loc_3FA19:
mov	ax, 2ECDh
push	ds
push	ax
mov	cx, 5
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_C]	; Load Effective Address
push	ss
push	ax
mov	ax, 2ED2h
push	ds
push	ax
mov	cx, 5
call	SCOPY@		; Call Procedure
push	[idk_LBX_w36FC8]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_3FA4A:
push	[idk_LBX_w3AB78]
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 9Eh	; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 5
push	ax
mov	ax, 5
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
mov	ax, 30D9h
push	ax		; int
mov	ax, 1
push	ax		; int
mov	ax, 0F2h ; ''
push	ax		; int

loc_3FA78:		; Call Procedure
call	sub_196ED
add	sp, 6		; Add
mov	al, [byte_38610]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax

loc_3FA88:
push	[word ptr bx+52C6h]
mov	ax, 0Ah
push	ax
mov	ax, 18h
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int

loc_3FAA4:		; Call Procedure
call	idk_PalFnt_s1AB64
pop	cx
pop	cx
lea	ax, [bp+var_6]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_3FABA:
mov	ax, 6901h
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Eh	; 'N'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, 6901h
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_C]	; Load Effective Address
push	ax
mov	ax, 4
push	ax

loc_3FAEA:		; Call Procedure
call	sub_19399
pop	cx
pop	cx
mov	ax, 6901h
push	ax		; int
mov	ax, 77h	; 'w'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	di, 24h	; '$'
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FB2B	; Jump

loc_3FB0C:		; CODE XREF: sub_3FA0C+123j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-721Ah]

loc_3FB1A:
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_3FB2B:		; CODE XREF: sub_3FA0C+FEj
cmp	si, [word_38670] ; Compare Two Operands
jl	short loc_3FB0C	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FB54	; Jump

loc_3FB35:		; CODE XREF: sub_3FA0C+14Cj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7214h]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_3FB54:		; CODE XREF: sub_3FA0C+127j
cmp	si, [word_3866C] ; Compare Two Operands
jl	short loc_3FB35	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FB7D	; Jump

loc_3FB5E:		; CODE XREF: sub_3FA0C+175j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-720Eh]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_3FB7D:		; CODE XREF: sub_3FA0C+150j
cmp	si, [word_3866A] ; Compare Two Operands
jl	short loc_3FB5E	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FBA6	; Jump

loc_3FB87:		; CODE XREF: sub_3FA0C+19Ej
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7208h]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_3FBA6:		; CODE XREF: sub_3FA0C+179j
cmp	si, [word_38672] ; Compare Two Operands
jl	short loc_3FB87	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FBCF	; Jump

loc_3FBB0:		; CODE XREF: sub_3FA0C+1C7j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7202h]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_3FBCF:		; CODE XREF: sub_3FA0C+1A2j
cmp	si, [word_3866E] ; Compare Two Operands
jl	short loc_3FBB0	; Jump if Less (SF!=OF)
nop			; No Operation
push	cs
call	near ptr sub_4043A ; Call Procedure
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_3FA0C



; Attributes: bp-based frame

proc sub_3FBE0 far	; CODE XREF: sub_318C0J
			; sub_3DA30+AFp

var_34=	word ptr -34h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_10=	word ptr -10h
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 34h		; Integer Subtraction
push	si
push	di
lea	ax, [bp+var_34]	; Load Effective Address
push	ss
push	ax
mov	ax, 2ED8h
push	ds
push	ax
mov	cx, 12h
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_10]	; Load Effective Address
push	ss
push	ax
mov	ax, 2EEAh
push	ds
push	ax
mov	cx, 0Ah
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_18]	; Load Effective Address
push	ss
push	ax
mov	ax, 2EF4h
push	ds
push	ax
mov	cx, 8
call	SCOPY@		; Call Procedure
mov	ax, [word_34C0C]
mov	[bp+var_1A], ax
mov	ax, [word_34C0E]
mov	[bp+var_1C], ax
mov	ax, [word_34C10]
mov	[bp+var_1E], ax
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
xor	ax, ax		; Logical Exclusive OR
push	ax		; argEntryNumber
mov	ax, 3090h
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w36FC8], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 36h	; '6'
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB78], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 37h	; '7'
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w3AB5A], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Ch	; ','
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADD8], ax
push	[idk_LBX_w37EBE] ; arg4_Int

loc_3FC8F:
mov	ax, 2Dh	; '-'
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADD6], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FCC5	; Jump

loc_3FCA6:		; CODE XREF: sub_3FBE0+E8j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 18h		; Add
push	ax		; argFileName
mov	ax, 3090h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-721Ah], ax
inc	si		; Increment by 1

loc_3FCC5:		; CODE XREF: sub_3FBE0+C4j
cmp	si, 0Fh		; Compare Two Operands
jl	short loc_3FCA6	; Jump if Less (SF!=OF)
mov	ax, 2ABCh
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	[bp+var_4], 0
mov	[bp+var_2], 0
mov	[bp+var_20], 6964h
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FD28	; Jump

loc_3FCF1:		; CODE XREF: sub_3FBE0+14Bj
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, si
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 2Dh	; '-'   ; Add
push	ax
mov	ax, 10Eh
push	ax
mov	ax, si
mov	dx, 0Ah
imul	dx		; Signed Multiply

loc_3FD0F:		; Add
add	ax, 26h	; '&'
push	ax
mov	ax, 0D3h ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71F4h], ax
inc	si		; Increment by 1

loc_3FD28:		; CODE XREF: sub_3FBE0+10Fj
cmp	si, 9		; Compare Two Operands
jl	short loc_3FCF1	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FD68	; Jump

loc_3FD31:		; CODE XREF: sub_3FBE0+18Bj
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, si
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 9Ah	; ''   ; Add
push	ax
mov	ax, 10Eh
push	ax
mov	ax, si
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 93h	; ''   ; Add
push	ax
mov	ax, 0D3h ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71E2h], ax
inc	si		; Increment by 1

loc_3FD68:		; CODE XREF: sub_3FBE0+14Fj
cmp	si, 5		; Compare Two Operands
jl	short loc_3FD31	; Jump if Less (SF!=OF)
mov	ax, 3059h
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
mov	[bp+var_22], ax
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 3Eh	; '>'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
nop			; No Operation
push	cs
call	near ptr LBX_HelpEntry_s434F6 ;	Call Procedure
jmp	loc_3FE84	; Jump

loc_3FD96:		; CODE XREF: sub_3FBE0+2AAj
call	_f020105_bios_timeofday	; Call Procedure
call	sub_2B97A	; Call Procedure
mov	[bp+var_6], ax
mov	ax, [bp+var_6]
cmp	ax, [bp+var_22]	; Compare Two Operands
jnz	short loc_3FDB1	; Jump if Not Zero (ZF=0)
mov	ax, 0FFFFh

loc_3FDAE:		; CODE XREF: sub_3FBE0+44Ej
jmp	loc_40031	; Jump

loc_3FDB1:		; CODE XREF: sub_3FBE0+1C9j
xor	si, si		; Logical Exclusive OR
jmp	short loc_3FDD6	; Jump

loc_3FDB5:		; CODE XREF: sub_3FBE0+1F9j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_3FDD5	; Jump if Not Zero (ZF=0)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_34]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	[word_3ABB4], ax
mov	[bp+var_4], 1

loc_3FDD5:		; CODE XREF: sub_3FBE0+1E0j
inc	si		; Increment by 1

loc_3FDD6:		; CODE XREF: sub_3FBE0+1D3j
cmp	si, 9		; Compare Two Operands
jl	short loc_3FDB5	; Jump if Less (SF!=OF)
mov	si, 9
jmp	short loc_3FE50	; Jump

loc_3FDE0:		; CODE XREF: sub_3FBE0+273j
mov	bx, [bp+var_20]
cmp	[byte ptr bx+9], 1 ; Compare Two Operands
jnz	short loc_3FE0B	; Jump if Not Zero (ZF=0)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_3FE09	; Jump if Not Zero (ZF=0)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	[word_3ABB4], ax
mov	[bp+var_4], 1

loc_3FE09:		; CODE XREF: sub_3FBE0+214j
jmp	short loc_3FE4F	; Jump

loc_3FE0B:		; CODE XREF: sub_3FBE0+207j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_3FE4F	; Jump if Not Zero (ZF=0)
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	ax, 30E7h
push	ax
call	sub_31ABF	; Call Procedure
pop	cx
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 3Eh	; '>'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
mov	ax, 0Eh
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx

loc_3FE4F:		; CODE XREF: sub_3FBE0:loc_3FE09j
			; sub_3FBE0+236j
inc	si		; Increment by 1

loc_3FE50:		; CODE XREF: sub_3FBE0+1FEj
cmp	si, 0Eh		; Compare Two Operands
jl	short loc_3FDE0	; Jump if Less (SF!=OF)
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_3FE84	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_40037 ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_2E303	; Call Procedure
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_3FE7A	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 1
call	sub_1E525	; Call Procedure

loc_3FE7A:		; CODE XREF: sub_3FBE0+28Ej
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_3FE84:		; CODE XREF: sub_3FBE0+1B3j
			; sub_3FBE0+279j
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_3FE8D	; Jump if Not Zero (ZF=0)
jmp	loc_3FD96	; Jump

loc_3FE8D:		; CODE XREF: sub_3FBE0+2A8j
xor	si, si		; Logical Exclusive OR
jmp	loc_40019	; Jump

loc_3FE92:		; CODE XREF: sub_3FBE0:loc_4001Ej
call	_f020105_bios_timeofday	; Call Procedure
xor	di, di		; Logical Exclusive OR
jmp	loc_3FF3A	; Jump

loc_3FE9C:		; CODE XREF: sub_3FBE0+35Fj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_34]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [word_3ABB4] ; Compare Two Operands
jz	short loc_3FEB0	; Jump if Zero (ZF=1)
jmp	loc_3FF39	; Jump

loc_3FEB0:		; CODE XREF: sub_3FBE0+2CBj
lea	ax, [bp+var_1E]	; Load Effective Address
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_34]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax
push	[word ptr bx+1DF6h]
mov	ax, di
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 27h	; '''   ; Add
push	ax
mov	ax, 0DDh ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
or	si, si		; Logical Inclusive OR
jz	short loc_3FEF5	; Jump if Zero (ZF=1)
cmp	si, 2		; Compare Two Operands
jnz	short loc_3FEFA	; Jump if Not Zero (ZF=0)

loc_3FEF5:		; CODE XREF: sub_3FBE0+30Ej
lea	ax, [bp+var_1C]	; Load Effective Address
jmp	short loc_3FEFD	; Jump

loc_3FEFA:		; CODE XREF: sub_3FBE0+313j
lea	ax, [bp+var_1A]	; Load Effective Address

loc_3FEFD:		; CODE XREF: sub_3FBE0+318j
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_34]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax
push	[word ptr bx+1DF6h]
mov	ax, di
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 26h	; '&'   ; Add
push	ax
mov	ax, 0DCh ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	di, 9

loc_3FF39:		; CODE XREF: sub_3FBE0+2CDj
inc	di		; Increment by 1

loc_3FF3A:		; CODE XREF: sub_3FBE0+2B9j
cmp	di, 9		; Compare Two Operands
jge	short loc_3FF42	; Jump if Greater or Equal (SF=OF)
jmp	loc_3FE9C	; Jump

loc_3FF42:		; CODE XREF: sub_3FBE0+35Dj
mov	di, 9
jmp	loc_3FFEC	; Jump

loc_3FF48:		; CODE XREF: sub_3FBE0+411j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [word_3ABB4] ; Compare Two Operands
jz	short loc_3FF5C	; Jump if Zero (ZF=1)
jmp	loc_3FFEB	; Jump

loc_3FF5C:		; CODE XREF: sub_3FBE0+377j
lea	ax, [bp+var_1E]	; Load Effective Address
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax
push	[word ptr bx+1DF6h]
mov	ax, di
add	ax, 0FFF7h	; Add
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 94h	; ''   ; Add
push	ax
mov	ax, 0DDh ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
or	si, si		; Logical Inclusive OR
jz	short loc_3FFA4	; Jump if Zero (ZF=1)

loc_3FF9F:		; Compare Two Operands
cmp	si, 2
jnz	short loc_3FFA9	; Jump if Not Zero (ZF=0)

loc_3FFA4:		; CODE XREF: sub_3FBE0+3BDj
lea	ax, [bp+var_1A]	; Load Effective Address
jmp	short loc_3FFAC	; Jump

loc_3FFA9:		; CODE XREF: sub_3FBE0+3C2j
lea	ax, [bp+var_1C]	; Load Effective Address

loc_3FFAC:		; CODE XREF: sub_3FBE0+3C7j
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure

loc_3FFB6:
pop	cx
pop	cx
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax
push	[word ptr bx+1DF6h]
mov	ax, di
add	ax, 0FFF7h	; Add
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 93h	; ''   ; Add
push	ax
mov	ax, 0DCh ; ''
push	ax

loc_3FFE0:		; Call Procedure
call	sub_1993F
add	sp, 6		; Add
mov	di, 0Eh

loc_3FFEB:		; CODE XREF: sub_3FBE0+379j
inc	di		; Increment by 1

loc_3FFEC:		; CODE XREF: sub_3FBE0+365j
cmp	di, 0Eh		; Compare Two Operands
jge	short loc_3FFF4	; Jump if Greater or Equal (SF=OF)
jmp	loc_3FF48	; Jump

loc_3FFF4:		; CODE XREF: sub_3FBE0+40Fj
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_2E303	; Call Procedure
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_4000E	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 1

loc_40009:		; Call Procedure
call	sub_1E525

loc_4000E:		; CODE XREF: sub_3FBE0+422j
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
inc	si		; Increment by 1

loc_40019:		; CODE XREF: sub_3FBE0+2AFj
cmp	si, 4		; Compare Two Operands

loc_4001C:		; Jump if Greater or Equal (SF=OF)
jge	short loc_40021

loc_4001E:		; Jump
jmp	loc_3FE92

loc_40021:		; CODE XREF: sub_3FBE0:loc_4001Cj
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	ax, 7
jmp	loc_3FDAE	; Jump

loc_40031:		; CODE XREF: sub_3FBE0:loc_3FDAEj
pop	di
pop	si
mov	sp, bp
pop	bp

locret_40036:		; Return Far from Procedure
retf
endp sub_3FBE0



; Attributes: bp-based frame

proc sub_40037 far	; CODE XREF: sub_3188EJ
			; sub_3FBE0+27Dp

var_3C=	word ptr -3Ch
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1A=	word ptr -1Ah
var_14=	word ptr -14h
var_E= word ptr	-0Eh
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 3Ch		; Integer Subtraction
push	si

loc_4003E:
push	di

loc_4003F:		; Load Effective Address
lea	ax, [bp+var_3C]
push	ss
push	ax
mov	ax, 2F02h
push	ds
push	ax
mov	cx, 12h
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_E]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F14h
push	ds
push	ax
mov	cx, 0Ah

loc_4005E:		; Call Procedure
call	SCOPY@
lea	ax, [bp+var_14]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F1Eh
push	ds
push	ax
mov	cx, 5
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_1A]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F23h
push	ds

loc_4007E:
push	ax
mov	cx, 5
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_20]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F28h
push	ds
push	ax
mov	cx, 5
call	SCOPY@		; Call Procedure
mov	ax, [word_34C3D]
mov	[bp+var_22], ax
mov	ax, [word_34C3F]
mov	[bp+var_24], ax
mov	ax, [word_34C41]
mov	[bp+var_26], ax
mov	ax, [word_34C43]
mov	[bp+var_28], ax
push	[idk_LBX_w36FC8]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_400BB:		; Call Procedure
call	sub_1F655

loc_400C0:		; Add
add	sp, 6
push	[idk_LBX_w3AB78]
mov	ax, 12h
push	ax
mov	ax, 0A4h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
push	[idk_LBX_w3AB5A]
mov	ax, 22h	; '"'
push	ax
mov	ax, 0D0h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 5
push	ax
mov	ax, 5
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
mov	ax, 312Ch
push	ax		; int
mov	ax, 1
push	ax		; int
mov	ax, 0F2h ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	al, [byte_38610]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax

loc_40116:
push	[word ptr bx+52C6h]
mov	ax, 0Ah
push	ax
mov	ax, 18h
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_14]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_40148:
mov	ax, 6901h
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Eh	; 'N'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, 6901h
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add

loc_40170:		; Load Effective Address
lea	ax, [bp+var_1A]
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 6901h
push	ax		; int
mov	ax, 77h	; 'w'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure

loc_40190:		; Add
add	sp, 6

loc_40193:		; Call Procedure
call	sub_27AFB
mov	[bp+var_4], ax
mov	[bp+var_2A], 6964h
mov	[bp+var_2], 24h	; '$'
xor	si, si		; Logical Exclusive OR
jmp	short loc_401CB	; Jump

loc_401A9:		; CODE XREF: sub_40037+198j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-721Ah]
mov	ax, 87h	; ''
push	ax
push	[bp+var_2]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_2], 8	; Add
inc	si		; Increment by 1

loc_401CB:		; CODE XREF: sub_40037+170j
cmp	si, [word_38670] ; Compare Two Operands
jl	short loc_401A9	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_401F7	; Jump

loc_401D5:		; CODE XREF: sub_40037+1C4j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7214h]
mov	ax, 87h	; ''
push	ax
push	[bp+var_2]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_2], 8	; Add
inc	si		; Increment by 1

loc_401F7:		; CODE XREF: sub_40037+19Cj
cmp	si, [word_3866C] ; Compare Two Operands
jl	short loc_401D5	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_40223	; Jump

loc_40201:		; CODE XREF: sub_40037+1F0j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-720Eh]
mov	ax, 87h	; ''
push	ax
push	[bp+var_2]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_2], 8	; Add
inc	si		; Increment by 1

loc_40223:		; CODE XREF: sub_40037+1C8j
cmp	si, [word_3866A] ; Compare Two Operands
jl	short loc_40201	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4024F	; Jump

loc_4022D:		; CODE XREF: sub_40037+21Cj
mov	bx, si

loc_4022F:		; Shift	Logical	Left
shl	bx, 1
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left

loc_40237:
push	[word ptr bx-7208h]
mov	ax, 87h	; ''
push	ax
push	[bp+var_2]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_2], 8	; Add
inc	si		; Increment by 1

loc_4024F:		; CODE XREF: sub_40037+1F4j
cmp	si, [word_38672] ; Compare Two Operands
jl	short loc_4022D	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4027B	; Jump

loc_40259:		; CODE XREF: sub_40037+248j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_4025D:
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left

loc_40263:
push	[word ptr bx-7202h]

loc_40267:
mov	ax, 87h	; ''
push	ax
push	[bp+var_2]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_2], 8	; Add
inc	si		; Increment by 1

loc_4027B:		; CODE XREF: sub_40037+220j
cmp	si, [word_3866E] ; Compare Two Operands
jl	short loc_40259	; Jump if Less (SF!=OF)
nop			; No Operation
push	cs
call	near ptr sub_4043A ; Call Procedure
lea	ax, [bp+var_20]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure

loc_40293:
pop	cx
pop	cx
mov	ax, 0Fh
push	ax
mov	ax, 3
push	ax

loc_4029D:		; Call Procedure
call	sub_1922A
pop	cx
pop	cx
mov	ax, 3138h
push	ax

loc_402A8:
mov	ax, 19h
push	ax
mov	ax, 0C6h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
xor	di, di		; Logical Exclusive OR
jmp	loc_40348	; Jump

loc_402BD:		; CODE XREF: sub_40037+316j
lea	ax, [bp+var_28]	; Load Effective Address
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_3C]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax

loc_402DE:
push	[word ptr bx+1DF6h]
mov	ax, di
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 27h	; '''   ; Add
push	ax

loc_402ED:
mov	ax, 0DDh ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]

loc_40301:		; Compare Two Operands
cmp	ax, [bp+var_4]
jnz	short loc_4030B	; Jump if Not Zero (ZF=0)
lea	ax, [bp+var_22]	; Load Effective Address
jmp	short loc_4030E	; Jump

loc_4030B:		; CODE XREF: sub_40037+2CDj
lea	ax, [bp+var_24]	; Load Effective Address

loc_4030E:		; CODE XREF: sub_40037+2D2j
push	ax
mov	ax, 2
push	ax

loc_40313:		; Call Procedure
call	sub_19399
pop	cx

loc_40319:
pop	cx
mov	bx, di
shl	bx, 1		; Shift	Logical	Left

loc_4031E:		; Load Effective Address
lea	ax, [bp+var_3C]

loc_40321:		; Add
add	bx, ax
mov	ax, [bx]
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax
push	[word ptr bx+1DF6h]
mov	ax, di
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 26h	; '&'   ; Add
push	ax
mov	ax, 0DCh ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
inc	di		; Increment by 1

loc_40348:		; CODE XREF: sub_40037+283j
cmp	di, 9		; Compare Two Operands

loc_4034B:		; Jump if Greater or Equal (SF=OF)
jge	short loc_40350
jmp	loc_402BD	; Jump

loc_40350:		; CODE XREF: sub_40037:loc_4034Bj
lea	ax, [bp+var_20]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_4035F:
mov	ax, 0Fh

loc_40362:
push	ax

loc_40363:
mov	ax, 3
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
mov	ax, 3148h
push	ax
mov	ax, 86h	; ''
push	ax
mov	ax, 0CAh ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
xor	di, di		; Logical Exclusive OR
jmp	loc_4042C	; Jump

loc_40387:		; CODE XREF: sub_40037:loc_40431j
lea	ax, [bp+var_28]	; Load Effective Address
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_E]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax
push	[word ptr bx+1DF6h]
mov	ax, di
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 94h	; ''   ; Add
push	ax
mov	ax, 0DDh ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	bx, [bp+var_2A]
cmp	[byte ptr bx+9], 1 ; Compare Two Operands

loc_403CA:		; Jump if Not Zero (ZF=0)
jnz	short loc_403EF
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71E2h]
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_403DE	; Jump if Not Zero (ZF=0)
lea	ax, [bp+var_22]	; Load Effective Address
jmp	short loc_403E1	; Jump

loc_403DE:		; CODE XREF: sub_40037+3A0j
lea	ax, [bp+var_24]	; Load Effective Address

loc_403E1:		; CODE XREF: sub_40037+3A5j
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
jmp	short loc_403FE	; Jump

loc_403EF:		; CODE XREF: sub_40037:loc_403CAj
lea	ax, [bp+var_26]	; Load Effective Address
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_403FE:		; CODE XREF: sub_40037+3B6j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_E]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax
push	[word ptr bx+1DF6h]
mov	ax, di
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	ax, 93h	; ''   ; Add
push	ax
mov	ax, 0DCh ; ''
push	ax

loc_40423:		; Call Procedure
call	sub_1993F

loc_40428:		; Add
add	sp, 6
inc	di		; Increment by 1

loc_4042C:		; CODE XREF: sub_40037+34Dj
cmp	di, 5		; Compare Two Operands
jge	short loc_40434	; Jump if Greater or Equal (SF=OF)

loc_40431:		; Jump
jmp	loc_40387

loc_40434:		; CODE XREF: sub_40037+3F8j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_40037



; Attributes: bp-based frame

proc sub_4043A far	; CODE XREF: sub_31901J
			; sub_3F6BF+112p
			; sub_3FA0C+1CBp
			; sub_40037+24Cp
			; sub_40EC0+B8Cp
			; sub_424BB+2A6p

var_98=	word ptr -98h
argDst=	byte ptr -8Ch
var_E= word ptr	-0Eh
dest= word ptr -0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 98h		; Integer Subtraction
push	si
push	di		; argSrc
mov	ax, [word_34C47]
mov	dx, [word_34C45] ; int
mov	[bp+var_2], ax
mov	[bp+var_4], dx
mov	ax, [word_34C49]
mov	[bp+var_6], ax
lea	ax, [bp+var_98]	; Load Effective Address
push	ss
push	ax

loc_4045C:
mov	ax, 2F3Ch
push	ds

loc_40460:
push	ax

loc_40461:
mov	cx, 0Ch
call	SCOPY@		; Call Procedure
mov	[bp+var_A], 0

loc_4046E:
mov	[bp+dest], 0
mov	[bp+argDst], 0
mov	[bp+var_8], 6964h
xor	di, di		; Logical Exclusive OR
xor	si, si		; Logical Exclusive OR
jmp	short loc_4048F	; Jump

loc_40483:		; CODE XREF: sub_4043A+58j
mov	bx, [bp+var_8]

loc_40486:		; Add
add	bx, si
cmp	[byte ptr bx], 1 ; Compare Two Operands
jnz	short loc_4048E	; Jump if Not Zero (ZF=0)
inc	di		; Increment by 1

loc_4048E:		; CODE XREF: sub_4043A+51j
inc	si		; Increment by 1

loc_4048F:		; CODE XREF: sub_4043A+47j
cmp	si, 12h		; Compare Two Operands
jl	short loc_40483	; Jump if Less (SF!=OF)
mov	ax, 3049h
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_404A4:
mov	[bp+dest], 0

loc_404A9:		; Logical Exclusive OR
xor	si, si
jmp	short loc_404DE	; Jump

loc_404AD:		; CODE XREF: sub_4043A:loc_404E1j
mov	bx, [bp+var_8]

loc_404B0:		; Add
add	bx, si
cmp	[byte ptr bx], 1 ; Compare Two Operands
jnz	short loc_404DD	; Jump if Not Zero (ZF=0)
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; int
push	di
lea	ax, [bp+dest]	; int
push	ax		; dest
nop			; No Operation
push	cs
call	near ptr sub_43529 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+1F96h]
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)

loc_404DB:
pop	cx
pop	cx

loc_404DD:		; CODE XREF: sub_4043A+7Bj
inc	si		; Increment by 1

loc_404DE:		; CODE XREF: sub_4043A+71j
cmp	si, 12h		; Compare Two Operands

loc_404E1:		; Jump if Less (SF!=OF)
jl	short loc_404AD
or	di, di		; Logical Inclusive OR
jle	short loc_404F7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 30C9h
push	ax

loc_404EB:		; Load Effective Address
lea	ax, [bp+argDst]

loc_404EF:		; argDst
push	ax

loc_404F0:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx

loc_404F7:		; CODE XREF: sub_4043A+ABj
cmp	di, 5		; Compare Two Operands
jle	short loc_40503	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_E], 0B2h ; ''
jmp	short loc_40508	; Jump

loc_40503:		; CODE XREF: sub_4043A+C0j
mov	[bp+var_E], 0B4h ; ''

loc_40508:		; CODE XREF: sub_4043A+C7j
mov	ax, 0Fh
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_4]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 1
push	ax
call	sub_19316	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
mov	ax, 8Ah	; ''
push	ax
mov	ax, [bp+var_E]
inc	ax		; Increment by 1
push	ax
mov	ax, 0Dh
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
lea	ax, [bp+var_6]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_40559:
mov	ax, 1
push	ax
call	sub_19316	; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
mov	ax, 8Ah	; ''
push	ax
push	[bp+var_E]
mov	ax, 0Ch
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
pop	di
pop	si
mov	sp, bp
pop	bp

locret_40583:		; Return Far from Procedure
retf
endp sub_4043A ; sp-analysis failed



; Attributes: bp-based frame

proc sub_40584 far	; CODE XREF: sub_318F7J
			; sub_3EDD1+560p
			; sub_3F6BF+10Cp

var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 0Eh		; Integer Subtraction
push	si
push	di
mov	[bp+var_2], 0FFFFh
mov	[bp+var_4], 0FFFFh
mov	[bp+var_8], 0
mov	[bp+var_A], 0
mov	di, 24h	; '$'
mov	[bp+var_C], 0FFFFh
mov	[bp+var_E], 0FFFFh
mov	ax, [bp+arg_0]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2ADAh	; Add
mov	[bp+var_6], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_4060C	; Jump

loc_405BF:		; CODE XREF: sub_40584+8Bj
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_6]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands

loc_405CB:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_4060B
db 83h,7Eh,0FEh,0FFh ; <BAD>cmp	    [bp+var_2],	0FFFFh ; Compare Two Operands
jnz	short loc_405F0	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 3
imul	dx		; Signed Multiply
mov	[bp+var_2], ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_6]
add	bx, ax		; Add
mov	ax, [bx]
add	[bp+var_8], ax	; Add
mov	[bp+var_C], si
jmp	short loc_4060B	; Jump

loc_405F0:		; CODE XREF: sub_40584+4Dj
mov	ax, si
mov	dx, 3
imul	dx		; Signed Multiply
mov	[bp+var_4], ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_6]
add	bx, ax		; Add
mov	ax, [bx]
add	[bp+var_A], ax	; Add
mov	[bp+var_E], si

loc_4060B:		; CODE XREF: sub_40584:loc_405CBj
			; sub_40584+6Aj
inc	si		; Increment by 1

loc_4060C:		; CODE XREF: sub_40584+39j
cmp	si, 5		; Compare Two Operands
jl	short loc_405BF	; Jump if Less (SF!=OF)
db 83h,7Eh,0FEh,0FFh ; <BAD>cmp	    [bp+var_2],	0FFFFh ; Compare Two Operands
jz	short loc_40644	; Jump if Zero (ZF=1)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4063F	; Jump

loc_4061B:		; CODE XREF: sub_40584+BEj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_2]
add	ax, [bx-72AEh]	; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
push	[word ptr bx-721Ah]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_4063B:		; Add
add	di, 8
inc	si		; Increment by 1

loc_4063F:		; CODE XREF: sub_40584+95j
cmp	si, [bp+var_8]	; Compare Two Operands
jl	short loc_4061B	; Jump if Less (SF!=OF)

loc_40644:		; CODE XREF: sub_40584+91j
db 83h,7Eh,0FCh,0FFh ; <BAD>cmp	    [bp+var_4],	0FFFFh ; Compare Two Operands
jz	short loc_40677	; Jump if Zero (ZF=1)
xor	si, si		; Logical Exclusive OR

loc_4064C:		; Jump
jmp	short loc_40672

loc_4064E:		; CODE XREF: sub_40584+F1j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_4]
add	ax, [bx-72AEh]	; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
push	[word ptr bx-721Ah]
mov	ax, 87h	; ''
push	ax

loc_40665:
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_40672:		; CODE XREF: sub_40584:loc_4064Cj
cmp	si, [bp+var_A]	; Compare Two Operands
jl	short loc_4064E	; Jump if Less (SF!=OF)

loc_40677:		; CODE XREF: sub_40584+C4j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_40584



; Attributes: bp-based frame

proc sub_4067D far	; CODE XREF: sub_318B6J
			; sub_3DA30+A1p

var_E8=	word ptr -0E8h
argDst=	byte ptr -0B6h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
argPtrCharArr= byte ptr	-14h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0E8h	; Integer Subtraction
push	si
push	di		; argConversionBase
lea	ax, [bp+var_E8]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F48h
push	ds
push	ax
mov	cx, 32h	; '2'
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_1E]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F7Ah
push	ds
push	ax
mov	cx, 0Ah
call	SCOPY@		; Call Procedure
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
mov	ax, 29h	; ')'
push	ax		; argEntryNumber
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w36FC8], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Ah	; '*'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[idk_LBX_w379C0], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Bh	; '+'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ABBC], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_40713	; Jump

LOOP_x15:		; CODE XREF: sub_4067D+99j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 24		; Add
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-721Ah], ax
inc	si		; Increment by 1

loc_40713:		; CODE XREF: sub_4067D+75j
cmp	si, 15		; Compare Two Operands
jl	short LOOP_x15	; Jump if Less (SF!=OF)
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Ch	; ','
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADD8], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Dh	; '-'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADD6], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 34h	; '4'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ABA6], ax
mov	ax, 2ABCh
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
call	SetFlag_1_CfgMom_w36A54	; Call Procedure
mov	[bp+var_E], 6964h
mov	[bp+var_4], 0
mov	[bp+var_2], 0
mov	[word_3AB58], 0
mov	[word_3ABA4], 0Bh
mov	[word_3ABBA], 0
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 0C4h ; ''
push	ax
mov	ax, 11Ah
push	ax
mov	ax, 0B5h ; ''
push	ax
mov	ax, 0FBh ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[word_3ABA2], ax
mov	[word_3AAF0], 0
mov	[word_3AAEE], 0
mov	[word_3AAEC], 0
mov	[word_3AAEA], 0
mov	[word_3AAE8], 0
mov	[word_3AA60], 0
mov	[word_3ABA8], 0
mov	[bp+var_A], 2CECh
xor	si, si		; Logical Exclusive OR
jmp	short loc_407F6	; Jump

LOOP_x18:		; CODE XREF: sub_4067D+17Cj
mov	bx, [bp+var_E]
add	bx, si		; Add
mov	[byte ptr bx], 0
inc	si		; Increment by 1

loc_407F6:		; CODE XREF: sub_4067D+16Ej
cmp	si, 18		; Compare Two Operands
jl	short LOOP_x18	; Jump if Less (SF!=OF)

loc_407FB:
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 8DE0h
push	ax
mov	ax, 16h
push	ax
mov	ax, 60h	; '`'
push	ax
mov	ax, 5Fh	; '_'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 60h	; '`'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 2Fh	; '/'
push	ax
mov	ax, 0BEh ; ''
push	ax
call	sub_2A027	; Call Procedure
add	sp, 16h		; Add
mov	[word_3AB1C], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 8DDEh
push	ax
mov	ax, 16h
push	ax
mov	ax, 60h	; '`'
push	ax
mov	ax, 5Fh	; '_'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 60h	; '`'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 49h	; 'I'
push	ax
mov	ax, 0BEh ; ''
push	ax
call	sub_2A027	; Call Procedure
add	sp, 16h		; Add
mov	[word_3AB1E], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 8DDCh
push	ax
mov	ax, 16h
push	ax
mov	ax, 60h	; '`'
push	ax
mov	ax, 5Fh	; '_'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 60h	; '`'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 63h	; 'c'
push	ax
mov	ax, 0BEh ; ''
push	ax
call	sub_2A027	; Call Procedure
add	sp, 16h		; Add
mov	[word_3AB20], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 8DDAh
push	ax
mov	ax, 16h
push	ax
mov	ax, 60h	; '`'
push	ax
mov	ax, 5Fh	; '_'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 60h	; '`'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 7Dh	; '}'
push	ax
mov	ax, 0BEh ; ''
push	ax
call	sub_2A027	; Call Procedure
add	sp, 16h		; Add
mov	[word_3AB22], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, 8DD8h
push	ax
mov	ax, 16h
push	ax
mov	ax, 60h	; '`'
push	ax
mov	ax, 5Fh	; '_'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 60h	; '`'
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 97h	; ''
push	ax
mov	ax, 0BEh ; ''
push	ax
call	sub_2A027	; Call Procedure
add	sp, 16h		; Add
mov	[word_3AB24], ax
xor	si, si		; Logical Exclusive OR
jmp	loc_409AC	; Jump

loc_40909:		; CODE XREF: sub_4067D+334j
mov	ax, 0FFFFh
push	ax

loc_4090D:
mov	ax, 3049h
push	ax
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply

loc_40918:		; Add
add	ax, 0Ah
push	ax
mov	ax, 0CAh ; ''
push	ax
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 5		; Add
push	ax

loc_4092B:
mov	ax, 0A4h ; ''
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add

loc_40937:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7196h], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 0Ah		; Add
push	ax
mov	ax, 0FCh ; ''
push	ax

loc_40956:
mov	ax, si

loc_40958:
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 5		; Add
push	ax
mov	ax, 0CBh ; ''

loc_40964:
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-718Ah], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h

loc_4097C:
push	ax
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 0Ah		; Add
push	ax
mov	ax, 13Fh
push	ax
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 5		; Add
push	ax
mov	ax, 0FDh ; ''

loc_4099A:
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure

loc_409A0:		; Add
add	sp, 0Ch
mov	bx, si

loc_409A5:		; Shift	Logical	Left
shl	bx, 1
mov	[bx-717Eh], ax
inc	si		; Increment by 1

loc_409AC:		; CODE XREF: sub_4067D+289j
cmp	si, 6		; Compare Two Operands
jge	short loc_409B4	; Jump if Greater or Equal (SF=OF)
jmp	loc_40909	; Jump

loc_409B4:		; CODE XREF: sub_4067D+332j
mov	ax, 3059h
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
mov	[bp+var_20], ax
mov	[word_3866A], 0
mov	[word_3866C], 0
mov	[word_3866E], 0
mov	[word_38670], 0
mov	[word_38672], 0
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 39h	; '9'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
nop			; No Operation
push	cs
call	near ptr LBX_HelpEntry_s434C3 ;	Call Procedure
jmp	loc_40E94	; Jump

loc_409FB:		; CODE XREF: sub_4067D+81Dj
call	sub_2B97A	; Call Procedure
mov	[bp+var_6], ax
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, [bp+var_6]
cmp	ax, [bp+var_20]	; Compare Two Operands
jnz	short loc_40A16	; Jump if Not Zero (ZF=0)
mov	ax, 3

loc_40A13:		; CODE XREF: sub_4067D+82Dj
jmp	loc_40EAD	; Jump

loc_40A16:		; CODE XREF: sub_4067D+391j
mov	ax, [bp+var_6]
cmp	ax, [word_3ABA2] ; Compare Two Operands
jnz	short loc_40A2B	; Jump if Not Zero (ZF=0)

loc_40A1F:		; Compare Two Operands
cmp	[word_3ABBA], 0
jz	short loc_40A2B	; Jump if Zero (ZF=1)

loc_40A26:
mov	[bp+var_4], 1

loc_40A2B:		; CODE XREF: sub_4067D+3A0j
			; sub_4067D+3A7j
mov	[bp+var_8], 0
xor	si, si		; Logical Exclusive OR
jmp	short loc_40A42	; Jump

loc_40A34:		; CODE XREF: sub_4067D+3C8j
mov	bx, [bp+var_E]
add	bx, si		; Add
cmp	[byte ptr bx], 1 ; Compare Two Operands
jnz	short loc_40A41	; Jump if Not Zero (ZF=0)
inc	[bp+var_8]	; Increment by 1

loc_40A41:		; CODE XREF: sub_4067D+3BFj
inc	si		; Increment by 1

loc_40A42:		; CODE XREF: sub_4067D+3B5j
cmp	si, 18		; Compare Two Operands
jl	short loc_40A34	; Jump if Less (SF!=OF)
mov	ax, [bp+var_6]
cmp	ax, [word_3AB1C] ; Compare Two Operands
jnz	short loc_40A57	; Jump if Not Zero (ZF=0)
cmp	[word_38672], 0	; Compare Two Operands
jnz	short loc_40A67	; Jump if Not Zero (ZF=0)

loc_40A57:		; CODE XREF: sub_4067D+3D1j
mov	ax, [bp+var_6]
cmp	ax, [word_3AB1E] ; Compare Two Operands
jnz	short loc_40A6D	; Jump if Not Zero (ZF=0)
cmp	[word_38670], 0	; Compare Two Operands
jz	short loc_40A6D	; Jump if Zero (ZF=1)

loc_40A67:		; CODE XREF: sub_4067D+3D8j
mov	[word_3AA60], 4

loc_40A6D:		; CODE XREF: sub_4067D+3E1j
			; sub_4067D+3E8j
cmp	[word_3AA60], 0	; Compare Two Operands
jg	short loc_40A77	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_40D80	; Jump

loc_40A77:		; CODE XREF: sub_4067D+3F5j
mov	bx, [word_3AA60]
dec	bx		; Decrement by 1
cmp	bx, 5		; switch 6 cases
jbe	short loc_40A84	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_40D40	; default

loc_40A84:		; CODE XREF: sub_4067D+402j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_40EB4+bx] ; switch jump

loc_40A8B:		; DATA XREF: ovr050:off_40EB4o
mov	ax, offset aYouNeedToMakeA ; case 0x0

loc_40A8E:		; CODE XREF: sub_4067D+424j
			; sub_4067D+6B4j
			; sub_4067D+6BAj
			; sub_4067D+6C0j
push	ax

loc_40A8F:		; Load Effective Address
lea	ax, [bp+argDst]
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx

loc_40A9A:
pop	cx
jmp	loc_40D42	; Jump

loc_40A9E:		; CODE XREF: sub_4067D+409j
			; DATA XREF: ovr050:off_40EB4o
mov	ax, offset aYouMayNotSelec ; case 0x1
jmp	short loc_40A8E	; Jump

loc_40AA3:		; CODE XREF: sub_4067D+409j
			; DATA XREF: ovr050:off_40EB4o
mov	ax, offset aToSelect ; case 0x2
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	bx, [word_3AA5E]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+1F96h]
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aYouNeed ; "	you need:   "
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, [word_3AA5E]
mov	dx, 14
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+2CEEh], 1 ; Compare Two Operands
jz	short loc_40AED	; Jump if Zero (ZF=1)
jmp	loc_40B9B	; Jump

loc_40AED:		; CODE XREF: sub_4067D+46Bj
mov	ax, [word_3AA5E]
mov	dx, 14
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+2CECh], 0 ; Compare Two Operands
jz	short loc_40B01	; Jump if Zero (ZF=1)
jmp	loc_40B9B	; Jump

loc_40B01:		; CODE XREF: sub_4067D+47Fj
xor	si, si		; Logical Exclusive OR
jmp	loc_40B90	; Jump

loc_40B06:		; CODE XREF: sub_4067D+518j
mov	ax, [word_3AA5E]
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, si		; Add

loc_40B10:		; Add
add	ax, 2
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_A]
add	bx, ax		; Add

loc_40B1A:		; Compare Two Operands
cmp	[word ptr bx], 0
jle	short loc_40B8F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	ax, [word_3AA5E]
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, si		; Add
add	ax, 2		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_A]
add	bx, ax		; Add
push	[word ptr bx]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aPicksIn ; "	picks in "
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, si
mov	dx, 0Ah
imul	dx		; Signed Multiply
lea	dx, [bp+var_E8]	; Load Effective Address
add	ax, dx		; Add
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aMagic ; " Magic"
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_40B8F:		; CODE XREF: sub_4067D+4A0j
inc	si		; Increment by 1

loc_40B90:		; CODE XREF: sub_4067D+486j
cmp	si, 5		; Compare Two Operands
jge	short loc_40B98	; Jump if Greater or Equal (SF=OF)
jmp	loc_40B06	; Jump

loc_40B98:		; CODE XREF: sub_4067D+516j
jmp	loc_40D2C	; Jump

loc_40B9B:		; CODE XREF: sub_4067D+46Dj
			; sub_4067D+481j
mov	ax, [word_3AA5E]
mov	dx, 14
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+2CECh], 0 ; Compare Two Operands

loc_40BAA:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_40BAF
jmp	loc_40C74	; Jump

loc_40BAF:		; CODE XREF: sub_4067D:loc_40BAAj
mov	ax, 10
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	ax, [word_3AA5E]
mov	dx, 14
imul	dx		; Signed Multiply
mov	bx, [bp+var_A]
add	bx, ax		; Add
push	[word ptr bx]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aPick ; " pick"
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, [word_3AA5E]
mov	dx, 0Eh
imul	dx		; Signed Multiply
mov	bx, [bp+var_A]
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jle	short SINGULAR_PickInAny ; Jump	if Less	or Equal (ZF=1 | SF!=OF)

PLURAL_PicksInAny:	; "s in	any "
mov	ax, offset aSInAny
jmp	short loc_40C08	; Jump

SINGULAR_PickInAny:	; CODE XREF: sub_4067D+581j
mov	ax, (offset aSInAny+1)

loc_40C08:		; CODE XREF: sub_4067D+586j
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, [word_3AA5E]
mov	dx, 7
imul	dx		; Signed Multiply
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_A]
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jle	short loc_40C61	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	ax, [word_3AA5E]
mov	dx, 7
imul	dx		; Signed Multiply
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_A]
add	bx, ax		; Add
push	[word ptr bx]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aRealmsOfMagic ; " Realms of	Magic"
jmp	short loc_40C64	; Jump

loc_40C61:		; CODE XREF: sub_4067D+5ABj
mov	ax, offset aRealmOfMagic ; "Realm of Magic"

loc_40C64:		; CODE XREF: sub_4067D+5E2j
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
jmp	loc_40D2C	; Jump

loc_40C74:		; CODE XREF: sub_4067D+52Fj
mov	[bp+var_C], 0
xor	di, di		; Logical Exclusive OR
jmp	loc_40D24	; Jump

loc_40C7E:		; CODE XREF: sub_4067D+6ACj
mov	ax, [word_3AA5E]
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, di		; Add
add	ax, 2		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_A]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jg	short loc_40C9A	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_40D23	; Jump

loc_40C9A:		; CODE XREF: sub_4067D+618j
cmp	[bp+var_C], 0	; Compare Two Operands
jle	short loc_40CB0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, offset aComma ; ", "
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_40CB0:		; CODE XREF: sub_4067D+621j
mov	ax, 10
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	ax, [word_3AA5E]
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, di		; Add
add	ax, 2		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_A]
add	bx, ax		; Add
push	[word ptr bx]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aPickIn ; " pick in "
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, di
mov	dx, 10
imul	dx		; Signed Multiply
lea	dx, [bp+var_E8]	; Load Effective Address
add	ax, dx		; Add
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aMagic ; " Magic"
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
inc	[bp+var_C]	; Increment by 1

loc_40D23:		; CODE XREF: sub_4067D+61Aj
inc	di		; Increment by 1

loc_40D24:		; CODE XREF: sub_4067D+5FEj
cmp	di, 5		; Compare Two Operands
jge	short loc_40D2C	; Jump if Greater or Equal (SF=OF)
jmp	loc_40C7E	; Jump

loc_40D2C:		; CODE XREF: sub_4067D:loc_40B98j
			; sub_4067D+5F4j
			; sub_4067D+6AAj
jmp	short loc_40D42	; Jump

loc_40D2E:		; CODE XREF: sub_4067D+409j
			; DATA XREF: ovr050:off_40EB4o
mov	ax, offset aYouCanNotSel_0 ; case 0x3
jmp	loc_40A8E	; Jump

loc_40D34:		; CODE XREF: sub_4067D+409j
			; DATA XREF: ovr050:off_40EB4o
mov	ax, offset aYouHaveAlready ; case 0x4
jmp	loc_40A8E	; Jump

loc_40D3A:		; CODE XREF: sub_4067D+409j
			; DATA XREF: ovr050:off_40EB4o
mov	ax, offset aYouDonTHaveEno ; case 0x5
jmp	loc_40A8E	; Jump

loc_40D40:		; CODE XREF: sub_4067D+404j
jmp	short $+2	; default

loc_40D42:		; CODE XREF: sub_4067D+41Ej
			; sub_4067D:loc_40D2Cj
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
call	sub_31ABF	; Call Procedure
pop	cx
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 39h	; '9'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
mov	ax, 19h
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
mov	[word_3AA60], 0

loc_40D80:		; CODE XREF: sub_4067D+3F7j
xor	si, si		; Logical Exclusive OR
jmp	loc_40E5D	; Jump

loc_40D85:		; CODE XREF: sub_4067D+7E5j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-7196h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jz	short loc_40D95	; Jump if Zero (ZF=1)
jmp	loc_40E5C	; Jump

loc_40D95:		; CODE XREF: sub_4067D+713j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_E]
add	ax, [bx+2DE8h]	; Add
mov	bx, ax
cmp	[byte ptr bx], 1 ; Compare Two Operands
jnz	short loc_40DBA	; Jump if Not Zero (ZF=0)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_E]
add	ax, [bx+2DE8h]	; Add
mov	bx, ax
mov	[byte ptr bx], 0
jmp	loc_40E5C	; Jump

loc_40DBA:		; CODE XREF: sub_4067D+728j
cmp	[word_3ABA4], 0	; Compare Two Operands
jg	short loc_40DC4	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_40E56	; Jump

loc_40DC4:		; CODE XREF: sub_4067D+742j
cmp	[bp+var_8], 5	; Compare Two Operands
jle	short loc_40DD3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[word_3AA60], 2
jmp	loc_40E54	; Jump

loc_40DD3:		; CODE XREF: sub_4067D+74Bj
mov	[bp+var_4], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_40E0E	; Jump

loc_40DDC:		; CODE XREF: sub_4067D+794j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1E]	; Load Effective Address
add	bx, ax		; Add
cmp	[bx], si	; Compare Two Operands
jnz	short loc_40E0D	; Jump if Not Zero (ZF=0)
cmp	[word_3ABA4], 2	; Compare Two Operands
jge	short loc_40DF8	; Jump if Greater or Equal (SF=OF)
mov	[word_3AA60], 6
jmp	short loc_40E08	; Jump

loc_40DF8:		; CODE XREF: sub_4067D+771j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_E]
add	ax, [bx+2DE8h]	; Add
mov	bx, ax
mov	[byte ptr bx], 1

loc_40E08:		; CODE XREF: sub_4067D+779j
mov	[bp+var_4], 1

loc_40E0D:		; CODE XREF: sub_4067D+76Aj
inc	di		; Increment by 1

loc_40E0E:		; CODE XREF: sub_4067D+75Dj
cmp	di, 5		; Compare Two Operands
jl	short loc_40DDC	; Jump if Less (SF!=OF)
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_40E39	; Jump if Not Zero (ZF=0)
cmp	si, 7		; Compare Two Operands
jnz	short loc_40E39	; Jump if Not Zero (ZF=0)
cmp	[word_3ABA4], 3	; Compare Two Operands
jge	short loc_40E2D	; Jump if Greater or Equal (SF=OF)
mov	[word_3AA60], 6

loc_40E2B:		; Jump
jmp	short loc_40E34

loc_40E2D:		; CODE XREF: sub_4067D+7A6j
mov	bx, [bp+var_E]
mov	[byte ptr bx+9], 1

loc_40E34:		; CODE XREF: sub_4067D:loc_40E2Bj
mov	[bp+var_4], 1

loc_40E39:		; CODE XREF: sub_4067D+79Aj
			; sub_4067D+79Fj
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_40E4F	; Jump if Not Zero (ZF=0)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_E]
add	ax, [bx+2DE8h]	; Add
mov	bx, ax
mov	[byte ptr bx], 1

loc_40E4F:		; CODE XREF: sub_4067D+7C0j
mov	[bp+var_4], 0

loc_40E54:		; CODE XREF: sub_4067D+753j
jmp	short loc_40E5C	; Jump

loc_40E56:		; CODE XREF: sub_4067D+744j
mov	[word_3AA60], 5

loc_40E5C:		; CODE XREF: sub_4067D+715j
			; sub_4067D+73Aj
			; sub_4067D:loc_40E54j
inc	si		; Increment by 1

loc_40E5D:		; CODE XREF: sub_4067D+705j
cmp	si, 12h		; Compare Two Operands
jge	short loc_40E65	; Jump if Greater or Equal (SF=OF)
jmp	loc_40D85	; Jump

loc_40E65:		; CODE XREF: sub_4067D+7E3j
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_40E94	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_40EC0 ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_2E303	; Call Procedure
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_40E8A	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 1
call	sub_1E525	; Call Procedure

loc_40E8A:		; CODE XREF: sub_4067D+801j
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_40E94:		; CODE XREF: sub_4067D+37Bj
			; sub_4067D+7ECj
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_40E9D	; Jump if Not Zero (ZF=0)
jmp	loc_409FB	; Jump

loc_40E9D:		; CODE XREF: sub_4067D+81Bj
call	sub_2E257	; Call Procedure
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	ax, 5
jmp	loc_40A13	; Jump

loc_40EAD:		; CODE XREF: sub_4067D:loc_40A13j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4067D

align 2
off_40EB4 dw offset loc_40A8B
			; DATA XREF: sub_4067D+409r
dw offset loc_40A9E	; jump table for switch	statement
dw offset loc_40AA3
dw offset loc_40D2E
dw offset loc_40D34
dw offset loc_40D3A


; Attributes: bp-based frame

proc sub_40EC0 far	; CODE XREF: sub_31889J
			; sub_4067D+7F0p

var_54=	word ptr -54h
var_51=	byte ptr -51h
var_4E=	byte ptr -4Eh
var_4D=	byte ptr -4Dh
var_4C=	byte ptr -4Ch
var_4A=	byte ptr -4Ah
var_48=	byte ptr -48h
var_47=	byte ptr -47h
var_46=	byte ptr -46h
var_45=	byte ptr -45h
var_44=	byte ptr -44h
var_43=	byte ptr -43h
argDst=	byte ptr -42h
var_2E=	word ptr -2Eh
var_2C=	word ptr -2Ch
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_1E=	word ptr -1Eh
var_18=	word ptr -18h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp

loc_40EC3:		; Integer Subtraction
sub	sp, 54h

loc_40EC6:
push	si
push	di		; argConversionBase
lea	ax, [bp+var_18]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F84h
push	ds
push	ax
mov	cx, 0Ah
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_1E]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F8Eh
push	ds
push	ax

loc_40EE4:
mov	cx, 5
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_24]	; Load Effective Address
push	ss
push	ax
mov	ax, 2F93h
push	ds
push	ax
mov	cx, 5
call	SCOPY@		; Call Procedure
mov	ax, [word_34CA8]
mov	[bp+var_26], ax
mov	ax, [word_34CAA]
mov	[bp+var_28], ax
mov	ax, [word_34CAC]
mov	[bp+var_2A], ax
mov	ax, [word_34CAE]
mov	[bp+var_2C], ax

loc_40F16:		; Load Effective Address
lea	ax, [bp+var_54]
push	ss
push	ax
mov	ax, 2FA0h
push	ds
push	ax
mov	cx, 12h
call	SCOPY@		; Call Procedure
mov	[bp+var_2E], 6964h
call	sub_2601C	; Call Procedure
mov	[bp+var_2], ax
mov	[bp+var_6], 24h	; '$'
push	[idk_LBX_w36FC8]
xor	ax, ax		; Logical Exclusive OR

loc_40F40:
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	al, [byte_38610]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
push	[word ptr bx+52C6h]
mov	ax, 0Ah
push	ax
mov	ax, 18h

loc_40F5F:
push	ax

loc_40F60:		; Call Procedure
call	sub_1F655
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_40F6B:
mov	ax, 0C4h ; ''
push	ax
mov	ax, 11Ah
push	ax
mov	ax, 0B5h ; ''
push	ax
mov	ax, 0FBh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
mov	[bp+var_8], 0
xor	si, si		; Logical Exclusive OR
jmp	short loc_40F9A	; Jump

loc_40F8C:		; CODE XREF: sub_40EC0+DDj
mov	bx, [bp+var_2E]
add	bx, si		; Add
cmp	[byte ptr bx], 1 ; Compare Two Operands
jnz	short loc_40F99	; Jump if Not Zero (ZF=0)
inc	[bp+var_8]	; Increment by 1

loc_40F99:		; CODE XREF: sub_40EC0+D4j
inc	si		; Increment by 1

loc_40F9A:		; CODE XREF: sub_40EC0+CAj
cmp	si, 12h		; Compare Two Operands
jl	short loc_40F8C	; Jump if Less (SF!=OF)
mov	ax, [bp+var_8]
mov	[bp+var_E], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_40FC8	; Jump

loc_40FA9:		; CODE XREF: sub_40EC0+10Bj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_18]	; Load Effective Address
add	bx, ax		; Add
mov	bx, [bx]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_2E]
add	ax, [bx+2DE8h]	; Add
mov	bx, ax

loc_40FBF:		; Compare Two Operands
cmp	[byte ptr bx], 1
jnz	short loc_40FC7	; Jump if Not Zero (ZF=0)
inc	[bp+var_E]	; Increment by 1

loc_40FC7:		; CODE XREF: sub_40EC0+102j
inc	si		; Increment by 1

loc_40FC8:		; CODE XREF: sub_40EC0+E7j
cmp	si, 5		; Compare Two Operands
jl	short loc_40FA9	; Jump if Less (SF!=OF)
mov	bx, [bp+var_2E]
cmp	[byte ptr bx+9], 1 ; Compare Two Operands
jnz	short loc_40FDA	; Jump if Not Zero (ZF=0)
add	[bp+var_E], 2	; Add

loc_40FDA:		; CODE XREF: sub_40EC0+114j
mov	ax, 0Bh
sub	ax, [bp+var_E]	; Integer Subtraction
sub	ax, [word_38670] ; Integer Subtraction
sub	ax, [word_38672] ; Integer Subtraction
sub	ax, [word_3866E] ; Integer Subtraction
sub	ax, [word_3866A] ; Integer Subtraction
sub	ax, [word_3866C] ; Integer Subtraction

loc_40FF4:
mov	[word_3ABA4], ax
mov	ax, [word_3ABA4]
mov	[bp+var_4], ax
xor	si, si		; Logical Exclusive OR
jmp	loc_411F9	; Jump

loc_41002:		; CODE XREF: sub_40EC0:loc_411FEj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_2]	; Compare Two Operands
jz	short loc_41012	; Jump if Zero (ZF=1)
jmp	loc_411F8	; Jump

loc_41012:		; CODE XREF: sub_40EC0+14Dj
mov	bx, si
cmp	bx, 4		; switch 5 cases
jbe	short loc_4101C	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_411CD	; default

loc_4101C:		; CODE XREF: sub_40EC0+157j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_41A55+bx] ; switch jump

loc_41023:		; DATA XREF: ovr050:off_41A55o
mov	ax, [word_3ABA4] ; case	0x0
add	ax, [word_38670] ; Add
mov	[word_3ABA4], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_41048	; Jump

loc_41031:		; CODE XREF: sub_40EC0+193j
cmp	[word_38672], 0	; Compare Two Operands
jz	short loc_4103A	; Jump if Zero (ZF=1)
jmp	short loc_41055	; Jump

loc_4103A:		; CODE XREF: sub_40EC0+176j
cmp	[word_3ABA4], 0	; Compare Two Operands

loc_4103F:		; Jump if Not Zero (ZF=0)
jnz	short loc_41043
jmp	short loc_41055	; Jump

loc_41043:		; CODE XREF: sub_40EC0:loc_4103Fj
dec	[word_3ABA4]	; Decrement by 1
inc	di		; Increment by 1

loc_41048:		; CODE XREF: sub_40EC0+16Fj
mov	ax, [word_3AAF0]

loc_4104B:
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands
jg	short loc_41031	; Jump if Greater (ZF=0	& SF=OF)

loc_41055:		; CODE XREF: sub_40EC0+178j
			; sub_40EC0+181j
mov	[word_38670], di
mov	ax, [word_3AAF0]

loc_4105C:
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands

loc_41064:		; Jump if Not Zero (ZF=0)
jnz	short loc_4107B
mov	ax, [word_3ABA4]
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_4107B	; Jump if Not Zero (ZF=0)
cmp	[word_3ABA4], 0	; Compare Two Operands
jnz	short loc_4107B	; Jump if Not Zero (ZF=0)
mov	[word_3ABA4], 0FFFFh

loc_4107B:		; CODE XREF: sub_40EC0:loc_41064j
			; sub_40EC0+1ACj
			; sub_40EC0+1B3j
jmp	loc_411CD	; default

loc_4107E:		; CODE XREF: sub_40EC0+15Ej
			; DATA XREF: ovr050:off_41A55o
mov	ax, [word_3ABA4] ; case	0x1
add	ax, [word_38672] ; Add
mov	[word_3ABA4], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_410A3	; Jump

loc_4108C:		; CODE XREF: sub_40EC0+1EEj
cmp	[word_38670], 0	; Compare Two Operands
jz	short loc_41095	; Jump if Zero (ZF=1)
jmp	short loc_410B0	; Jump

loc_41095:		; CODE XREF: sub_40EC0+1D1j
cmp	[word_3ABA4], 0	; Compare Two Operands

loc_4109A:		; Jump if Not Zero (ZF=0)
jnz	short loc_4109E

loc_4109C:		; Jump
jmp	short loc_410B0

loc_4109E:		; CODE XREF: sub_40EC0:loc_4109Aj
dec	[word_3ABA4]	; Decrement by 1
inc	di		; Increment by 1

loc_410A3:		; CODE XREF: sub_40EC0+1CAj
mov	ax, [word_3AAEE]

loc_410A6:
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands
jg	short loc_4108C	; Jump if Greater (ZF=0	& SF=OF)

loc_410B0:		; CODE XREF: sub_40EC0+1D3j
			; sub_40EC0:loc_4109Cj
mov	[word_38672], di
mov	ax, [word_3AAEE]
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands

loc_410BF:		; Jump if Not Zero (ZF=0)
jnz	short loc_410D6
mov	ax, [word_3ABA4]

loc_410C4:		; Compare Two Operands
cmp	ax, [bp+var_4]
jnz	short loc_410D6	; Jump if Not Zero (ZF=0)
cmp	[word_3ABA4], 0	; Compare Two Operands
jnz	short loc_410D6	; Jump if Not Zero (ZF=0)
mov	[word_3ABA4], 0FFFFh

loc_410D6:		; CODE XREF: sub_40EC0:loc_410BFj
			; sub_40EC0+207j
			; sub_40EC0+20Ej
jmp	loc_411CD	; default

loc_410D9:		; CODE XREF: sub_40EC0+15Ej
			; DATA XREF: ovr050:off_41A55o
mov	ax, [word_3ABA4] ; case	0x2
add	ax, [word_3866E] ; Add
mov	[word_3ABA4], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_410F5	; Jump

loc_410E7:		; CODE XREF: sub_40EC0+240j
cmp	[word_3ABA4], 0	; Compare Two Operands

loc_410EC:		; Jump if Not Zero (ZF=0)
jnz	short loc_410F0
jmp	short loc_41102	; Jump

loc_410F0:		; CODE XREF: sub_40EC0:loc_410ECj
dec	[word_3ABA4]	; Decrement by 1
inc	di		; Increment by 1

loc_410F5:		; CODE XREF: sub_40EC0+225j
mov	ax, [word_3AAEC]
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands
jg	short loc_410E7	; Jump if Greater (ZF=0	& SF=OF)

loc_41102:		; CODE XREF: sub_40EC0+22Ej
mov	[word_3866E], di
mov	ax, [word_3AAEC]
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands
jnz	short loc_41128	; Jump if Not Zero (ZF=0)
mov	ax, [word_3ABA4]

loc_41116:		; Compare Two Operands
cmp	ax, [bp+var_4]
jnz	short loc_41128	; Jump if Not Zero (ZF=0)
cmp	[word_3ABA4], 0	; Compare Two Operands
jnz	short loc_41128	; Jump if Not Zero (ZF=0)
mov	[word_3ABA4], 0FFFFh

loc_41128:		; CODE XREF: sub_40EC0+251j
			; sub_40EC0+259j
			; sub_40EC0+260j
jmp	loc_411CD	; default

loc_4112B:		; CODE XREF: sub_40EC0+15Ej
			; DATA XREF: ovr050:off_41A55o
mov	ax, [word_3ABA4] ; case	0x3
add	ax, [word_3866A] ; Add
mov	[word_3ABA4], ax
xor	di, di		; Logical Exclusive OR

loc_41137:		; Jump
jmp	short loc_41147

loc_41139:		; CODE XREF: sub_40EC0+292j
cmp	[word_3ABA4], 0	; Compare Two Operands
jnz	short loc_41142	; Jump if Not Zero (ZF=0)

loc_41140:		; Jump
jmp	short loc_41154

loc_41142:		; CODE XREF: sub_40EC0+27Ej
dec	[word_3ABA4]	; Decrement by 1
inc	di		; Increment by 1

loc_41147:		; CODE XREF: sub_40EC0:loc_41137j
mov	ax, [word_3AAEA]
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands
jg	short loc_41139	; Jump if Greater (ZF=0	& SF=OF)

loc_41154:		; CODE XREF: sub_40EC0:loc_41140j
mov	[word_3866A], di
mov	ax, [word_3AAEA]

loc_4115B:
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands
jnz	short loc_4117A	; Jump if Not Zero (ZF=0)
mov	ax, [word_3ABA4]
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_4117A	; Jump if Not Zero (ZF=0)
cmp	[word_3ABA4], 0	; Compare Two Operands
jnz	short loc_4117A	; Jump if Not Zero (ZF=0)
mov	[word_3ABA4], 0FFFFh

loc_4117A:		; CODE XREF: sub_40EC0+2A3j
			; sub_40EC0+2ABj
			; sub_40EC0+2B2j
jmp	short loc_411CD	; default

loc_4117C:		; CODE XREF: sub_40EC0+15Ej
			; DATA XREF: ovr050:off_41A55o
mov	ax, [word_3ABA4] ; case	0x4
add	ax, [word_3866C] ; Add
mov	[word_3ABA4], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_41198	; Jump

loc_4118A:		; CODE XREF: sub_40EC0+2E3j
cmp	[word_3ABA4], 0	; Compare Two Operands
jnz	short loc_41193	; Jump if Not Zero (ZF=0)
jmp	short loc_411A5	; Jump

loc_41193:		; CODE XREF: sub_40EC0+2CFj
dec	[word_3ABA4]	; Decrement by 1
inc	di		; Increment by 1

loc_41198:		; CODE XREF: sub_40EC0+2C8j
mov	ax, [word_3AAE8]
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands
jg	short loc_4118A	; Jump if Greater (ZF=0	& SF=OF)

loc_411A5:		; CODE XREF: sub_40EC0+2D1j
mov	[word_3866C], di
mov	ax, [word_3AAE8]
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, di		; Compare Two Operands
jnz	short loc_411CB	; Jump if Not Zero (ZF=0)
mov	ax, [word_3ABA4]
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_411CB	; Jump if Not Zero (ZF=0)

loc_411BE:		; Compare Two Operands
cmp	[word_3ABA4], 0
jnz	short loc_411CB	; Jump if Not Zero (ZF=0)
mov	[word_3ABA4], 0FFFFh

loc_411CB:		; CODE XREF: sub_40EC0+2F4j
			; sub_40EC0+2FCj
			; sub_40EC0+303j
jmp	short $+2	; Jump

loc_411CD:		; CODE XREF: sub_40EC0+159j
			; sub_40EC0:loc_4107Bj
			; sub_40EC0:loc_410D6j
			; sub_40EC0:loc_41128j
			; sub_40EC0:loc_4117Aj
cmp	[word_3ABA4], 0	; default
jnz	short loc_411EB	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
cmp	ax, [word_3ABA4] ; Compare Two Operands
jnz	short loc_411EB	; Jump if Not Zero (ZF=0)
mov	ax, [word_3ABA8]

loc_411E0:		; Compare Two Operands
cmp	ax, [bp+var_2]
jz	short loc_411EB	; Jump if Zero (ZF=1)

loc_411E5:
mov	[word_3AA60], 5

loc_411EB:		; CODE XREF: sub_40EC0+312j
			; sub_40EC0+31Bj
			; sub_40EC0+323j
cmp	[word_3ABA4], 0	; Compare Two Operands
jge	short loc_411F8	; Jump if Greater or Equal (SF=OF)
mov	[word_3ABA4], 0

loc_411F8:		; CODE XREF: sub_40EC0+14Fj
			; sub_40EC0+330j
inc	si		; Increment by 1

loc_411F9:		; CODE XREF: sub_40EC0+13Fj
cmp	si, 5		; Compare Two Operands
jge	short loc_41201	; Jump if Greater or Equal (SF=OF)

loc_411FE:		; Jump
jmp	loc_41002

loc_41201:		; CODE XREF: sub_40EC0+33Cj
mov	ax, [bp+var_2]

loc_41204:
mov	[word_3ABA8], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_41251	; Jump

loc_4120B:		; CODE XREF: sub_40EC0:loc_41255j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-7282h]
shl	bx, 1		; Shift	Logical	Left

loc_41215:
push	[word ptr bx-721Ah]
mov	ax, 31h	; '1'
push	ax
mov	ax, si
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
add	ax, 0C5h ; ''  ; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-721Ah]
mov	ax, 87h	; ''
push	ax
push	[bp+var_6]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_6], 8	; Add
inc	si		; Increment by 1

loc_41251:		; CODE XREF: sub_40EC0+349j
cmp	si, [word_38670] ; Compare Two Operands

loc_41255:		; Jump if Less (SF!=OF)
jl	short loc_4120B
xor	si, si		; Logical Exclusive OR
jmp	short loc_412A1	; Jump

loc_4125B:		; CODE XREF: sub_40EC0+3E5j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-7298h]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7208h]
mov	ax, 4Bh	; 'K'
push	ax
mov	ax, si

loc_4126F:
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
add	ax, 0C5h ; ''  ; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_41283:
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7208h]

loc_4128D:
mov	ax, 87h	; ''
push	ax
push	[bp+var_6]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_6], 8	; Add
inc	si		; Increment by 1

loc_412A1:		; CODE XREF: sub_40EC0+399j
cmp	si, [word_38672] ; Compare Two Operands
jl	short loc_4125B	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_412F1	; Jump

loc_412AB:		; CODE XREF: sub_40EC0+435j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_412AF:
mov	bx, [bx-7240h]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7202h]
mov	ax, 65h	; 'e'
push	ax
mov	ax, si
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
add	ax, 0C5h ; ''  ; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7202h]
mov	ax, 87h	; ''
push	ax
push	[bp+var_6]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_6], 8	; Add
inc	si		; Increment by 1

loc_412F1:		; CODE XREF: sub_40EC0+3E9j
cmp	si, [word_3866E] ; Compare Two Operands
jl	short loc_412AB	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR

loc_412F9:		; Jump
jmp	short loc_41341

loc_412FB:		; CODE XREF: sub_40EC0:loc_41345j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-726Ch]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-720Eh]
mov	ax, 7Fh	; ''
push	ax

loc_4130D:
mov	ax, si

loc_4130F:
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
add	ax, 0C5h ; ''  ; Add
push	ax

loc_41317:		; Call Procedure
call	sub_1F655

loc_4131C:		; Add
add	sp, 6

loc_4131F:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_41323:
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-720Eh]
mov	ax, 87h	; ''
push	ax
push	[bp+var_6]

loc_41334:		; Call Procedure
call	sub_1F655
add	sp, 6		; Add
add	[bp+var_6], 8	; Add

loc_41340:		; Increment by 1
inc	si

loc_41341:		; CODE XREF: sub_40EC0:loc_412F9j
cmp	si, [word_3866A] ; Compare Two Operands

loc_41345:		; Jump if Less (SF!=OF)
jl	short loc_412FB
xor	si, si		; Logical Exclusive OR
jmp	short loc_41391	; Jump

loc_4134B:		; CODE XREF: sub_40EC0+4D5j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-7256h]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7214h]

loc_41359:
mov	ax, 99h	; ''
push	ax
mov	ax, si
mov	cl, 3
shl	ax, cl		; Shift	Logical	Left
add	ax, 0C5h ; ''  ; Add
push	ax
call	sub_1F655	; Call Procedure

loc_4136C:		; Add
add	sp, 6
mov	bx, si

loc_41371:		; Shift	Logical	Left
shl	bx, 1
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7214h]
mov	ax, 87h	; ''
push	ax
push	[bp+var_6]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	[bp+var_6], 8	; Add
inc	si		; Increment by 1

loc_41391:		; CODE XREF: sub_40EC0+489j
cmp	si, [word_3866C] ; Compare Two Operands
jl	short loc_4134B	; Jump if Less (SF!=OF)
cmp	[word_3ABBA], 0	; Compare Two Operands
jz	short loc_413CA	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]
cmp	ax, [word_3ABA2] ; Compare Two Operands
jnz	short loc_413B4	; Jump if Not Zero (ZF=0)
push	[idk_LBX_w379C0]
mov	ax, 0B7h ; ''
push	ax
mov	ax, 0FDh ; ''
jmp	short loc_413BF	; Jump

loc_413B4:		; CODE XREF: sub_40EC0+4E5j
push	[idk_LBX_w379C0]
mov	ax, 0B6h ; ''
push	ax
mov	ax, 0FCh ; ''

loc_413BF:		; CODE XREF: sub_40EC0+4F2j
push	ax

loc_413C0:		; Call Procedure
call	sub_1F655
add	sp, 6		; Add
jmp	short loc_413ED	; Jump

loc_413CA:		; CODE XREF: sub_40EC0+4DCj
push	[word_3ABBC]
mov	ax, 0B6h ; ''
push	ax
mov	ax, 0FCh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_2]
cmp	ax, [word_3ABA2] ; Compare Two Operands
jnz	short loc_413ED	; Jump if Not Zero (ZF=0)
mov	[word_3AA60], 1

loc_413ED:		; CODE XREF: sub_40EC0+508j
			; sub_40EC0+525j
cmp	[word_3866A], 3	; Compare Two Operands
jle	short loc_41400	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_47], 1
mov	[bp+var_51], 1
mov	[bp+var_44], 1

loc_41400:		; CODE XREF: sub_40EC0+532j
cmp	[word_3866C], 3	; Compare Two Operands
jle	short loc_41413	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_46], 1
mov	[bp+var_51], 1
mov	[bp+var_44], 1

loc_41413:		; CODE XREF: sub_40EC0+545j
cmp	[word_3866E], 3	; Compare Two Operands
jle	short loc_41426	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_48], 1
mov	[bp+var_51], 1
mov	[bp+var_44], 1

loc_41426:		; CODE XREF: sub_40EC0+558j
cmp	[word_38672], 3	; Compare Two Operands
jle	short loc_41439	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_45], 1

loc_41431:
mov	[bp+var_51], 1
mov	[bp+var_44], 1

loc_41439:		; CODE XREF: sub_40EC0+56Bj
cmp	[word_38670], 3	; Compare Two Operands
jle	short loc_4144C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_4C], 1
mov	[bp+var_51], 1

loc_41448:
mov	[bp+var_44], 1

loc_4144C:		; CODE XREF: sub_40EC0+57Ej
mov	[bp+var_C], 0
mov	[bp+var_A], 0
xor	si, si		; Logical Exclusive OR
jmp	short loc_41477	; Jump

loc_4145A:		; CODE XREF: sub_40EC0+5BAj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+695Ah], 0 ; Compare Two Operands
jle	short loc_41468	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_41465:		; Increment by 1
inc	[bp+var_C]

loc_41468:		; CODE XREF: sub_40EC0+5A3j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+695Ah], 1 ; Compare Two Operands
jle	short loc_41476	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
inc	[bp+var_A]	; Increment by 1

loc_41476:		; CODE XREF: sub_40EC0+5B1j
inc	si		; Increment by 1

loc_41477:		; CODE XREF: sub_40EC0+598j
cmp	si, 5		; Compare Two Operands
jl	short loc_4145A	; Jump if Less (SF!=OF)
cmp	[bp+var_C], 1	; Compare Two Operands
jle	short loc_41486	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_41482:
mov	[bp+var_4E], 1

loc_41486:		; CODE XREF: sub_40EC0+5C0j
cmp	[bp+var_A], 2	; Compare Two Operands
jle	short loc_41490	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_4148C:
mov	[bp+var_4A], 1

loc_41490:		; CODE XREF: sub_40EC0+5CAj
xor	si, si		; Logical Exclusive OR
jmp	short loc_414CA	; Jump

loc_41494:		; CODE XREF: sub_40EC0+60Dj
mov	bx, si

loc_41496:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_18]	; Load Effective Address
add	bx, ax		; Add
mov	bx, [bx]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_2E]

loc_414A4:		; Add
add	ax, [bx+2DE8h]

loc_414A8:
mov	bx, ax

loc_414AA:		; Compare Two Operands
cmp	[byte ptr bx], 1
jz	short loc_414C9	; Jump if Zero (ZF=1)

loc_414AF:		; Compare Two Operands
cmp	[word_3ABA4], 2
jge	short loc_414C9	; Jump if Greater or Equal (SF=OF)
mov	bx, si

loc_414B8:		; Shift	Logical	Left
shl	bx, 1

loc_414BA:		; Load Effective Address
lea	ax, [bp+var_18]

loc_414BD:		; Add
add	bx, ax

loc_414BF:
mov	bx, [bx]
lea	ax, [bp+var_54]	; Load Effective Address
add	bx, ax		; Add
mov	[byte ptr bx], 0

loc_414C9:		; CODE XREF: sub_40EC0+5EDj
			; sub_40EC0+5F4j
inc	si		; Increment by 1

loc_414CA:		; CODE XREF: sub_40EC0+5D2j
cmp	si, 5		; Compare Two Operands
jl	short loc_41494	; Jump if Less (SF!=OF)
mov	bx, [bp+var_2E]
cmp	[byte ptr bx+9], 1 ; Compare Two Operands
jz	short loc_414E3	; Jump if Zero (ZF=1)
cmp	[word_3ABA4], 3	; Compare Two Operands
jge	short loc_414E3	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_4D], 0

loc_414E3:		; CODE XREF: sub_40EC0+616j
			; sub_40EC0+61Dj
cmp	[word_3866E], 0	; Compare Two Operands
jle	short loc_414FC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[word_3866C], 0	; Compare Two Operands
jle	short loc_414FC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[word_3866A], 0	; Compare Two Operands
jle	short loc_414FC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_43], 1

loc_414FC:		; CODE XREF: sub_40EC0+628j
			; sub_40EC0+62Fj
			; sub_40EC0+636j
mov	ax, 0Fh
push	ax		; int

loc_41500:		; Logical Exclusive OR
xor	ax, ax
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure

loc_41508:
pop	cx
pop	cx
xor	di, di		; Logical Exclusive OR

loc_4150C:		; Jump
jmp	loc_41784

loc_4150F:		; CODE XREF: sub_40EC0+8C9j
xor	si, si		; Logical Exclusive OR

loc_41511:		; Jump
jmp	loc_4177B

loc_41514:		; CODE XREF: sub_40EC0:loc_41780j
mov	ax, di

loc_41516:
mov	dx, 6
imul	dx		; Signed Multiply

loc_4151B:
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_2E]

loc_41524:		; Add
add	ax, [bx+2DE8h]
mov	bx, ax
cmp	[byte ptr bx], 1 ; Compare Two Operands
jz	short loc_41532	; Jump if Zero (ZF=1)

loc_4152F:		; Jump
jmp	loc_415FF

loc_41532:		; CODE XREF: sub_40EC0+66Dj
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
lea	ax, [bp+var_54]	; Load Effective Address

loc_41540:		; Add
add	bx, ax
cmp	[byte ptr bx], 1 ; Compare Two Operands
jz	short loc_4154A	; Jump if Zero (ZF=1)
jmp	loc_415FF	; Jump

loc_4154A:		; CODE XREF: sub_40EC0+685j
cmp	[word_3ABA4], 0	; Compare Two Operands
jge	short loc_41554	; Jump if Greater or Equal (SF=OF)
jmp	loc_415FF	; Jump

loc_41554:		; CODE XREF: sub_40EC0+68Fj
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, di

loc_41564:
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left

loc_4156F:
mov	bx, [bx+2DE8h]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+1F96h]
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 6		; Add
push	ax
mov	ax, di

loc_41586:
mov	dx, 27h	; '''
imul	dx		; Signed Multiply
add	ax, 0ACh ; ''  ; Add
push	ax

loc_4158F:		; Call Procedure
call	sub_1993F

loc_41594:		; Add
add	sp, 6

loc_41597:		; Load Effective Address
lea	ax, [bp+var_2A]
push	ax

loc_4159B:		; Logical Exclusive OR
xor	ax, ax
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx+2DE8h]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+1F96h]
mov	ax, si

loc_415BE:
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 5		; Add
push	ax
mov	ax, di
mov	dx, 27h	; '''
imul	dx		; Signed Multiply
add	ax, 0ABh ; ''  ; Add
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
push	[word_3ABA6]
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 6		; Add
push	ax
mov	ax, di
mov	dx, 27h	; '''
imul	dx		; Signed Multiply
add	ax, 0A5h ; ''  ; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
jmp	loc_4177A	; Jump

loc_415FF:		; CODE XREF: sub_40EC0:loc_4152Fj
			; sub_40EC0+687j
			; sub_40EC0+691j
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_2E]
add	ax, [bx+2DE8h]	; Add
mov	bx, ax

loc_41615:		; Compare Two Operands
cmp	[byte ptr bx], 1
jnz	short loc_41662	; Jump if Not Zero (ZF=0)

loc_4161A:
mov	ax, di

loc_4161C:
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
lea	ax, [bp+var_54]	; Load Effective Address
add	bx, ax		; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jnz	short loc_41649	; Jump if Not Zero (ZF=0)

loc_4162F:
mov	[word_3AA60], 3
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2DE8h]

loc_41646:
mov	[word_3AA5E], ax

loc_41649:		; CODE XREF: sub_40EC0+76Dj
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply

loc_41650:
mov	bx, si
add	bx, ax		; Add

loc_41654:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bp+var_2E]
add	ax, [bx+2DE8h]	; Add
mov	bx, ax
mov	[byte ptr bx], 0

loc_41662:		; CODE XREF: sub_40EC0+758j
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
lea	ax, [bp+var_54]	; Load Effective Address
add	bx, ax		; Add
cmp	[byte ptr bx], 1 ; Compare Two Operands
jnz	short loc_416CC	; Jump if Not Zero (ZF=0)

loc_41677:		; Compare Two Operands
cmp	[bp+var_8], 6
jge	short loc_416CC	; Jump if Greater or Equal (SF=OF)
cmp	[word_3ABA4], 0	; Compare Two Operands
jle	short loc_416CC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_41684:		; Load Effective Address
lea	ax, [bp+var_2C]
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_4168B:		; Call Procedure
call	sub_19399
pop	cx
pop	cx
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx+2DE8h]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+1F96h]

loc_416A9:
mov	ax, si
mov	dx, 7

loc_416AE:		; Signed Multiply
imul	dx
add	ax, 6		; Add
push	ax
mov	ax, di

loc_416B6:
mov	dx, 27h	; '''
imul	dx		; Signed Multiply

loc_416BB:		; Add
add	ax, 0ACh ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_26]	; Load Effective Address
jmp	short loc_4173A	; Jump

loc_416CC:		; CODE XREF: sub_40EC0+7B5j
			; sub_40EC0+7BBj
			; sub_40EC0+7C2j
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply

loc_416D3:
mov	bx, si
add	bx, ax		; Add
lea	ax, [bp+var_54]	; Load Effective Address
add	bx, ax		; Add
cmp	[byte ptr bx], 1 ; Compare Two Operands

loc_416DF:		; Jump if Not Zero (ZF=0)
jnz	short loc_416F4
mov	ax, di
mov	dx, 6

loc_416E6:		; Signed Multiply
imul	dx
mov	bx, si

loc_416EA:		; Add
add	bx, ax
lea	ax, [bp+var_54]	; Load Effective Address
add	bx, ax		; Add
mov	[byte ptr bx], 0

loc_416F4:		; CODE XREF: sub_40EC0:loc_416DFj
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax

loc_416F8:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_416FB:		; Call Procedure
call	sub_19399
pop	cx

loc_41701:
pop	cx
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx+2DE8h]
shl	bx, 1		; Shift	Logical	Left

loc_41715:
push	[word ptr bx+1F96h]
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 6		; Add
push	ax
mov	ax, di
mov	dx, 27h	; '''
imul	dx		; Signed Multiply

loc_4172B:		; Add
add	ax, 0ACh ; ''
push	ax

loc_4172F:		; Call Procedure
call	sub_1993F
add	sp, 6		; Add
lea	ax, [bp+var_28]	; Load Effective Address

loc_4173A:		; CODE XREF: sub_40EC0+80Aj
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_4173E:		; Call Procedure
call	sub_19399
pop	cx
pop	cx
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left

loc_41752:
mov	bx, [bx+2DE8h]

loc_41756:		; Shift	Logical	Left
shl	bx, 1
push	[word ptr bx+1F96h]
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 5		; Add
push	ax

loc_41767:
mov	ax, di
mov	dx, 27h	; '''
imul	dx		; Signed Multiply
add	ax, 0ABh ; ''  ; Add
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add

loc_4177A:		; CODE XREF: sub_40EC0+73Cj
inc	si		; Increment by 1

loc_4177B:		; CODE XREF: sub_40EC0:loc_41511j
cmp	si, 6		; Compare Two Operands
jge	short loc_41783	; Jump if Greater or Equal (SF=OF)

loc_41780:		; Jump
jmp	loc_41514

loc_41783:		; CODE XREF: sub_40EC0+8BEj
inc	di		; Increment by 1

loc_41784:		; CODE XREF: sub_40EC0:loc_4150Cj
cmp	di, 2		; Compare Two Operands
jge	short loc_4178C	; Jump if Greater or Equal (SF=OF)
jmp	loc_4150F	; Jump

loc_4178C:		; CODE XREF: sub_40EC0+8C7j
xor	si, si		; Logical Exclusive OR
jmp	loc_4194D	; Jump

loc_41791:		; CODE XREF: sub_40EC0+A92j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_2E]

loc_41798:		; Add
add	ax, [bx+2E00h]
mov	bx, ax

loc_4179E:		; Compare Two Operands
cmp	[byte ptr bx], 1
jz	short loc_417A6	; Jump if Zero (ZF=1)
jmp	loc_41846	; Jump

loc_417A6:		; CODE XREF: sub_40EC0+8E1j
cmp	[bp+si+var_48],	1 ; Compare Two	Operands

loc_417AA:		; Jump if Zero (ZF=1)
jz	short loc_417AF
jmp	loc_41846	; Jump

loc_417AF:		; CODE XREF: sub_40EC0:loc_417AAj
cmp	[word_3ABA4], 0	; Compare Two Operands
jge	short loc_417B9	; Jump if Greater or Equal (SF=OF)
jmp	loc_41846	; Jump

loc_417B9:		; CODE XREF: sub_40EC0+8F4j
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_417C0:		; Call Procedure
call	sub_19399
pop	cx

loc_417C6:
pop	cx

loc_417C7:
mov	ax, di

loc_417C9:
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add

loc_417D2:		; Shift	Logical	Left
shl	bx, 1
mov	bx, [bx+2DE8h]

loc_417D8:		; Shift	Logical	Left
shl	bx, 1

loc_417DA:
push	[word ptr bx+1F96h]

loc_417DE:
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 6		; Add
push	ax

loc_417E9:
mov	ax, 105h
push	ax
call	sub_1993F	; Call Procedure

loc_417F2:		; Add
add	sp, 6

loc_417F5:		; Load Effective Address
lea	ax, [bp+var_2A]

loc_417F8:
push	ax

loc_417F9:		; Logical Exclusive OR
xor	ax, ax
push	ax
call	sub_19399	; Call Procedure
pop	cx

loc_41802:
pop	cx
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_41807:
mov	bx, [bx+2E00h]

loc_4180B:		; Shift	Logical	Left
shl	bx, 1

loc_4180D:
push	[word ptr bx+1F96h]

loc_41811:
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 5		; Add
push	ax

loc_4181C:
mov	ax, 104h
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
push	[word_3ABA6]
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply

loc_41833:		; Add
add	ax, 6

loc_41836:
push	ax

loc_41837:
mov	ax, 0FEh ; ''

loc_4183A:
push	ax
call	sub_1F655	; Call Procedure

loc_41840:		; Add
add	sp, 6
jmp	loc_4194C	; Jump

loc_41846:		; CODE XREF: sub_40EC0+8E3j
			; sub_40EC0+8ECj
			; sub_40EC0+8F6j
mov	bx, si

loc_41848:		; Shift	Logical	Left
shl	bx, 1

loc_4184A:
mov	ax, [bp+var_2E]

loc_4184D:		; Add
add	ax, [bx+2E00h]
mov	bx, ax
cmp	[byte ptr bx], 1 ; Compare Two Operands
jnz	short loc_4187F	; Jump if Not Zero (ZF=0)
cmp	[bp+si+var_48],	0 ; Compare Two	Operands
jnz	short loc_4186F	; Jump if Not Zero (ZF=0)
mov	[word_3AA60], 3
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_41868:
mov	ax, [bx+2E00h]
mov	[word_3AA5E], ax

loc_4186F:		; CODE XREF: sub_40EC0+99Cj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_2E]
add	ax, [bx+2E00h]	; Add

loc_4187A:
mov	bx, ax
mov	[byte ptr bx], 0

loc_4187F:		; CODE XREF: sub_40EC0+996j
cmp	[bp+si+var_48],	1 ; Compare Two	Operands
jnz	short loc_418D3	; Jump if Not Zero (ZF=0)
cmp	[bp+var_8], 6	; Compare Two Operands
jge	short loc_418D3	; Jump if Greater or Equal (SF=OF)
cmp	[word_3ABA4], 0	; Compare Two Operands
jle	short loc_418D3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_41899:		; Call Procedure
call	sub_19399
pop	cx
pop	cx

loc_418A0:
mov	ax, di

loc_418A2:
mov	dx, 6
imul	dx		; Signed Multiply
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left

loc_418AD:
mov	bx, [bx+2DE8h]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+1F96h]

loc_418B7:
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply

loc_418BE:		; Add
add	ax, 6
push	ax
mov	ax, 105h
push	ax

loc_418C6:		; Call Procedure
call	sub_1993F
add	sp, 6		; Add

loc_418CE:		; Load Effective Address
lea	ax, [bp+var_26]
jmp	short loc_4191C	; Jump

loc_418D3:		; CODE XREF: sub_40EC0+9C3j
			; sub_40EC0+9C9j
			; sub_40EC0+9D0j
cmp	[bp+si+var_48],	1 ; Compare Two	Operands
jnz	short loc_418DD	; Jump if Not Zero (ZF=0)
mov	[bp+si+var_48],	0

loc_418DD:		; CODE XREF: sub_40EC0+A17j
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, di
mov	dx, 6
imul	dx		; Signed Multiply

loc_418F2:
mov	bx, si
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left

loc_418F8:
mov	bx, [bx+2DE8h]
shl	bx, 1		; Shift	Logical	Left

loc_418FE:
push	[word ptr bx+1F96h]
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, 6		; Add
push	ax

loc_4190D:
mov	ax, 105h

loc_41910:
push	ax

loc_41911:		; Call Procedure
call	sub_1993F

loc_41916:		; Add
add	sp, 6

loc_41919:		; Load Effective Address
lea	ax, [bp+var_28]

loc_4191C:		; CODE XREF: sub_40EC0+A11j
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_41920:		; Call Procedure
call	sub_19399
pop	cx
pop	cx
mov	bx, si

loc_41929:		; Shift	Logical	Left
shl	bx, 1

loc_4192B:
mov	bx, [bx+2E00h]

loc_4192F:		; Shift	Logical	Left
shl	bx, 1
push	[word ptr bx+1F96h]

loc_41935:
mov	ax, si
mov	dx, 7
imul	dx		; Signed Multiply

loc_4193C:		; Add
add	ax, 5
push	ax

loc_41940:
mov	ax, 104h
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add

loc_4194C:		; CODE XREF: sub_40EC0+983j
inc	si		; Increment by 1

loc_4194D:		; CODE XREF: sub_40EC0+8CEj
cmp	si, 6		; Compare Two Operands
jge	short loc_41955	; Jump if Greater or Equal (SF=OF)
jmp	loc_41791	; Jump

loc_41955:		; CODE XREF: sub_40EC0+A90j
mov	ax, 0Ah
push	ax
lea	ax, [bp+argDst]	; Load Effective Address

loc_4195C:		; argPtrCharArr
push	ax

loc_4195D:		; argNumber
push	[word_3ABA4]
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, 3272h
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
cmp	[word_3ABA4], 0	; Compare Two Operands
jnz	short loc_41987	; Jump if Not Zero (ZF=0)
mov	[word_3ABBA], 1
jmp	short loc_4198D	; Jump

loc_41987:		; CODE XREF: sub_40EC0+ABDj
mov	[word_3ABBA], 0

loc_4198D:		; CODE XREF: sub_40EC0+AC5j
mov	ax, 0Fh
push	ax		; int
mov	ax, 3
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_24]	; Load Effective Address
push	ax

loc_419A0:
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_419AB:		; Load Effective Address
lea	ax, [bp+argDst]
push	ax		; int
mov	ax, 0BAh ; ''
push	ax		; int
mov	ax, 0DEh ; ''
push	ax		; int

loc_419B7:		; Call Procedure
call	sub_196ED
add	sp, 6		; Add

loc_419BF:		; Load Effective Address
lea	ax, [bp+var_1E]
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx

loc_419CD:
pop	cx

loc_419CE:		; Load Effective Address
lea	ax, [bp+argDst]
push	ax		; int

loc_419D2:
mov	ax, 0B9h ; ''
push	ax		; int
mov	ax, 0DDh ; ''
push	ax		; int

loc_419DA:		; Call Procedure
call	sub_196ED
add	sp, 6		; Add
mov	ax, 0Fh
push	ax		; int

loc_419E6:
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx

loc_419F0:
pop	cx
lea	ax, [bp+var_1E]	; Load Effective Address

loc_419F4:
push	ax
mov	ax, 4
push	ax

loc_419F9:		; Call Procedure
call	sub_19399
pop	cx
pop	cx

loc_41A00:
mov	ax, 6901h
push	ax		; int

loc_41A04:
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Eh	; 'N'
push	ax		; int

loc_41A0C:		; Call Procedure
call	sub_196ED
add	sp, 6		; Add
mov	ax, 6901h
push	ax		; int

loc_41A18:
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure

loc_41A25:		; Add
add	sp, 6

loc_41A28:		; Load Effective Address
lea	ax, [bp+var_24]
push	ax
mov	ax, 4

loc_41A2F:
push	ax

loc_41A30:		; Call Procedure
call	sub_19399
pop	cx
pop	cx
mov	ax, 6901h

loc_41A3A:		; int
push	ax

loc_41A3B:
mov	ax, 77h	; 'w'
push	ax		; int

loc_41A3F:
mov	ax, 4Dh	; 'M'
push	ax		; int

loc_41A43:		; Call Procedure
call	sub_196ED

loc_41A48:		; Add
add	sp, 6
push	cs
call	near ptr sub_4043A ; Call Procedure
pop	di
pop	si

loc_41A51:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_40EC0

off_41A55 dw offset loc_41023
			; DATA XREF: sub_40EC0+15Er
dw offset loc_4107E	; jump table for switch	statement
dw offset loc_410D9
dw offset loc_4112B
dw offset loc_4117C


; Attributes: bp-based frame

proc LBX_NewGame_s41A5F	far
			; CODE XREF: j_LBX_NewGame_s41A5FJ
			; sub_3DA30:loc_3DAD8p

dest= byte ptr -0BAh
var_24=	word ptr -24h
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp

loc_41A60:
mov	bp, sp
sub	sp, 0BAh	; Integer Subtraction

loc_41A66:
push	si
push	di		; src
lea	ax, [bp+var_24]	; Load Effective Address
push	ss
push	ax
mov	ax, 2FB2h
push	ds
push	ax

loc_41A72:
mov	cx, 0Ah

loc_41A75:		; Call Procedure
call	SCOPY@

loc_41A7A:		; argPtrBuffer_EMS
push	[idk_LBX_w37EBE]
xor	ax, ax		; Logical Exclusive OR
push	ax		; argEntryNumber

loc_41A81:		; "NEWGAME.LBX"
mov	ax, offset strNEWGAMELBX
push	ax		; argLbxFileName

loc_41A85:		; Call Procedure
call	LBX_Load_Entry_0_1

loc_41A8A:		; Add
add	sp, 6

loc_41A8D:
mov	[idk_LBX_w36FC8], ax

loc_41A90:		; arg4_Int
push	[idk_LBX_w37EBE]

loc_41A94:
mov	ax, 2Fh	; '/'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add

loc_41AA4:
mov	[idk_LBX_w3AB78], ax

loc_41AA7:		; arg4_Int
push	[idk_LBX_w37EBE]
mov	ax, 30h	; '0'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure

loc_41AB8:		; Add
add	sp, 6

loc_41ABB:
mov	[idk_LBX_w3AB5A], ax

loc_41ABE:		; arg4_Int
push	[idk_LBX_w37EBE]
mov	ax, 31h	; '1'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber

loc_41ACA:		; Call Procedure
call	LBX_Load_Entry_0_2
add	sp, 6		; Add

loc_41AD2:
mov	[idk_LBX_w3AB5C], ax
push	[idk_LBX_w37EBE] ; arg4_Int

loc_41AD9:
mov	ax, 32h	; '2'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"

loc_41AE0:		; argEntryNumber
push	ax
call	LBX_Load_Entry_0_2 ; Call Procedure

loc_41AE6:		; Add
add	sp, 6
mov	[idk_LBX_w3AB5E], ax

loc_41AEC:		; arg4_Int
push	[idk_LBX_w37EBE]
mov	ax, 33h	; '3'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber

loc_41AF8:		; Call Procedure
call	LBX_Load_Entry_0_2
add	sp, 6		; Add
mov	[idk_LBX_w3AB60], ax

loc_41B03:		; arg4_Int
push	[idk_LBX_w37EBE]

loc_41B07:
mov	ax, 2Ah	; '*'

loc_41B0A:		; argFileName
push	ax

loc_41B0B:		; "NEWGAME.LBX"
mov	ax, offset strNEWGAMELBX
push	ax		; argEntryNumber

loc_41B0F:		; Call Procedure
call	LBX_Load_Entry_0_2

loc_41B14:		; Add
add	sp, 6

loc_41B17:
mov	[idk_LBX_w379C0], ax

loc_41B1A:		; arg4_Int
push	[idk_LBX_w37EBE]

loc_41B1E:
mov	ax, 2Bh	; '+'
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber

loc_41B26:		; Call Procedure
call	LBX_Load_Entry_0_2

loc_41B2B:		; Add
add	sp, 6
mov	[word_3ABBC], ax
xor	si, si		; Logical Exclusive OR

loc_41B33:		; Jump
jmp	short loc_41B54

loc_41B35:		; CODE XREF: LBX_NewGame_s41A5F:loc_41B57j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 18h		; Add
push	ax		; argFileName

loc_41B3F:		; "NEWGAME.LBX"
mov	ax, offset strNEWGAMELBX
push	ax		; argEntryNumber

loc_41B43:		; Call Procedure
call	LBX_Load_Entry_0_2

loc_41B48:		; Add
add	sp, 6
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_41B4F:
mov	[bx-721Ah], ax
inc	si		; Increment by 1

loc_41B54:		; CODE XREF: LBX_NewGame_s41A5F:loc_41B33j
cmp	si, 0Fh		; Compare Two Operands

loc_41B57:		; Jump if Less (SF!=OF)
jl	short loc_41B35

loc_41B59:		; arg4_Int
push	[idk_LBX_w37EBE]

loc_41B5D:
mov	ax, 2Ch	; ','
push	ax		; argFileName
mov	ax, offset strNEWGAMELBX ; "NEWGAME.LBX"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADD8], ax
push	[idk_LBX_w37EBE] ; arg4_Int

loc_41B74:
mov	ax, 2Dh	; '-'
push	ax		; argFileName

loc_41B78:		; "NEWGAME.LBX"
mov	ax, offset strNEWGAMELBX
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure

loc_41B81:		; Add
add	sp, 6

loc_41B84:
mov	[word_3ADD6], ax

loc_41B87:		; arg4_Int
push	[idk_LBX_w37EBE]

loc_41B8B:
mov	ax, 34h	; '4'

loc_41B8E:		; argFileName
push	ax

loc_41B8F:		; "NEWGAME.LBX"
mov	ax, offset strNEWGAMELBX
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure

loc_41B98:		; Add
add	sp, 6
mov	[word_3ABA6], ax

loc_41B9E:
mov	[word_3ABA4], 0

loc_41BA4:
mov	[word_3AA60], 0

loc_41BAA:
mov	ax, 1
push	ax
mov	ax, seg	stub050
push	ax

loc_41BB2:
mov	ax, 48h	; 'H'
push	ax
call	sub_2E1FB	; Call Procedure

loc_41BBB:		; Add
add	sp, 6
xor	si, si		; Logical Exclusive OR

loc_41BC0:		; Jump
jmp	short loc_41BF5

loc_41BC2:		; CODE XREF: LBX_NewGame_s41A5F:loc_41BF8j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_41BC6:
mov	[word ptr bx-758Ah], 0

loc_41BCC:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-75BEh], 0
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_41BDA:
mov	[word ptr bx-75A4h], 0
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7570h], 0

loc_41BEA:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7556h], 0

loc_41BF4:		; Increment by 1
inc	si

loc_41BF5:		; CODE XREF: LBX_NewGame_s41A5F:loc_41BC0j
cmp	si, 0Dh		; Compare Two Operands

loc_41BF8:		; Jump if Less (SF!=OF)
jl	short loc_41BC2

loc_41BFA:
mov	ax, 0Ah
push	ax		; int
mov	ax, 1Eh
push	ax		; int

loc_41C02:		; Logical Exclusive OR
xor	ax, ax
push	ax		; int
mov	ax, 85B0h

loc_41C08:		; int
push	ax

loc_41C09:
mov	ax, 24h	; '$'

loc_41C0C:		; int
push	ax

loc_41C0D:		; int
mov	ax, offset aHlpentry_lbx_0
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add

loc_41C19:
mov	[bp+var_A], 0
jmp	loc_421C0	; Jump

loc_41C21:		; CODE XREF: LBX_NewGame_s41A5F+767j
mov	[bp+var_4], 1

loc_41C26:
mov	bx, [bp+var_A]

loc_41C29:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_24]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]

loc_41C32:
mov	[word_3ABAC], ax

loc_41C35:
mov	[word_3ABBA], 0

loc_41C3B:		;
call	setFlagsMaybeMouseEGA ;	mov	word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, 3059h
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx

loc_41C4A:
mov	[word_36FD0], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h

loc_41C54:
push	ax
mov	ax, 0C4h ; ''
push	ax
mov	ax, 11Ah
push	ax
mov	ax, 0B5h ; ''
push	ax
mov	ax, 0FBh ; ''

loc_41C64:
push	ax

loc_41C65:		; Call Procedure
call	idk_Mouse_s29A0B

loc_41C6A:		; Add
add	sp, 0Ch
mov	[word_3ABA2], ax

loc_41C70:		; Logical Exclusive OR
xor	si, si

loc_41C72:		; Jump
jmp	short loc_41C7F

loc_41C74:		; CODE XREF: LBX_NewGame_s41A5F+223j
mov	bx, si

loc_41C76:		; Shift	Logical	Left
shl	bx, 1

loc_41C78:
mov	[word ptr bx-71F4h], 0FC18h

loc_41C7E:		; Increment by 1
inc	si

loc_41C7F:		; CODE XREF: LBX_NewGame_s41A5F:loc_41C72j
cmp	si, 1Eh		; Compare Two Operands
jl	short loc_41C74	; Jump if Less (SF!=OF)

loc_41C84:
mov	bx, [word_3ABAC]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+695Ah], 1 ; Compare Two Operands
jg	short loc_41C94	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_41DA4	; Jump

loc_41C94:		; CODE XREF: LBX_NewGame_s41A5F+230j
nop			; No Operation
push	cs

loc_41C96:		; Call Procedure
call	near ptr sub_421DA

loc_41C99:
mov	[bp+var_4], 0

loc_41C9E:
mov	[bp+var_2], 0
cmp	[word_3ABAC], 2	; Compare Two Operands

loc_41CA8:		; Jump if Not Zero (ZF=0)
jnz	short loc_41CB9

loc_41CAA:
mov	[bp+var_16], 8A76h

loc_41CAF:
mov	[bp+var_1A], 2C9Eh
mov	[bp+var_12], 2

loc_41CB9:		; CODE XREF: LBX_NewGame_s41A5F:loc_41CA8j
cmp	[word_3ABAC], 1	; Compare Two Operands
jnz	short loc_41CCF	; Jump if Not Zero (ZF=0)

loc_41CC0:
mov	[bp+var_16], 8A5Ch

loc_41CC5:
mov	[bp+var_1A], 2C84h

loc_41CCA:
mov	[bp+var_12], 1

loc_41CCF:		; CODE XREF: LBX_NewGame_s41A5F+25Fj
cmp	[word_3ABAC], 0	; Compare Two Operands
jnz	short loc_41CE5	; Jump if Not Zero (ZF=0)

loc_41CD6:
mov	[bp+var_16], 8A42h

loc_41CDB:
mov	[bp+var_1A], 2C6Ah
mov	[bp+var_12], 0

loc_41CE5:		; CODE XREF: LBX_NewGame_s41A5F+275j
cmp	[word_3ABAC], 3	; Compare Two Operands
jnz	short loc_41CFB	; Jump if Not Zero (ZF=0)

loc_41CEC:
mov	[bp+var_16], 8A90h

loc_41CF1:
mov	[bp+var_1A], 2CB8h

loc_41CF6:
mov	[bp+var_12], 3

loc_41CFB:		; CODE XREF: LBX_NewGame_s41A5F+28Bj
cmp	[word_3ABAC], 4	; Compare Two Operands
jnz	short loc_41D11	; Jump if Not Zero (ZF=0)

loc_41D02:
mov	[bp+var_16], 8AAAh

loc_41D07:
mov	[bp+var_1A], 2CD2h

loc_41D0C:
mov	[bp+var_12], 4

loc_41D11:		; CODE XREF: LBX_NewGame_s41A5F+2A1j
mov	bx, [word_3ABAC]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1
mov	[bp+var_E], ax
mov	ax, [bp+var_E]
dec	ax		; Decrement by 1
mov	[bp+var_10], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_41D41	; Jump

loc_41D2A:		; CODE XREF: LBX_NewGame_s41A5F+2EBj
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_1A]
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, dx		; Add
mov	[bx], ax
inc	si		; Increment by 1

loc_41D41:		; CODE XREF: LBX_NewGame_s41A5F+2C9j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C2Eh], si	; Compare Two Operands
jg	short loc_41D2A	; Jump if Greater (ZF=0	& SF=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_41D6D	; Jump

loc_41D50:		; CODE XREF: LBX_NewGame_s41A5F+317j
mov	ax, si
add	ax, 0Ah		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_1A]
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, si
add	dx, 0Ah		; Add
shl	dx, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]

loc_41D68:		; Add
add	bx, dx

loc_41D6A:
mov	[bx], ax
inc	si		; Increment by 1

loc_41D6D:		; CODE XREF: LBX_NewGame_s41A5F+2EFj
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left

loc_41D72:		; Compare Two Operands
cmp	[bx+2C42h], si
jg	short loc_41D50	; Jump if Greater (ZF=0	& SF=OF)

loc_41D78:		; Logical Exclusive OR
xor	si, si

loc_41D7A:		; Jump
jmp	short loc_41D99

loc_41D7C:		; CODE XREF: LBX_NewGame_s41A5F+343j
mov	ax, si

loc_41D7E:		; Add
add	ax, 0Ch
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_1A]
add	bx, ax		; Add

loc_41D88:
mov	ax, [bx]
mov	dx, si

loc_41D8C:		; Add
add	dx, 0Ch

loc_41D8F:		; Shift	Logical	Left
shl	dx, 1
mov	bx, [bp+var_16]
add	bx, dx		; Add

loc_41D96:
mov	[bx], ax
inc	si		; Increment by 1

loc_41D99:		; CODE XREF: LBX_NewGame_s41A5F:loc_41D7Aj
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left

loc_41D9E:		; Compare Two Operands
cmp	[bx+2C56h], si
jg	short loc_41D7C	; Jump if Greater (ZF=0	& SF=OF)

loc_41DA4:		; CODE XREF: LBX_NewGame_s41A5F+232j
jmp	loc_421B4	; Jump

loc_41DA7:		; CODE XREF: LBX_NewGame_s41A5F:loc_421BAj
call	_f020105_bios_timeofday	; Call Procedure
call	sub_2B97A	; Call Procedure
mov	[bp+var_6], ax
mov	ax, [bp+var_6]
cmp	ax, [word_36FD0] ; Compare Two Operands
jnz	short loc_41DC3	; Jump if Not Zero (ZF=0)
mov	ax, 4

loc_41DC0:		; CODE XREF: LBX_NewGame_s41A5F+772j
jmp	loc_421D4	; Jump

loc_41DC3:		; CODE XREF: LBX_NewGame_s41A5F+35Cj
mov	ax, [bp+var_6]
cmp	ax, [word_3ABA2] ; Compare Two Operands
jnz	short loc_41DD8	; Jump if Not Zero (ZF=0)
cmp	[word_3ABBA], 0	; Compare Two Operands
jz	short loc_41DD8	; Jump if Zero (ZF=1)
mov	[bp+var_4], 1

loc_41DD8:		; CODE XREF: LBX_NewGame_s41A5F+36Bj
			; LBX_NewGame_s41A5F+372j
cmp	[bp+var_E], 0	; Compare Two Operands
jg	short loc_41DE1	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4212C	; Jump

loc_41DE1:		; CODE XREF: LBX_NewGame_s41A5F+37Dj
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_41DEA	; Jump if Not Zero (ZF=0)
jmp	loc_4212C	; Jump

loc_41DEA:		; CODE XREF: LBX_NewGame_s41A5F+386j
cmp	[bp+var_6], 0	; Compare Two Operands
jnz	short loc_41DF3	; Jump if Not Zero (ZF=0)
jmp	loc_4212C	; Jump

loc_41DF3:		; CODE XREF: LBX_NewGame_s41A5F+38Fj
mov	[bp+var_C], 0
mov	ax, [bp+var_E]
dec	ax		; Decrement by 1
mov	[bp+var_10], ax
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C2Eh], 0 ; Compare Two Operands
jg	short loc_41E0E	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_41F08	; Jump

loc_41E0E:		; CODE XREF: LBX_NewGame_s41A5F+3AAj
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C2Eh], 0Ah ; Compare Two Operands
jl	short loc_41E1D	; Jump if Less (SF!=OF)
jmp	loc_41F08	; Jump

loc_41E1D:		; CODE XREF: LBX_NewGame_s41A5F+3B9j
xor	si, si		; Logical Exclusive OR
jmp	loc_41EFD	; Jump

loc_41E22:		; CODE XREF: LBX_NewGame_s41A5F+4A3j
mov	[bp+var_8], 0
jmp	loc_41EF3	; Jump

loc_41E2A:		; CODE XREF: LBX_NewGame_s41A5F+49Aj
mov	ax, [bp+var_12]

loc_41E2D:
mov	dx, 28h	; '('

loc_41E30:		; Signed Multiply
imul	dx
add	ax, [bp+var_8]	; Add
push	ax
mov	ax, si
mov	dx, 5
imul	dx		; Signed Multiply
pop	dx
add	dx, ax		; Add
inc	dx		; Increment by 1
mov	[bp+var_14], dx
mov	ax, si
mov	dx, 5
imul	dx		; Signed Multiply
mov	bx, [bp+var_8]
add	bx, ax		; Add

loc_41E50:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jz	short loc_41E5E	; Jump if Zero (ZF=1)
jmp	loc_41EF0	; Jump

loc_41E5E:		; CODE XREF: LBX_NewGame_s41A5F+3FAj
mov	[bp+var_18], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_41E90	; Jump

loc_41E67:		; CODE XREF: LBX_NewGame_s41A5F+43Aj
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_14]	; Compare Two Operands
jnz	short loc_41E8F	; Jump if Not Zero (ZF=0)
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_41E8F	; Jump if Not Zero (ZF=0)
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
mov	[word ptr bx], 0
mov	[bp+var_18], 1

loc_41E8F:		; CODE XREF: LBX_NewGame_s41A5F+416j
			; LBX_NewGame_s41A5F+41Cj
inc	di		; Increment by 1

loc_41E90:		; CODE XREF: LBX_NewGame_s41A5F+406j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C2Eh], di	; Compare Two Operands
jg	short loc_41E67	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_41EE4	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_41ED9	; Jump

loc_41EA5:		; CODE XREF: LBX_NewGame_s41A5F+483j
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_41EB9	; Jump if Not Zero (ZF=0)

loc_41EB3:		; Compare Two Operands
cmp	[bp+var_18], 0
jz	short loc_41EC5	; Jump if Zero (ZF=1)

loc_41EB9:		; CODE XREF: LBX_NewGame_s41A5F+452j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C2Eh], 1 ; Compare Two Operands
jnz	short loc_41ED8	; Jump if Not Zero (ZF=0)

loc_41EC5:		; CODE XREF: LBX_NewGame_s41A5F+458j
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add

loc_41ECE:
mov	ax, [bp+var_14]
mov	[bx], ax
mov	[bp+var_18], 1

loc_41ED8:		; CODE XREF: LBX_NewGame_s41A5F+464j
inc	di		; Increment by 1

loc_41ED9:		; CODE XREF: LBX_NewGame_s41A5F+444j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C2Eh], di	; Compare Two Operands
jg	short loc_41EA5	; Jump if Greater (ZF=0	& SF=OF)

loc_41EE4:		; CODE XREF: LBX_NewGame_s41A5F+440j
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_41EF0	; Jump if Not Zero (ZF=0)
mov	[word_3AA60], 2

loc_41EF0:		; CODE XREF: LBX_NewGame_s41A5F+3FCj
			; LBX_NewGame_s41A5F+489j
inc	[bp+var_8]	; Increment by 1

loc_41EF3:		; CODE XREF: LBX_NewGame_s41A5F+3C8j
cmp	[bp+var_8], 5	; Compare Two Operands
jge	short loc_41EFC	; Jump if Greater or Equal (SF=OF)
jmp	loc_41E2A	; Jump

loc_41EFC:		; CODE XREF: LBX_NewGame_s41A5F+498j
inc	si		; Increment by 1

loc_41EFD:		; CODE XREF: LBX_NewGame_s41A5F+3C0j
cmp	si, 2		; Compare Two Operands
jge	short loc_41F05	; Jump if Greater or Equal (SF=OF)
jmp	loc_41E22	; Jump

loc_41F05:		; CODE XREF: LBX_NewGame_s41A5F+4A1j
inc	[bp+var_C]	; Increment by 1

loc_41F08:		; CODE XREF: LBX_NewGame_s41A5F+3ACj
			; LBX_NewGame_s41A5F+3BBj
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C42h], 0 ; Compare Two Operands
jg	short loc_41F17	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4201A	; Jump

loc_41F17:		; CODE XREF: LBX_NewGame_s41A5F+4B3j
xor	si, si		; Logical Exclusive OR
jmp	loc_4200F	; Jump

loc_41F1C:		; CODE XREF: LBX_NewGame_s41A5F+5B5j
mov	[bp+var_8], 0
jmp	loc_42005	; Jump

loc_41F24:		; CODE XREF: LBX_NewGame_s41A5F+5ACj
mov	ax, [bp+var_12]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
add	ax, [bp+var_8]	; Add
push	ax
mov	ax, si
mov	dx, 5
imul	dx		; Signed Multiply
pop	dx
add	dx, ax		; Add
add	dx, 0Bh		; Add
mov	[bp+var_14], dx
mov	ax, si
mov	dx, 5
imul	dx		; Signed Multiply
mov	bx, [bp+var_8]
add	bx, ax		; Add
mov	ax, [bp+var_C]
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jz	short loc_41F64	; Jump if Zero (ZF=1)
jmp	loc_42002	; Jump

loc_41F64:		; CODE XREF: LBX_NewGame_s41A5F+500j
mov	[bp+var_18], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_41F9C	; Jump

loc_41F6D:		; CODE XREF: LBX_NewGame_s41A5F+546j
mov	ax, di
add	ax, 0Ah		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_14]	; Compare Two Operands
jnz	short loc_41F9B	; Jump if Not Zero (ZF=0)
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_41F9B	; Jump if Not Zero (ZF=0)
mov	ax, di
add	ax, 0Ah		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
mov	[word ptr bx], 0
mov	[bp+var_18], 1

loc_41F9B:		; CODE XREF: LBX_NewGame_s41A5F+51Fj
			; LBX_NewGame_s41A5F+525j
inc	di		; Increment by 1

loc_41F9C:		; CODE XREF: LBX_NewGame_s41A5F+50Cj
mov	bx, [bp+var_10]

loc_41F9F:		; Shift	Logical	Left
shl	bx, 1
cmp	[bx+2C42h], di	; Compare Two Operands
jg	short loc_41F6D	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_41FF6	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_41FEB	; Jump

loc_41FB1:		; CODE XREF: LBX_NewGame_s41A5F+595j
mov	ax, di
add	ax, 0Ah		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_41FC8	; Jump if Not Zero (ZF=0)
cmp	[bp+var_18], 0	; Compare Two Operands
jz	short loc_41FD4	; Jump if Zero (ZF=1)

loc_41FC8:		; CODE XREF: LBX_NewGame_s41A5F+561j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C42h], 1 ; Compare Two Operands
jnz	short loc_41FEA	; Jump if Not Zero (ZF=0)

loc_41FD4:		; CODE XREF: LBX_NewGame_s41A5F+567j
mov	ax, di
add	ax, 0Ah		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
mov	ax, [bp+var_14]
mov	[bx], ax
mov	[bp+var_18], 1

loc_41FEA:		; CODE XREF: LBX_NewGame_s41A5F+573j
inc	di		; Increment by 1

loc_41FEB:		; CODE XREF: LBX_NewGame_s41A5F+550j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C42h], di	; Compare Two Operands
jg	short loc_41FB1	; Jump if Greater (ZF=0	& SF=OF)

loc_41FF6:		; CODE XREF: LBX_NewGame_s41A5F+54Cj
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_42002	; Jump if Not Zero (ZF=0)
mov	[word_3AA60], 2

loc_42002:		; CODE XREF: LBX_NewGame_s41A5F+502j
			; LBX_NewGame_s41A5F+59Bj
inc	[bp+var_8]	; Increment by 1

loc_42005:		; CODE XREF: LBX_NewGame_s41A5F+4C2j
cmp	[bp+var_8], 5	; Compare Two Operands
jge	short loc_4200E	; Jump if Greater or Equal (SF=OF)
jmp	loc_41F24	; Jump

loc_4200E:		; CODE XREF: LBX_NewGame_s41A5F+5AAj
inc	si		; Increment by 1

loc_4200F:		; CODE XREF: LBX_NewGame_s41A5F+4BAj
cmp	si, 2		; Compare Two Operands
jge	short loc_42017	; Jump if Greater or Equal (SF=OF)
jmp	loc_41F1C	; Jump

loc_42017:		; CODE XREF: LBX_NewGame_s41A5F+5B3j
inc	[bp+var_C]	; Increment by 1

loc_4201A:		; CODE XREF: LBX_NewGame_s41A5F+4B5j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C56h], 0 ; Compare Two Operands
jg	short loc_42029	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4212C	; Jump

loc_42029:		; CODE XREF: LBX_NewGame_s41A5F+5C5j
xor	si, si		; Logical Exclusive OR
jmp	loc_42121	; Jump

loc_4202E:		; CODE XREF: LBX_NewGame_s41A5F+6C7j
mov	[bp+var_8], 0
jmp	loc_42117	; Jump

loc_42036:		; CODE XREF: LBX_NewGame_s41A5F+6BEj
mov	ax, [bp+var_12]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
add	ax, [bp+var_8]	; Add
push	ax
mov	ax, si
mov	dx, 5
imul	dx		; Signed Multiply
pop	dx

loc_4204A:		; Add
add	dx, ax
add	dx, 15h		; Add
mov	[bp+var_14], dx
mov	ax, si
mov	dx, 5
imul	dx		; Signed Multiply

loc_42059:
mov	bx, [bp+var_8]
add	bx, ax		; Add
mov	ax, [bp+var_C]
mov	dx, 0Ah
imul	dx		; Signed Multiply
add	bx, ax		; Add
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-71F4h]
cmp	ax, [bp+var_6]	; Compare Two Operands
jz	short loc_42076	; Jump if Zero (ZF=1)
jmp	loc_42114	; Jump

loc_42076:		; CODE XREF: LBX_NewGame_s41A5F+612j
mov	[bp+var_18], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_420AE	; Jump

loc_4207F:		; CODE XREF: LBX_NewGame_s41A5F+658j
mov	ax, di
add	ax, 0Ch		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_14]	; Compare Two Operands
jnz	short loc_420AD	; Jump if Not Zero (ZF=0)
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_420AD	; Jump if Not Zero (ZF=0)
mov	ax, di
add	ax, 0Ch		; Add
shl	ax, 1		; Shift	Logical	Left

loc_4209F:
mov	bx, [bp+var_16]
add	bx, ax		; Add
mov	[word ptr bx], 0
mov	[bp+var_18], 1

loc_420AD:		; CODE XREF: LBX_NewGame_s41A5F+631j
			; LBX_NewGame_s41A5F+637j
inc	di		; Increment by 1

loc_420AE:		; CODE XREF: LBX_NewGame_s41A5F+61Ej
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C56h], di	; Compare Two Operands
jg	short loc_4207F	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_42108	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_420FD	; Jump

loc_420C3:		; CODE XREF: LBX_NewGame_s41A5F+6A7j
mov	ax, di
add	ax, 0Ch		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_420DA	; Jump if Not Zero (ZF=0)
cmp	[bp+var_18], 0	; Compare Two Operands
jz	short loc_420E6	; Jump if Zero (ZF=1)

loc_420DA:		; CODE XREF: LBX_NewGame_s41A5F+673j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C56h], 1 ; Compare Two Operands
jnz	short loc_420FC	; Jump if Not Zero (ZF=0)

loc_420E6:		; CODE XREF: LBX_NewGame_s41A5F+679j
mov	ax, di
add	ax, 0Ch		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_16]
add	bx, ax		; Add
mov	ax, [bp+var_14]
mov	[bx], ax
mov	[bp+var_18], 1

loc_420FC:		; CODE XREF: LBX_NewGame_s41A5F+685j
inc	di		; Increment by 1

loc_420FD:		; CODE XREF: LBX_NewGame_s41A5F+662j
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C56h], di	; Compare Two Operands
jg	short loc_420C3	; Jump if Greater (ZF=0	& SF=OF)

loc_42108:		; CODE XREF: LBX_NewGame_s41A5F+65Ej
cmp	[bp+var_18], 0	; Compare Two Operands
jnz	short loc_42114	; Jump if Not Zero (ZF=0)
mov	[word_3AA60], 2

loc_42114:		; CODE XREF: LBX_NewGame_s41A5F+614j
			; LBX_NewGame_s41A5F+6ADj
inc	[bp+var_8]	; Increment by 1

loc_42117:		; CODE XREF: LBX_NewGame_s41A5F+5D4j
cmp	[bp+var_8], 5	; Compare Two Operands
jge	short loc_42120	; Jump if Greater or Equal (SF=OF)
jmp	loc_42036	; Jump

loc_42120:		; CODE XREF: LBX_NewGame_s41A5F+6BCj
inc	si		; Increment by 1

loc_42121:		; CODE XREF: LBX_NewGame_s41A5F+5CCj
cmp	si, 2		; Compare Two Operands
jge	short loc_42129	; Jump if Greater or Equal (SF=OF)
jmp	loc_4202E	; Jump

loc_42129:		; CODE XREF: LBX_NewGame_s41A5F+6C5j
inc	[bp+var_C]	; Increment by 1

loc_4212C:		; CODE XREF: LBX_NewGame_s41A5F+37Fj
			; LBX_NewGame_s41A5F+388j
			; LBX_NewGame_s41A5F+391j
			; LBX_NewGame_s41A5F+5C7j
cmp	[word_3AA60], 0	; Compare Two Operands
jle	short loc_42185	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_3AA60]
cmp	ax, 1		; Compare Two Operands
jz	short loc_42142	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_42154	; Jump if Zero (ZF=1)
jmp	short loc_42159	; Jump

loc_42142:		; CODE XREF: LBX_NewGame_s41A5F+6DAj
mov	ax, offset aYouNeedToMakeA ; "You need to make all your	picks before "...

loc_42145:		; CODE XREF: LBX_NewGame_s41A5F+6F8j
push	ax
lea	ax, [bp+dest]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
jmp	short loc_4215B	; Jump

loc_42154:		; CODE XREF: LBX_NewGame_s41A5F+6DFj
mov	ax, offset aYouHaveNoPicks ; "You have no picks	left in	this area, to"...
jmp	short loc_42145	; Jump

loc_42159:		; CODE XREF: LBX_NewGame_s41A5F+6E1j
jmp	short $+2	; Jump

loc_4215B:		; CODE XREF: LBX_NewGame_s41A5F+6F3j
call	sub_2E257	; Call Procedure
lea	ax, [bp+dest]	; Load Effective Address

loc_42164:
push	ax

loc_42165:		; Call Procedure
call	sub_31ABF
pop	cx
mov	ax, 1

loc_4216E:
push	ax
mov	ax, seg	stub050
push	ax
mov	ax, 48h	; 'H'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
mov	[word_3AA60], 0

loc_42185:		; CODE XREF: LBX_NewGame_s41A5F+6D2j
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_421B4	; Jump if Not Zero (ZF=0)
nop			; No Operation

loc_4218C:
push	cs
call	near ptr sub_424BB ; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_2E303	; Call Procedure
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_421AA	; Jump if Not Zero (ZF=0)

loc_421A0:
mov	[bp+var_2], 1
call	sub_1E525	; Call Procedure

loc_421AA:		; CODE XREF: LBX_NewGame_s41A5F+73Fj
mov	ax, 2

loc_421AD:
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_421B4:		; CODE XREF: LBX_NewGame_s41A5F:loc_41DA4j
			; LBX_NewGame_s41A5F+72Aj
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_421BD	; Jump if Not Zero (ZF=0)

loc_421BA:		; Jump
jmp	loc_41DA7

loc_421BD:		; CODE XREF: LBX_NewGame_s41A5F+759j
inc	[bp+var_A]	; Increment by 1

loc_421C0:		; CODE XREF: LBX_NewGame_s41A5F+1BFj
cmp	[bp+var_A], 5	; Compare Two Operands
jge	short loc_421C9	; Jump if Greater or Equal (SF=OF)
jmp	loc_41C21	; Jump

loc_421C9:		; CODE XREF: LBX_NewGame_s41A5F+765j
call	sub_2E257	; Call Procedure
mov	ax, 6
jmp	loc_41DC0	; Jump

loc_421D4:		; CODE XREF: LBX_NewGame_s41A5F:loc_41DC0j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_NewGame_s41A5F	; sp-analysis failed



; Attributes: bp-based frame

proc sub_421DA far	; CODE XREF: sub_31915J
			; LBX_NewGame_s41A5F:loc_41C96p

var_18=	word ptr -18h
var_12=	word ptr -12h
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si
push	di

loc_421E2:		; Load Effective Address
lea	ax, [bp+var_12]

loc_421E5:
push	ss
push	ax
mov	ax, 2FBCh
push	ds
push	ax

loc_421EC:
mov	cx, 6
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_18]	; Load Effective Address
push	ss
push	ax
mov	ax, 2FC2h
push	ds
push	ax
mov	cx, 6
call	SCOPY@		; Call Procedure
cmp	[word_3ABAC], 2	; Compare Two Operands
jnz	short loc_42212	; Jump if Not Zero (ZF=0)

loc_4220D:
mov	[bp+var_8], 2

loc_42212:		; CODE XREF: sub_421DA+31j
cmp	[word_3ABAC], 1	; Compare Two Operands
jnz	short loc_4221E	; Jump if Not Zero (ZF=0)

loc_42219:
mov	[bp+var_8], 1

loc_4221E:		; CODE XREF: sub_421DA+3Dj
cmp	[word_3ABAC], 0	; Compare Two Operands
jnz	short loc_4222A	; Jump if Not Zero (ZF=0)
mov	[bp+var_8], 0

loc_4222A:		; CODE XREF: sub_421DA+49j
cmp	[word_3ABAC], 3	; Compare Two Operands
jnz	short loc_42236	; Jump if Not Zero (ZF=0)
mov	[bp+var_8], 3

loc_42236:		; CODE XREF: sub_421DA+55j
cmp	[word_3ABAC], 4	; Compare Two Operands
jnz	short loc_42242	; Jump if Not Zero (ZF=0)
mov	[bp+var_8], 4

loc_42242:		; CODE XREF: sub_421DA+61j
mov	bx, [word_3ABAC]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1
mov	[bp+var_2], ax

loc_42250:
mov	[bp+var_4], 0
mov	[bp+var_C], 0
mov	[bp+var_A], 27h	; '''
xor	si, si		; Logical Exclusive OR
jmp	short loc_42273	; Jump

loc_42263:		; CODE XREF: sub_421DA+9Cj
mov	ax, si
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	bx, ax

loc_4226C:
mov	[word ptr bx-7A50h], 0FFFFh
inc	si		; Increment by 1

loc_42273:		; CODE XREF: sub_421DA+87j
cmp	si, 1Eh		; Compare Two Operands
jl	short loc_42263	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 0	; Compare Two Operands
jg	short loc_42281	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_424A6	; Jump

loc_42281:		; CODE XREF: sub_421DA+A2j
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1

loc_42285:
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C2Eh], 0 ; Compare Two Operands
jg	short loc_42297	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4233C	; Jump

loc_42297:		; CODE XREF: sub_421DA+B8j
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left

loc_4229C:		; Compare Two Operands
cmp	[word ptr bx+2C2Eh], 0Ah
jl	short loc_422A6	; Jump if Less (SF!=OF)
jmp	loc_4233C	; Jump

loc_422A6:		; CODE XREF: sub_421DA+C7j
xor	si, si		; Logical Exclusive OR
jmp	short loc_42304	; Jump

loc_422AA:		; CODE XREF: sub_421DA+12Dj
xor	di, di		; Logical Exclusive OR
jmp	short loc_422FE	; Jump

loc_422AE:		; CODE XREF: sub_421DA+127j
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, di
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]

loc_422C0:		; Add
add	dx, ax
add	dx, 5		; Add
push	dx
mov	ax, si
mov	dx, 4Eh	; 'N'
imul	dx		; Signed Multiply
add	ax, 0F0h ; ''  ; Add
push	ax
mov	ax, di
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]
add	dx, ax		; Add
push	dx
mov	ax, si
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0AAh ; ''  ; Add
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, [bp+var_C]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71F4h], ax
inc	[bp+var_C]	; Increment by 1
inc	di		; Increment by 1

loc_422FE:		; CODE XREF: sub_421DA+D2j
cmp	di, 5		; Compare Two Operands
jl	short loc_422AE	; Jump if Less (SF!=OF)
inc	si		; Increment by 1

loc_42304:		; CODE XREF: sub_421DA+CEj
cmp	si, 2		; Compare Two Operands
jl	short loc_422AA	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_42334	; Jump

loc_4230D:		; CODE XREF: sub_421DA+15Dj
mov	ax, [bp+var_8]

loc_42310:
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
add	ax, si		; Add
inc	ax		; Increment by 1
push	ax
mov	ax, [bp+var_4]
mov	dx, 0Ah
imul	dx		; Signed Multiply
push	ax
mov	ax, si
pop	dx
add	ax, dx		; Add
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx-7A50h], ax
inc	si		; Increment by 1

loc_42334:		; CODE XREF: sub_421DA+131j
cmp	si, 0Ah		; Compare Two Operands
jl	short loc_4230D	; Jump if Less (SF!=OF)
inc	[bp+var_4]	; Increment by 1

loc_4233C:		; CODE XREF: sub_421DA+BAj
			; sub_421DA+C9j
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C42h], 0 ; Compare Two Operands
jg	short loc_4234B	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_423F1	; Jump

loc_4234B:		; CODE XREF: sub_421DA+16Cj
mov	ax, [bp+var_4]
mov	dx, 33h	; '3'
imul	dx		; Signed Multiply
add	ax, 27h	; '''   ; Add
mov	[bp+var_A], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_423B7	; Jump

loc_4235D:		; CODE XREF: sub_421DA+1E0j
xor	di, di		; Logical Exclusive OR
jmp	short loc_423B1	; Jump

loc_42361:		; CODE XREF: sub_421DA+1DAj
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, di
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]
add	dx, ax		; Add
add	dx, 5		; Add
push	dx
mov	ax, si
mov	dx, 4Eh	; 'N'
imul	dx		; Signed Multiply
add	ax, 0F0h ; ''  ; Add
push	ax
mov	ax, di

loc_42386:
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]
add	dx, ax		; Add
push	dx
mov	ax, si
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0AAh ; ''  ; Add
push	ax

loc_4239C:		; Call Procedure
call	idk_Mouse_s29A0B
add	sp, 0Ch		; Add
mov	bx, [bp+var_C]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71F4h], ax
inc	[bp+var_C]	; Increment by 1
inc	di		; Increment by 1

loc_423B1:		; CODE XREF: sub_421DA+185j
cmp	di, 5		; Compare Two Operands
jl	short loc_42361	; Jump if Less (SF!=OF)
inc	si		; Increment by 1

loc_423B7:		; CODE XREF: sub_421DA+181j
cmp	si, 2		; Compare Two Operands
jl	short loc_4235D	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_423E9	; Jump

loc_423C0:		; CODE XREF: sub_421DA+212j
mov	ax, [bp+var_8]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
add	ax, si		; Add
add	ax, 0Bh		; Add
push	ax
mov	ax, [bp+var_4]
mov	dx, 0Ah
imul	dx		; Signed Multiply
push	ax
mov	ax, si
pop	dx
add	ax, dx		; Add
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx-7A50h], ax
inc	si		; Increment by 1

loc_423E9:		; CODE XREF: sub_421DA+1E4j
cmp	si, 0Ah		; Compare Two Operands
jl	short loc_423C0	; Jump if Less (SF!=OF)
inc	[bp+var_4]	; Increment by 1

loc_423F1:		; CODE XREF: sub_421DA+16Ej
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C56h], 0 ; Compare Two Operands
jg	short loc_42400	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_424A6	; Jump

loc_42400:		; CODE XREF: sub_421DA+221j
mov	ax, [bp+var_4]
mov	dx, 33h	; '3'
imul	dx		; Signed Multiply

loc_42408:		; Add
add	ax, 27h	; '''
mov	[bp+var_A], ax
xor	si, si		; Logical Exclusive OR

loc_42410:		; Jump
jmp	short loc_4246C

loc_42412:		; CODE XREF: sub_421DA+295j
xor	di, di		; Logical Exclusive OR
jmp	short loc_42466	; Jump

loc_42416:		; CODE XREF: sub_421DA+28Fj
mov	ax, 0FFFFh
push	ax
mov	ax, 3049h
push	ax
mov	ax, di
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]
add	dx, ax		; Add
add	dx, 5		; Add
push	dx
mov	ax, si
mov	dx, 4Eh	; 'N'
imul	dx		; Signed Multiply
add	ax, 0F0h ; ''  ; Add
push	ax
mov	ax, di
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]
add	dx, ax		; Add
push	dx
mov	ax, si
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0AAh ; ''  ; Add
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, [bp+var_C]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-71F4h], ax
inc	[bp+var_C]	; Increment by 1
inc	di		; Increment by 1

loc_42466:		; CODE XREF: sub_421DA+23Aj
cmp	di, 5		; Compare Two Operands
jl	short loc_42416	; Jump if Less (SF!=OF)
inc	si		; Increment by 1

loc_4246C:		; CODE XREF: sub_421DA:loc_42410j
cmp	si, 2		; Compare Two Operands
jl	short loc_42412	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4249E	; Jump

loc_42475:		; CODE XREF: sub_421DA+2C7j
mov	ax, [bp+var_8]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
add	ax, si		; Add
add	ax, 15h		; Add
push	ax
mov	ax, [bp+var_4]
mov	dx, 0Ah
imul	dx		; Signed Multiply
push	ax
mov	ax, si
pop	dx
add	ax, dx		; Add
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx-7A50h], ax
inc	si		; Increment by 1

loc_4249E:		; CODE XREF: sub_421DA+299j
cmp	si, 0Ah		; Compare Two Operands
jl	short loc_42475	; Jump if Less (SF!=OF)
inc	[bp+var_4]	; Increment by 1

loc_424A6:		; CODE XREF: sub_421DA+A4j
			; sub_421DA+223j
mov	ax, 1Eh
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_421DA



; Attributes: bp-based frame

proc sub_424BB far	; CODE XREF: sub_31898J
			; LBX_NewGame_s41A5F+72Ep

argDst=	byte ptr -16h
var_C= word ptr	-0Ch
var_6= word ptr	-6

push	bp
mov	bp, sp
sub	sp, 16h		; Integer Subtraction
push	si
push	di		; argConversionBase
lea	ax, [bp+var_6]	; Load Effective Address
push	ss
push	ax
mov	ax, 2FC8h
push	ds
push	ax
mov	cx, 5
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_C]	; Load Effective Address
push	ss
push	ax
mov	ax, 2FCDh
push	ds
push	ax
mov	cx, 5
call	SCOPY@		; Call Procedure
call	sub_2601C	; Call Procedure
mov	[word_36FD4], ax
push	[idk_LBX_w36FC8]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
push	[idk_LBX_w3AB78]
mov	ax, 12h
push	ax
mov	ax, 0B5h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
push	[idk_LBX_w3AB60]
mov	ax, 0B4h ; ''
push	ax
mov	ax, 0C4h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0C4h ; ''
push	ax
mov	ax, 11Ah
push	ax
mov	ax, 0B5h ; ''
push	ax
mov	ax, 0FBh ; ''
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_6]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 6901h
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Eh	; 'N'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, 6901h
push	ax		; int
mov	ax, 78h	; 'x'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_C]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 6901h
push	ax		; int
mov	ax, 77h	; 'w'
push	ax		; int
mov	ax, 4Dh	; 'M'
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	di, 24h	; '$'
xor	si, si		; Logical Exclusive OR
jmp	short loc_425D3	; Jump

loc_425B4:		; CODE XREF: sub_424BB+11Cj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-721Ah]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_425D3:		; CODE XREF: sub_424BB+F7j
cmp	si, [word_38670] ; Compare Two Operands
jl	short loc_425B4	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_425FC	; Jump

loc_425DD:		; CODE XREF: sub_424BB+145j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7208h]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_425FC:		; CODE XREF: sub_424BB+120j
cmp	si, [word_38672] ; Compare Two Operands
jl	short loc_425DD	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_42625	; Jump

loc_42606:		; CODE XREF: sub_424BB+16Ej
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]

loc_4260E:		; Shift	Logical	Left
shl	bx, 1

loc_42610:
push	[word ptr bx-7202h]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_42625:		; CODE XREF: sub_424BB+149j
cmp	si, [word_3866E] ; Compare Two Operands
jl	short loc_42606	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4264E	; Jump

loc_4262F:		; CODE XREF: sub_424BB+197j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-720Eh]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_4264E:		; CODE XREF: sub_424BB+172j
cmp	si, [word_3866A] ; Compare Two Operands
jl	short loc_4262F	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_42677	; Jump

loc_42658:		; CODE XREF: sub_424BB+1C0j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-72AEh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7214h]
mov	ax, 87h	; ''
push	ax
push	di
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
add	di, 8		; Add
inc	si		; Increment by 1

loc_42677:		; CODE XREF: sub_424BB+19Bj
cmp	si, [word_3866C] ; Compare Two Operands
jl	short loc_42658	; Jump if Less (SF!=OF)
cmp	[word_3ABBA], 0	; Compare Two Operands
jz	short loc_426B0	; Jump if Zero (ZF=1)
mov	ax, [word_36FD4]
cmp	ax, [word_3ABA2] ; Compare Two Operands
jnz	short loc_4269A	; Jump if Not Zero (ZF=0)
push	[idk_LBX_w379C0]
mov	ax, 0B7h ; ''
push	ax
mov	ax, 0FDh ; ''
jmp	short loc_426A5	; Jump

loc_4269A:		; CODE XREF: sub_424BB+1D0j
push	[idk_LBX_w379C0]
mov	ax, 0B6h ; ''
push	ax
mov	ax, 0FCh ; ''

loc_426A5:		; CODE XREF: sub_424BB+1DDj
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
jmp	short loc_426D3	; Jump

loc_426B0:		; CODE XREF: sub_424BB+1C7j
push	[word_3ABBC]
mov	ax, 0B6h ; ''
push	ax
mov	ax, 0FCh ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, [word_36FD4]
cmp	ax, [word_3ABA2] ; Compare Two Operands
jnz	short loc_426D3	; Jump if Not Zero (ZF=0)
mov	[word_3AA60], 1

loc_426D3:		; CODE XREF: sub_424BB+1F3j
			; sub_424BB+210j
mov	ax, 0Ah
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argPtrCharArr
push	[word_3ABA4]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, 3272h
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
cmp	[word_3ABA4], 0	; Compare Two Operands
jnz	short loc_42705	; Jump if Not Zero (ZF=0)
mov	[word_3ABBA], 1
jmp	short loc_4270B	; Jump

loc_42705:		; CODE XREF: sub_424BB+240j
mov	[word_3ABBA], 0

loc_4270B:		; CODE XREF: sub_424BB+248j
mov	ax, 0Fh
push	ax		; int
mov	ax, 3
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+var_C]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; int
mov	ax, 0BAh ; ''
push	ax		; int
mov	ax, 0DEh ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
lea	ax, [bp+var_6]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; int
mov	ax, 0B9h ; ''
push	ax		; int
mov	ax, 0DDh ; ''
push	ax		; int
call	sub_196ED	; Call Procedure

loc_4275D:		; Add
add	sp, 6
push	cs
call	near ptr sub_4043A ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_4276F ; Call Procedure
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_424BB



; Attributes: bp-based frame

proc sub_4276F far	; CODE XREF: sub_3191AJ
			; sub_424BB+2ABp

argDst=	byte ptr -0C0h
var_A2=	word ptr -0A2h
var_70=	word ptr -70h
var_66=	word ptr -66h
var_5C=	word ptr -5Ch
var_48=	word ptr -48h
var_33=	byte ptr -33h
var_32=	word ptr -32h
argPtrCharArr= byte ptr	-2Ch
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_1C=	word ptr -1Ch
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0C0h	; Integer Subtraction
push	si
push	di		; argConversionBase
lea	ax, [bp+var_1C]	; Load Effective Address
push	ss
push	ax
mov	ax, 2FD2h
push	ds
push	ax
mov	cx, 6
call	SCOPY@		; Call Procedure
lea	ax, [bp+var_22]	; Load Effective Address
push	ss
push	ax
mov	ax, 2FD8h
push	ds
push	ax
mov	cx, 6
call	SCOPY@		; Call Procedure
mov	ax, [word_34CEE]
mov	[bp+var_24], ax
mov	ax, [word_34CF0]
mov	[bp+var_26], ax
mov	ax, [word_34CF2]
mov	[bp+var_28], ax
lea	ax, [bp+var_70]	; Load Effective Address
push	ss
push	ax
mov	ax, 2FE4h
push	ds
push	ax
mov	cx, 28h	; '('
call	SCOPY@		; Call Procedure

loc_427C0:		; Load Effective Address
lea	ax, [bp+var_A2]
push	ss
push	ax

loc_427C6:
mov	ax, 300Ch
push	ds
push	ax
mov	cx, 32h	; '2'

loc_427CE:		; Call Procedure
call	SCOPY@
cmp	[word_3ABAC], 2	; Compare Two Operands

loc_427D8:		; Jump if Not Zero (ZF=0)
jnz	short loc_427E8
mov	[bp+var_12], 8A76h

loc_427DF:
mov	[bp+var_33], 0C9h ; ''

loc_427E3:
mov	[bp+var_C], 2

loc_427E8:		; CODE XREF: sub_4276F:loc_427D8j
cmp	[word_3ABAC], 1	; Compare Two Operands
jnz	short loc_427FD	; Jump if Not Zero (ZF=0)

loc_427EF:
mov	[bp+var_12], 8A5Ch
mov	[bp+var_33], 0ACh ; ''
mov	[bp+var_C], 1

loc_427FD:		; CODE XREF: sub_4276F+7Ej
cmp	[word_3ABAC], 0	; Compare Two Operands
jnz	short loc_42812	; Jump if Not Zero (ZF=0)
mov	[bp+var_12], 8A42h
mov	[bp+var_33], 0D8h ; ''

loc_4280D:
mov	[bp+var_C], 0

loc_42812:		; CODE XREF: sub_4276F+93j
cmp	[word_3ABAC], 3	; Compare Two Operands
jnz	short loc_42827	; Jump if Not Zero (ZF=0)
mov	[bp+var_12], 8A90h
mov	[bp+var_33], 0Dh
mov	[bp+var_C], 3

loc_42827:		; CODE XREF: sub_4276F+A8j
cmp	[word_3ABAC], 4	; Compare Two Operands
jnz	short loc_4283C	; Jump if Not Zero (ZF=0)
mov	[bp+var_12], 8AAAh
mov	[bp+var_33], 72h ; 'r'
mov	[bp+var_C], 4

loc_4283C:		; CODE XREF: sub_4276F+BDj
xor	di, di		; Logical Exclusive OR
jmp	short loc_42847	; Jump

loc_42840:		; CODE XREF: sub_4276F+DBj
mov	al, [bp+var_33]
mov	[byte ptr bp+di+var_32], al
inc	di		; Increment by 1

loc_42847:		; CODE XREF: sub_4276F+CFj
cmp	di, 5		; Compare Two Operands
jl	short loc_42840	; Jump if Less (SF!=OF)
mov	ax, 331Ah
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, [bp+var_C]
mov	dx, 0Ah
imul	dx		; Signed Multiply
lea	dx, [bp+var_A2]	; Load Effective Address
add	ax, dx		; Add
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, 3322h
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+var_32]	; Load Effective Address
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax
mov	ax, 4
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; int
mov	ax, 6
push	ax		; int
mov	ax, 0F1h ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	al, [byte_38610]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
push	[word ptr bx+52C6h]
mov	ax, 0Ah
push	ax
mov	ax, 18h
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	bx, [word_3ABAC]

loc_428DA:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1
mov	[bp+var_6], ax
mov	[bp+var_8], 0
mov	[bp+var_E], 27h	; '''
mov	[word_3ABA4], 0
cmp	[bp+var_6], 0	; Compare Two Operands
jg	short loc_428FD	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4309E	; Jump

loc_428FD:		; CODE XREF: sub_4276F+189j
mov	ax, [bp+var_6]
dec	ax		; Decrement by 1
mov	[bp+var_A], ax
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C2Eh], 0Ah ; Compare Two Operands
jge	short loc_42924	; Jump if Greater or Equal (SF=OF)
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C2Eh]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_12]
add	bx, ax		; Add
mov	[word ptr bx], 0

loc_42924:		; CODE XREF: sub_4276F+19Fj
xor	di, di		; Logical Exclusive OR
jmp	short loc_4295A	; Jump

loc_42928:		; CODE XREF: sub_4276F+1EEj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
mov	si, [bp+var_12]
add	si, ax		; Add
mov	ax, [si]
mov	[bx], ax
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_42959	; Jump if Not Zero (ZF=0)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0FFFFh

loc_42959:		; CODE XREF: sub_4276F+1DBj
inc	di		; Increment by 1

loc_4295A:		; CODE XREF: sub_4276F+1B7j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_42928	; Jump if Less (SF!=OF)
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C2Eh], 0 ; Compare Two Operands
jg	short loc_4296E	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_42B88	; Jump

loc_4296E:		; CODE XREF: sub_4276F+1FAj
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C2Eh], 0Ah ; Compare Two Operands
jl	short loc_4297D	; Jump if Less (SF!=OF)
jmp	loc_42B88	; Jump

loc_4297D:		; CODE XREF: sub_4276F+209j
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C2Eh]
add	[word_3ABA4], ax ; Add
lea	ax, [bp+var_70]	; Load Effective Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 332Ah
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, 0Ah

loc_429AD:
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+2C2Eh] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add

loc_429C3:		; Load Effective Address
lea	ax, [bp+argPtrCharArr]
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst

loc_429CC:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
lea	ax, [bp+var_32]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax
mov	ax, 3
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1C]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, 0A7h ; ''
push	ax
call	sub_1993F	; Call Procedure

loc_42A0B:		; Add
add	sp, 6

loc_42A0E:
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-71B6h]
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, 0A7h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	[bp+var_14], 0
xor	di, di		; Logical Exclusive OR
jmp	loc_42B7D	; Jump

loc_42A39:		; CODE XREF: sub_4276F+413j
mov	[bp+var_2], 0
jmp	loc_42B73	; Jump

loc_42A41:		; CODE XREF: sub_4276F+40Aj
mov	ax, [bp+var_C]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
add	ax, [bp+var_2]	; Add
push	ax
mov	ax, di
mov	dx, 5
imul	dx		; Signed Multiply
pop	dx
add	dx, ax		; Add
inc	dx		; Increment by 1
mov	[bp+var_10], dx
lea	ax, [bp+var_28]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [bp+var_10]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3833C]
add	dx, ax		; Add
push	[word ptr dword_3833C+2]
push	dx
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
add	dx, ax		; Add
inc	dx		; Increment by 1
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0B0h ; ''  ; Add
push	ax
call	sub_1953F	; Call Procedure
add	sp, 8		; Add
mov	[bp+var_16], 0FFFFh
mov	[bp+var_4], 0
jmp	short loc_42AE0	; Jump

loc_42AAA:		; CODE XREF: sub_4276F+37Dj
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_10]	; Compare Two Operands

loc_42AB9:		; Jump if Not Zero (ZF=0)
jnz	short loc_42ADD
inc	[bp+var_14]	; Increment by 1
mov	[bp+var_16], 1
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left

loc_42AC8:		; Load Effective Address
lea	ax, [bp+var_48]
add	bx, ax		; Add
mov	[word ptr bx], 0FFFFh
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C2Eh]
mov	[bp+var_4], ax

loc_42ADD:		; CODE XREF: sub_4276F:loc_42AB9j
inc	[bp+var_4]	; Increment by 1

loc_42AE0:		; CODE XREF: sub_4276F+339j
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C2Eh]
cmp	ax, [bp+var_4]	; Compare Two Operands
jg	short loc_42AAA	; Jump if Greater (ZF=0	& SF=OF)
db 83h,7Eh,0EAh,0FFh ; <BAD>cmp	    [bp+var_16], 0FFFFh	; Compare Two Operands
jz	short loc_42B2E	; Jump if Zero (ZF=1)
lea	ax, [bp+var_26]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
push	[word_3ABA6]
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply

loc_42B0E:
mov	dx, [bp+var_E]
add	dx, ax		; Add
inc	dx		; Increment by 1
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0A9h ; ''  ; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
dec	[word_3ABA4]	; Decrement by 1
jmp	short loc_42B3C	; Jump

loc_42B2E:		; CODE XREF: sub_4276F+383j
lea	ax, [bp+var_24]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_42B3C:		; CODE XREF: sub_4276F+3BDj
mov	ax, [bp+var_10]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3833C]
add	dx, ax		; Add
push	[word ptr dword_3833C+2]
push	dx
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
add	dx, ax		; Add
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0AFh ; ''  ; Add
push	ax
call	sub_1953F	; Call Procedure
add	sp, 8		; Add
inc	[bp+var_2]	; Increment by 1

loc_42B73:		; CODE XREF: sub_4276F+2CFj
cmp	[bp+var_2], 5	; Compare Two Operands
jge	short loc_42B7C	; Jump if Greater or Equal (SF=OF)
jmp	loc_42A41	; Jump

loc_42B7C:		; CODE XREF: sub_4276F+408j
inc	di		; Increment by 1

loc_42B7D:		; CODE XREF: sub_4276F+2C7j
cmp	di, 2		; Compare Two Operands
jge	short loc_42B85	; Jump if Greater or Equal (SF=OF)
jmp	loc_42A39	; Jump

loc_42B85:		; CODE XREF: sub_4276F+411j
inc	[bp+var_8]	; Increment by 1

loc_42B88:		; CODE XREF: sub_4276F+1FCj
			; sub_4276F+20Bj
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C42h], 2 ; Compare Two Operands
jge	short loc_42BAB	; Jump if Greater or Equal (SF=OF)
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C42h]
add	ax, 0Ah		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_12]
add	bx, ax		; Add
mov	[word ptr bx], 0

loc_42BAB:		; CODE XREF: sub_4276F+423j
xor	di, di		; Logical Exclusive OR
jmp	short loc_42BE4	; Jump

loc_42BAF:		; CODE XREF: sub_4276F:loc_42BE7j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	ax, di
add	ax, 0Ah		; Add
shl	ax, 1		; Shift	Logical	Left
mov	si, [bp+var_12]
add	si, ax		; Add
mov	ax, [si]
mov	[bx], ax
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_42BE3	; Jump if Not Zero (ZF=0)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0FFFFh

loc_42BE3:		; CODE XREF: sub_4276F+465j
inc	di		; Increment by 1

loc_42BE4:		; CODE XREF: sub_4276F+43Ej
cmp	di, 2		; Compare Two Operands

loc_42BE7:		; Jump if Less (SF!=OF)
jl	short loc_42BAF
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C42h], 0 ; Compare Two Operands
jg	short loc_42BF8	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_42E13	; Jump

loc_42BF8:		; CODE XREF: sub_4276F+484j
mov	bx, [bp+var_A]

loc_42BFB:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bx+2C42h]
add	[word_3ABA4], ax ; Add
mov	ax, [bp+var_8]
mov	dx, 33h	; '3'
imul	dx		; Signed Multiply
add	ax, 27h	; '''   ; Add

loc_42C10:
mov	[bp+var_E], ax
lea	ax, [bp+var_66]	; Load Effective Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 332Ah
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst

loc_42C2C:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+2C42h] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+var_32]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax
mov	ax, 3
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1C]	; Load Effective Address
add	bx, ax		; Add

loc_42C89:
push	[word ptr bx]
mov	ax, 0A7h ; ''
push	ax

loc_42C8F:		; Call Procedure
call	sub_1993F
add	sp, 6		; Add
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-71B6h]
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, 0A7h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	[bp+var_14], 0
xor	di, di		; Logical Exclusive OR
jmp	loc_42E08	; Jump

loc_42CC2:		; CODE XREF: sub_4276F+69Ej
mov	[bp+var_2], 0
jmp	loc_42DFE	; Jump

loc_42CCA:		; CODE XREF: sub_4276F+695j
mov	ax, [bp+var_C]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
add	ax, [bp+var_2]	; Add
push	ax
mov	ax, di
mov	dx, 5

loc_42CDB:		; Signed Multiply
imul	dx
pop	dx
add	dx, ax		; Add
add	dx, 0Bh		; Add
mov	[bp+var_10], dx
lea	ax, [bp+var_28]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_42CF4:
mov	ax, [bp+var_10]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3833C]
add	dx, ax		; Add
push	[word ptr dword_3833C+2]
push	dx
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply

loc_42D0F:
mov	dx, [bp+var_E]
add	dx, ax		; Add
inc	dx		; Increment by 1
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0B0h ; ''  ; Add
push	ax
call	sub_1953F	; Call Procedure
add	sp, 8		; Add
mov	[bp+var_16], 0FFFFh

loc_42D2E:
mov	[bp+var_4], 0
jmp	short loc_42D6B	; Jump

loc_42D35:		; CODE XREF: sub_4276F+608j
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnz	short loc_42D68	; Jump if Not Zero (ZF=0)
inc	[bp+var_14]	; Increment by 1
mov	[bp+var_16], 1
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0FFFFh
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C42h]
mov	[bp+var_4], ax

loc_42D68:		; CODE XREF: sub_4276F+5D5j
inc	[bp+var_4]	; Increment by 1

loc_42D6B:		; CODE XREF: sub_4276F+5C4j
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C42h]
cmp	ax, [bp+var_4]	; Compare Two Operands
jg	short loc_42D35	; Jump if Greater (ZF=0	& SF=OF)
db 83h,7Eh,0EAh,0FFh ; <BAD>cmp	    [bp+var_16], 0FFFFh	; Compare Two Operands
jz	short loc_42DB9	; Jump if Zero (ZF=1)
lea	ax, [bp+var_26]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
push	[word_3ABA6]
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
add	dx, ax		; Add
inc	dx		; Increment by 1
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0A9h ; ''  ; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
dec	[word_3ABA4]	; Decrement by 1
jmp	short loc_42DC7	; Jump

loc_42DB9:		; CODE XREF: sub_4276F+60Ej
lea	ax, [bp+var_24]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_42DC7:		; CODE XREF: sub_4276F+648j
mov	ax, [bp+var_10]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3833C]
add	dx, ax		; Add
push	[word ptr dword_3833C+2]
push	dx
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
add	dx, ax		; Add
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0AFh ; ''  ; Add
push	ax
call	sub_1953F	; Call Procedure
add	sp, 8		; Add
inc	[bp+var_2]	; Increment by 1

loc_42DFE:		; CODE XREF: sub_4276F+558j
cmp	[bp+var_2], 5	; Compare Two Operands
jge	short loc_42E07	; Jump if Greater or Equal (SF=OF)
jmp	loc_42CCA	; Jump

loc_42E07:		; CODE XREF: sub_4276F+693j
inc	di		; Increment by 1

loc_42E08:		; CODE XREF: sub_4276F+550j
cmp	di, 2		; Compare Two Operands
jge	short loc_42E10	; Jump if Greater or Equal (SF=OF)
jmp	loc_42CC2	; Jump

loc_42E10:		; CODE XREF: sub_4276F+69Cj
inc	[bp+var_8]	; Increment by 1

loc_42E13:		; CODE XREF: sub_4276F+486j
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C56h], 1 ; Compare Two Operands
jge	short loc_42E36	; Jump if Greater or Equal (SF=OF)
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C56h]
add	ax, 0Ch		; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_12]
add	bx, ax		; Add
mov	[word ptr bx], 0

loc_42E36:		; CODE XREF: sub_4276F+6AEj
xor	di, di		; Logical Exclusive OR
jmp	short loc_42E6F	; Jump

loc_42E3A:		; CODE XREF: sub_4276F+703j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	ax, di
add	ax, 0Ch		; Add
shl	ax, 1		; Shift	Logical	Left
mov	si, [bp+var_12]
add	si, ax		; Add
mov	ax, [si]
mov	[bx], ax
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_42E6E	; Jump if Not Zero (ZF=0)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0FFFFh

loc_42E6E:		; CODE XREF: sub_4276F+6F0j
inc	di		; Increment by 1

loc_42E6F:		; CODE XREF: sub_4276F+6C9j
cmp	di, 1		; Compare Two Operands
jl	short loc_42E3A	; Jump if Less (SF!=OF)
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C56h], 0 ; Compare Two Operands
jg	short loc_42E83	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4309E	; Jump

loc_42E83:		; CODE XREF: sub_4276F+70Fj
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C56h]
add	[word_3ABA4], ax ; Add
mov	ax, [bp+var_8]
mov	dx, 33h	; '3'
imul	dx		; Signed Multiply
add	ax, 27h	; '''   ; Add
mov	[bp+var_E], ax
lea	ax, [bp+var_5C]	; Load Effective Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 332Ah
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst

loc_42EB7:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
mov	ax, 0Ah
push	ax
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax		; argPtrCharArr
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+2C56h] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+argPtrCharArr] ; Load Effective	Address
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+var_32]	; Load Effective Address
push	ax
mov	ax, 3
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax
mov	ax, 3
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1C]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
mov	ax, 0A7h ; ''
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-71B6h]
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]

loc_42F37:
mov	ax, 0A7h ; ''
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	[bp+var_14], 0
xor	di, di		; Logical Exclusive OR
jmp	loc_43093	; Jump

loc_42F4D:		; CODE XREF: sub_4276F+929j
mov	[bp+var_2], 0
jmp	loc_43089	; Jump

loc_42F55:		; CODE XREF: sub_4276F+920j
mov	ax, [bp+var_C]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
add	ax, [bp+var_2]	; Add
push	ax
mov	ax, di
mov	dx, 5
imul	dx		; Signed Multiply
pop	dx
add	dx, ax		; Add
add	dx, 15h		; Add
mov	[bp+var_10], dx
lea	ax, [bp+var_28]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, [bp+var_10]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3833C]
add	dx, ax		; Add
push	[word ptr dword_3833C+2]
push	dx
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
add	dx, ax		; Add
inc	dx		; Increment by 1
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0B0h ; ''  ; Add
push	ax
call	sub_1953F	; Call Procedure
add	sp, 8		; Add
mov	[bp+var_16], 0FFFFh
mov	[bp+var_4], 0
jmp	short loc_42FF6	; Jump

loc_42FC0:		; CODE XREF: sub_4276F+893j
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnz	short loc_42FF3	; Jump if Not Zero (ZF=0)
inc	[bp+var_14]	; Increment by 1
mov	[bp+var_16], 1
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_48]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0FFFFh
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C56h]
mov	[bp+var_4], ax

loc_42FF3:		; CODE XREF: sub_4276F+860j
inc	[bp+var_4]	; Increment by 1

loc_42FF6:		; CODE XREF: sub_4276F+84Fj
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C56h]
cmp	ax, [bp+var_4]	; Compare Two Operands
jg	short loc_42FC0	; Jump if Greater (ZF=0	& SF=OF)
db 83h,7Eh,0EAh,0FFh ; <BAD>cmp	    [bp+var_16], 0FFFFh	; Compare Two Operands
jz	short loc_43044	; Jump if Zero (ZF=1)
lea	ax, [bp+var_26]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
push	[word_3ABA6]
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
add	dx, ax		; Add
inc	dx		; Increment by 1
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0A9h ; ''  ; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
dec	[word_3ABA4]	; Decrement by 1
jmp	short loc_43052	; Jump

loc_43044:		; CODE XREF: sub_4276F+899j
lea	ax, [bp+var_24]	; Load Effective Address
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_43052:		; CODE XREF: sub_4276F+8D3j
mov	ax, [bp+var_10]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3833C]
add	dx, ax		; Add

loc_43060:
push	[word ptr dword_3833C+2]
push	dx
mov	ax, [bp+var_2]
mov	dx, 7
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
add	dx, ax		; Add
push	dx
mov	ax, di
mov	dx, 4Ah	; 'J'
imul	dx		; Signed Multiply
add	ax, 0AFh ; ''  ; Add
push	ax

loc_4307E:		; Call Procedure
call	sub_1953F
add	sp, 8		; Add
inc	[bp+var_2]	; Increment by 1

loc_43089:		; CODE XREF: sub_4276F+7E3j
cmp	[bp+var_2], 5	; Compare Two Operands
jge	short loc_43092	; Jump if Greater or Equal (SF=OF)
jmp	loc_42F55	; Jump

loc_43092:		; CODE XREF: sub_4276F+91Ej
inc	di		; Increment by 1

loc_43093:		; CODE XREF: sub_4276F+7DBj
cmp	di, 2		; Compare Two Operands
jge	short loc_4309B	; Jump if Greater or Equal (SF=OF)
jmp	loc_42F4D	; Jump

loc_4309B:		; CODE XREF: sub_4276F+927j
inc	[bp+var_8]	; Increment by 1

loc_4309E:		; CODE XREF: sub_4276F+18Bj
			; sub_4276F+711j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4276F



; Attributes: bp-based frame

; int __fastcall __far sub_430A4(int, int, int,	char)
proc sub_430A4 far	; CODE XREF: sub_318F2J
			; sub_3EBA0+1CCp

var_2= word ptr	-2
arg_0= byte ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di		; argSrc
mov	al, [bp+arg_0]
mov	[byte_38610], al
mov	ax, [word ptr bp+arg_0]
mov	dx, 16h
imul	dx		; Signed Multiply

loc_430BA:
mov	bx, ax
mov	ax, [bx+2ADEh]
mov	[word_3866A], ax
mov	ax, [word ptr bp+arg_0]
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+2ADCh]
mov	[word_3866C], ax
mov	ax, [word ptr bp+arg_0]
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax

loc_430DE:
mov	ax, [bx+2AE2h]
mov	[word_3866E], ax
mov	ax, [word ptr bp+arg_0]
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+2ADAh]
mov	[word_38670], ax
mov	ax, [word ptr bp+arg_0]
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+2AE0h]
mov	[word_38672], ax
mov	[bp+var_2], 6964h
xor	si, si		; Logical Exclusive OR
jmp	short loc_43133	; Jump

loc_43110:		; CODE XREF: sub_430A4+92j
mov	ax, [word ptr bp+arg_0]
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[bx+2AE4h], si	; Compare Two Operands
jnz	short loc_4312A	; Jump if Not Zero (ZF=0)

loc_43120:
mov	bx, [bp+var_2]
add	bx, si		; Add
mov	[byte ptr bx], 1
jmp	short loc_43132	; Jump

loc_4312A:		; CODE XREF: sub_430A4+7Aj
mov	bx, [bp+var_2]
add	bx, si		; Add
mov	[byte ptr bx], 0

loc_43132:		; CODE XREF: sub_430A4+84j
inc	si		; Increment by 1

loc_43133:		; CODE XREF: sub_430A4+6Aj
cmp	si, 12h		; Compare Two Operands
jl	short loc_43110	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR

loc_4313A:		; Jump
jmp	short loc_4316F

loc_4313C:		; CODE XREF: sub_430A4+CEj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-75BEh], 0
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-75A4h], 0
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-758Ah], 0
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7570h], 0
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7556h], 0
inc	si		; Increment by 1

loc_4316F:		; CODE XREF: sub_430A4:loc_4313Aj
cmp	si, 0Dh		; Compare Two Operands
jl	short loc_4313C	; Jump if Less (SF!=OF)
mov	di, [word_3866A]
cmp	di, 1		; Compare Two Operands
jle	short loc_431CC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_43192	; Jump

loc_43181:		; CODE XREF: sub_430A4+F6j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C6Ah]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-75BEh], ax
inc	si		; Increment by 1

loc_43192:		; CODE XREF: sub_430A4+DBj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C2Ch], si	; Compare Two Operands
jg	short loc_43181	; Jump if Greater (ZF=0	& SF=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_431B1	; Jump

loc_431A0:		; CODE XREF: sub_430A4+115j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C7Eh]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-75AAh], ax
inc	si		; Increment by 1

loc_431B1:		; CODE XREF: sub_430A4+FAj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C40h], si	; Compare Two Operands
jg	short loc_431A0	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C54h], 0 ; Compare Two Operands
jle	short loc_431CC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_34992]
mov	[word_3A76A], ax

loc_431CC:		; CODE XREF: sub_430A4+D7j
			; sub_430A4+120j
mov	di, [word_3866C]
cmp	di, 1		; Compare Two Operands
jle	short loc_43224	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_431EA	; Jump

loc_431D9:		; CODE XREF: sub_430A4+14Ej
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C84h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-75A4h], ax
inc	si		; Increment by 1

loc_431EA:		; CODE XREF: sub_430A4+133j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C2Ch], si	; Compare Two Operands
jg	short loc_431D9	; Jump if Greater (ZF=0	& SF=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_43209	; Jump

loc_431F8:		; CODE XREF: sub_430A4+16Dj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C98h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7590h], ax
inc	si		; Increment by 1

loc_43209:		; CODE XREF: sub_430A4+152j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C40h], si	; Compare Two Operands
jg	short loc_431F8	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C54h], 0 ; Compare Two Operands
jle	short loc_43224	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_349AC]
mov	[word_3A784], ax

loc_43224:		; CODE XREF: sub_430A4+12Fj
			; sub_430A4+178j
mov	di, [word_3866E]
cmp	di, 1		; Compare Two Operands
jle	short loc_4327C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_43242	; Jump

loc_43231:		; CODE XREF: sub_430A4+1A6j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2C9Eh]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-758Ah], ax
inc	si		; Increment by 1

loc_43242:		; CODE XREF: sub_430A4+18Bj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C2Ch], si	; Compare Two Operands
jg	short loc_43231	; Jump if Greater (ZF=0	& SF=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_43261	; Jump

loc_43250:		; CODE XREF: sub_430A4+1C5j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2CB2h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7576h], ax
inc	si		; Increment by 1

loc_43261:		; CODE XREF: sub_430A4+1AAj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C40h], si	; Compare Two Operands
jg	short loc_43250	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C54h], 0 ; Compare Two Operands
jle	short loc_4327C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_349C6]
mov	[word_3A79E], ax

loc_4327C:		; CODE XREF: sub_430A4+187j
			; sub_430A4+1D0j
mov	di, [word_38670]
cmp	di, 1		; Compare Two Operands
jle	short loc_432D4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4329A	; Jump

loc_43289:		; CODE XREF: sub_430A4+1FEj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2CB8h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7570h], ax
inc	si		; Increment by 1

loc_4329A:		; CODE XREF: sub_430A4+1E3j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C2Ch], si	; Compare Two Operands
jg	short loc_43289	; Jump if Greater (ZF=0	& SF=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_432B9	; Jump

loc_432A8:		; CODE XREF: sub_430A4+21Dj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2CCCh]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-755Ch], ax
inc	si		; Increment by 1

loc_432B9:		; CODE XREF: sub_430A4+202j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C40h], si	; Compare Two Operands
jg	short loc_432A8	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C54h], 0 ; Compare Two Operands
jle	short loc_432D4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_349E0]
mov	[word_3A7B8], ax

loc_432D4:		; CODE XREF: sub_430A4+1DFj
			; sub_430A4+228j
mov	di, [word_38672]
cmp	di, 1		; Compare Two Operands
jle	short loc_4332C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_432F2	; Jump

loc_432E1:		; CODE XREF: sub_430A4+256j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2CD2h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7556h], ax
inc	si		; Increment by 1

loc_432F2:		; CODE XREF: sub_430A4+23Bj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C2Ch], si	; Compare Two Operands
jg	short loc_432E1	; Jump if Greater (ZF=0	& SF=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_43311	; Jump

loc_43300:		; CODE XREF: sub_430A4+275j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+2CE6h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-7542h], ax
inc	si		; Increment by 1

loc_43311:		; CODE XREF: sub_430A4+25Aj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+2C40h], si	; Compare Two Operands
jg	short loc_43300	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+2C54h], 0 ; Compare Two Operands
jle	short loc_4332C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_349FA]
mov	[word_3A7D2], ax

loc_4332C:		; CODE XREF: sub_430A4+237j
			; sub_430A4+280j
mov	ax, [word ptr bp+arg_0]
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax
mov	ax, 6901h
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_430A4



; Attributes: bp-based frame

proc sub_43349 far	; CODE XREF: sub_318CFJ
			; sub_3DB5F+9p
			; sub_3DBA6+F2p
			; sub_3E1DE+17p
push	bp
mov	bp, sp
push	si


mov	si, 25
jmp	short loc_43379	; Jump

loc_43352:		; CODE XREF: sub_43349+33j
call	_f020105_bios_timeofday	; Call Procedure


mov	ax, 255
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx


push	si
call	idk_VGA_PAL_s1C554 ; Call Procedure
pop	cx


mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx


add	si, 25		; Add

loc_43379:		; CODE XREF: sub_43349+7j
cmp	si, 101		; Compare Two Operands
jl	short loc_43352	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_43349



; Attributes: bp-based frame

proc sub_43381 far	; CODE XREF: sub_318DEJ
			; sub_3DBA6+3BDp
			; sub_3E1DE+40Fp
push	bp
mov	bp, sp
push	si
mov	si, 75
jmp	short loc_433B1	; Jump

loc_4338A:		; CODE XREF: sub_43381+32j
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, 255
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx
push	si
call	idk_VGA_PAL_s1C554 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
sub	si, 25		; Integer Subtraction

loc_433B1:		; CODE XREF: sub_43381+7j
or	si, si		; Logical Inclusive OR
jge	short loc_4338A	; Jump if Greater or Equal (SF=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_43381



; Attributes: bp-based frame

proc LBX_HelpEntry_s433B8 far
			; CODE XREF: j_LBX_HelpEntry_s433B8J
			; sub_3DBA6:loc_3DE9Cp
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 4
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 85B0h
push	ax		; int
mov	ax, 1Ah
push	ax		; int
mov	ax, offset aHlpentry_lbx_0 ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	ax, 4
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_HelpEntry_s433B8 ; sp-analysis	failed



; Attributes: bp-based frame

proc LBX_HelpEntry_s433EB far
			; CODE XREF: j_LBX_HelpEntry_s433EBJ
			; sub_3E1DE+307p
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 6
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 85B0h
push	ax		; int
mov	ax, 1Dh
push	ax		; int
mov	ax, offset aHlpentry_lbx_0 ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	ax, 6
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_HelpEntry_s433EB ; sp-analysis	failed



; Attributes: bp-based frame

proc LBX_HelpEntry_s4341E far
			; CODE XREF: j_LBX_HelpEntry_s4341EJ
			; sub_3F7D8+173p
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 1
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 85B0h
push	ax		; int
mov	ax, 1Eh
push	ax		; int

loc_43434:		; int
mov	ax, offset aHlpentry_lbx_0
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure

loc_4343D:		; Add
add	sp, 0Ch
mov	ax, 1
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_HelpEntry_s4341E ; sp-analysis	failed



; Attributes: bp-based frame

proc LBX_HelpEntry_s43451 far
			; CODE XREF: j_LBX_HelpEntry_s43451J
			; sub_3F3C6+13Ep
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 1
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 85B0h
push	ax		; int
mov	ax, 1Fh
push	ax		; int
mov	ax, offset aHlpentry_lbx_0 ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	ax, 1
push	ax
mov	ax, 85B0h
push	ax

loc_4347B:		; Call Procedure
call	idk_SetThreeFlagsOrValues_s25E72
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_HelpEntry_s43451 ; sp-analysis	failed



; Attributes: bp-based frame

proc LBX_HelpEntry_s43484 far
			; CODE XREF: j_LBX_HelpEntry_s43484J
			; sub_3EBA0+184p

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 0Fh
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 85B0h
push	ax		; int
mov	ax, 20h	; ' '
push	ax		; int
mov	ax, offset aHlpentry_lbx_0 ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
cmp	[bp+arg_0], 0	; Compare Two Operands
jz	short loc_434B2	; Jump if Zero (ZF=1)
mov	[word_3A34C], 2A1h

loc_434B2:		; CODE XREF: LBX_HelpEntry_s43484+26j
mov	ax, 0Fh
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_HelpEntry_s43484 ; sp-analysis	failed



; Attributes: bp-based frame

proc LBX_HelpEntry_s434C3 far
			; CODE XREF: j_LBX_HelpEntry_s434C3J
			; sub_4067D+378p
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 19h
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 85B0h
push	ax		; int
mov	ax, 21h	; '!'
push	ax		; int
mov	ax, offset aHlpentry_lbx_0 ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	ax, 19h
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_HelpEntry_s434C3 ; sp-analysis	failed



; Attributes: bp-based frame

proc LBX_HelpEntry_s434F6 far
			; CODE XREF: j_LBX_HelpEntry_s434F6J
			; sub_3FBE0+1B0p
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax		; int
mov	ax, 0Eh
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 85B0h
push	ax		; int
mov	ax, 23h	; '#'
push	ax		; int
mov	ax, offset aHlpentry_lbx_0 ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	ax, 0Eh
push	ax
mov	ax, 85B0h
push	ax
call	idk_SetThreeFlagsOrValues_s25E72 ; Call	Procedure
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
endp LBX_HelpEntry_s434F6 ; sp-analysis	failed



; Attributes: bp-based frame

; int __fastcall __far sub_43529(int, int, int,	int, int, char *dest)
proc sub_43529 far	; CODE XREF: sub_31870J
			; sub_4043A+89p

arg_0= word ptr	 6
arg_2= word ptr	 8
argDst=	dword ptr  0Ah

push	bp
mov	bp, sp
push	si
push	di		; argSrc
mov	si, [bp+arg_0]
mov	di, [word ptr bp+argDst]
mov	ax, [si]
inc	ax		; Increment by 1
mov	[si], ax
mov	ax, [si]
cmp	ax, [bp+arg_2]	; Compare Two Operands
jnz	short loc_43553	; Jump if Not Zero (ZF=0)
cmp	[word ptr si], 1 ; Compare Two Operands
jle	short loc_43551	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 332Dh
push	ax
push	di		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_43551:		; CODE XREF: sub_43529+1Aj
jmp	short loc_43564	; Jump

loc_43553:		; CODE XREF: sub_43529+15j
cmp	[word ptr si], 1 ; Compare Two Operands
jle	short loc_43564	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 321Ah
push	ax
push	di		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_43564:		; CODE XREF: sub_43529:loc_43551j
			; sub_43529+2Dj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_43529

; [00000005 BYTES: COLLAPSED FUNCTION filebuf::terminate(void).	PRESS KEYPAD "+" TO EXPAND]
; [00000005 BYTES: COLLAPSED FUNCTION filebuf::terminate(void).	PRESS KEYPAD "+" TO EXPAND]


; Attributes: bp-based frame

proc sub_43572 far	; CODE XREF: sub_31929J
push	bp
mov	bp, sp
call	sub_2E303	; Call Procedure
pop	bp
retf			; Return Far from Procedure
endp sub_43572

ends ovr050


; Segment type:	Pure code
segment	ovr051 para public 'OVERLAY' use16
assume cs:ovr051
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc idk_BuildingWorlds	far
			; CODE XREF: j_idk_BuildingWorldsJ
push	bp
mov	bp, sp
push	si

loc_43584:
push	di

loc_43585:
mov	ax, 52

loc_43588:
push	ax

loc_43589:
mov	ax, 36

loc_4358C:
push	ax

loc_4358D:		; Logical Exclusive OR
xor	ax, ax
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, offset strBUILDDAT ; "BUILDDAT"
push	ax
call	LBX_PreLoad_s15453 ; Call Procedure
add	sp, 0Ah		; Add
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_38422+2], dx
mov	[word ptr dword_38422],	ax
mov	ax, offset unk_35074
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	sub_1E525	; Call Procedure
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
push	[word_3AAE6]
mov	ax, 67
push	ax
mov	ax, 75
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 3
push	ax		; int
mov	ax, 3
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
mov	ax, offset aBuildingTheWorlds ;	"Building The Worlds..."
push	ax
mov	ax, 76
push	ax
mov	ax, 88
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
call	sub_2E257	; Call Procedure
call	sub_2E303	; Call Procedure
call	sub_1E525	; Call Procedure
call	sub_31BB0	; Call Procedure
mov	ax, 5
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_449D0 ; Call Procedure
pop	cx
mov	ax, 10
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_449D0 ; Call Procedure
pop	cx
mov	ax, 15
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_45389 ; Call Procedure
pop	cx
mov	ax, 20
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_45389 ; Call Procedure
pop	cx
mov	ax, 25
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_450F6 ; Call Procedure
pop	cx
mov	ax, 30
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_450F6 ; Call Procedure
pop	cx
mov	ax, 35
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_44CBB ; Call Procedure
pop	cx
mov	ax, 40
push	ax
nop			; No Operation
push	cs

loc_436A4:		; Call Procedure
call	near ptr sub_4CAF3
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_44CBB ; Call Procedure
pop	cx
mov	ax, 45
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
nop			; No Operation
push	cs
call	near ptr sub_45645 ; Call Procedure
mov	ax, 50
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_44A0E ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_44A0E ; Call Procedure
pop	cx
mov	ax, 55
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
nop			; No Operation
push	cs
call	near ptr sub_43C95 ; Call Procedure
mov	ax, 60
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_438C4 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_438C4 ; Call Procedure
pop	cx
nop			; No Operation
push	cs
call	near ptr sub_46406 ; Call Procedure
mov	ax, 65
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
mov	[word_3A4D8], 0
nop			; No Operation
push	cs
call	near ptr sub_43E4F ; Call Procedure
mov	ax, 70
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4A942 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4A942 ; Call Procedure
pop	cx
mov	ax, 75
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4BF93 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4BF93 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4BA53 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4BA53 ; Call Procedure
pop	cx
mov	ax, 80
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
nop			; No Operation
push	cs
call	near ptr LBX_Terrtype_s4763F ; Call Procedure
mov	ax, 85
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	di, di		; Logical Exclusive OR
jmp	short loc_437C0	; Jump

loc_4378E:		; CODE XREF: idk_BuildingWorlds+243j
xor	si, si		; Logical Exclusive OR
jmp	short loc_43793	; Jump

loc_43792:		; CODE XREF: idk_BuildingWorlds+224j
inc	si		; Increment by 1

loc_43793:		; CODE XREF: idk_BuildingWorlds+210j
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_48C63 ; Call Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_437A6	; Jump if Not Zero (ZF=0)

loc_437A0:		; Compare Two Operands
cmp	si, 2000
jl	short loc_43792	; Jump if Less (SF!=OF)

loc_437A6:		; CODE XREF: idk_BuildingWorlds+21Ej
xor	si, si		; Logical Exclusive OR
jmp	short loc_437AB	; Jump

loc_437AA:		; CODE XREF: idk_BuildingWorlds+23Dj
inc	si		; Increment by 1

loc_437AB:		; CODE XREF: idk_BuildingWorlds+228j
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_48C63 ; Call Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_437BF	; Jump if Not Zero (ZF=0)
cmp	si, 2000	; Compare Two Operands
jl	short loc_437AA	; Jump if Less (SF!=OF)

loc_437BF:		; CODE XREF: idk_BuildingWorlds+237j
inc	di		; Increment by 1

loc_437C0:		; CODE XREF: idk_BuildingWorlds+20Cj
cmp	di, 10		; Compare Two Operands
jl	short loc_4378E	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR

loc_437C7:
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4910F ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4910F ; Call Procedure
pop	cx
nop			; No Operation
push	cs
call	near ptr LBX_Terrtype_s472C7 ; Call Procedure
mov	ax, 85
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
nop			; No Operation
push	cs
call	near ptr LBX_Terrtype_s48821 ; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4C79C ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4C79C ; Call Procedure
pop	cx
mov	ax, 90
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4BF24 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4BF24 ; Call Procedure
pop	cx
mov	ax, 95
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAF3 ; Call Procedure
pop	cx
nop			; No Operation
push	cs
call	near ptr sub_4C4FA ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_4CE35 ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_43839 ; Call Procedure
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_BuildingWorlds



; Attributes: bp-based frame

proc sub_43839 far	; CODE XREF: sub_3195AJ
			; idk_BuildingWorlds+2B2p
push	bp
mov	bp, sp
push	si

loc_4383D:		; Logical Exclusive OR
xor	si, si
jmp	short loc_438BC	; Jump

loc_43841:		; CODE XREF: sub_43839:loc_438BFj
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+6]
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+6]
mov	cl, 4
shl	al, cl		; Shift	Logical	Left
pop	dx
add	dl, al		; Add
mov	ax, si
mov	bx, 18h
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], al
mov	ax, si

loc_43880:
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx

loc_43889:		; Add
add	bx, ax
mov	al, [es:bx+8]
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+8]
mov	cl, 4
shl	al, cl		; Shift	Logical	Left
pop	dx
add	dl, al		; Add
mov	ax, si
mov	bx, 18h
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+8], al
inc	si		; Increment by 1

loc_438BC:		; CODE XREF: sub_43839+6j
cmp	si, 66h	; 'f'   ; Compare Two Operands

loc_438BF:		; Jump if Less (SF!=OF)
jl	short loc_43841
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_43839



; Attributes: bp-based frame

proc sub_438C4 far	; CODE XREF: sub_3195FJ
			; idk_BuildingWorlds+17Cp
			; idk_BuildingWorlds+186p

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
push	si
push	di
mov	di, 1
jmp	loc_43C74	; Jump

loc_438D2:		; CODE XREF: sub_438C4+3B5j
mov	si, 1
jmp	loc_43C6B	; Jump

loc_438D8:		; CODE XREF: sub_438C4+3ACj
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	[bp+var_2], ax
mov	[bp+var_6], 0
mov	[bp+var_4], 0
jmp	short loc_4393A	; Jump

loc_43907:		; CODE XREF: sub_438C4+7Aj
mov	ax, [bp+var_4]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)

loc_43919:		; Compare Two Operands
cmp	ax, di
jnz	short loc_43937	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
cmp	ax, si		; Compare Two Operands
jnz	short loc_43937	; Jump if Not Zero (ZF=0)
mov	[bp+var_6], 1

loc_43937:		; CODE XREF: sub_438C4+57j
			; sub_438C4+6Cj
inc	[bp+var_4]	; Increment by 1

loc_4393A:		; CODE XREF: sub_438C4+41j
cmp	[bp+var_4], 6	; Compare Two Operands
jl	short loc_43907	; Jump if Less (SF!=OF)

loc_43940:		; Compare Two Operands
cmp	[bp+var_2], 0A8h ; ''

loc_43945:		; Jump if Zero (ZF=1)
jz	short loc_4395E
cmp	[bp+var_2], 0A9h ; '' ; Compare Two Operands
jz	short loc_4395E	; Jump if Zero (ZF=1)

loc_4394E:		; Compare Two Operands
cmp	[bp+var_2], 0AAh ; ''
jz	short loc_4395E	; Jump if Zero (ZF=1)
cmp	[bp+var_6], 1	; Compare Two Operands

loc_43959:		; Jump if Zero (ZF=1)
jz	short loc_4395E
jmp	loc_43C6A	; Jump

loc_4395E:		; CODE XREF: sub_438C4:loc_43945j
			; sub_438C4+88j
			; sub_438C4+8Fj
			; sub_438C4:loc_43959j
push	[bp+arg_0]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
push	si
nop			; No Operation
push	cs

loc_43968:		; Call Procedure
call	near ptr sub_4CF1C
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands

loc_43971:		; Jump if Zero (ZF=1)
jz	short loc_43976
jmp	loc_43C6A	; Jump

loc_43976:		; CODE XREF: sub_438C4:loc_43971j
push	[bp+arg_0]
push	di
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jz	short loc_4398E	; Jump if Zero (ZF=1)
jmp	loc_43C6A	; Jump

loc_4398E:		; CODE XREF: sub_438C4+C5j
push	[bp+arg_0]
push	di
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jz	short loc_439A6	; Jump if Zero (ZF=1)
jmp	loc_43C6A	; Jump

loc_439A6:		; CODE XREF: sub_438C4+DDj
push	[bp+arg_0]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jz	short loc_439BE	; Jump if Zero (ZF=1)
jmp	loc_43C6A	; Jump

loc_439BE:		; CODE XREF: sub_438C4+F5j
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jg	short loc_439D0	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_43C6A	; Jump

loc_439D0:		; CODE XREF: sub_438C4+107j
mov	ax, 8
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
inc	ax		; Increment by 1
mov	[bp+var_8], ax
mov	[bp+var_4], 0
jmp	loc_43C5F	; Jump

loc_439E6:		; CODE XREF: sub_438C4+3A3j
mov	ax, 3
push	ax

loc_439EA:		; Call Procedure
call	idk_Arg_0Fail_ElseMathyDiSi
pop	cx
add	ax, 0FFFEh	; Add
mov	[bp+var_A], ax
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 0FFFEh	; Add
mov	[bp+var_C], ax
cmp	[bp+var_A], 0	; Compare Two Operands
jnz	short loc_43A15	; Jump if Not Zero (ZF=0)
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_43A15	; Jump if Not Zero (ZF=0)
jmp	loc_43C5C	; Jump

loc_43A15:		; CODE XREF: sub_438C4+146j
			; sub_438C4+14Cj
mov	ax, di
add	ax, [bp+var_C]	; Add
push	ax
mov	ax, si
add	ax, [bp+var_A]	; Add
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CFE8 ; Call Procedure
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_43A2F	; Jump if Zero (ZF=1)
jmp	loc_43C5C	; Jump

loc_43A2F:		; CODE XREF: sub_438C4+166j
push	[bp+arg_0]
mov	ax, di
add	ax, [bp+var_C]	; Add
push	ax
mov	ax, si
add	ax, [bp+var_A]	; Add
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF8C ; Call Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR

loc_43A48:		; Jump if Zero (ZF=1)
jz	short loc_43A4D
jmp	loc_43C5C	; Jump

loc_43A4D:		; CODE XREF: sub_438C4:loc_43A48j
mov	ax, [bp+var_C]
mov	dx, 3
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]
add	dx, ax		; Add
inc	dx		; Increment by 1
mov	[bp+var_10], dx
mov	[bp+var_E], 0
mov	bx, [bp+var_10]
dec	bx		; Decrement by 1
cmp	bx, 8		; switch 9 cases
jbe	short loc_43A6F	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_43C17	; default

loc_43A6F:		; CODE XREF: sub_438C4+1A6j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_43C83+bx] ; switch jump

loc_43A76:		; DATA XREF: ovr051:off_43C83o
mov	ax, [bp+arg_0]	; case 0x0
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_C]	; Add
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_43ACA	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_C]	; Add
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jz	short loc_43AD1	; Jump if Zero (ZF=1)

loc_43ACA:		; CODE XREF: sub_438C4+1DAj
mov	[bp+var_E], 1
jmp	short loc_43AD6	; Jump

loc_43AD1:		; CODE XREF: sub_438C4+204j
mov	[bp+var_E], 0

loc_43AD6:		; CODE XREF: sub_438C4+20Bj
jmp	loc_43C17	; default

loc_43AD9:		; CODE XREF: sub_438C4+1ADj
			; sub_438C4:loc_43B44j
			; sub_438C4:loc_43B4Ej
			; sub_438C4:loc_43BB2j
			; DATA XREF: ovr051:off_43C83o
mov	[bp+var_E], 1	; case 0x1
jmp	loc_43C17	; default

loc_43AE1:		; CODE XREF: sub_438C4+1ADj
			; DATA XREF: ovr051:off_43C83o
mov	ax, [bp+arg_0]	; case 0x2
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_C]	; Add
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_43B35	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_C]	; Add
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jz	short loc_43B3C	; Jump if Zero (ZF=1)

loc_43B35:		; CODE XREF: sub_438C4+245j
mov	[bp+var_E], 1
jmp	short loc_43B41	; Jump

loc_43B3C:		; CODE XREF: sub_438C4+26Fj
mov	[bp+var_E], 0

loc_43B41:		; CODE XREF: sub_438C4+276j
jmp	loc_43C17	; default

loc_43B44:		; CODE XREF: sub_438C4+1ADj
			; DATA XREF: ovr051:off_43C83o
jmp	short loc_43AD9	; case 0x3

loc_43B46:		; CODE XREF: sub_438C4+1ADj
			; DATA XREF: ovr051:off_43C83o
mov	[bp+var_E], 0	; case 0x4
jmp	loc_43C17	; default

loc_43B4E:		; CODE XREF: sub_438C4+1ADj
			; DATA XREF: ovr051:off_43C83o
jmp	short loc_43AD9	; case 0x5

loc_43B50:		; CODE XREF: sub_438C4+1ADj
			; DATA XREF: ovr051:off_43C83o
mov	ax, [bp+arg_0]	; case 0x6
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx

loc_43B5C:		; Add
add	bx, ax
mov	ax, di
add	ax, [bp+var_C]	; Add
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_43BA4	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_C]	; Add
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jz	short loc_43BAB	; Jump if Zero (ZF=1)

loc_43BA4:		; CODE XREF: sub_438C4+2B4j
mov	[bp+var_E], 1

loc_43BA9:		; Jump
jmp	short loc_43BB0

loc_43BAB:		; CODE XREF: sub_438C4+2DEj
mov	[bp+var_E], 0

loc_43BB0:		; CODE XREF: sub_438C4:loc_43BA9j
jmp	short loc_43C17	; default

loc_43BB2:		; CODE XREF: sub_438C4+1ADj
			; DATA XREF: ovr051:off_43C83o
jmp	loc_43AD9	; case 0x7

loc_43BB5:		; CODE XREF: sub_438C4+1ADj
			; DATA XREF: ovr051:off_43C83o
mov	ax, [bp+arg_0]	; case 0x8
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_C]	; Add
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_43C09	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_C]	; Add
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jz	short loc_43C10	; Jump if Zero (ZF=1)

loc_43C09:		; CODE XREF: sub_438C4+319j
mov	[bp+var_E], 1
jmp	short loc_43C15	; Jump

loc_43C10:		; CODE XREF: sub_438C4+343j
mov	[bp+var_E], 0

loc_43C15:		; CODE XREF: sub_438C4+34Aj
jmp	short $+2	; Jump

loc_43C17:		; CODE XREF: sub_438C4+1A8j
			; sub_438C4:loc_43AD6j
			; sub_438C4+21Aj
			; sub_438C4:loc_43B41j
			; sub_438C4+287j
			; sub_438C4:loc_43BB0j
cmp	[bp+var_E], 1	; default
jnz	short loc_43C5C	; Jump if Not Zero (ZF=0)
mov	ax, di
add	ax, [bp+var_C]	; Add
push	ax
mov	ax, si
add	ax, [bp+var_A]	; Add
push	ax
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_46029 ; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_C]	; Add
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_A]	; Add
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''

loc_43C5C:		; CODE XREF: sub_438C4+14Ej
			; sub_438C4+168j
			; sub_438C4+186j
			; sub_438C4+357j
inc	[bp+var_4]	; Increment by 1

loc_43C5F:		; CODE XREF: sub_438C4+11Fj
mov	ax, [bp+var_4]
cmp	ax, [bp+var_8]	; Compare Two Operands
jge	short loc_43C6A	; Jump if Greater or Equal (SF=OF)
jmp	loc_439E6	; Jump

loc_43C6A:		; CODE XREF: sub_438C4+97j
			; sub_438C4+AFj
			; sub_438C4+C7j
			; sub_438C4+DFj
			; sub_438C4+F7j
			; sub_438C4+109j
			; sub_438C4+3A1j
inc	si		; Increment by 1

loc_43C6B:		; CODE XREF: sub_438C4+11j
cmp	si, 3Bh	; ';'   ; Compare Two Operands
jge	short loc_43C73	; Jump if Greater or Equal (SF=OF)
jmp	loc_438D8	; Jump

loc_43C73:		; CODE XREF: sub_438C4+3AAj
inc	di		; Increment by 1

loc_43C74:		; CODE XREF: sub_438C4+Bj
cmp	di, 27h	; '''   ; Compare Two Operands
jge	short loc_43C7C	; Jump if Greater or Equal (SF=OF)
jmp	loc_438D2	; Jump

loc_43C7C:		; CODE XREF: sub_438C4+3B3j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_438C4

db 0
off_43C83 dw offset loc_43A76
			; DATA XREF: sub_438C4+1ADr
dw offset loc_43AD9	; jump table for switch	statement
dw offset loc_43AE1
dw offset loc_43B44
dw offset loc_43B46
dw offset loc_43B4E
dw offset loc_43B50
dw offset loc_43BB2
dw offset loc_43BB5


; Attributes: bp-based frame

proc sub_43C95 far	; CODE XREF: sub_31964J
			; idk_BuildingWorlds+16Ap

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction
push	si
push	di
mov	[bp+var_6], 0Ah
xor	di, di		; Logical Exclusive OR
jmp	loc_43E41	; Jump

loc_43CA7:		; CODE XREF: sub_43C95+8Bj
			; sub_43C95+CBj
			; sub_43C95+113j
			; sub_43C95+1B1j
inc	[bp+var_8]	; Increment by 1
cmp	[bp+var_8], 1F4h ; Compare Two Operands
jle	short loc_43CB9	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_8], 1C2h
dec	[bp+var_6]	; Decrement by 1

loc_43CB9:		; CODE XREF: sub_43C95+1Aj
mov	ax, 36h	; '6'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_2], ax
mov	ax, 22h	; '"'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_43D22	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx+12C0h],	0 ; Compare Two	Operands

loc_43D0F:		; Jump if Not Zero (ZF=0)
jnz	short loc_43D22
mov	ax, 28h	; '('
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jle	short loc_43D22	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	short loc_43CA7	; Jump

loc_43D22:		; CODE XREF: sub_43C95+5Dj
			; sub_43C95:loc_43D0Fj
			; sub_43C95+89j
xor	si, si		; Logical Exclusive OR
jmp	short loc_43D64	; Jump

loc_43D26:		; CODE XREF: sub_43C95+D1j
mov	ax, 3Ch	; '<'
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax

loc_43D4D:
push	[bp+var_4]

loc_43D50:
push	[bp+var_2]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
cmp	ax, [bp+var_6]	; Compare Two Operands
jge	short loc_43D63	; Jump if Greater or Equal (SF=OF)
jmp	loc_43CA7	; Jump

loc_43D63:		; CODE XREF: sub_43C95+C9j
inc	si		; Increment by 1

loc_43D64:		; CODE XREF: sub_43C95+8Fj
cmp	si, di		; Compare Two Operands
jl	short loc_43D26	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_43DAC	; Jump

loc_43D6C:		; CODE XREF: sub_43C95+11Aj
mov	ax, 3Ch	; '<'
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_43D7D:
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_4]
push	[bp+var_2]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
cmp	ax, 4		; Compare Two Operands
jge	short loc_43DAB	; Jump if Greater or Equal (SF=OF)
jmp	loc_43CA7	; Jump

loc_43DAB:		; CODE XREF: sub_43C95+111j
inc	si		; Increment by 1

loc_43DAC:		; CODE XREF: sub_43C95+D5j
cmp	si, 1Eh		; Compare Two Operands
jl	short loc_43D6C	; Jump if Less (SF!=OF)
mov	ax, di
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_2]
mov	[es:bx], al
mov	ax, di
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx

loc_43DCD:		; Add
add	bx, ax
mov	al, [byte ptr bp+var_4]
mov	[es:bx+1], al
mov	ax, di
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_43DE2:
mov	[byte ptr es:bx+2], 0FFh
push	[bp+var_4]
push	[bp+var_2]
xor	ax, ax		; Logical Exclusive OR
push	ax
nop			; No Operation
push	cs
call	near ptr sub_46029 ; Call Procedure
add	sp, 6		; Add
push	[bp+var_4]
push	[bp+var_2]
mov	ax, 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_46029 ; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+var_4]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
mov	ax, [bp+var_4]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx+12C0h],	0A2h ; ''
inc	di		; Increment by 1

loc_43E41:		; CODE XREF: sub_43C95+Fj
cmp	di, 6		; Compare Two Operands
jge	short loc_43E49	; Jump if Greater or Equal (SF=OF)
jmp	loc_43CA7	; Jump

loc_43E49:		; CODE XREF: sub_43C95+1AFj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_43C95



; Attributes: bp-based frame

proc sub_43E4F far	; CODE XREF: sub_31969J
			; idk_BuildingWorlds+1A1p

var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si
push	di
mov	[bp+var_14], 10h
mov	[bp+var_16], 8

loc_43E61:		; CODE XREF: sub_43E4F+2F4j
dec	[bp+var_14]	; Decrement by 1
dec	[bp+var_16]	; Decrement by 1
cmp	[bp+var_16], 1	; Compare Two Operands
jge	short loc_43E72	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_16], 1

loc_43E72:		; CODE XREF: sub_43E4F+1Cj
cmp	[bp+var_14], 0Ah ; Compare Two Operands
jge	short loc_43E7D	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_14], 0Ah

loc_43E7D:		; CODE XREF: sub_43E4F+27j
mov	[bp+var_E], 0

loc_43E82:
mov	[bp+var_6], 0
mov	[bp+var_4], 0
mov	[bp+var_18], 0

loc_43E91:		; CODE XREF: sub_43E4F+279j
mov	[bp+var_2], 0
jmp	loc_4412C	; Jump

loc_43E99:		; CODE XREF: sub_43E4F+247j
			; sub_43E4F:loc_440CDj
			; sub_43E4F+2EAj
			; sub_43E4F+550j
inc	[bp+var_E]	; Increment by 1
mov	[bp+var_8], 0
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Dh], 0 ; Compare Two Operands
jz	short loc_43EB7	; Jump if Zero (ZF=1)
mov	[bp+var_8], 1

loc_43EB7:		; CODE XREF: sub_43E4F+61j
mov	ax, 36h	; '6'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_A], ax
mov	ax, 22h	; '"'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_C], ax
mov	[bp+var_10], 0
mov	ax, [bp+var_8]

loc_43EDF:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_C]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_A]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_43F06	; Jump if Not Zero (ZF=0)
mov	[bp+var_10], 1

loc_43F06:		; CODE XREF: sub_43E4F+B0j
xor	si, si		; Logical Exclusive OR
jmp	short loc_43F60	; Jump

loc_43F0A:		; CODE XREF: sub_43E4F+114j
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+var_8]	; Compare Two Operands
jnz	short loc_43F5F	; Jump if Not Zero (ZF=0)
mov	ax, 3Ch	; '<'
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_C]
push	[bp+var_A]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
cmp	ax, [bp+var_14]	; Compare Two Operands
jge	short loc_43F5F	; Jump if Greater or Equal (SF=OF)

loc_43F5A:
mov	[bp+var_10], 1

loc_43F5F:		; CODE XREF: sub_43E4F+CFj
			; sub_43E4F+109j
inc	si		; Increment by 1

loc_43F60:		; CODE XREF: sub_43E4F+B9j
cmp	si, [bp+var_2]	; Compare Two Operands
jl	short loc_43F0A	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_43FCB	; Jump

loc_43F69:		; CODE XREF: sub_43E4F+17Fj
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+var_8]	; Compare Two Operands
jnz	short loc_43FCA	; Jump if Not Zero (ZF=0)
mov	ax, 3Ch	; '<'
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx

loc_43F8F:		; Add
add	bx, ax
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_C]
push	[bp+var_A]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
push	ax
mov	ax, [bp+var_16]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
pop	dx
cmp	dx, ax		; Compare Two Operands
jge	short loc_43FCA	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_10], 1

loc_43FCA:		; CODE XREF: sub_43E4F+12Fj
			; sub_43E4F+174j
inc	si		; Increment by 1

loc_43FCB:		; CODE XREF: sub_43E4F+118j
cmp	si, 1Eh		; Compare Two Operands
jl	short loc_43F69	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_44019	; Jump

loc_43FD4:		; CODE XREF: sub_43E4F+1CDj
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left

loc_43FDA:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6EA]

loc_43FDE:		; Add
add	bx, ax
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_C]
push	[bp+var_A]
call	sub_1D6D9	; Call Procedure
add	sp, 8		; Add
push	ax
mov	ax, [bp+var_16]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction

loc_4400C:		; Shift	Arithmetic Right
sar	ax, 1
pop	dx
cmp	dx, ax		; Compare Two Operands
jge	short loc_44018	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_10], 1

loc_44018:		; CODE XREF: sub_43E4F+1C2j
inc	si		; Increment by 1

loc_44019:		; CODE XREF: sub_43E4F+183j
cmp	si, 6		; Compare Two Operands
jl	short loc_43FD4	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_44084	; Jump

loc_44022:		; CODE XREF: sub_43E4F+238j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+var_8]	; Compare Two Operands
jnz	short loc_44083	; Jump if Not Zero (ZF=0)
mov	ax, 3Ch	; '<'
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_C]
push	[bp+var_A]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
push	ax
mov	ax, [bp+var_16]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
pop	dx
cmp	dx, ax		; Compare Two Operands
jge	short loc_44083	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_10], 1

loc_44083:		; CODE XREF: sub_43E4F+1E8j
			; sub_43E4F+22Dj
inc	si		; Increment by 1

loc_44084:		; CODE XREF: sub_43E4F+1D1j
cmp	si, 66h	; 'f'   ; Compare Two Operands
jl	short loc_44022	; Jump if Less (SF!=OF)
cmp	[bp+var_E], 3E8h ; Compare Two Operands
jge	short loc_44099	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_10], 1	; Compare Two Operands
jnz	short loc_44099	; Jump if Not Zero (ZF=0)
jmp	loc_43E99	; Jump

loc_44099:		; CODE XREF: sub_43E4F+23Fj
			; sub_43E4F+245j
push	[bp+var_8]
push	[bp+var_C]
push	[bp+var_A]
nop			; No Operation
push	cs
call	near ptr sub_4D448 ; Call Procedure
add	sp, 6		; Add
push	ax
mov	ax, [bp+var_2]
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 8
sub	dx, ax		; Integer Subtraction
pop	ax
cmp	ax, dx		; Compare Two Operands
jge	short loc_440D0	; Jump if Greater or Equal (SF=OF)
inc	[bp+var_18]	; Increment by 1
cmp	[bp+var_18], 1F4h ; Compare Two	Operands
jle	short loc_440CD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_43E91	; Jump
jmp	short loc_440D0	; Jump

loc_440CD:		; CODE XREF: sub_43E4F+277j
jmp	loc_43E99	; Jump

loc_440D0:		; CODE XREF: sub_43E4F+26Dj
			; sub_43E4F+27Cj
mov	ax, [bp+var_2]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_A]
mov	[es:bx], al
mov	ax, [bp+var_2]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_C]
mov	[es:bx+1], al
mov	ax, [bp+var_2]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_8]
mov	[es:bx+2], al
mov	ax, [bp+var_2]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+3], 1
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_6]	; Load Effective Address
add	bx, ax		; Add
inc	[word ptr bx]	; Increment by 1
inc	[bp+var_2]	; Increment by 1

loc_4412C:		; CODE XREF: sub_43E4F+47j
cmp	[bp+var_2], 6	; Compare Two Operands
jge	short loc_4413C	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_E], 3E8h ; Compare Two Operands
jge	short loc_4413C	; Jump if Greater or Equal (SF=OF)
jmp	loc_43E99	; Jump

loc_4413C:		; CODE XREF: sub_43E4F+2E1j
			; sub_43E4F+2E8j
cmp	[bp+var_E], 3E8h ; Compare Two Operands
jl	short loc_44146	; Jump if Less (SF!=OF)
jmp	loc_43E61	; Jump

loc_44146:		; CODE XREF: sub_43E4F+2F2j
mov	[word_3A4DA], 0
mov	[bp+var_12], 0
jmp	loc_44758	; Jump

loc_44154:		; CODE XREF: sub_43E4F+912j
cmp	[bp+var_12], 0	; Compare Two Operands
jnz	short loc_44172	; Jump if Not Zero (ZF=0)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr word_3ABB4]
mov	[es:bx+0Eh], al
jmp	loc_443A2	; Jump

loc_44172:		; CODE XREF: sub_43E4F+309j
mov	ax, [bp+var_12]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Dh], 0 ; Compare Two Operands
jnz	short loc_44186	; Jump if Not Zero (ZF=0)
jmp	loc_4420B	; Jump

loc_44186:		; CODE XREF: sub_43E4F+332j
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 4		; switch 5 cases
ja	short loc_44208	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_449C6+bx] ; switch jump

loc_4419F:		; DATA XREF: ovr051:off_449C6o
mov	ax, [word_3A4DA] ; case	0x0
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 1
jmp	short loc_44208	; default

loc_441B4:		; CODE XREF: sub_43E4F+34Bj
			; DATA XREF: ovr051:off_449C6o
mov	ax, [word_3A4DA] ; case	0x1
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 2
jmp	short loc_44208	; default

loc_441C9:		; CODE XREF: sub_43E4F+34Bj
			; DATA XREF: ovr051:off_449C6o
mov	ax, [word_3A4DA] ; case	0x2
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 3
jmp	short loc_44208	; default

loc_441DE:		; CODE XREF: sub_43E4F+34Bj
			; DATA XREF: ovr051:off_449C6o
mov	ax, [word_3A4DA] ; case	0x3
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 4
jmp	short loc_44208	; default

loc_441F3:		; CODE XREF: sub_43E4F+34Bj
			; DATA XREF: ovr051:off_449C6o
mov	ax, [word_3A4DA] ; case	0x4
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0Dh
jmp	short $+2	; Jump

loc_44208:		; CODE XREF: sub_43E4F+347j
			; sub_43E4F+363j
			; sub_43E4F+378j
			; sub_43E4F+38Dj
			; sub_43E4F+3A2j
jmp	loc_44375	; default

loc_4420B:		; CODE XREF: sub_43E4F+334j
cmp	[word_3A4DC], 2	; Compare Two Operands
jg	short loc_44215	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4429A	; Jump

loc_44215:		; CODE XREF: sub_43E4F+3C1j
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 4		; switch 5 cases
ja	short loc_44297	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_449BC+bx] ; switch jump

loc_4422E:		; DATA XREF: ovr051:off_449BCo
mov	ax, [word_3A4DA] ; case	0x0
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 9
jmp	short loc_44297	; default

loc_44243:		; CODE XREF: sub_43E4F+3DAj
			; DATA XREF: ovr051:off_449BCo
mov	ax, [word_3A4DA] ; case	0x1
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 7
jmp	short loc_44297	; default

loc_44258:		; CODE XREF: sub_43E4F+3DAj
			; DATA XREF: ovr051:off_449BCo
mov	ax, [word_3A4DA] ; case	0x2
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 6
jmp	short loc_44297	; default

loc_4426D:		; CODE XREF: sub_43E4F+3DAj
			; DATA XREF: ovr051:off_449BCo
mov	ax, [word_3A4DA] ; case	0x3
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 8
jmp	short loc_44297	; default

loc_44282:		; CODE XREF: sub_43E4F+3DAj
			; DATA XREF: ovr051:off_449BCo
mov	ax, [word_3A4DA] ; case	0x4
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0Bh
jmp	short $+2	; Jump

loc_44297:		; CODE XREF: sub_43E4F+3D6j
			; sub_43E4F+3F2j
			; sub_43E4F+407j
			; sub_43E4F+41Cj
			; sub_43E4F+431j
jmp	loc_44375	; default

loc_4429A:		; CODE XREF: sub_43E4F+3C3j
mov	ax, 9
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 8		; switch 9 cases
jbe	short loc_442AF	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_44375	; default

loc_442AF:		; CODE XREF: sub_43E4F+45Bj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_449AA+bx] ; switch jump

loc_442B6:		; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x0
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0
jmp	loc_44375	; default

loc_442CC:		; CODE XREF: sub_43E4F+462j
			; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x1
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_442DA:
mov	[byte ptr es:bx+0Eh], 5
jmp	loc_44375	; default

loc_442E2:		; CODE XREF: sub_43E4F+462j
			; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x2
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 6
jmp	short loc_44375	; default

loc_442F7:		; CODE XREF: sub_43E4F+462j
			; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x3
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 7
jmp	short loc_44375	; default

loc_4430C:		; CODE XREF: sub_43E4F+462j
			; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x4
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 8
jmp	short loc_44375	; default

loc_44321:		; CODE XREF: sub_43E4F+462j
			; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x5
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4432F:
mov	[byte ptr es:bx+0Eh], 9
jmp	short loc_44375	; default

loc_44336:		; CODE XREF: sub_43E4F+462j
			; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x6
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0Ah
jmp	short loc_44375	; default

loc_4434B:		; CODE XREF: sub_43E4F+462j
			; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x7
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0Bh
jmp	short loc_44375	; default

loc_44360:		; CODE XREF: sub_43E4F+462j
			; DATA XREF: ovr051:off_449AAo
mov	ax, [word_3A4DA] ; case	0x8
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0Ch
jmp	short $+2	; Jump

loc_44375:		; CODE XREF: sub_43E4F:loc_44208j
			; sub_43E4F:loc_44297j
			; sub_43E4F+45Dj
			; sub_43E4F+47Aj
			; sub_43E4F+490j
			; sub_43E4F+4A6j
			; sub_43E4F+4BBj
			; sub_43E4F+4D0j
			; sub_43E4F+4E5j
			; sub_43E4F+4FAj
			; sub_43E4F+50Fj
mov	ax, [word_3A4DA] ; default
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+0Eh], 7	; Compare Two Operands

loc_44388:		; Jump if Not Zero (ZF=0)
jnz	short loc_443A2

loc_4438A:
push	[bp+var_8]
push	[bp+var_C]
push	[bp+var_A]
nop			; No Operation
push	cs
call	near ptr sub_4D02B ; Call Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_443A2	; Jump if Not Zero (ZF=0)
jmp	loc_43E99	; Jump

loc_443A2:		; CODE XREF: sub_43E4F+320j
			; sub_43E4F:loc_44388j
			; sub_43E4F+54Ej
mov	ax, [bp+var_12]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+0Fh], al
mov	ax, [bp+var_12]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+10h], al
mov	ax, [bp+var_12]
mov	cl, 2		; int
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+11h], al
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_12]
mov	[es:bx+12h], al
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+13h], 1
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+14h], 4
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+1Eh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+5Eh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+18h], 0

loc_44486:		; Compare Two Operands
cmp	[bp+var_12], 0
jnz	short loc_444A2	; Jump if Not Zero (ZF=0)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+1Ch], 2
jmp	short loc_444B6	; Jump

loc_444A2:		; CODE XREF: sub_43E4F+63Bj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+1Ch], 0FFFCh

loc_444B6:		; CODE XREF: sub_43E4F+651j
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+43h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+5Ah], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+44h], 0

loc_444EF:
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+45h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+46h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+47h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+48h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+49h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+5Bh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Ah], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx

loc_44580:		; Add
add	bx, ax
mov	[byte ptr es:bx+4Bh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+50h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Eh], 0

loc_445AD:
mov	ax, [word_3A4DA]

loc_445B0:
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Fh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Dh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Ch], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+51h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+52h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+53h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+54h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_44640:
mov	[byte ptr es:bx+55h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+56h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+57h], 0
mov	ax, [word_3A4DA]

loc_4466E:
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+58h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+59h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+5Ch], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+15h], 3
xor	si, si		; Logical Exclusive OR
jmp	short loc_446D1	; Jump

loc_446BB:		; CODE XREF: sub_43E4F+885j
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx+1Fh], 0FFh
inc	si		; Increment by 1

loc_446D1:		; CODE XREF: sub_43E4F+86Aj
cmp	si, 24h	; '$'   ; Compare Two Operands
jl	short loc_446BB	; Jump if Less (SF!=OF)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+1Fh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+27h], 1
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+22h], 1
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+3Fh], 1
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6E2]
add	dx, ax		; Add
push	[word ptr dword_3A6E2+2] ; int
push	dx		; int
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'   ; int
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
cbw			; int
push	ax		; int
nop			; No Operation
push	cs
call	near ptr LBX_Cityname_s4B973 ; Call Procedure
add	sp, 6		; Add
inc	[word_3A4DA]	; Increment by 1
inc	[bp+var_12]	; Increment by 1

loc_44758:		; CODE XREF: sub_43E4F+302j
mov	ax, [bp+var_12]
cmp	ax, [word_3A4E2] ; Compare Two Operands

loc_4475F:		; Jump if Greater or Equal (SF=OF)
jge	short loc_44764
jmp	loc_44154	; Jump

loc_44764:		; CODE XREF: sub_43E4F:loc_4475Fj
mov	[bp+var_12], 0
jmp	loc_44836	; Jump

loc_4476C:		; CODE XREF: sub_43E4F:loc_4483Fj
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
cbw			; AL ->	AX (with sign)
mov	bx, ax
cmp	bx, 0Dh		; switch 14 cases
ja	short loc_447D3	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4498E+bx] ; switch jump

loc_4478D:		; DATA XREF: ovr051:off_4498Eo
mov	di, 27h	; '''   ; case 0x0
jmp	short loc_447D3	; default

loc_44792:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 2Eh	; '.'   ; case 0x1
jmp	short loc_447D3	; default

loc_44797:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 39h	; '9'   ; case 0x2
jmp	short loc_447D3	; default

loc_4479C:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 42h	; 'B'   ; case 0x3
jmp	short loc_447D3	; default

loc_447A1:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 4Ch	; 'L'   ; case 0x4
jmp	short loc_447D3	; default

loc_447A6:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 53h	; 'S'   ; case 0x5
jmp	short loc_447D3	; default

loc_447AB:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 59h	; 'Y'   ; case 0x6
jmp	short loc_447D3	; default

loc_447B0:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 5Fh	; '_'   ; case 0x7
jmp	short loc_447D3	; default

loc_447B5:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 68h	; 'h'   ; case 0x8
jmp	short loc_447D3	; default

loc_447BA:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 72h	; 'r'   ; case 0x9

loc_447BD:		; default
jmp	short loc_447D3

loc_447BF:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 78h	; 'x'   ; case 0xA
jmp	short loc_447D3	; default

loc_447C4:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 7Fh	; ''   ; case 0xB
jmp	short loc_447D3	; default

loc_447C9:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 89h	; ''   ; case 0xC
jmp	short loc_447D3	; default

loc_447CE:		; CODE XREF: sub_43E4F+939j
			; DATA XREF: ovr051:off_4498Eo
mov	di, 93h	; ''   ; case 0xD
jmp	short $+2	; Jump

loc_447D3:		; CODE XREF: sub_43E4F+935j
			; sub_43E4F+941j
			; sub_43E4F+946j
			; sub_43E4F+94Bj
			; sub_43E4F+950j
			; sub_43E4F+955j
			; sub_43E4F+95Aj
			; sub_43E4F+95Fj
			; sub_43E4F+964j
			; sub_43E4F+969j
			; sub_43E4F:loc_447BDj
			; sub_43E4F+973j
			; sub_43E4F+978j
			; sub_43E4F+97Dj
mov	ax, [bp+var_12]	; default
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx

loc_447DF:		; Add
add	bx, ax
cmp	[byte ptr es:bx+0Eh], 4	; Compare Two Operands
jz	short loc_44833	; Jump if Zero (ZF=1)
push	[bp+var_12]
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_12]
push	di
nop			; No Operation
push	cs
call	near ptr sub_4CB55 ; Call Procedure
add	sp, 0Ch		; Add

loc_44833:		; CODE XREF: sub_43E4F+997j
inc	[bp+var_12]	; Increment by 1

loc_44836:		; CODE XREF: sub_43E4F+91Aj
mov	ax, [bp+var_12]
cmp	ax, [word_3A4E2] ; Compare Two Operands
jge	short loc_44842	; Jump if Greater or Equal (SF=OF)

loc_4483F:		; Jump
jmp	loc_4476C

loc_44842:		; CODE XREF: sub_43E4F+9EEj
mov	[bp+var_12], 0
jmp	loc_4495F	; Jump

loc_4484A:		; CODE XREF: sub_43E4F+B19j
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
cbw			; AL ->	AX (with sign)
mov	bx, ax
cmp	bx, 0Dh		; switch 14 cases
ja	short loc_448B1	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_44972+bx] ; switch jump

loc_4486B:		; DATA XREF: ovr051:off_44972o
mov	di, 28h	; '('   ; case 0x0
jmp	short loc_448B1	; default

loc_44870:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 2Fh	; '/'   ; case 0x1
jmp	short loc_448B1	; default

loc_44875:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 3Ah	; ':'   ; case 0x2
jmp	short loc_448B1	; default

loc_4487A:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 43h	; 'C'   ; case 0x3
jmp	short loc_448B1	; default

loc_4487F:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 4Ch	; 'L'   ; case 0x4
jmp	short loc_448B1	; default

loc_44884:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 54h	; 'T'   ; case 0x5
jmp	short loc_448B1	; default

loc_44889:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 5Ah	; 'Z'   ; case 0x6
jmp	short loc_448B1	; default

loc_4488E:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 60h	; '`'   ; case 0x7
jmp	short loc_448B1	; default

loc_44893:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 69h	; 'i'   ; case 0x8
jmp	short loc_448B1	; default

loc_44898:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 73h	; 's'   ; case 0x9
jmp	short loc_448B1	; default

loc_4489D:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 79h	; 'y'   ; case 0xA
jmp	short loc_448B1	; default

loc_448A2:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 80h	; ''   ; case 0xB
jmp	short loc_448B1	; default

loc_448A7:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 8Ah	; ''   ; case 0xC
jmp	short loc_448B1	; default

loc_448AC:		; CODE XREF: sub_43E4F+A17j
			; DATA XREF: ovr051:off_44972o
mov	di, 94h	; ''   ; case 0xD
jmp	short $+2	; Jump

loc_448B1:		; CODE XREF: sub_43E4F+A13j
			; sub_43E4F+A1Fj
			; sub_43E4F+A24j
			; sub_43E4F+A29j
			; sub_43E4F+A2Ej
			; sub_43E4F+A33j
			; sub_43E4F+A38j
			; sub_43E4F+A3Dj
			; sub_43E4F+A42j
			; sub_43E4F+A47j
			; sub_43E4F+A4Cj
			; sub_43E4F+A51j
			; sub_43E4F+A56j
			; sub_43E4F+A5Bj
mov	ax, [bp+var_12]	; default
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+0Eh], 4	; Compare Two Operands
jnz	short loc_44911	; Jump if Not Zero (ZF=0)
push	[bp+var_12]
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_12]
push	di
nop			; No Operation
push	cs
call	near ptr sub_4CB55 ; Call Procedure
add	sp, 0Ch		; Add

loc_44911:		; CODE XREF: sub_43E4F+A75j
push	[bp+var_12]
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_12]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_12]
push	di
nop			; No Operation
push	cs
call	near ptr sub_4CB55 ; Call Procedure
add	sp, 0Ch		; Add
inc	[bp+var_12]	; Increment by 1

loc_4495F:		; CODE XREF: sub_43E4F+9F8j
mov	ax, [bp+var_12]
cmp	ax, [word_3A4E2] ; Compare Two Operands
jge	short loc_4496B	; Jump if Greater or Equal (SF=OF)
jmp	loc_4484A	; Jump

loc_4496B:		; CODE XREF: sub_43E4F+B17j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_43E4F ; sp-analysis failed

align 2
off_44972 dw offset loc_4486B
			; DATA XREF: sub_43E4F+A17r
dw offset loc_44870	; jump table for switch	statement
dw offset loc_44875
dw offset loc_4487A
dw offset loc_4487F
dw offset loc_44884
dw offset loc_44889
dw offset loc_4488E
dw offset loc_44893
dw offset loc_44898
dw offset loc_4489D
dw offset loc_448A2
dw offset loc_448A7
dw offset loc_448AC
off_4498E dw offset loc_4478D
			; DATA XREF: sub_43E4F+939r
dw offset loc_44792	; jump table for switch	statement
dw offset loc_44797
dw offset loc_4479C
dw offset loc_447A1
dw offset loc_447A6
dw offset loc_447AB
dw offset loc_447B0
dw offset loc_447B5
dw offset loc_447BA
dw offset loc_447BF
dw offset loc_447C4
dw offset loc_447C9
dw offset loc_447CE
off_449AA dw offset loc_442B6
			; DATA XREF: sub_43E4F+462r
dw offset loc_442CC	; jump table for switch	statement
dw offset loc_442E2
dw offset loc_442F7
dw offset loc_4430C
dw offset loc_44321
dw offset loc_44336
dw offset loc_4434B
dw offset loc_44360
off_449BC dw offset loc_4422E
			; DATA XREF: sub_43E4F+3DAr
dw offset loc_44243	; jump table for switch	statement
dw offset loc_44258
dw offset loc_4426D
dw offset loc_44282
off_449C6 dw offset loc_4419F
			; DATA XREF: sub_43E4F+34Br
dw offset loc_441B4	; jump table for switch	statement
dw offset loc_441C9
dw offset loc_441DE
dw offset loc_441F3


; Attributes: bp-based frame

proc sub_449D0 far	; CODE XREF: sub_3196EJ
			; idk_BuildingWorlds+A5p
			; idk_BuildingWorlds+B9p

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
mov	[word_3AD50], 1
xor	si, si		; Logical Exclusive OR
jmp	short loc_44A06	; Jump

loc_449DE:		; CODE XREF: sub_449D0+39j
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_44A00	; Jump

loc_449E2:		; CODE XREF: sub_449D0+33j
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, cx		; Add
mov	[byte ptr es:bx], 0
inc	cx		; Increment by 1

loc_44A00:		; CODE XREF: sub_449D0+10j
cmp	cx, 3Ch	; '<'   ; Compare Two Operands
jl	short loc_449E2	; Jump if Less (SF!=OF)
inc	si		; Increment by 1

loc_44A06:		; CODE XREF: sub_449D0+Cj
cmp	si, 28h	; '('   ; Compare Two Operands
jl	short loc_449DE	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_449D0



; Attributes: bp-based frame

proc sub_44A0E far	; CODE XREF: sub_31973J
			; idk_BuildingWorlds+150p
			; idk_BuildingWorlds+15Ap

var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 0Eh		; Integer Subtraction
push	si
push	di
mov	[bp+var_2], 0
mov	[bp+var_4], 0
mov	[bp+var_6], 0
mov	[bp+var_8], 0
jmp	short loc_44A79	; Jump

loc_44A2C:		; CODE XREF: sub_44A0E+6Fj
mov	ax, [bp+var_8]
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jnz	short loc_44A76	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_8]
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2Dh]
cbw			; AL ->	AX (with sign)
or	ax, ax		; Logical Inclusive OR
jz	short loc_44A67	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_44A6C	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_44A71	; Jump if Zero (ZF=1)
jmp	short loc_44A76	; Jump

loc_44A67:		; CODE XREF: sub_44A0E+4Bj
inc	[bp+var_4]	; Increment by 1
jmp	short loc_44A76	; Jump

loc_44A6C:		; CODE XREF: sub_44A0E+50j
inc	[bp+var_6]	; Increment by 1
jmp	short loc_44A76	; Jump

loc_44A71:		; CODE XREF: sub_44A0E+55j
inc	[bp+var_2]	; Increment by 1
jmp	short $+2	; Jump

loc_44A76:		; CODE XREF: sub_44A0E+34j
			; sub_44A0E+57j
			; sub_44A0E+5Cj
			; sub_44A0E+61j
inc	[bp+var_8]	; Increment by 1

loc_44A79:		; CODE XREF: sub_44A0E+1Cj
cmp	[bp+var_8], 1Eh	; Compare Two Operands
jl	short loc_44A2C	; Jump if Less (SF!=OF)
mov	[bp+var_A], 0
mov	[bp+var_C], 0
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_44ACF	; Jump if Not Zero (ZF=0)
cmp	[bp+var_4], 9	; Compare Two Operands
jle	short loc_44AA0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
add	ax, 0FFF7h	; Add
mov	[bp+var_E], ax
jmp	short loc_44AA5	; Jump

loc_44AA0:		; CODE XREF: sub_44A0E+85j
mov	[bp+var_E], 0

loc_44AA5:		; CODE XREF: sub_44A0E+90j
jmp	short loc_44AAD	; Jump

loc_44AA7:		; CODE XREF: sub_44A0E:loc_44AB7j
inc	[bp+var_2]	; Increment by 1

loc_44AAA:		; Increment by 1
inc	[bp+var_A]

loc_44AAD:		; CODE XREF: sub_44A0E:loc_44AA5j
cmp	[bp+var_2], 6	; Compare Two Operands
jge	short loc_44AB9	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_E], 0	; Compare Two Operands

loc_44AB7:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_44AA7

loc_44AB9:		; CODE XREF: sub_44A0E+A3j
jmp	short loc_44AC1	; Jump

loc_44ABB:		; CODE XREF: sub_44A0E+BDj
inc	[bp+var_6]	; Increment by 1
inc	[bp+var_C]	; Increment by 1

loc_44AC1:		; CODE XREF: sub_44A0E:loc_44AB9j
cmp	[bp+var_6], 6	; Compare Two Operands
jge	short loc_44ACD	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_E], 0	; Compare Two Operands
jg	short loc_44ABB	; Jump if Greater (ZF=0	& SF=OF)

loc_44ACD:		; CODE XREF: sub_44A0E+B7j
jmp	short loc_44B0D	; Jump

loc_44ACF:		; CODE XREF: sub_44A0E+7Fj
cmp	[bp+var_4], 4	; Compare Two Operands

loc_44AD3:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_44AE0
mov	ax, [bp+var_4]
add	ax, 0FFFCh	; Add
mov	[bp+var_E], ax
jmp	short loc_44AE5	; Jump

loc_44AE0:		; CODE XREF: sub_44A0E:loc_44AD3j
mov	[bp+var_E], 0

loc_44AE5:		; CODE XREF: sub_44A0E+D0j
jmp	short loc_44AED	; Jump

loc_44AE7:		; CODE XREF: sub_44A0E+E9j
inc	[bp+var_2]	; Increment by 1
inc	[bp+var_A]	; Increment by 1

loc_44AED:		; CODE XREF: sub_44A0E:loc_44AE5j
cmp	[bp+var_2], 3	; Compare Two Operands
jge	short loc_44AF9	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_E], 0	; Compare Two Operands
jg	short loc_44AE7	; Jump if Greater (ZF=0	& SF=OF)

loc_44AF9:		; CODE XREF: sub_44A0E+E3j
jmp	short loc_44B01	; Jump

loc_44AFB:		; CODE XREF: sub_44A0E+FDj
inc	[bp+var_6]	; Increment by 1
inc	[bp+var_C]	; Increment by 1

loc_44B01:		; CODE XREF: sub_44A0E:loc_44AF9j
cmp	[bp+var_6], 3	; Compare Two Operands
jge	short loc_44B0D	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_E], 0	; Compare Two Operands
jg	short loc_44AFB	; Jump if Greater (ZF=0	& SF=OF)

loc_44B0D:		; CODE XREF: sub_44A0E:loc_44ACDj
			; sub_44A0E+F7j
jmp	loc_44BD8	; Jump

loc_44B10:		; CODE XREF: sub_44A0E:loc_44BDEj
mov	ax, 1Eh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	di, ax
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply

loc_44B24:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6F2]
add	bx, ax		; Add

loc_44B2A:
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jz	short loc_44B37	; Jump if Zero (ZF=1)
jmp	loc_44BD8	; Jump

loc_44B37:		; CODE XREF: sub_44A0E+124j
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_44B44:		; Compare Two Operands
cmp	[byte ptr es:bx+2Dh], 0
jz	short loc_44B4E	; Jump if Zero (ZF=1)

loc_44B4B:		; Jump
jmp	loc_44BD8

loc_44B4E:		; CODE XREF: sub_44A0E+13Bj
mov	ax, di
mov	dx, 30h	; '0'

loc_44B53:		; Signed Multiply
imul	dx
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+2Dh], 2

loc_44B60:
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_0]

loc_44B7B:
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_44B80:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply

loc_44B90:
push	es
les	si, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es

loc_44BA0:
mov	[word ptr es:bx], 0AAh ; ''
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax

loc_44BB8:
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax

loc_44BCA:
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_46029 ; Call Procedure
add	sp, 6		; Add
dec	[bp+var_A]	; Decrement by 1

loc_44BD8:		; CODE XREF: sub_44A0E:loc_44B0Dj
			; sub_44A0E+126j
			; sub_44A0E:loc_44B4Bj
cmp	[bp+var_A], 0	; Compare Two Operands
jle	short loc_44BE1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_44BDE:		; Jump
jmp	loc_44B10

loc_44BE1:		; CODE XREF: sub_44A0E+1CEj
jmp	loc_44CAC	; Jump

loc_44BE4:		; CODE XREF: sub_44A0E+2A4j
mov	ax, 1Eh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	di, ax
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_44BFE:
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jz	short loc_44C0B	; Jump if Zero (ZF=1)
jmp	loc_44CAC	; Jump

loc_44C0B:		; CODE XREF: sub_44A0E+1F8j
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+2Dh], 0	; Compare Two Operands
jz	short loc_44C22	; Jump if Zero (ZF=1)
jmp	loc_44CAC	; Jump

loc_44C22:		; CODE XREF: sub_44A0E+20Fj
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+2Dh], 1
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
push	es
les	si, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es
mov	[word ptr es:bx], 0A9h ; ''
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_46029 ; Call Procedure
add	sp, 6		; Add
dec	[bp+var_C]	; Decrement by 1

loc_44CAC:		; CODE XREF: sub_44A0E:loc_44BE1j
			; sub_44A0E+1FAj
			; sub_44A0E+211j
cmp	[bp+var_C], 0	; Compare Two Operands
jle	short loc_44CB5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_44BE4	; Jump

loc_44CB5:		; CODE XREF: sub_44A0E+2A2j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_44A0E



; Attributes: bp-based frame

proc sub_44CBB far	; CODE XREF: sub_31978J
			; idk_BuildingWorlds+11Ap
			; idk_BuildingWorlds+12Ep

var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 14h		; Integer Subtraction
push	si
push	di
mov	si, 2
jmp	loc_44DD7	; Jump

loc_44CC9:		; CODE XREF: sub_44CBB+121j
xor	di, di		; Logical Exclusive OR
jmp	loc_44DCE	; Jump

loc_44CCE:		; CODE XREF: sub_44CBB+118j
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jz	short loc_44D16	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A3h ; '' ; Compare Two Operands
jnz	short loc_44D49	; Jump if Not Zero (ZF=0)

loc_44D16:		; CODE XREF: sub_44CBB+35j
mov	ax, 8
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
cmp	ax, si		; Compare Two Operands
jl	short loc_44D49	; Jump if Less (SF!=OF)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A7h ; ''

loc_44D49:		; CODE XREF: sub_44CBB+59j
			; sub_44CBB+6Aj
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_44D51:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, 27h	; '''
sub	ax, si		; Integer Subtraction
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jz	short loc_44D97	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, 27h	; '''
sub	ax, si		; Integer Subtraction
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A3h ; '' ; Compare Two Operands
jnz	short loc_44DCD	; Jump if Not Zero (ZF=0)

loc_44D97:		; CODE XREF: sub_44CBB+B3j
mov	ax, 8
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
cmp	ax, si		; Compare Two Operands
jl	short loc_44DCD	; Jump if Less (SF!=OF)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, 27h	; '''
sub	ax, si		; Integer Subtraction
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A7h ; ''

loc_44DCD:		; CODE XREF: sub_44CBB+DAj
			; sub_44CBB+EBj
inc	di		; Increment by 1

loc_44DCE:		; CODE XREF: sub_44CBB+10j
cmp	di, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_44DD6	; Jump if Greater or Equal (SF=OF)
jmp	loc_44CCE	; Jump

loc_44DD6:		; CODE XREF: sub_44CBB+116j
inc	si		; Increment by 1

loc_44DD7:		; CODE XREF: sub_44CBB+Bj
cmp	si, 8		; Compare Two Operands
jge	short loc_44DDF	; Jump if Greater or Equal (SF=OF)
jmp	loc_44CC9	; Jump

loc_44DDF:		; CODE XREF: sub_44CBB+11Fj
mov	[bp+var_8], 0
jmp	loc_44F58	; Jump

loc_44DE7:		; CODE XREF: sub_44CBB:loc_44F5Ej
mov	ax, 36h	; '6'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_4], ax
mov	ax, 18h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 8		; Add
mov	[bp+var_6], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_6]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A3h ; '' ; Compare Two Operands
jnz	short loc_44E51	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_6]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A5h ; ''

loc_44E51:		; CODE XREF: sub_44CBB+170j
mov	[bp+var_E], 0
jmp	loc_44F4C	; Jump

loc_44E59:		; CODE XREF: sub_44CBB+297j
mov	bx, [bp+var_E]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+3350h]
add	ax, [bp+var_4]	; Add
mov	[bp+var_A], ax
mov	bx, [bp+var_E]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+335Ah]
add	ax, [bp+var_6]	; Add
mov	[bp+var_C], ax
mov	[bp+var_14], 0FFFFh
mov	ax, 6
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 4		; Add
mov	[bp+var_12], ax
mov	[bp+var_2], 0
jmp	loc_44F3E	; Jump

loc_44E94:		; CODE XREF: sub_44CBB+28Bj
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_10], ax
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_A]
add	ax, [bx+3350h]	; Add
mov	di, ax
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_C]
add	ax, [bx+335Ah]	; Add
mov	si, ax
cmp	di, 3Ch	; '<'   ; Compare Two Operands
jl	short loc_44ECA	; Jump if Less (SF!=OF)
mov	ax, di
add	ax, 0FFC4h	; Add
mov	di, ax

loc_44ECA:		; CODE XREF: sub_44CBB+206j
cmp	si, 28h	; '('   ; Compare Two Operands
jl	short loc_44ED6	; Jump if Less (SF!=OF)
mov	ax, si
add	ax, 0FFD8h	; Add
mov	si, ax

loc_44ED6:		; CODE XREF: sub_44CBB+212j
or	di, di		; Logical Inclusive OR
jge	short loc_44EE1	; Jump if Greater or Equal (SF=OF)
mov	ax, di
add	ax, 3Ch	; '<'   ; Add
mov	di, ax

loc_44EE1:		; CODE XREF: sub_44CBB+21Dj
or	si, si		; Logical Inclusive OR
jge	short loc_44EEC	; Jump if Greater or Equal (SF=OF)
mov	ax, si
add	ax, 28h	; '('   ; Add
mov	si, ax

loc_44EEC:		; CODE XREF: sub_44CBB+228j
mov	[bp+var_A], di
mov	[bp+var_C], si
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_C]

loc_44F03:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_A]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jz	short loc_44F3B	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_C]
mov	dx, 78h	; 'x'

loc_44F2B:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, [bp+var_A]
shl	ax, 1		; Shift	Logical	Left

loc_44F34:		; Add
add	bx, ax
mov	[word ptr es:bx], 0A5h ; ''

loc_44F3B:		; CODE XREF: sub_44CBB+25Aj
inc	[bp+var_2]	; Increment by 1

loc_44F3E:		; CODE XREF: sub_44CBB+1D6j
mov	ax, [bp+var_2]
cmp	ax, [bp+var_12]	; Compare Two Operands
jge	short loc_44F49	; Jump if Greater or Equal (SF=OF)
jmp	loc_44E94	; Jump

loc_44F49:		; CODE XREF: sub_44CBB+289j
inc	[bp+var_E]	; Increment by 1

loc_44F4C:		; CODE XREF: sub_44CBB+19Bj
cmp	[bp+var_E], 5	; Compare Two Operands
jge	short loc_44F55	; Jump if Greater or Equal (SF=OF)
jmp	loc_44E59	; Jump

loc_44F55:		; CODE XREF: sub_44CBB+295j
inc	[bp+var_8]	; Increment by 1

loc_44F58:		; CODE XREF: sub_44CBB+129j
cmp	[bp+var_8], 8	; Compare Two Operands
jge	short loc_44F61	; Jump if Greater or Equal (SF=OF)

loc_44F5E:		; Jump
jmp	loc_44DE7

loc_44F61:		; CODE XREF: sub_44CBB+2A1j
mov	[bp+var_8], 0
jmp	loc_450E7	; Jump

loc_44F69:		; CODE XREF: sub_44CBB+2D8j
			; sub_44CBB+432j
mov	ax, 38h	; '8'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	ax, 14h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 0Ah		; Add

loc_44F84:
mov	[bp+var_6], ax
cmp	[bp+var_6], 23h	; '#' ; Compare Two Operands
jl	short loc_44F95	; Jump if Less (SF!=OF)
cmp	[bp+var_6], 2Dh	; '-' ; Compare Two Operands
jg	short loc_44F95	; Jump if Greater (ZF=0	& SF=OF)
jmp	short loc_44F69	; Jump

loc_44F95:		; CODE XREF: sub_44CBB+2D0j
			; sub_44CBB+2D6j
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_6]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply

loc_44FAB:		; Add
add	bx, ax
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_44FB4:		; Compare Two Operands
cmp	[word ptr es:bx], 0A3h ; ''
jnz	short loc_44FDF	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]

loc_44FBE:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_6]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A6h ; ''

loc_44FDF:		; CODE XREF: sub_44CBB+2FEj
mov	[bp+var_E], 0
jmp	loc_450DB	; Jump

loc_44FE7:		; CODE XREF: sub_44CBB+426j
mov	bx, [bp+var_E]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+3350h]
add	ax, [bp+var_4]	; Add
mov	[bp+var_A], ax
mov	bx, [bp+var_E]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+335Ah]
add	ax, [bp+var_6]	; Add
mov	[bp+var_C], ax
mov	[bp+var_14], 0FFFFh
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx

loc_45014:		; Add
add	ax, 2
mov	[bp+var_12], ax

loc_4501A:
mov	[bp+var_2], 0
jmp	loc_450CD	; Jump

loc_45022:		; CODE XREF: sub_44CBB+41Aj
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_10], ax
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_A]
add	ax, [bx+3350h]	; Add
mov	di, ax
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_C]
add	ax, [bx+335Ah]	; Add
mov	si, ax
cmp	di, 3Ch	; '<'   ; Compare Two Operands
jl	short loc_45058	; Jump if Less (SF!=OF)
mov	ax, di
add	ax, 0FFC4h	; Add
mov	di, ax

loc_45058:		; CODE XREF: sub_44CBB+394j
cmp	si, 28h	; '('   ; Compare Two Operands
jl	short loc_45064	; Jump if Less (SF!=OF)
mov	ax, si
add	ax, 0FFD8h	; Add
mov	si, ax

loc_45064:		; CODE XREF: sub_44CBB+3A0j
or	di, di		; Logical Inclusive OR
jge	short loc_4506F	; Jump if Greater or Equal (SF=OF)
mov	ax, di
add	ax, 3Ch	; '<'   ; Add
mov	di, ax

loc_4506F:		; CODE XREF: sub_44CBB+3ABj
or	si, si		; Logical Inclusive OR
jge	short loc_4507A	; Jump if Greater or Equal (SF=OF)
mov	ax, si
add	ax, 28h	; '('   ; Add
mov	si, ax

loc_4507A:		; CODE XREF: sub_44CBB+3B6j
mov	[bp+var_A], di
mov	[bp+var_C], si
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_C]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply

loc_45096:		; Add
add	bx, ax
mov	ax, [bp+var_A]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A3h ; '' ; Compare Two Operands
jnz	short loc_450CA	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx

loc_450B2:		; Add
add	bx, ax
mov	ax, [bp+var_C]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_A]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A6h ; ''

loc_450CA:		; CODE XREF: sub_44CBB+3E9j
inc	[bp+var_2]	; Increment by 1

loc_450CD:		; CODE XREF: sub_44CBB+364j
mov	ax, [bp+var_2]
cmp	ax, [bp+var_12]	; Compare Two Operands
jge	short loc_450D8	; Jump if Greater or Equal (SF=OF)
jmp	loc_45022	; Jump

loc_450D8:		; CODE XREF: sub_44CBB+418j
inc	[bp+var_E]	; Increment by 1

loc_450DB:		; CODE XREF: sub_44CBB+329j
cmp	[bp+var_E], 5	; Compare Two Operands
jge	short loc_450E4	; Jump if Greater or Equal (SF=OF)
jmp	loc_44FE7	; Jump

loc_450E4:		; CODE XREF: sub_44CBB+424j
inc	[bp+var_8]	; Increment by 1

loc_450E7:		; CODE XREF: sub_44CBB+2ABj
cmp	[bp+var_8], 8	; Compare Two Operands
jge	short loc_450F0	; Jump if Greater or Equal (SF=OF)
jmp	loc_44F69	; Jump

loc_450F0:		; CODE XREF: sub_44CBB+430j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_44CBB



; Attributes: bp-based frame

proc sub_450F6 far	; CODE XREF: sub_3197DJ
			; idk_BuildingWorlds+F3p
			; idk_BuildingWorlds+107p

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_0]
mov	[bp+var_2], 0
jmp	loc_45291	; Jump

loc_45109:		; CODE XREF: sub_450F6+1A1j
xor	si, si		; Logical Exclusive OR
jmp	loc_45286	; Jump

loc_4510E:		; CODE XREF: sub_450F6+195j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_45134	; Jump if Not Zero (ZF=0)
jmp	loc_45285	; Jump

loc_45134:		; CODE XREF: sub_450F6+39j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 3 ; Compare Two Operands
ja	short loc_4515A	; Jump if Above	(CF=0 &	ZF=0)
jmp	loc_451E9	; Jump

loc_4515A:		; CODE XREF: sub_450F6+5Fj
mov	ax, di

loc_4515C:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 4 ; Compare Two Operands
jz	short loc_451A0	; Jump if Zero (ZF=1)
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]

loc_4518D:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 5 ; Compare Two Operands
jnz	short loc_451C4	; Jump if Not Zero (ZF=0)

loc_451A0:		; CODE XREF: sub_450F6+85j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0ABh ; ''
jmp	short loc_451E6	; Jump

loc_451C4:		; CODE XREF: sub_450F6+A8j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A4h ; ''

loc_451E6:		; CODE XREF: sub_450F6+CCj
jmp	loc_45285	; Jump

loc_451E9:		; CODE XREF: sub_450F6+61j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 1 ; Compare Two Operands
jbe	short loc_45230	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_45229:
mov	[word ptr es:bx], 0A3h ; ''

loc_4522E:		; Jump
jmp	short loc_45285

loc_45230:		; CODE XREF: sub_450F6+114j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_45263	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A3h ; ''
jmp	short loc_45285	; Jump

loc_45263:		; CODE XREF: sub_450F6+147j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''

loc_45285:		; CODE XREF: sub_450F6+3Bj
			; sub_450F6:loc_451E6j
			; sub_450F6:loc_4522Ej
			; sub_450F6+16Bj
inc	si		; Increment by 1

loc_45286:		; CODE XREF: sub_450F6+15j
cmp	si, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_4528E	; Jump if Greater or Equal (SF=OF)
jmp	loc_4510E	; Jump

loc_4528E:		; CODE XREF: sub_450F6+193j
inc	[bp+var_2]	; Increment by 1

loc_45291:		; CODE XREF: sub_450F6+10j
cmp	[bp+var_2], 28h	; '(' ; Compare Two Operands
jge	short loc_4529A	; Jump if Greater or Equal (SF=OF)
jmp	loc_45109	; Jump

loc_4529A:		; CODE XREF: sub_450F6+19Fj
xor	si, si		; Logical Exclusive OR
jmp	loc_4537B	; Jump

loc_4529F:		; CODE XREF: sub_450F6+28Aj
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A7h ; ''
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx+1248h],	0A7h ; ''
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_45325	; Jump if Not Zero (ZF=0)
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_6], ax
mov	[bp+var_4], 0
jmp	short loc_45313	; Jump

loc_452F4:		; CODE XREF: sub_450F6:loc_45323j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_4]	; Add
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_4530A:
mov	[word ptr es:bx+78h], 0A7h ; ''
inc	[bp+var_4]	; Increment by 1

loc_45313:		; CODE XREF: sub_450F6+1FCj
mov	ax, [bp+var_4]

loc_45316:		; Compare Two Operands
cmp	ax, [bp+var_6]
jge	short loc_45325	; Jump if Greater or Equal (SF=OF)
mov	ax, si
add	ax, [bp+var_4]	; Add
cmp	ax, 3Ch	; '<'   ; Compare Two Operands

loc_45323:		; Jump if Less (SF!=OF)
jl	short loc_452F4

loc_45325:		; CODE XREF: sub_450F6+1E8j
			; sub_450F6+223j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4537A	; Jump if Not Zero (ZF=0)

loc_45334:
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_6], ax
mov	[bp+var_4], 0
jmp	short loc_45368	; Jump

loc_45348:		; CODE XREF: sub_450F6+282j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
add	ax, [bp+var_4]	; Add
shl	ax, 1		; Shift	Logical	Left

loc_4535C:		; Add
add	bx, ax
mov	[word ptr es:bx+11D0h],	0A7h ; ''
inc	[bp+var_4]	; Increment by 1

loc_45368:		; CODE XREF: sub_450F6+250j
mov	ax, [bp+var_4]
cmp	ax, [bp+var_6]	; Compare Two Operands
jge	short loc_4537A	; Jump if Greater or Equal (SF=OF)

loc_45370:
mov	ax, si
add	ax, [bp+var_4]	; Add
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jl	short loc_45348	; Jump if Less (SF!=OF)

loc_4537A:		; CODE XREF: sub_450F6+23Cj
			; sub_450F6+278j
inc	si		; Increment by 1

loc_4537B:		; CODE XREF: sub_450F6+1A6j
cmp	si, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_45383	; Jump if Greater or Equal (SF=OF)
jmp	loc_4529F	; Jump

loc_45383:		; CODE XREF: sub_450F6+288j
pop	di

loc_45384:
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_450F6



; Attributes: bp-based frame

proc sub_45389 far	; CODE XREF: sub_31982J
			; idk_BuildingWorlds+CCp
			; idk_BuildingWorlds+E0p

var_56=	word ptr -56h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 56h		; Integer Subtraction
push	si
push	di
xor	di, di		; Logical Exclusive OR
jmp	short loc_453C2	; Jump

loc_45395:		; CODE XREF: sub_45389+3Cj
xor	si, si		; Logical Exclusive OR

loc_45397:		; Jump
jmp	short loc_453BC

loc_45399:		; CODE XREF: sub_45389:loc_453BFj
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'

loc_453AC:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0
inc	si		; Increment by 1

loc_453BC:		; CODE XREF: sub_45389:loc_45397j
cmp	si, 3Ch	; '<'   ; Compare Two Operands

loc_453BF:		; Jump if Less (SF!=OF)
jl	short loc_45399
inc	di		; Increment by 1

loc_453C2:		; CODE XREF: sub_45389+Aj
cmp	di, 28h	; '('   ; Compare Two Operands
jl	short loc_45395	; Jump if Less (SF!=OF)
xor	di, di		; Logical Exclusive OR
jmp	short loc_453EE	; Jump

loc_453CB:		; CODE XREF: sub_45389+68j
xor	si, si		; Logical Exclusive OR
jmp	short loc_453E8	; Jump

loc_453CF:		; CODE XREF: sub_45389+62j
mov	ax, di
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
lea	dx, [bp+var_56]	; Load Effective Address

loc_453DF:		; Add
add	ax, dx
mov	bx, ax
mov	[word ptr bx], 0
inc	si		; Increment by 1

loc_453E8:		; CODE XREF: sub_45389+44j
cmp	si, 5		; Compare Two Operands
jl	short loc_453CF	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_453EE:		; CODE XREF: sub_45389+40j
cmp	di, 5		; Compare Two Operands
jl	short loc_453CB	; Jump if Less (SF!=OF)
mov	[bp+var_18], 8
mov	[bp+var_1A], 10h
mov	[bp+var_1C], 0Bh
mov	[bp+var_2], 0
mov	ax, [word_3A4E0]
or	ax, ax		; Logical Inclusive OR
jz	short loc_4541A	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_45421	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_45428	; Jump if Zero (ZF=1)
jmp	short loc_4542F	; Jump

loc_4541A:		; CODE XREF: sub_45389+83j
mov	[bp+var_4], 168h
jmp	short loc_4542F	; Jump

loc_45421:		; CODE XREF: sub_45389+88j
mov	[bp+var_4], 1E0h
jmp	short loc_4542F	; Jump

loc_45428:		; CODE XREF: sub_45389+8Dj
mov	[bp+var_4], 2D0h
jmp	short $+2	; Jump

loc_4542F:		; CODE XREF: sub_45389+8Fj
			; sub_45389+96j
			; sub_45389+9Dj
jmp	loc_45634	; Jump

loc_45432:		; CODE XREF: sub_45389+2B3j
mov	[bp+var_14], 0FFFFh
mov	[bp+var_16], 1

loc_4543C:		; CODE XREF: sub_45389+FCj
mov	ax, 2Eh	; '.'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 6		; Add
mov	[bp+var_22], ax
mov	ax, 1Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 6		; Add
mov	[bp+var_24], ax
cmp	[bp+var_18], 0	; Compare Two Operands
jle	short loc_454AC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_24]
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_1C]	; Signed Divide
mov	dx, 0Ah
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_22]
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_1A]	; Signed Divide
shl	ax, 1		; Shift	Logical	Left
pop	bx
add	bx, ax		; Add
lea	ax, [bp+var_56]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jnz	short loc_45487	; Jump if Not Zero (ZF=0)
jmp	short loc_4543C	; Jump

loc_45487:		; CODE XREF: sub_45389+FAj
mov	ax, [bp+var_24]
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_1C]	; Signed Divide
mov	dx, 0Ah
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_22]
cwd			; AX ->	DX:AX (with sign)
idiv	[bp+var_1A]	; Signed Divide
shl	ax, 1		; Shift	Logical	Left
pop	bx
add	bx, ax		; Add
lea	ax, [bp+var_56]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 1
dec	[bp+var_18]	; Decrement by 1

loc_454AC:		; CODE XREF: sub_45389+D7j
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_1E], ax
mov	[bp+var_20], 0
jmp	loc_45629	; Jump

loc_454C4:		; CODE XREF: sub_45389+2A8j
mov	ax, [word_3A4E0]
or	ax, ax		; Logical Inclusive OR
jz	short loc_454D7	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_454E9	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_454F8	; Jump if Zero (ZF=1)
jmp	short loc_45507	; Jump

loc_454D7:		; CODE XREF: sub_45389+140j
mov	ax, 0Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure

loc_454E0:
pop	cx
add	ax, 5		; Add

loc_454E4:		; CODE XREF: sub_45389+16Dj
			; sub_45389+17Cj
mov	[bp+var_E], ax
jmp	short loc_45507	; Jump

loc_454E9:		; CODE XREF: sub_45389+145j
mov	ax, 0Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 0Ah		; Add
jmp	short loc_454E4	; Jump

loc_454F8:		; CODE XREF: sub_45389+14Aj
mov	ax, 0Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 14h		; Add
jmp	short loc_454E4	; Jump

loc_45507:		; CODE XREF: sub_45389+14Cj
			; sub_45389+15Ej
mov	bx, [bp+var_20]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_22]
add	ax, [bx+3350h]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_20]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_24]
add	ax, [bx+335Ah]	; Add
mov	[bp+var_8], ax
mov	[bp+var_10], 0
jmp	loc_45613	; Jump

loc_4552D:		; CODE XREF: sub_45389+29Aj
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_8]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_45555	; Jump if Not Zero (ZF=0)
inc	[bp+var_2]	; Increment by 1

loc_45555:		; CODE XREF: sub_45389+1C7j
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_8]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
inc	[word ptr es:bx] ; Increment by	1
push	[bp+var_8]
push	[bp+var_6]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_46029 ; Call Procedure
add	sp, 6		; Add

loc_45588:		; CODE XREF: sub_45389+226j
			; sub_45389+279j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_12], ax
mov	ax, [bp+var_12]
cmp	ax, [bp+var_14]	; Compare Two Operands
jnz	short loc_455B6	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_16]
shl	ax, 1		; Shift	Logical	Left
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jz	short loc_455B1	; Jump if Zero (ZF=1)
jmp	short loc_45588	; Jump

loc_455B1:		; CODE XREF: sub_45389+224j
inc	[bp+var_16]	; Increment by 1
jmp	short loc_455BB	; Jump

loc_455B6:		; CODE XREF: sub_45389+213j
mov	[bp+var_16], 1

loc_455BB:		; CODE XREF: sub_45389+22Bj
mov	ax, [bp+var_12]
mov	[bp+var_14], ax
mov	bx, [bp+var_12]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]
add	ax, [bx+3334h]	; Add
mov	[bp+var_A], ax
mov	bx, [bp+var_12]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]
add	ax, [bx+333Eh]	; Add
mov	[bp+var_C], ax
cmp	[bp+var_A], 2	; Compare Two Operands
jge	short loc_455E7	; Jump if Greater or Equal (SF=OF)
jmp	short loc_455FD	; Jump

loc_455E7:		; CODE XREF: sub_45389+25Aj
cmp	[bp+var_C], 4	; Compare Two Operands
jge	short loc_455EF	; Jump if Greater or Equal (SF=OF)
jmp	short loc_455FD	; Jump

loc_455EF:		; CODE XREF: sub_45389+262j
cmp	[bp+var_A], 3Ah	; ':' ; Compare Two Operands
jl	short loc_455F7	; Jump if Less (SF!=OF)
jmp	short loc_455FD	; Jump

loc_455F7:		; CODE XREF: sub_45389+26Aj
cmp	[bp+var_C], 24h	; '$' ; Compare Two Operands
jl	short loc_45604	; Jump if Less (SF!=OF)

loc_455FD:		; CODE XREF: sub_45389+25Cj
			; sub_45389+264j
			; sub_45389+26Cj
mov	[bp+var_14], 0FFFFh
jmp	short loc_45588	; Jump

loc_45604:		; CODE XREF: sub_45389+272j
mov	ax, [bp+var_A]
mov	[bp+var_6], ax
mov	ax, [bp+var_C]
mov	[bp+var_8], ax
inc	[bp+var_10]	; Increment by 1

loc_45613:		; CODE XREF: sub_45389+1A1j
mov	ax, [bp+var_10]
cmp	ax, [bp+var_E]	; Compare Two Operands
jge	short loc_45626	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_2]
cmp	ax, [bp+var_4]	; Compare Two Operands
jg	short loc_45626	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4552D	; Jump

loc_45626:		; CODE XREF: sub_45389+290j
			; sub_45389+298j
inc	[bp+var_20]	; Increment by 1

loc_45629:		; CODE XREF: sub_45389+138j
mov	ax, [bp+var_20]
cmp	ax, [bp+var_1E]	; Compare Two Operands
jge	short loc_45634	; Jump if Greater or Equal (SF=OF)
jmp	loc_454C4	; Jump

loc_45634:		; CODE XREF: sub_45389:loc_4542Fj
			; sub_45389+2A6j
mov	ax, [bp+var_2]
cmp	ax, [bp+var_4]	; Compare Two Operands
jg	short loc_4563F	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_45432	; Jump

loc_4563F:		; CODE XREF: sub_45389+2B1j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_45389



; Attributes: bp-based frame

proc sub_45645 far	; CODE XREF: sub_31987J
			; idk_BuildingWorlds+13Ep

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction
push	si
push	di
xor	si, si		; Logical Exclusive OR
jmp	loc_458AF	; Jump

loc_45652:		; CODE XREF: sub_45645+93j
			; sub_45645+9Cj
			; sub_45645+A5j
			; sub_45645+AEj
			; sub_45645+DBj
			; sub_45645:loc_45763j
			; sub_45645+1F9j
			; sub_45645+26Fj
mov	ax, si
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	bx, 0Ch
mov	ax, dx
imul	bx		; Signed Multiply
mov	[bp+var_2], ax
mov	ax, si
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	[bp+var_4], ax
mov	ax, 18h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, [bp+var_2]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_6], ax
mov	ax, 14h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, [bp+var_4]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
cmp	[bp+var_6], 3Ch	; '<' ; Compare Two Operands
jl	short loc_456A5	; Jump if Less (SF!=OF)
mov	ax, [bp+var_6]
add	ax, 0FFC4h	; Add
mov	[bp+var_6], ax

loc_456A5:		; CODE XREF: sub_45645+55j
cmp	[bp+var_8], 28h	; '(' ; Compare Two Operands
jl	short loc_456B4	; Jump if Less (SF!=OF)
mov	ax, [bp+var_8]
add	ax, 0FFD8h	; Add
mov	[bp+var_8], ax

loc_456B4:		; CODE XREF: sub_45645+64j
cmp	[bp+var_6], 0	; Compare Two Operands
jge	short loc_456C3	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_6]
add	ax, 3Ch	; '<'   ; Add
mov	[bp+var_6], ax

loc_456C3:		; CODE XREF: sub_45645+73j
cmp	[bp+var_8], 0	; Compare Two Operands
jge	short loc_456D2	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_8]
add	ax, 28h	; '('   ; Add
mov	[bp+var_8], ax

loc_456D2:		; CODE XREF: sub_45645+82j
cmp	[bp+var_6], 3	; Compare Two Operands
jge	short loc_456DB	; Jump if Greater or Equal (SF=OF)
jmp	loc_45652	; Jump

loc_456DB:		; CODE XREF: sub_45645+91j
cmp	[bp+var_8], 2	; Compare Two Operands
jge	short loc_456E4	; Jump if Greater or Equal (SF=OF)
jmp	loc_45652	; Jump

loc_456E4:		; CODE XREF: sub_45645+9Aj
cmp	[bp+var_6], 39h	; '9' ; Compare Two Operands
jl	short loc_456ED	; Jump if Less (SF!=OF)
jmp	loc_45652	; Jump

loc_456ED:		; CODE XREF: sub_45645+A3j
cmp	[bp+var_8], 25h	; '%' ; Compare Two Operands
jl	short loc_456F6	; Jump if Less (SF!=OF)
jmp	loc_45652	; Jump

loc_456F6:		; CODE XREF: sub_45645+ACj
mov	ax, [bp+var_8]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_45723	; Jump if Not Zero (ZF=0)
mov	ax, 28h	; '('
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jz	short loc_45723	; Jump if Zero (ZF=1)
jmp	loc_45652	; Jump

loc_45723:		; CODE XREF: sub_45645+CAj
			; sub_45645+D9j
xor	di, di		; Logical Exclusive OR
jmp	short loc_45767	; Jump

loc_45727:		; CODE XREF: sub_45645+124j
mov	ax, 3Ch	; '<'
push	ax
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_8]
push	[bp+var_6]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
cmp	ax, 3		; Compare Two Operands
jge	short loc_45766	; Jump if Greater or Equal (SF=OF)

loc_45763:		; Jump
jmp	loc_45652

loc_45766:		; CODE XREF: sub_45645+11Cj
inc	di		; Increment by 1

loc_45767:		; CODE XREF: sub_45645+E0j
cmp	di, si		; Compare Two Operands
jl	short loc_45727	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_6]
mov	[es:bx], al
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4578B:
mov	al, [byte ptr bp+var_8]
mov	[es:bx+1], al
mov	ax, si

loc_45794:
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+2], 0
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+2Eh], 0
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply

loc_457BD:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6F2]
add	bx, ax		; Add
mov	[byte ptr es:bx+3], 0FFh
mov	ax, 6
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	al, 4		; Add
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+4], al
push	[bp+var_8]
push	[bp+var_6]
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 19h		; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 5		; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)
push	ax
nop			; No Operation
push	cs
call	near ptr sub_45B42 ; Call Procedure
add	sp, 0Eh		; Add
push	si
nop			; No Operation
push	cs
call	near ptr sub_45CDF ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_45841	; Jump if Not Zero (ZF=0)
jmp	loc_45652	; Jump

loc_45841:		; CODE XREF: sub_45645+1F7j
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 2Dh	; '-'   ; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add

loc_45876:		; Add
add	dx, 19h
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 5		; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)
push	ax
nop			; No Operation
push	cs
call	near ptr sub_45DC9 ; Call Procedure
add	sp, 10h		; Add
inc	si		; Increment by 1

loc_458AF:		; CODE XREF: sub_45645+Aj
cmp	si, 10h		; Compare Two Operands
jge	short loc_458B7	; Jump if Greater or Equal (SF=OF)
jmp	loc_45652	; Jump

loc_458B7:		; CODE XREF: sub_45645+26Dj
mov	si, 10h
jmp	loc_45B34	; Jump

loc_458BD:		; CODE XREF: sub_45645+304j
			; sub_45645+30Dj
			; sub_45645+316j
			; sub_45645+31Fj
			; sub_45645+34Cj
			; sub_45645+3A3j
			; sub_45645+47Ej
			; sub_45645+4F4j
mov	ax, si
add	ax, 0FFECh	; Add
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	bx, 0Ch
mov	ax, dx
imul	bx		; Signed Multiply
mov	[bp+var_2], ax
mov	ax, si
add	ax, 0FFECh	; Add
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 14h
imul	dx		; Signed Multiply
mov	[bp+var_4], ax
mov	ax, 18h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, [bp+var_2]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_6], ax
mov	ax, 28h	; '('
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, [bp+var_4]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
cmp	[bp+var_6], 3Ch	; '<' ; Compare Two Operands
jl	short loc_45916	; Jump if Less (SF!=OF)
mov	ax, [bp+var_6]
add	ax, 0FFC4h	; Add
mov	[bp+var_6], ax

loc_45916:		; CODE XREF: sub_45645+2C6j
cmp	[bp+var_8], 28h	; '(' ; Compare Two Operands
jl	short loc_45925	; Jump if Less (SF!=OF)
mov	ax, [bp+var_8]
add	ax, 0FFD8h	; Add
mov	[bp+var_8], ax

loc_45925:		; CODE XREF: sub_45645+2D5j
cmp	[bp+var_6], 0	; Compare Two Operands
jge	short loc_45934	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_6]
add	ax, 3Ch	; '<'   ; Add
mov	[bp+var_6], ax

loc_45934:		; CODE XREF: sub_45645+2E4j
cmp	[bp+var_8], 0	; Compare Two Operands
jge	short loc_45943	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_8]

loc_4593D:		; Add
add	ax, 28h	; '('
mov	[bp+var_8], ax

loc_45943:		; CODE XREF: sub_45645+2F3j
cmp	[bp+var_6], 3	; Compare Two Operands
jge	short loc_4594C	; Jump if Greater or Equal (SF=OF)
jmp	loc_458BD	; Jump

loc_4594C:		; CODE XREF: sub_45645+302j
cmp	[bp+var_8], 2	; Compare Two Operands
jge	short loc_45955	; Jump if Greater or Equal (SF=OF)
jmp	loc_458BD	; Jump

loc_45955:		; CODE XREF: sub_45645+30Bj
cmp	[bp+var_6], 39h	; '9' ; Compare Two Operands
jl	short loc_4595E	; Jump if Less (SF!=OF)
jmp	loc_458BD	; Jump

loc_4595E:		; CODE XREF: sub_45645+314j
cmp	[bp+var_8], 25h	; '%' ; Compare Two Operands
jl	short loc_45967	; Jump if Less (SF!=OF)
jmp	loc_458BD	; Jump

loc_45967:		; CODE XREF: sub_45645+31Dj
mov	ax, [bp+var_8]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_45994	; Jump if Not Zero (ZF=0)
mov	ax, 19h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jz	short loc_45994	; Jump if Zero (ZF=1)
jmp	loc_458BD	; Jump

loc_45994:		; CODE XREF: sub_45645+33Bj
			; sub_45645+34Aj
xor	di, di		; Logical Exclusive OR
jmp	short loc_459EC	; Jump

loc_45998:		; CODE XREF: sub_45645+3A9j
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+2], 1 ;	Compare	Two Operands
jnz	short loc_459EB	; Jump if Not Zero (ZF=0)
mov	ax, 3Ch	; '<'
push	ax
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, di
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_8]
push	[bp+var_6]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
cmp	ax, 3		; Compare Two Operands
jge	short loc_459EB	; Jump if Greater or Equal (SF=OF)
jmp	loc_458BD	; Jump

loc_459EB:		; CODE XREF: sub_45645+365j
			; sub_45645+3A1j
inc	di		; Increment by 1

loc_459EC:		; CODE XREF: sub_45645+351j
cmp	di, si		; Compare Two Operands
jl	short loc_45998	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_6]
mov	[es:bx], al
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_8]
mov	[es:bx+1], al
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+2], 1
mov	ax, si
mov	dx, 30h	; '0'

loc_45A2E:		; Signed Multiply
imul	dx

loc_45A30:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6F2]
add	bx, ax		; Add
mov	[byte ptr es:bx+2Eh], 0
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+3], 0FFh
mov	ax, 0Bh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	al, 9		; Add
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+4], al
push	[bp+var_8]
push	[bp+var_6]
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 19h		; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 5		; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)
push	ax
nop			; No Operation
push	cs
call	near ptr sub_45B42 ; Call Procedure
add	sp, 0Eh		; Add
push	si
nop			; No Operation
push	cs
call	near ptr sub_45CDF ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_45AC6	; Jump if Not Zero (ZF=0)
jmp	loc_458BD	; Jump

loc_45AC6:		; CODE XREF: sub_45645+47Cj
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 2Dh	; '-'   ; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 19h		; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6F2]
add	dx, ax		; Add
add	dx, 5		; Add
push	[word ptr dword_3A6F2+2]
push	dx
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)
push	ax
nop			; No Operation
push	cs
call	near ptr sub_45DC9 ; Call Procedure
add	sp, 10h		; Add
inc	si		; Increment by 1

loc_45B34:		; CODE XREF: sub_45645+275j
cmp	si, 1Eh		; Compare Two Operands
jge	short loc_45B3C	; Jump if Greater or Equal (SF=OF)
jmp	loc_458BD	; Jump

loc_45B3C:		; CODE XREF: sub_45645+4F2j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_45645



; Attributes: bp-based frame

proc sub_45B42 far	; CODE XREF: sub_3198CJ
			; sub_45645+1E7p
			; sub_45645+46Cp

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= dword ptr  8
arg_6= dword ptr  0Ch
arg_A= word ptr	 10h
arg_C= byte ptr	 12h

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
mov	al, [byte ptr bp+arg_A]
mov	[es:bx], al
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
mov	al, [bp+arg_C]
mov	[es:bx], al
mov	si, 1
jmp	loc_45C06	; Jump

loc_45B62:		; CODE XREF: sub_45B42+AAj
			; sub_45B42+CEj
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_6], ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+3334h]
add	ax, [bp+arg_A]	; Add
mov	[bp+var_2], ax
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+333Eh]
add	ax, [word ptr bp+arg_C]	; Add
mov	[bp+var_4], ax
mov	[bp+var_A], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_45BC5	; Jump

loc_45BA5:		; CODE XREF: sub_45B42+85j
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
cmp	al, [byte ptr bp+var_2]	; Compare Two Operands
jnz	short loc_45BC4	; Jump if Not Zero (ZF=0)
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
cmp	al, [byte ptr bp+var_4]	; Compare Two Operands
jnz	short loc_45BC4	; Jump if Not Zero (ZF=0)
mov	[bp+var_A], 1

loc_45BC4:		; CODE XREF: sub_45B42+6Ej
			; sub_45B42+7Bj
inc	di		; Increment by 1

loc_45BC5:		; CODE XREF: sub_45B42+61j
cmp	di, si		; Compare Two Operands
jl	short loc_45BA5	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 0	; Compare Two Operands
jle	short loc_45BE1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_4], 0	; Compare Two Operands
jle	short loc_45BE1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_2], 3Bh	; ';' ; Compare Two Operands
jge	short loc_45BE1	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_4], 27h	; ''' ; Compare Two Operands
jl	short loc_45BE6	; Jump if Less (SF!=OF)

loc_45BE1:		; CODE XREF: sub_45B42+8Bj
			; sub_45B42+91j
			; sub_45B42+97j
mov	[bp+var_A], 1

loc_45BE6:		; CODE XREF: sub_45B42+9Dj
cmp	[bp+var_A], 1	; Compare Two Operands
jnz	short loc_45BEF	; Jump if Not Zero (ZF=0)
jmp	loc_45B62	; Jump

loc_45BEF:		; CODE XREF: sub_45B42+A8j
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	al, [byte ptr bp+var_2]
mov	[es:bx], al
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	al, [byte ptr bp+var_4]
mov	[es:bx], al
inc	si		; Increment by 1

loc_45C06:		; CODE XREF: sub_45B42+1Dj
cmp	si, [bp+arg_0]	; Compare Two Operands
jge	short loc_45C13	; Jump if Greater or Equal (SF=OF)
cmp	si, 9		; Compare Two Operands
jge	short loc_45C13	; Jump if Greater or Equal (SF=OF)
jmp	loc_45B62	; Jump

loc_45C13:		; CODE XREF: sub_45B42+C7j
			; sub_45B42+CCj
mov	si, 9
jmp	loc_45CD1	; Jump

loc_45C19:		; CODE XREF: sub_45B42+175j
			; sub_45B42+194j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_6], ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
imul	[word ptr bx+3334h] ; Signed Multiply
add	ax, [bp+arg_A]	; Add
mov	[bp+var_2], ax
mov	ax, 2
push	ax

loc_45C52:		; Call Procedure
call	idk_Arg_0Fail_ElseMathyDiSi
pop	cx
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
imul	[word ptr bx+333Eh] ; Signed Multiply
add	ax, [word ptr bp+arg_C]	; Add
mov	[bp+var_4], ax

loc_45C67:
mov	[bp+var_A], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_45C90	; Jump

loc_45C70:		; CODE XREF: sub_45B42+150j
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
cmp	al, [byte ptr bp+var_2]	; Compare Two Operands
jnz	short loc_45C8F	; Jump if Not Zero (ZF=0)
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]

loc_45C85:		; Compare Two Operands
cmp	al, [byte ptr bp+var_4]
jnz	short loc_45C8F	; Jump if Not Zero (ZF=0)
mov	[bp+var_A], 1

loc_45C8F:		; CODE XREF: sub_45B42+139j
			; sub_45B42+146j
inc	di		; Increment by 1

loc_45C90:		; CODE XREF: sub_45B42+12Cj
cmp	di, si		; Compare Two Operands
jl	short loc_45C70	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 0	; Compare Two Operands
jle	short loc_45CAC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_4], 0	; Compare Two Operands
jle	short loc_45CAC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[byte ptr bp+var_2], 3Bh ; ';' ; Compare Two Operands
jge	short loc_45CAC	; Jump if Greater or Equal (SF=OF)
cmp	[byte ptr bp+var_4], 27h ; ''' ; Compare Two Operands
jl	short loc_45CB1	; Jump if Less (SF!=OF)

loc_45CAC:		; CODE XREF: sub_45B42+156j
			; sub_45B42+15Cj
			; sub_45B42+162j
mov	[bp+var_A], 1

loc_45CB1:		; CODE XREF: sub_45B42+168j
cmp	[bp+var_A], 1	; Compare Two Operands
jnz	short loc_45CBA	; Jump if Not Zero (ZF=0)
jmp	loc_45C19	; Jump

loc_45CBA:		; CODE XREF: sub_45B42+173j
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	al, [byte ptr bp+var_2]
mov	[es:bx], al
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, si		; Add
mov	al, [byte ptr bp+var_4]
mov	[es:bx], al
inc	si		; Increment by 1

loc_45CD1:		; CODE XREF: sub_45B42+D4j
cmp	si, [bp+arg_0]	; Compare Two Operands

loc_45CD4:		; Jump if Greater or Equal (SF=OF)
jge	short loc_45CD9
jmp	loc_45C19	; Jump

loc_45CD9:		; CODE XREF: sub_45B42:loc_45CD4j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_45B42



; Attributes: bp-based frame

proc sub_45CDF far	; CODE XREF: sub_31991J
			; sub_45645+1F0p
			; sub_45645+475p

var_52=	word ptr -52h
var_2A=	word ptr -2Ah
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 52h		; Integer Subtraction
push	si
push	di

loc_45CE7:
mov	ax, [bp+arg_0]
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)
mov	[bp+var_2], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_45D42	; Jump

loc_45D01:		; CODE XREF: sub_45CDF+66j
mov	ax, [bp+arg_0]

loc_45D04:
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, cx		; Add
mov	al, [es:bx+5]
cbw			; AL ->	AX (with sign)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_2A]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
mov	ax, [bp+arg_0]
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, cx		; Add
mov	al, [es:bx+19h]
cbw			; AL ->	AX (with sign)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_52]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_45D42:		; CODE XREF: sub_45CDF+20j
cmp	cx, [bp+var_2]	; Compare Two Operands
jl	short loc_45D01	; Jump if Less (SF!=OF)
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_45DBA	; Jump

loc_45D4B:		; CODE XREF: sub_45CDF+DEj
xor	si, si		; Logical Exclusive OR
jmp	short loc_45DA3	; Jump

loc_45D4F:		; CODE XREF: sub_45CDF+D8j
xor	di, di		; Logical Exclusive OR
jmp	short loc_45D9D	; Jump

loc_45D53:		; CODE XREF: sub_45CDF+C1j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_2A]	; Load Effective Address
add	bx, ax		; Add
mov	al, [bx]
push	ax
mov	ax, cx
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
pop	ax
cmp	al, [es:bx+5]	; Compare Two Operands
jnz	short loc_45D9C	; Jump if Not Zero (ZF=0)
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_52]	; Load Effective Address

loc_45D7C:		; Add
add	bx, ax

loc_45D7E:
mov	al, [bx]
push	ax
mov	ax, cx
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply

loc_45D88:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6F2]
add	bx, ax		; Add
add	bx, si		; Add
pop	ax

loc_45D91:		; Compare Two Operands
cmp	al, [es:bx+19h]
jnz	short loc_45D9C	; Jump if Not Zero (ZF=0)
mov	ax, 1

loc_45D9A:		; CODE XREF: sub_45CDF+E2j
jmp	short loc_45DC3	; Jump

loc_45D9C:		; CODE XREF: sub_45CDF+94j
			; sub_45CDF+B6j
inc	di		; Increment by 1

loc_45D9D:		; CODE XREF: sub_45CDF+72j
cmp	di, [bp+var_2]	; Compare Two Operands
jl	short loc_45D53	; Jump if Less (SF!=OF)
inc	si		; Increment by 1

loc_45DA3:		; CODE XREF: sub_45CDF+6Ej
mov	ax, cx
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)

loc_45DB5:		; Compare Two Operands
cmp	ax, si
jg	short loc_45D4F	; Jump if Greater (ZF=0	& SF=OF)

loc_45DB9:		; Increment by 1
inc	cx

loc_45DBA:		; CODE XREF: sub_45CDF+6Aj
cmp	cx, [bp+arg_0]	; Compare Two Operands
jl	short loc_45D4B	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_45D9A	; Jump

loc_45DC3:		; CODE XREF: sub_45CDF:loc_45D9Aj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_45CDF



; Attributes: bp-based frame

proc sub_45DC9 far	; CODE XREF: sub_31996J
			; sub_45645+263p
			; sub_45645+4E8p

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= dword ptr  8
arg_6= dword ptr  0Ch
arg_A= word ptr	 10h
arg_C= dword ptr  12h

push	bp
mov	bp, sp

loc_45DCC:		; Integer Subtraction
sub	sp, 6
push	si
push	di
mov	[bp+var_2], 0
mov	[bp+var_4], 0
mov	[bp+var_6], 0

loc_45DE0:		; Logical Exclusive OR
xor	di, di

loc_45DE2:		; Jump
jmp	loc_45EFC

loc_45DE5:		; CODE XREF: sub_45DC9+138j
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)

loc_45DEE:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax

loc_45DF4:
mov	ax, [bp+arg_A]
mov	dx, 12C0h

loc_45DFA:		; Signed Multiply
imul	dx
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
push	es

loc_45E06:		; Load Full Pointer to ES:xx
les	si, [bp+arg_2]
add	si, di		; Add
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_45E1D	; Jump if Not Zero (ZF=0)

loc_45E1A:		; Increment by 1
inc	[bp+var_2]

loc_45E1D:		; CODE XREF: sub_45DC9+4Fj
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_A]

loc_45E2F:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
push	es

loc_45E3E:		; Load Full Pointer to ES:xx
les	si, [bp+arg_2]
add	si, di		; Add
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es

loc_45E4C:		; Compare Two Operands
cmp	[word ptr es:bx], 0A4h ; ''

loc_45E51:		; Jump if Zero (ZF=1)
jz	short loc_45E89
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax

loc_45E62:
mov	ax, [bp+arg_A]
mov	dx, 12C0h

loc_45E68:		; Signed Multiply
imul	dx
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx

loc_45E6E:		; Add
add	bx, ax
pop	ax

loc_45E71:		; Add
add	bx, ax
push	es
les	si, [bp+arg_2]	; Load Full Pointer to ES:xx
add	si, di		; Add
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es
cmp	[word ptr es:bx], 0A5h ; '' ; Compare Two Operands
jnz	short loc_45E8C	; Jump if Not Zero (ZF=0)

loc_45E89:		; CODE XREF: sub_45DC9:loc_45E51j
inc	[bp+var_4]	; Increment by 1

loc_45E8C:		; CODE XREF: sub_45DC9+BEj
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_A]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
push	es
les	si, [bp+arg_2]	; Load Full Pointer to ES:xx
add	si, di		; Add

loc_45EB2:
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jz	short loc_45EF8	; Jump if Zero (ZF=1)
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
add	bx, di		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_A]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
push	es
les	si, [bp+arg_2]	; Load Full Pointer to ES:xx
add	si, di		; Add
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es
cmp	[word ptr es:bx], 0A3h ; '' ; Compare Two Operands
jnz	short loc_45EFB	; Jump if Not Zero (ZF=0)

loc_45EF8:		; CODE XREF: sub_45DC9+F7j
inc	[bp+var_6]	; Increment by 1

loc_45EFB:		; CODE XREF: sub_45DC9+12Dj
inc	di		; Increment by 1

loc_45EFC:		; CODE XREF: sub_45DC9:loc_45DE2j
cmp	di, [bp+arg_0]	; Compare Two Operands
jge	short loc_45F04	; Jump if Greater or Equal (SF=OF)
jmp	loc_45DE5	; Jump

loc_45F04:		; CODE XREF: sub_45DC9+136j
mov	ax, 19h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_2], ax
mov	ax, 0Fh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_4], ax
mov	ax, 0Fh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_6], ax
mov	ax, [bp+var_4]
cmp	ax, [bp+var_2]	; Compare Two Operands
jle	short loc_45F90	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
cmp	ax, [bp+var_6]	; Compare Two Operands
jle	short loc_45F90	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_A]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
push	es
les	si, [bp+arg_2]	; Load Full Pointer to ES:xx
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es
mov	[word ptr es:bx], 0AAh ; ''
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
mov	[byte ptr es:bx], 2
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+arg_A]
nop			; No Operation
push	cs
call	near ptr sub_46029 ; Call Procedure
add	sp, 6		; Add
jmp	loc_46023	; Jump

loc_45F90:		; CODE XREF: sub_45DC9+168j
			; sub_45DC9+170j
mov	ax, [bp+var_2]
cmp	ax, [bp+var_6]	; Compare Two Operands
jle	short loc_45FD1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_A]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
push	es
les	si, [bp+arg_2]	; Load Full Pointer to ES:xx
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es
mov	[word ptr es:bx], 0A8h ; ''
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
mov	[byte ptr es:bx], 0
jmp	short loc_46008	; Jump

loc_45FD1:		; CODE XREF: sub_45DC9+1CDj
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_A]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
push	es
les	si, [bp+arg_2]	; Load Full Pointer to ES:xx
mov	al, [es:si]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	es
mov	[word ptr es:bx], 0A9h ; ''
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
mov	[byte ptr es:bx], 1

loc_46008:		; CODE XREF: sub_45DC9+206j
les	bx, [bp+arg_6]	; Load Full Pointer to ES:xx
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
les	bx, [bp+arg_2]	; Load Full Pointer to ES:xx
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+arg_A]
nop			; No Operation
push	cs
call	near ptr sub_46029 ; Call Procedure
add	sp, 6		; Add

loc_46023:		; CODE XREF: sub_45DC9+1C4j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_45DC9



; Attributes: bp-based frame

proc sub_46029 far	; CODE XREF: sub_3199BJ
			; sub_438C4+36Ap
			; sub_43C95+15Dp
			; sub_43C95+16Fp
			; sub_44A0E+1C1p
			; sub_44A0E+295p
			; sub_45389+1F9p
			; sub_45DC9+1BEp
			; sub_45DC9+254p

var_20=	word ptr -20h
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 20h		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
mov	[bp+var_2], 0

loc_4603C:		; Logical Exclusive OR
xor	cx, cx
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
jz	short loc_46087	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_20]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_46087:		; CODE XREF: sub_46029+32j
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr es:bx-1], 0 ;	Compare	Two Operands
jz	short loc_460D4	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx-1]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_20]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_460D4:		; CODE XREF: sub_46029+7Dj
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
jz	short loc_4611F	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_20]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_4611F:		; CODE XREF: sub_46029+C9j
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr es:bx+1], 0 ;	Compare	Two Operands
jz	short loc_4616C	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx+1]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_20]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_4616C:		; CODE XREF: sub_46029+115j
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr es:bx-1], 0 ;	Compare	Two Operands
jz	short loc_461B7	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx-1]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_20]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_461B7:		; CODE XREF: sub_46029+161j
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add

loc_461D0:		; Compare Two Operands
cmp	[byte ptr es:bx+1], 0
jz	short loc_46202	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx+1]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left

loc_461FA:		; Load Effective Address
lea	dx, [bp+var_20]
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_46202:		; CODE XREF: sub_46029+1ACj
mov	ax, si

loc_46204:
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr es:bx-1], 0 ;	Compare	Two Operands
jz	short loc_4624F	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_46230:
mov	ax, [bp+arg_4]
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx-1]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_20]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_4624F:		; CODE XREF: sub_46029+1F8j
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
jz	short loc_4629A	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_20]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_4629A:		; CODE XREF: sub_46029+244j
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr es:bx+1], 0 ;	Compare	Two Operands
jz	short loc_462E7	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [es:bx+1]
mov	ah, 0
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_20]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax

loc_462E6:		; Increment by 1
inc	cx

loc_462E7:		; CODE XREF: sub_46029+290j
or	cx, cx		; Logical Inclusive OR
jnz	short loc_46311	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [byte ptr word_3AD50]
mov	[es:bx], al
inc	[word_3AD50]	; Increment by 1
jmp	loc_46400	; Jump

loc_46311:		; CODE XREF: sub_46029+2C0j
mov	ax, [bp+var_20]
mov	[bp+var_2], ax
mov	[bp+var_4], 1
jmp	loc_463D9	; Jump

loc_4631F:		; CODE XREF: sub_46029+3B5j
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_20]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_2]	; Compare Two Operands
jnz	short loc_46333	; Jump if Not Zero (ZF=0)
jmp	loc_463D6	; Jump

loc_46333:		; CODE XREF: sub_46029+305j
mov	bx, [bp+var_4]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_20]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	[bp+var_C], ax
mov	ax, [bp+var_4]
mov	[bp+var_6], ax
jmp	short loc_4636D	; Jump

loc_4634A:		; CODE XREF: sub_46029+347j
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_20]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
cmp	ax, [bp+var_C]	; Compare Two Operands
jnz	short loc_4636A	; Jump if Not Zero (ZF=0)
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_20]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	[bx], ax

loc_4636A:		; CODE XREF: sub_46029+330j
inc	[bp+var_6]	; Increment by 1

loc_4636D:		; CODE XREF: sub_46029+31Fj
cmp	[bp+var_6], cx	; Compare Two Operands
jl	short loc_4634A	; Jump if Less (SF!=OF)
mov	[bp+var_A], 0
jmp	short loc_463D0	; Jump

loc_46379:		; CODE XREF: sub_46029+3ABj
mov	[bp+var_8], 0
jmp	short loc_463C7	; Jump

loc_46380:		; CODE XREF: sub_46029+3A2j
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_A]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
mov	al, [es:bx]
mov	ah, 0
cmp	ax, [bp+var_C]	; Compare Two Operands
jnz	short loc_463C4	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply

loc_463AB:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6F6]
add	bx, ax		; Add
mov	ax, [bp+var_A]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
mov	al, [byte ptr bp+var_2]
mov	[es:bx], al

loc_463C4:		; CODE XREF: sub_46029+379j
inc	[bp+var_8]	; Increment by 1

loc_463C7:		; CODE XREF: sub_46029+355j
cmp	[bp+var_8], 3Ch	; '<' ; Compare Two Operands
jl	short loc_46380	; Jump if Less (SF!=OF)
inc	[bp+var_A]	; Increment by 1

loc_463D0:		; CODE XREF: sub_46029+34Ej
cmp	[bp+var_A], 28h	; '(' ; Compare Two Operands
jl	short loc_46379	; Jump if Less (SF!=OF)

loc_463D6:		; CODE XREF: sub_46029+307j
inc	[bp+var_4]	; Increment by 1

loc_463D9:		; CODE XREF: sub_46029+2F3j
cmp	[bp+var_4], cx	; Compare Two Operands
jge	short loc_463E1	; Jump if Greater or Equal (SF=OF)
jmp	loc_4631F	; Jump

loc_463E1:		; CODE XREF: sub_46029+3B3j
mov	ax, si
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	al, [byte ptr bp+var_2]
mov	[es:bx], al

loc_46400:		; CODE XREF: sub_46029+2E5j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_46029



; Attributes: bp-based frame

proc sub_46406 far	; CODE XREF: sub_319A0J
			; idk_BuildingWorlds+18Cp

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
mov	[bp+var_2], 19h
xor	si, si		; Logical Exclusive OR
jmp	short loc_46461	; Jump

loc_46417:		; CODE XREF: sub_46406+5Ej
mov	ax, 0Bh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 32h	; '2'
imul	dx		; Signed Multiply
add	ax, 28Ah	; Add
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 3
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4644F:
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_467A7 ; Call Procedure
add	sp, 0Eh		; Add
inc	si		; Increment by 1

loc_46461:		; CODE XREF: sub_46406+Fj
cmp	si, 6		; Compare Two Operands
jl	short loc_46417	; Jump if Less (SF!=OF)
mov	si, 6
jmp	short loc_464B1	; Jump

loc_4646B:		; CODE XREF: sub_46406:loc_464B4j
mov	ax, 18h
push	ax		; int
mov	ax, si
add	ax, 0FFFAh	; Add
mov	dx, 18h
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6E6]
add	dx, ax		; Add
push	[word ptr dword_3A6E6+2] ; int
push	dx		; int
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6E6]
add	dx, ax		; Add
push	[word ptr dword_3A6E6+2] ; int
push	dx		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ah		; Add
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+2], 1
inc	si		; Increment by 1

loc_464B1:		; CODE XREF: sub_46406+63j
cmp	si, 0Ch		; Compare Two Operands

loc_464B4:		; Jump if Less (SF!=OF)
jl	short loc_4646B
xor	si, si		; Logical Exclusive OR
jmp	loc_46596	; Jump

loc_464BB:		; CODE XREF: sub_46406+195j
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_464C8:
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)
dec	ax		; Decrement by 1
imul	[word_3A4DE]	; Signed Multiply
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	bx, 6
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
inc	ax		; Increment by 1
mov	di, ax
cmp	di, 4		; Compare Two Operands
jle	short loc_464E8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_464E5:
mov	di, 4

loc_464E8:		; CODE XREF: sub_46406+DDj
cmp	di, 1		; Compare Two Operands
jge	short loc_464F0	; Jump if Greater or Equal (SF=OF)
mov	di, 1

loc_464F0:		; CODE XREF: sub_46406+E5j
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+4]
cbw			; AL ->	AX (with sign)
mov	dx, ax
pop	ax
imul	dx		; Signed Multiply
push	ax
mov	ax, 0Bh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 4		; Add
mov	dx, ax
pop	ax
imul	dx		; Signed Multiply
mov	dx, [word_3A4DE]
inc	dx		; Increment by 1
imul	dx		; Signed Multiply
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2Dh]
cbw			; AL ->	AX (with sign)
inc	ax		; Increment by 1
push	ax
push	di
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
add	ax, 0Ch		; Add
push	ax
nop			; No Operation
push	cs
call	near ptr sub_467A7 ; Call Procedure
add	sp, 0Eh		; Add
inc	si		; Increment by 1

loc_46596:		; CODE XREF: sub_46406+B2j
cmp	si, 1Eh		; Compare Two Operands
jge	short loc_4659E	; Jump if Greater or Equal (SF=OF)
jmp	loc_464BB	; Jump

loc_4659E:		; CODE XREF: sub_46406+193j
xor	si, si		; Logical Exclusive OR
jmp	loc_4668A	; Jump

loc_465A3:		; CODE XREF: sub_46406+1E1j
			; sub_46406+228j
			; sub_46406+289j
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_4], ax
mov	ax, 36h	; '6'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_8], ax
mov	ax, 22h	; '"'
push	ax

loc_465C5:		; Call Procedure
call	idk_Arg_0Fail_ElseMathyDiSi

loc_465CA:
pop	cx
add	ax, 2		; Add
mov	[bp+var_A], ax
push	[bp+var_4]
push	[bp+var_A]

loc_465D7:
push	[bp+var_8]
nop			; No Operation

loc_465DB:
push	cs

loc_465DC:		; Call Procedure
call	near ptr sub_4CF1C
add	sp, 6		; Add

loc_465E2:		; Compare Two Operands
cmp	ax, 1
jnz	short loc_465E9	; Jump if Not Zero (ZF=0)
jmp	short loc_465A3	; Jump

loc_465E9:		; CODE XREF: sub_46406+1DFj
mov	[bp+var_6], 0
jmp	short loc_46634	; Jump

loc_465F0:		; CODE XREF: sub_46406+236j
mov	ax, 3Ch	; '<'
push	ax
mov	ax, [bp+var_6]
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_6]
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_A]
push	[bp+var_8]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
cmp	ax, 2		; Compare Two Operands
jge	short loc_46631	; Jump if Greater or Equal (SF=OF)
jmp	loc_465A3	; Jump

loc_46631:		; CODE XREF: sub_46406+226j
inc	[bp+var_6]	; Increment by 1

loc_46634:		; CODE XREF: sub_46406+1E8j
mov	ax, si
add	ax, 2Ah	; '*'   ; Add
cmp	ax, [bp+var_6]	; Compare Two Operands
jg	short loc_465F0	; Jump if Greater (ZF=0	& SF=OF)

loc_4663E:		; Compare Two Operands
cmp	[bp+var_4], 0
jnz	short loc_46658	; Jump if Not Zero (ZF=0)
mov	ax, 1Dh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 32h	; '2'
imul	dx		; Signed Multiply
add	ax, 32h	; '2'   ; Add
jmp	short loc_4666A	; Jump

loc_46658:		; CODE XREF: sub_46406+23Cj
mov	ax, 18h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 64h	; 'd'
imul	dx		; Signed Multiply
add	ax, 64h	; 'd'   ; Add

loc_4666A:		; CODE XREF: sub_46406+250j
mov	di, ax
push	di
mov	ax, 4
push	ax
push	di
push	[bp+var_A]
push	[bp+var_8]
push	[bp+var_4]
mov	ax, si
add	ax, 2Ah	; '*'   ; Add
push	ax
nop			; No Operation
push	cs
call	near ptr sub_467A7 ; Call Procedure
add	sp, 0Eh		; Add
inc	si		; Increment by 1

loc_4668A:		; CODE XREF: sub_46406+19Aj
cmp	si, [bp+var_2]	; Compare Two Operands
jge	short loc_46692	; Jump if Greater or Equal (SF=OF)
jmp	loc_465A3	; Jump

loc_46692:		; CODE XREF: sub_46406+287j
xor	si, si		; Logical Exclusive OR
jmp	loc_46772	; Jump

loc_46697:		; CODE XREF: sub_46406+2D5j
			; sub_46406+31Cj
			; sub_46406+371j
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_4], ax
mov	ax, 36h	; '6'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_8], ax
mov	ax, 22h	; '"'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 2		; Add
mov	[bp+var_A], ax
push	[bp+var_4]
push	[bp+var_A]
push	[bp+var_8]
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add

loc_466D6:		; Compare Two Operands
cmp	ax, 1
jnz	short loc_466DD	; Jump if Not Zero (ZF=0)
jmp	short loc_46697	; Jump

loc_466DD:		; CODE XREF: sub_46406+2D3j
mov	[bp+var_6], 0
jmp	short loc_46728	; Jump

loc_466E4:		; CODE XREF: sub_46406+32Dj
mov	ax, 3Ch	; '<'
push	ax
mov	ax, [bp+var_6]
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [bp+var_6]
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx

loc_46708:		; Add
add	bx, ax
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_A]
push	[bp+var_8]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
cmp	ax, 2		; Compare Two Operands
jge	short loc_46725	; Jump if Greater or Equal (SF=OF)
jmp	loc_46697	; Jump

loc_46725:		; CODE XREF: sub_46406+31Aj
inc	[bp+var_6]	; Increment by 1

loc_46728:		; CODE XREF: sub_46406+2DCj
mov	ax, [bp+var_2]
add	ax, si		; Add
add	ax, 2Ah	; '*'   ; Add

loc_46730:		; Compare Two Operands
cmp	ax, [bp+var_6]
jg	short loc_466E4	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_46740	; Jump if Not Zero (ZF=0)
mov	ax, 0Ah
jmp	short loc_46743	; Jump

loc_46740:		; CODE XREF: sub_46406+333j
mov	ax, 14h

loc_46743:		; CODE XREF: sub_46406+338j
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	di, ax

loc_46751:
push	di

loc_46752:
mov	ax, 4
push	ax
push	di
push	[bp+var_A]
push	[bp+var_8]
push	[bp+var_4]

loc_46760:
mov	ax, si
add	ax, [bp+var_2]	; Add
add	ax, 2Ah	; '*'   ; Add
push	ax
nop			; No Operation
push	cs
call	near ptr sub_467A7 ; Call Procedure
add	sp, 0Eh		; Add
inc	si		; Increment by 1

loc_46772:		; CODE XREF: sub_46406+28Ej
cmp	si, 20h	; ' '   ; Compare Two Operands
jge	short loc_4677A	; Jump if Greater or Equal (SF=OF)
jmp	loc_46697	; Jump

loc_4677A:		; CODE XREF: sub_46406+36Fj
mov	ax, [bp+var_2]
add	ax, 4Ah	; 'J'   ; Add
mov	si, ax
jmp	short loc_46797	; Jump

loc_46784:		; CODE XREF: sub_46406+399j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+3], 0
inc	si		; Increment by 1

loc_46797:		; CODE XREF: sub_46406+37Cj
mov	ax, [bp+var_2]
add	ax, 4Dh	; 'M'   ; Add
cmp	ax, si		; Compare Two Operands
jg	short loc_46784	; Jump if Greater (ZF=0	& SF=OF)
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_46406



; Attributes: bp-based frame

proc sub_467A7 far	; CODE XREF: sub_319A5J
			; sub_46406+54p
			; sub_46406+189p
			; sub_46406+27Dp
			; sub_46406+365p

var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= byte ptr	 0Ah
arg_6= byte ptr	 0Ch
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
sub	sp, 0Eh		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]
xor	ax, ax		; Logical Exclusive OR
mov	dx, 4
push	ax
push	dx
mov	ax, [bp+arg_C]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [word_3A4DC]
inc	ax		; Increment by 1
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+arg_C], ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx

loc_467E0:		; Add
add	bx, ax
mov	al, [bp+arg_4]
mov	[es:bx], al
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [bp+arg_6]
mov	[es:bx+1], al
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+arg_2]
mov	[es:bx+2], al
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+3], 1
mov	bx, [bp+arg_A]
cmp	bx, 4		; switch 5 cases
ja	short loc_468A2	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4723D+bx] ; switch jump

loc_46831:		; DATA XREF: ovr051:off_4723Do
mov	ax, si		; case 0x0
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4], 0
jmp	short loc_468A2	; default

loc_46845:		; CODE XREF: sub_467A7+85j
			; DATA XREF: ovr051:off_4723Do
mov	ax, si		; case 0x3
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4], 1
jmp	short loc_468A2	; default

loc_46859:		; CODE XREF: sub_467A7+85j
			; DATA XREF: ovr051:off_4723Do
mov	ax, si		; case 0x2
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4], 2
jmp	short loc_468A2	; default

loc_4686D:		; CODE XREF: sub_467A7+85j
			; DATA XREF: ovr051:off_4723Do
mov	ax, si		; case 0x1
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4], 3
jmp	short loc_468A2	; default

loc_46881:		; CODE XREF: sub_467A7+85j
			; DATA XREF: ovr051:off_4723Do
mov	ax, 7		; case 0x4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	al, 3		; Add
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+4], al
jmp	short $+2	; Jump

loc_468A2:		; CODE XREF: sub_467A7+81j
			; sub_467A7+9Cj
			; sub_467A7+B0j
			; sub_467A7+C4j
			; sub_467A7+D8j
mov	ax, si		; default
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+0Ah], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+0Ch], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+10h], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Fh], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+5], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+7], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+6], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+8], 0
cmp	[bp+arg_A], 1	; Compare Two Operands
jnz	short loc_46954	; Jump if Not Zero (ZF=0)
mov	[bp+var_4], 11h
jmp	loc_46A52	; default

loc_46954:		; CODE XREF: sub_467A7+1A3j
cmp	[bp+arg_A], 3	; Compare Two Operands
jnz	short loc_46962	; Jump if Not Zero (ZF=0)
mov	[bp+var_4], 12h
jmp	loc_46A52	; default

loc_46962:		; CODE XREF: sub_467A7+1B1j
cmp	[bp+arg_A], 2	; Compare Two Operands
jnz	short loc_46970	; Jump if Not Zero (ZF=0)
mov	[bp+var_4], 10h
jmp	loc_46A52	; default

loc_46970:		; CODE XREF: sub_467A7+1BFj
cmp	[bp+arg_A], 0	; Compare Two Operands
jnz	short loc_469B7	; Jump if Not Zero (ZF=0)
mov	ax, 6
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 5		; switch 6 cases
ja	short loc_469B4	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_47231+bx] ; switch jump

loc_4698F:		; CODE XREF: sub_467A7:loc_46996j
			; DATA XREF: ovr051:off_47231o
mov	[bp+var_4], 14h	; case 0x0
jmp	short loc_469B4	; default

loc_46996:		; CODE XREF: sub_467A7+1E3j
			; DATA XREF: ovr051:off_47231o
jmp	short loc_4698F	; case 0x1

loc_46998:		; CODE XREF: sub_467A7+1E3j
			; DATA XREF: ovr051:off_47231o
mov	[bp+var_4], 12h	; case 0x2
jmp	short loc_469B4	; default

loc_4699F:		; CODE XREF: sub_467A7+1E3j
			; DATA XREF: ovr051:off_47231o
mov	[bp+var_4], 13h	; case 0x3
jmp	short loc_469B4	; default

loc_469A6:		; CODE XREF: sub_467A7+1E3j
			; DATA XREF: ovr051:off_47231o
mov	[bp+var_4], 10h	; case 0x4
jmp	short loc_469B4	; default

loc_469AD:		; CODE XREF: sub_467A7+1E3j
			; DATA XREF: ovr051:off_47231o
mov	[bp+var_4], 11h	; case 0x5
jmp	short $+2	; Jump

loc_469B4:		; CODE XREF: sub_467A7+1DFj
			; sub_467A7+1EDj
			; sub_467A7+1F6j
			; sub_467A7+1FDj
			; sub_467A7+204j
jmp	loc_46A52	; default

loc_469B7:		; CODE XREF: sub_467A7+1CDj
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+4], 6 ;	Compare	Two Operands
jz	short loc_469F3	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+4], 9 ;	Compare	Two Operands
jz	short loc_469F3	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+4], 0Ah	; Compare Two Operands
jnz	short loc_46A20	; Jump if Not Zero (ZF=0)

loc_469F3:		; CODE XREF: sub_467A7+222j
			; sub_467A7+236j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 3		; switch 4 cases
ja	short loc_46A1E	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_47229+bx] ; switch jump

loc_46A0C:		; CODE XREF: sub_467A7:loc_46A13j
			; sub_467A7:loc_46A15j
			; DATA XREF: ovr051:off_47229o
mov	[bp+var_4], 14h	; case 0x0
jmp	short loc_46A1E	; default

loc_46A13:		; CODE XREF: sub_467A7+260j
			; DATA XREF: ovr051:off_47229o
jmp	short loc_46A0C	; case 0x1

loc_46A15:		; CODE XREF: sub_467A7+260j
			; DATA XREF: ovr051:off_47229o
jmp	short loc_46A0C	; case 0x2

loc_46A17:		; CODE XREF: sub_467A7+260j
			; DATA XREF: ovr051:off_47229o
mov	[bp+var_4], 13h	; case 0x3
jmp	short $+2	; Jump

loc_46A1E:		; CODE XREF: sub_467A7+25Cj
			; sub_467A7+26Aj
jmp	short loc_46A52	; default

loc_46A20:		; CODE XREF: sub_467A7+24Aj
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 4		; switch 5 cases
ja	short loc_46A52	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4721F+bx] ; switch jump

loc_46A39:		; DATA XREF: ovr051:off_4721Fo
mov	[bp+var_4], 14h	; case 0x0

loc_46A3E:		; CODE XREF: sub_467A7+28Dj
			; DATA XREF: ovr051:off_4721Fo
mov	[bp+var_4], 14h	; case 0x1

loc_46A43:		; CODE XREF: sub_467A7+28Dj
			; DATA XREF: ovr051:off_4721Fo
mov	[bp+var_4], 12h	; case 0x2

loc_46A48:		; CODE XREF: sub_467A7+28Dj
			; DATA XREF: ovr051:off_4721Fo
mov	[bp+var_4], 12h	; case 0x3

loc_46A4D:		; CODE XREF: sub_467A7+28Dj
			; DATA XREF: ovr051:off_4721Fo
mov	[bp+var_4], 10h	; case 0x4

loc_46A52:		; CODE XREF: sub_467A7+1AAj
			; sub_467A7+1B8j
			; sub_467A7+1C6j
			; sub_467A7:loc_469B4j
			; sub_467A7:loc_46A1Ej
			; sub_467A7+289j
mov	[bp+var_E], 0	; default

loc_46A57:		; CODE XREF: sub_467A7+352j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
push	ax
mov	ax, [bp+arg_C]
cwd			; AX ->	DX:AX (with sign)
pop	bx
idiv	bx		; Signed Divide
mov	[bp+var_C], ax
mov	[bp+var_A], 0
mov	[bp+var_8], 0FFFFh
mov	[bp+var_2], 96h	; ''
jmp	short loc_46AE2	; Jump

loc_46A7D:		; CODE XREF: sub_467A7+340j
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+219h]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_46ADF	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+220h], 0 ;	Compare	Two Operands
jnz	short loc_46ADF	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]

loc_46AB0:		; Compare Two Operands
cmp	ax, [bp+var_A]
jle	short loc_46ADF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]
cmp	ax, [bp+var_C]	; Compare Two Operands
jge	short loc_46ADF	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]
mov	[bp+var_A], ax
mov	ax, [bp+var_2]
mov	[bp+var_8], ax

loc_46ADF:		; CODE XREF: sub_467A7+2E8j
			; sub_467A7+2F9j
			; sub_467A7+30Cj
			; sub_467A7+31Fj
inc	[bp+var_2]	; Increment by 1

loc_46AE2:		; CODE XREF: sub_467A7+2D4j
cmp	[bp+var_2], 0C6h ; '' ; Compare Two Operands
jl	short loc_46A7D	; Jump if Less (SF!=OF)
inc	[bp+var_E]	; Increment by 1
db 83h,7Eh,0F8h,0FFh ; <BAD>cmp	    [bp+var_8],	0FFFFh ; Compare Two Operands
jnz	short loc_46AFC	; Jump if Not Zero (ZF=0)
cmp	[bp+var_E], 0C8h ; '' ; Compare Two Operands
jge	short loc_46AFC	; Jump if Greater or Equal (SF=OF)
jmp	loc_46A57	; Jump

loc_46AFC:		; CODE XREF: sub_467A7+349j
			; sub_467A7+350j
cmp	[bp+var_E], 0C8h ; '' ; Compare Two Operands
jl	short loc_46B06	; Jump if Less (SF!=OF)
jmp	loc_46BF8	; Jump

loc_46B06:		; CODE XREF: sub_467A7+35Aj
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_8]
mov	[es:bx+5], al
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+5]
mov	ah, 0
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_C]
cwd			; AX ->	DX:AX (with sign)
pop	bx
idiv	[word ptr bx+216h] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], al
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+6], 1 ;	Compare	Two Operands
jbe	short loc_46B98	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_46B98	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+6]
add	al, 0FFh	; Add
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+6], al

loc_46B98:		; CODE XREF: sub_467A7+3BAj
			; sub_467A7+3C9j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+6], 8 ;	Compare	Two Operands
jbe	short loc_46BBE	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+6], 8

loc_46BBE:		; CODE XREF: sub_467A7+403j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+5]
mov	ah, 0
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+6]
mov	ah, 0
mov	dx, ax
pop	ax
imul	dx		; Signed Multiply
sub	[bp+arg_C], ax	; Integer Subtraction

loc_46BF8:		; CODE XREF: sub_467A7+35Cj
mov	[bp+var_E], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+6], 9 ;	Compare	Two Operands
jnz	short loc_46C14	; Jump if Not Zero (ZF=0)
jmp	loc_46DA8	; Jump

loc_46C14:		; CODE XREF: sub_467A7+468j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+6], 0 ;	Compare	Two Operands
jnz	short loc_46C2B	; Jump if Not Zero (ZF=0)
jmp	loc_46DA8	; Jump

loc_46C2B:		; CODE XREF: sub_467A7+47Fj
			; sub_467A7+556j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+6]
mov	ah, 0
mov	dx, 0Ah
sub	dx, ax		; Integer Subtraction
push	dx
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
push	ax
mov	ax, [bp+arg_C]
cwd			; AX ->	DX:AX (with sign)
pop	bx
idiv	bx		; Signed Divide
mov	[bp+var_C], ax
mov	[bp+var_A], 0
mov	[bp+var_8], 0FFFFh
mov	[bp+var_2], 96h	; ''
jmp	short loc_46CE3	; Jump

loc_46C66:		; CODE XREF: sub_467A7+543j
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+219h]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+var_4]	; Compare Two Operands
jnz	short loc_46CE0	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+220h], 0 ;	Compare	Two Operands
jnz	short loc_46CE0	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]
cmp	ax, [bp+var_A]	; Compare Two Operands
jle	short loc_46CE0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]
cmp	ax, [bp+var_C]	; Compare Two Operands
jge	short loc_46CE0	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+5]
mov	ah, 0
cmp	ax, [bp+var_2]	; Compare Two Operands
jz	short loc_46CE0	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]
mov	[bp+var_A], ax
mov	ax, [bp+var_2]
mov	[bp+var_8], ax

loc_46CE0:		; CODE XREF: sub_467A7+4D1j
			; sub_467A7+4E2j
			; sub_467A7+4F5j
			; sub_467A7+508j
			; sub_467A7+520j
inc	[bp+var_2]	; Increment by 1

loc_46CE3:		; CODE XREF: sub_467A7+4BDj
cmp	[bp+var_2], 0C6h ; '' ; Compare Two Operands
jge	short loc_46CED	; Jump if Greater or Equal (SF=OF)
jmp	loc_46C66	; Jump

loc_46CED:		; CODE XREF: sub_467A7+541j
inc	[bp+var_E]	; Increment by 1
db 83h,7Eh,0F8h,0FFh ; <BAD>cmp	    [bp+var_8],	0FFFFh ; Compare Two Operands
jnz	short loc_46D00	; Jump if Not Zero (ZF=0)
cmp	[bp+var_E], 0C8h ; '' ; Compare Two Operands
jge	short loc_46D00	; Jump if Greater or Equal (SF=OF)
jmp	loc_46C2B	; Jump

loc_46D00:		; CODE XREF: sub_467A7+54Dj
			; sub_467A7+554j
cmp	[bp+var_E], 0C8h ; '' ; Compare Two Operands
jl	short loc_46D0A	; Jump if Less (SF!=OF)
jmp	loc_46DA8	; Jump

loc_46D0A:		; CODE XREF: sub_467A7+55Ej
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_8]
mov	[es:bx+7], al
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_46D2B:
mov	al, [es:bx+7]
mov	ah, 0
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+arg_C]
cwd			; AX ->	DX:AX (with sign)
pop	bx
idiv	[word ptr bx+216h] ; Signed Divide
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_46D4F:
mov	[es:bx+8], al
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply

loc_46D5A:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6E6]
add	bx, ax		; Add
mov	al, [es:bx+6]
mov	ah, 0
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+8]
mov	ah, 0
pop	dx
add	dx, ax		; Add
cmp	dx, 9		; Compare Two Operands
jle	short loc_46DA8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, 9
sub	al, [es:bx+6]	; Integer Subtraction
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+8], al

loc_46DA8:		; CODE XREF: sub_467A7+46Aj
			; sub_467A7+481j
			; sub_467A7+560j
			; sub_467A7+5D9j
mov	ax, si

loc_46DAA:
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+5], 0 ;	Compare	Two Operands
jnz	short loc_46DCE	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_46DBE:
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+6], 0

loc_46DCE:		; CODE XREF: sub_467A7+613j
mov	ax, si

loc_46DD0:
mov	dx, 18h
imul	dx		; Signed Multiply

loc_46DD5:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6E6]
add	bx, ax		; Add

loc_46DDB:		; Compare Two Operands
cmp	[byte ptr es:bx+7], 0
jnz	short loc_46DF4	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+8], 0

loc_46DF4:		; CODE XREF: sub_467A7+639j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_46E01:
mov	al, [es:bx+5]
mov	ah, 0
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+6]
mov	ah, 0
mov	dx, ax
pop	ax
imul	dx		; Signed Multiply
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+7]
mov	ah, 0
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+216h]
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+8]
mov	ah, 0

loc_46E5E:
mov	dx, ax

loc_46E60:
pop	ax
imul	dx		; Signed Multiply
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
pop	dx
add	dx, ax		; Add
mov	di, dx
cmp	[word_3A4DC], 4	; Compare Two Operands
jz	short loc_46E8E	; Jump if Zero (ZF=1)
mov	ax, [word_3A4DC]
inc	ax		; Increment by 1
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
mov	cl, 2
call	LXLSH@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	di, ax

loc_46E8E:		; CODE XREF: sub_467A7+6CBj
cmp	[bp+arg_2], 0	; Compare Two Operands
jnz	short loc_46EAF	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
mov	dx, 64h	; 'd'
push	ax
push	dx
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
mov	ax, 4Ch	; 'L'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 31h	; '1'   ; Add
jmp	short loc_46EC8	; Jump

loc_46EAF:		; CODE XREF: sub_467A7+6EBj
xor	ax, ax		; Logical Exclusive OR
mov	dx, 64h	; 'd'
push	ax
push	dx
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
mov	ax, 64h	; 'd'
push	ax

loc_46EBF:		; Call Procedure
call	idk_Arg_0Fail_ElseMathyDiSi
pop	cx
add	ax, 4Bh	; 'K'   ; Add

loc_46EC8:		; CODE XREF: sub_467A7+706j
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	di, ax
cmp	di, 32h	; '2'   ; Compare Two Operands
jge	short loc_46EE1	; Jump if Greater or Equal (SF=OF)
mov	di, 32h	; '2'

loc_46EE1:		; CODE XREF: sub_467A7+735j
cmp	[bp+arg_A], 0	; Compare Two Operands
jnz	short loc_46F18	; Jump if Not Zero (ZF=0)
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_6], ax
mov	ax, [bp+var_6]
imul	[bp+var_6]	; Signed Multiply
mov	dx, 32h	; '2'
imul	dx		; Signed Multiply
add	ax, 0FF9Ch	; Add
sub	di, ax		; Integer Subtraction
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_6]
mov	[es:bx+0Eh], al

loc_46F18:		; CODE XREF: sub_467A7+73Ej
jmp	loc_47195	; default

loc_46F1B:		; CODE XREF: sub_467A7+9F3j
mov	ax, 0Fh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure

loc_46F24:
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 0Eh		; switch 15 cases
jbe	short loc_46F30	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_47195	; default

loc_46F30:		; CODE XREF: sub_467A7+784j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_47201+bx] ; switch jump

loc_46F37:		; DATA XREF: ovr051:off_47201o
mov	ax, 14h		; case 0x0
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure

loc_46F40:
pop	cx
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	[bp+var_6], ax
cmp	[bp+var_6], di	; Compare Two Operands
jle	short loc_46F51	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_6], di

loc_46F51:		; CODE XREF: sub_467A7+7A5j
mov	ax, [bp+var_6]

loc_46F54:
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	[bp+var_6], ax
sub	di, 0C8h ; ''  ; Integer Subtraction
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_6]
add	[es:bx+0Ah], ax	; Add
jmp	loc_47195	; default

loc_46F7D:		; CODE XREF: sub_467A7+78Bj
			; DATA XREF: ovr051:off_47201o
mov	ax, 14h		; case 0x2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	[bp+var_6], ax
cmp	[bp+var_6], di	; Compare Two Operands
jle	short loc_46F97	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_6], di

loc_46F97:		; CODE XREF: sub_467A7+7EBj
mov	ax, [bp+var_6]
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	[bp+var_6], ax
sub	di, 0C8h ; ''  ; Integer Subtraction
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply

loc_46FB3:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6E6]
add	bx, ax		; Add
mov	ax, [bp+var_6]
add	[es:bx+0Ch], ax	; Add

loc_46FC0:		; default
jmp	loc_47195

loc_46FC3:		; CODE XREF: sub_467A7+78Bj
			; DATA XREF: ovr051:off_47201o
mov	ax, si		; case 0x4
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_46FD0:		; Compare Two Operands
cmp	[byte ptr es:bx+10h], 3
jl	short loc_46FDA	; Jump if Less (SF!=OF)
jmp	loc_47066	; Jump

loc_46FDA:		; CODE XREF: sub_467A7+82Ej
cmp	di, 12Ch	; Compare Two Operands
jge	short loc_46FE3	; Jump if Greater or Equal (SF=OF)
jmp	loc_47066	; Jump

loc_46FE3:		; CODE XREF: sub_467A7+837j
mov	ax, 1Bh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 64h	; 'd'
imul	dx		; Signed Multiply
add	ax, 12Ch	; Add
mov	[bp+var_6], ax
cmp	[bp+var_6], di	; Compare Two Operands
jle	short loc_47000	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_6], di

loc_47000:		; CODE XREF: sub_467A7+854j
mov	ax, [bp+var_6]
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	[bp+var_6], ax
sub	di, [bp+var_6]	; Integer Subtraction
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left

loc_47028:
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_47036:
pop	ax
add	bx, ax		; Add
mov	ax, [bp+var_6]
mov	[es:bx+12h], ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4704D:
mov	al, [es:bx+10h]
inc	al		; Increment by 1
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply

loc_4705B:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6E6]
add	bx, ax		; Add
pop	ax
mov	[es:bx+10h], al

loc_47066:		; CODE XREF: sub_467A7+830j
			; sub_467A7+839j
jmp	loc_47195	; default

loc_47069:		; CODE XREF: sub_467A7+78Bj
			; DATA XREF: ovr051:off_47201o
cmp	di, 190h	; case 0x9
jl	short loc_47099	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4707C:		; Compare Two Operands
cmp	[byte ptr es:bx+0Fh], 0
jnz	short loc_47099	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Fh], 1
sub	di, 3E8h	; Integer Subtraction

loc_47099:		; CODE XREF: sub_467A7+8C6j
			; sub_467A7+8DAj
jmp	loc_47195	; default

loc_4709C:		; CODE XREF: sub_467A7+78Bj
			; DATA XREF: ovr051:off_47201o
mov	ax, 4		; case 0xA
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx

loc_470A6:
mov	[bp+var_6], ax
mov	ax, [bp+var_6]
imul	[bp+var_6]	; Signed Multiply
mov	dx, 32h	; '2'
imul	dx		; Signed Multiply
cmp	ax, di		; Compare Two Operands
jg	short loc_47126	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+0Eh], 4	; Compare Two Operands
jge	short loc_47126	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_6]
imul	[bp+var_6]	; Signed Multiply
mov	dx, 32h	; '2'
imul	dx		; Signed Multiply
sub	di, ax		; Integer Subtraction
mov	ax, si
mov	dx, 18h

loc_470DE:		; Signed Multiply
imul	dx
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
add	al, [byte ptr bp+var_6]	; Add
push	ax
mov	ax, si

loc_470F0:
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax

loc_470FC:
mov	[es:bx+0Eh], al
mov	ax, si

loc_47102:
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4710D:		; Compare Two Operands
cmp	[byte ptr es:bx+0Eh], 4
jle	short loc_47126	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 4

loc_47126:		; CODE XREF: sub_467A7+90Fj
			; sub_467A7+923j
			; sub_467A7+96Bj
jmp	short loc_47195	; default

loc_47128:		; CODE XREF: sub_467A7+78Bj
			; DATA XREF: ovr051:off_47201o
mov	ax, 4		; case 0xD
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_6], ax
cmp	[bp+var_6], 1	; Compare Two Operands
jnz	short loc_47159	; Jump if Not Zero (ZF=0)
cmp	di, 0BB8h	; Compare Two Operands
jl	short loc_47159	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4714E:
mov	[byte ptr es:bx+0Eh], 6
sub	di, 0BB8h	; Integer Subtraction
jmp	short loc_47193	; Jump

loc_47159:		; CODE XREF: sub_467A7+992j
			; sub_467A7+998j
cmp	di, 7D0h	; Compare Two Operands
jl	short loc_47177	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx

loc_4716A:		; Add
add	bx, ax

loc_4716C:
mov	[byte ptr es:bx+0Eh], 6
sub	di, 0BB8h	; Integer Subtraction
jmp	short loc_47193	; Jump

loc_47177:		; CODE XREF: sub_467A7+9B6j
cmp	di, 3E8h	; Compare Two Operands
jl	short loc_47193	; Jump if Less (SF!=OF)

loc_4717D:
mov	ax, si

loc_4717F:
mov	dx, 18h
imul	dx		; Signed Multiply

loc_47184:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6E6]
add	bx, ax		; Add

loc_4718A:
mov	[byte ptr es:bx+0Eh], 5
sub	di, 0BB8h	; Integer Subtraction

loc_47193:		; CODE XREF: sub_467A7+9B0j
			; sub_467A7+9CEj
			; sub_467A7+9D4j
jmp	short $+2	; Jump

loc_47195:		; CODE XREF: sub_467A7:loc_46F18j
			; sub_467A7+786j
			; sub_467A7+7D3j
			; sub_467A7:loc_46FC0j
			; sub_467A7:loc_47066j
			; sub_467A7:loc_47099j
			; sub_467A7:loc_47126j
cmp	di, 32h	; '2'   ; default
jl	short loc_4719D	; Jump if Less (SF!=OF)
jmp	loc_46F1B	; Jump

loc_4719D:		; CODE XREF: sub_467A7+9F1j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_471AA:		; Compare Two Operands
cmp	[byte ptr es:bx+0Eh], 4
jle	short loc_471FB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+0Ah], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_471D1:
mov	[word ptr es:bx+0Ch], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+10h], 0
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Fh], 0

loc_471FB:		; CODE XREF: sub_467A7+A08j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_467A7

off_47201 dw offset loc_46F37
			; DATA XREF: sub_467A7+78Br
dw offset loc_46F37	; jump table for switch	statement
dw offset loc_46F7D
dw offset loc_46F7D
dw offset loc_46FC3
dw offset loc_46FC3
dw offset loc_46FC3
dw offset loc_46FC3
dw offset loc_46FC3
dw offset loc_47069
dw offset loc_4709C
dw offset loc_4709C
dw offset loc_4709C
dw offset loc_47128
dw offset loc_47128
off_4721F dw offset loc_46A39
			; DATA XREF: sub_467A7+28Dr
dw offset loc_46A3E	; jump table for switch	statement
dw offset loc_46A43
dw offset loc_46A48
dw offset loc_46A4D
off_47229 dw offset loc_46A0C
			; DATA XREF: sub_467A7+260r
dw offset loc_46A13	; jump table for switch	statement
dw offset loc_46A15
dw offset loc_46A17
off_47231 dw offset loc_4698F
			; DATA XREF: sub_467A7+1E3r
dw offset loc_46996	; jump table for switch	statement
dw offset loc_46998
dw offset loc_4699F
dw offset loc_469A6
dw offset loc_469AD
off_4723D dw offset loc_46831
			; DATA XREF: sub_467A7+85r
dw offset loc_4686D	; jump table for switch	statement
dw offset loc_46859
dw offset loc_46845
dw offset loc_46881


; Attributes: bp-based frame

proc sub_47247 far	; CODE XREF: sub_319AAJ

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_47248:
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di

loc_4724F:
mov	di, [bp+arg_2]
xor	si, si		; Logical Exclusive OR
jmp	short loc_472B7	; Jump

loc_47256:		; CODE XREF: sub_47247+74j
mov	ax, 0C5h ; ''
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+219h]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jnz	short loc_472A0	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 24h	; '$'

loc_4727D:		; Signed Multiply
imul	dx

loc_4727F:
mov	bx, ax

loc_47281:
mov	al, [bx+218h]
cbw			; AL ->	AX (with sign)
cmp	ax, di		; Compare Two Operands
jg	short loc_472A0	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [bp+var_2]

loc_4728D:
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+20Eh], 0 ;	Compare	Two Operands
jz	short loc_472A0	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]

loc_4729E:		; CODE XREF: sub_47247+78j
jmp	short loc_472C1	; Jump

loc_472A0:		; CODE XREF: sub_47247+2Ej
			; sub_47247+41j
			; sub_47247+52j
cmp	si, 32h	; '2'   ; Compare Two Operands

loc_472A3:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_472B6

loc_472A5:
mov	ax, si
mov	bx, 0Ah
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
or	dx, dx		; Logical Inclusive OR
jnz	short loc_472B6	; Jump if Not Zero (ZF=0)
or	di, di		; Logical Inclusive OR
jle	short loc_472B6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
dec	di		; Decrement by 1

loc_472B6:		; CODE XREF: sub_47247:loc_472A3j
			; sub_47247+68j
			; sub_47247+6Cj
inc	si		; Increment by 1

loc_472B7:		; CODE XREF: sub_47247+Dj
cmp	si, 1F4h	; Compare Two Operands
jl	short loc_47256	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4729E	; Jump

loc_472C1:		; CODE XREF: sub_47247:loc_4729Ej
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_47247



; Attributes: bp-based frame

proc LBX_Terrtype_s472C7 far
			; CODE XREF: j_LBX_Terrtype_s472C7J
			; idk_BuildingWorlds+25Ap

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
mov	ax, 0A00h
push	ax		; arg_0
call	EMM_CheckAllocation ; Call Procedure
pop	cx
mov	[bp+var_A], ax
mov	ax, 200h
push	ax		; int
mov	ax, 5
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	[bp+var_A]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, offset strTERRTYPE ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_2], 0
jmp	loc_473CC	; Jump

loc_47301:		; CODE XREF: LBX_Terrtype_s472C7+10Bj
xor	di, di		; Logical Exclusive OR
jmp	loc_473C1	; Jump

loc_47306:		; CODE XREF: LBX_Terrtype_s472C7+FFj
xor	si, si		; Logical Exclusive OR
jmp	loc_473B8	; Jump

loc_4730B:		; CODE XREF: LBX_Terrtype_s472C7+F6j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add

loc_47322:
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 134h ; Compare Two Operands
jz	short loc_47332	; Jump if Zero (ZF=1)
jmp	loc_473B7	; Jump

loc_47332:		; CODE XREF: LBX_Terrtype_s472C7+66j
mov	[bp+var_8], 0FFFFh
jmp	short loc_473B1	; Jump

loc_47339:		; CODE XREF: LBX_Terrtype_s472C7+EEj
mov	[bp+var_6], 0FFFFh
jmp	short loc_473A8	; Jump

loc_47340:		; CODE XREF: LBX_Terrtype_s472C7+E5j
mov	ax, [bp+var_2]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_8]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
add	bx, si		; Add
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
jz	short loc_473A5	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
add	ax, [bp+var_8]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
add	bx, si		; Add
mov	al, [es:bx]
push	ax
mov	ax, [bp+var_2]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
pop	ax
mov	[es:bx], al

loc_473A5:		; CODE XREF: LBX_Terrtype_s472C7+9Cj
inc	[bp+var_6]	; Increment by 1

loc_473A8:		; CODE XREF: LBX_Terrtype_s472C7+77j
cmp	[bp+var_6], 2	; Compare Two Operands
jl	short loc_47340	; Jump if Less (SF!=OF)
inc	[bp+var_8]	; Increment by 1

loc_473B1:		; CODE XREF: LBX_Terrtype_s472C7+70j
cmp	[bp+var_8], 2	; Compare Two Operands
jl	short loc_47339	; Jump if Less (SF!=OF)

loc_473B7:		; CODE XREF: LBX_Terrtype_s472C7+68j
inc	si		; Increment by 1

loc_473B8:		; CODE XREF: LBX_Terrtype_s472C7+41j
cmp	si, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_473C0	; Jump if Greater or Equal (SF=OF)
jmp	loc_4730B	; Jump

loc_473C0:		; CODE XREF: LBX_Terrtype_s472C7+F4j
inc	di		; Increment by 1

loc_473C1:		; CODE XREF: LBX_Terrtype_s472C7+3Cj
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_473C9	; Jump if Greater or Equal (SF=OF)
jmp	loc_47306	; Jump

loc_473C9:		; CODE XREF: LBX_Terrtype_s472C7+FDj
inc	[bp+var_2]	; Increment by 1

loc_473CC:		; CODE XREF: LBX_Terrtype_s472C7+37j
cmp	[bp+var_2], 2	; Compare Two Operands
jge	short loc_473D5	; Jump if Greater or Equal (SF=OF)
jmp	loc_47301	; Jump

loc_473D5:		; CODE XREF: LBX_Terrtype_s472C7+109j
mov	[bp+var_2], 0
jmp	loc_47630	; Jump

loc_473DD:		; CODE XREF: LBX_Terrtype_s472C7+36Fj
xor	di, di		; Logical Exclusive OR
jmp	loc_47625	; Jump

loc_473E2:		; CODE XREF: LBX_Terrtype_s472C7+363j
xor	si, si		; Logical Exclusive OR
jmp	loc_4761C	; Jump

loc_473E7:		; CODE XREF: LBX_Terrtype_s472C7+35Aj
mov	ax, [bp+var_2]

loc_473EA:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A5h ; '' ; Compare Two Operands
jnz	short loc_4740E	; Jump if Not Zero (ZF=0)
jmp	loc_474A1	; Jump

loc_4740E:		; CODE XREF: LBX_Terrtype_s472C7+142j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0AEh ; '' ; Compare Two Operands
jz	short loc_474A1	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0AFh ; '' ; Compare Two Operands
jz	short loc_474A1	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]
mov	dx, 12C0h

loc_4745C:		; Signed Multiply
imul	dx
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0B0h ; '' ; Compare Two Operands
jz	short loc_474A1	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_47482:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 134h ; Compare Two Operands
jz	short loc_474A1	; Jump if Zero (ZF=1)
jmp	loc_4761B	; Jump

loc_474A1:		; CODE XREF: LBX_Terrtype_s472C7+144j
			; LBX_Terrtype_s472C7+169j
			; LBX_Terrtype_s472C7+18Dj
			; LBX_Terrtype_s472C7+1B1j
			; LBX_Terrtype_s472C7+1D5j
mov	[bp+var_4], 0
push	[bp+var_2]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_474CA	; Jump if Not Zero (ZF=0)
mov	ax, si
dec	ax		; Decrement by 1
jl	short loc_474CA	; Jump if Less (SF!=OF)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_474CA	; Jump if Less (SF!=OF)
inc	[bp+var_4]	; Increment by 1

loc_474CA:		; CODE XREF: LBX_Terrtype_s472C7+1F4j
			; LBX_Terrtype_s472C7+1F9j
			; LBX_Terrtype_s472C7+1FEj
push	[bp+var_2]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure

loc_474D7:		; Add
add	sp, 6
or	ax, ax		; Logical Inclusive OR
jnz	short loc_474E7	; Jump if Not Zero (ZF=0)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_474E7	; Jump if Less (SF!=OF)
add	[bp+var_4], 2	; Add

loc_474E7:		; CODE XREF: LBX_Terrtype_s472C7+215j
			; LBX_Terrtype_s472C7+21Aj
push	[bp+var_2]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_4750F	; Jump if Not Zero (ZF=0)
mov	ax, si
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_4750F	; Jump if Greater or Equal (SF=OF)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_4750F	; Jump if Less (SF!=OF)
add	[bp+var_4], 4	; Add

loc_4750F:		; CODE XREF: LBX_Terrtype_s472C7+235j
			; LBX_Terrtype_s472C7+23Dj
			; LBX_Terrtype_s472C7+242j
push	[bp+var_2]
push	di
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure
add	sp, 6		; Add

loc_4751F:		; Logical Inclusive OR
or	ax, ax
jnz	short loc_4752F	; Jump if Not Zero (ZF=0)
mov	ax, si
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_4752F	; Jump if Greater or Equal (SF=OF)

loc_4752B:		; Add
add	[bp+var_4], 8

loc_4752F:		; CODE XREF: LBX_Terrtype_s472C7+25Aj
			; LBX_Terrtype_s472C7+262j
push	[bp+var_2]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_4755A	; Jump if Not Zero (ZF=0)
mov	ax, si
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_4755A	; Jump if Greater or Equal (SF=OF)
mov	ax, di
inc	ax		; Increment by 1
cmp	ax, 28h	; '('   ; Compare Two Operands
jge	short loc_4755A	; Jump if Greater or Equal (SF=OF)
add	[bp+var_4], 10h	; Add

loc_4755A:		; CODE XREF: LBX_Terrtype_s472C7+27Dj
			; LBX_Terrtype_s472C7+285j
			; LBX_Terrtype_s472C7+28Dj
push	[bp+var_2]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_4757A	; Jump if Not Zero (ZF=0)
mov	ax, di
inc	ax		; Increment by 1
cmp	ax, 28h	; '('   ; Compare Two Operands
jge	short loc_4757A	; Jump if Greater or Equal (SF=OF)
add	[bp+var_4], 20h	; ' ' ; Add

loc_4757A:		; CODE XREF: LBX_Terrtype_s472C7+2A5j
			; LBX_Terrtype_s472C7+2ADj
push	[bp+var_2]
mov	ax, di

loc_4757F:		; Increment by 1
inc	ax

loc_47580:
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure

loc_4758A:		; Add
add	sp, 6
or	ax, ax		; Logical Inclusive OR
jnz	short loc_475A2	; Jump if Not Zero (ZF=0)
mov	ax, si
dec	ax		; Decrement by 1
jl	short loc_475A2	; Jump if Less (SF!=OF)
mov	ax, di
inc	ax		; Increment by 1
cmp	ax, 28h	; '('   ; Compare Two Operands
jge	short loc_475A2	; Jump if Greater or Equal (SF=OF)
add	[bp+var_4], 40h	; '@' ; Add

loc_475A2:		; CODE XREF: LBX_Terrtype_s472C7+2C8j
			; LBX_Terrtype_s472C7+2CDj
			; LBX_Terrtype_s472C7+2D5j
push	[bp+var_2]
push	di
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure
add	sp, 6		; Add

loc_475B2:		; Logical Inclusive OR
or	ax, ax
jnz	short loc_475C0	; Jump if Not Zero (ZF=0)

loc_475B6:
mov	ax, si
dec	ax		; Decrement by 1
jl	short loc_475C0	; Jump if Less (SF!=OF)

loc_475BB:		; Add
add	[bp+var_4], 80h	; ''

loc_475C0:		; CODE XREF: LBX_Terrtype_s472C7+2EDj
			; LBX_Terrtype_s472C7+2F2j
cmp	[bp+var_4], 0	; Compare Two Operands
jle	short loc_475F9	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_A]
add	bx, ax		; Add
mov	ax, [bx]
add	ax, 122h	; Add
push	ax
mov	ax, [bp+var_2]
mov	dx, 12C0h

loc_475DC:		; Signed Multiply
imul	dx
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	short loc_4761B	; Jump

loc_475F9:		; CODE XREF: LBX_Terrtype_s472C7+2FDj
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di

loc_47609:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A5h ; ''

loc_4761B:		; CODE XREF: LBX_Terrtype_s472C7+1D7j
			; LBX_Terrtype_s472C7+330j
inc	si		; Increment by 1

loc_4761C:		; CODE XREF: LBX_Terrtype_s472C7+11Dj
cmp	si, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_47624	; Jump if Greater or Equal (SF=OF)
jmp	loc_473E7	; Jump

loc_47624:		; CODE XREF: LBX_Terrtype_s472C7+358j
inc	di		; Increment by 1

loc_47625:		; CODE XREF: LBX_Terrtype_s472C7+118j
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_4762D	; Jump if Greater or Equal (SF=OF)
jmp	loc_473E2	; Jump

loc_4762D:		; CODE XREF: LBX_Terrtype_s472C7+361j
inc	[bp+var_2]	; Increment by 1

loc_47630:		; CODE XREF: LBX_Terrtype_s472C7+113j
cmp	[bp+var_2], 2	; Compare Two Operands
jge	short loc_47639	; Jump if Greater or Equal (SF=OF)
jmp	loc_473DD	; Jump

loc_47639:		; CODE XREF: LBX_Terrtype_s472C7+36Dj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Terrtype_s472C7 ; sp-analysis failed



; Attributes: bp-based frame

proc LBX_Terrtype_s4763F far
			; CODE XREF: j_LBX_Terrtype_s4763FJ
			; idk_BuildingWorlds+1FDp

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
mov	ax, 0A00h
push	ax		; arg_0
call	EMM_CheckAllocation ; Call Procedure
pop	cx
mov	[bp+var_A], ax
mov	ax, 200h
push	ax		; int
mov	ax, 5
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	[bp+var_A]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, offset strTERRTYPE ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_4], 0
jmp	loc_479FD	; Jump

loc_47679:		; CODE XREF: LBX_Terrtype_s4763F+3C4j
xor	di, di		; Logical Exclusive OR
jmp	loc_479F2	; Jump

loc_4767E:		; CODE XREF: LBX_Terrtype_s4763F+3B8j
mov	[bp+var_2], 0

loc_47683:		; Jump
jmp	loc_479E8

loc_47686:		; CODE XREF: LBX_Terrtype_s4763F+3AFj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands

loc_476A8:		; Jump if Zero (ZF=1)
jz	short loc_476AD
jmp	loc_479E5	; Jump

loc_476AD:		; CODE XREF: LBX_Terrtype_s4763F:loc_476A8j
mov	[bp+var_6], 0
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 0	; Compare Two Operands
jge	short loc_476C3	; Jump if Greater or Equal (SF=OF)
add	[bp+var_8], 3Ch	; '<' ; Add

loc_476C3:		; CODE XREF: LBX_Terrtype_s4763F+7Ej
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'

loc_476D7:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jb	short loc_47717	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_476F7:
mov	ax, di
dec	ax		; Decrement by 1

loc_476FA:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]

loc_47704:		; Shift	Logical	Left
shl	ax, 1
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
ja	short loc_47717	; Jump if Above	(CF=0 &	ZF=0)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_47717	; Jump if Less (SF!=OF)
inc	[bp+var_6]	; Increment by 1

loc_47717:		; CODE XREF: LBX_Terrtype_s4763F+A8j
			; LBX_Terrtype_s4763F+CEj
			; LBX_Terrtype_s4763F+D3j
mov	ax, [bp+var_4]

loc_4771A:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_47736:		; Compare Two Operands
cmp	[word ptr es:bx], 0A2h ; ''
jb	short loc_4776C	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4774B:
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
ja	short loc_4776C	; Jump if Above	(CF=0 &	ZF=0)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_4776C	; Jump if Less (SF!=OF)
add	[bp+var_6], 2	; Add

loc_4776C:		; CODE XREF: LBX_Terrtype_s4763F+FCj
			; LBX_Terrtype_s4763F+122j
			; LBX_Terrtype_s4763F+127j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 3Ch	; '<' ; Compare Two Operands
jl	short loc_4777D	; Jump if Less (SF!=OF)
sub	[bp+var_8], 3Ch	; '<' ; Integer Subtraction

loc_4777D:		; CODE XREF: LBX_Terrtype_s4763F+138j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_4779C:		; Compare Two Operands
cmp	[word ptr es:bx], 0A2h ; ''
jb	short loc_477D2	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left

loc_477C0:		; Add
add	bx, ax

loc_477C2:		; Compare Two Operands
cmp	[word ptr es:bx], 0ABh ; ''
ja	short loc_477D2	; Jump if Above	(CF=0 &	ZF=0)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_477D2	; Jump if Less (SF!=OF)
add	[bp+var_6], 4	; Add

loc_477D2:		; CODE XREF: LBX_Terrtype_s4763F+162j
			; LBX_Terrtype_s4763F+188j
			; LBX_Terrtype_s4763F+18Dj
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 3Ch	; '<' ; Compare Two Operands
jl	short loc_477E3	; Jump if Less (SF!=OF)
sub	[bp+var_8], 3Ch	; '<' ; Integer Subtraction

loc_477E3:		; CODE XREF: LBX_Terrtype_s4763F+19Ej
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jb	short loc_47831	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_47816:
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
ja	short loc_47831	; Jump if Above	(CF=0 &	ZF=0)

loc_4782D:		; Add
add	[bp+var_6], 8

loc_47831:		; CODE XREF: LBX_Terrtype_s4763F+1C7j
			; LBX_Terrtype_s4763F+1ECj
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 3Ch	; '<' ; Compare Two Operands
jl	short loc_47842	; Jump if Less (SF!=OF)
sub	[bp+var_8], 3Ch	; '<' ; Integer Subtraction

loc_47842:		; CODE XREF: LBX_Terrtype_s4763F+1FDj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jb	short loc_47897	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_47887:		; Compare Two Operands
cmp	[word ptr es:bx], 0ABh ; ''
ja	short loc_47897	; Jump if Above	(CF=0 &	ZF=0)
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_47897	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 10h	; Add

loc_47897:		; CODE XREF: LBX_Terrtype_s4763F+227j
			; LBX_Terrtype_s4763F+24Dj
			; LBX_Terrtype_s4763F+252j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_478B6:		; Compare Two Operands
cmp	[word ptr es:bx], 0A2h ; ''
jb	short loc_478EC	; Jump if Below	(CF=1)

loc_478BD:
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1

loc_478CE:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]

loc_478D8:		; Shift	Logical	Left
shl	ax, 1
add	bx, ax		; Add

loc_478DC:		; Compare Two Operands
cmp	[word ptr es:bx], 0ABh ; ''
ja	short loc_478EC	; Jump if Above	(CF=0 &	ZF=0)
cmp	di, 28h	; '('   ; Compare Two Operands

loc_478E6:		; Jump if Greater or Equal (SF=OF)
jge	short loc_478EC
add	[bp+var_6], 20h	; ' ' ; Add

loc_478EC:		; CODE XREF: LBX_Terrtype_s4763F+27Cj
			; LBX_Terrtype_s4763F+2A2j
			; LBX_Terrtype_s4763F:loc_478E6j
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 0	; Compare Two Operands
jge	short loc_478FD	; Jump if Greater or Equal (SF=OF)
add	[bp+var_8], 3Ch	; '<' ; Add

loc_478FD:		; CODE XREF: LBX_Terrtype_s4763F+2B8j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_47905:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jb	short loc_47952	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_47931:
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
ja	short loc_47952	; Jump if Above	(CF=0 &	ZF=0)
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_47952	; Jump if Greater or Equal (SF=OF)

loc_4794E:		; Add
add	[bp+var_6], 40h	; '@'

loc_47952:		; CODE XREF: LBX_Terrtype_s4763F+2E2j
			; LBX_Terrtype_s4763F+308j
			; LBX_Terrtype_s4763F+30Dj
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 0	; Compare Two Operands

loc_4795D:		; Jump if Greater or Equal (SF=OF)
jge	short loc_47963
add	[bp+var_8], 3Ch	; '<' ; Add

loc_47963:		; CODE XREF: LBX_Terrtype_s4763F:loc_4795Dj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_4796B:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left

loc_4797F:		; Add
add	bx, ax
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jb	short loc_479B2	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
ja	short loc_479B2	; Jump if Above	(CF=0 &	ZF=0)

loc_479AD:		; Add
add	[bp+var_6], 80h	; ''

loc_479B2:		; CODE XREF: LBX_Terrtype_s4763F+347j
			; LBX_Terrtype_s4763F+36Cj
cmp	[bp+var_6], 0	; Compare Two Operands
jle	short loc_479E5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
mov	si, [bp+var_A]
add	si, ax		; Add
mov	ax, [si]
mov	[es:bx], ax

loc_479E5:		; CODE XREF: LBX_Terrtype_s4763F+6Bj
			; LBX_Terrtype_s4763F+377j
inc	[bp+var_2]	; Increment by 1

loc_479E8:		; CODE XREF: LBX_Terrtype_s4763F:loc_47683j
cmp	[bp+var_2], 3Ch	; '<' ; Compare Two Operands
jge	short loc_479F1	; Jump if Greater or Equal (SF=OF)
jmp	loc_47686	; Jump

loc_479F1:		; CODE XREF: LBX_Terrtype_s4763F+3ADj
inc	di		; Increment by 1

loc_479F2:		; CODE XREF: LBX_Terrtype_s4763F+3Cj
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_479FA	; Jump if Greater or Equal (SF=OF)
jmp	loc_4767E	; Jump

loc_479FA:		; CODE XREF: LBX_Terrtype_s4763F+3B6j
inc	[bp+var_4]	; Increment by 1

loc_479FD:		; CODE XREF: LBX_Terrtype_s4763F+37j
cmp	[bp+var_4], 2	; Compare Two Operands
jge	short loc_47A06	; Jump if Greater or Equal (SF=OF)
jmp	loc_47679	; Jump

loc_47A06:		; CODE XREF: LBX_Terrtype_s4763F+3C2j
mov	[bp+var_4], 0
jmp	loc_47E9C	; Jump

loc_47A0E:		; CODE XREF: LBX_Terrtype_s4763F+863j
xor	di, di		; Logical Exclusive OR
jmp	loc_47E91	; Jump

loc_47A13:		; CODE XREF: LBX_Terrtype_s4763F+857j
mov	[bp+var_2], 0
jmp	loc_47E87	; Jump

loc_47A1B:		; CODE XREF: LBX_Terrtype_s4763F+84Ej
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply

loc_47A30:		; Add
add	bx, ax
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47A43	; Jump if Zero (ZF=1)
jmp	loc_47E84	; Jump

loc_47A43:		; CODE XREF: LBX_Terrtype_s4763F+3FFj
mov	[bp+var_6], 0
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47ABD	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 103h ; Compare Two Operands
jb	short loc_47ACB	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 112h ; Compare Two Operands
ja	short loc_47ACB	; Jump if Above	(CF=0 &	ZF=0)

loc_47ABD:		; CODE XREF: LBX_Terrtype_s4763F+42Ej
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
jl	short loc_47ACB	; Jump if Less (SF!=OF)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_47ACB	; Jump if Less (SF!=OF)
inc	[bp+var_6]	; Increment by 1

loc_47ACB:		; CODE XREF: LBX_Terrtype_s4763F+455j
			; LBX_Terrtype_s4763F+47Cj
			; LBX_Terrtype_s4763F+482j
			; LBX_Terrtype_s4763F+487j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47B3D	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 103h ; Compare Two Operands
jb	short loc_47B46	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 112h ; Compare Two Operands
ja	short loc_47B46	; Jump if Above	(CF=0 &	ZF=0)

loc_47B3D:		; CODE XREF: LBX_Terrtype_s4763F+4B0j
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_47B46	; Jump if Less (SF!=OF)
add	[bp+var_6], 2	; Add

loc_47B46:		; CODE XREF: LBX_Terrtype_s4763F+4D6j
			; LBX_Terrtype_s4763F+4FCj
			; LBX_Terrtype_s4763F+501j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47BBB	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 103h ; Compare Two Operands
jb	short loc_47BCD	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 112h ; Compare Two Operands
ja	short loc_47BCD	; Jump if Above	(CF=0 &	ZF=0)

loc_47BBB:		; CODE XREF: LBX_Terrtype_s4763F+52Cj
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_47BCD	; Jump if Greater or Equal (SF=OF)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_47BCD	; Jump if Less (SF!=OF)
add	[bp+var_6], 4	; Add

loc_47BCD:		; CODE XREF: LBX_Terrtype_s4763F+553j
			; LBX_Terrtype_s4763F+57Aj
			; LBX_Terrtype_s4763F+583j
			; LBX_Terrtype_s4763F+588j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47C3F	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 103h ; Compare Two Operands
jb	short loc_47C4C	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 112h ; Compare Two Operands
ja	short loc_47C4C	; Jump if Above	(CF=0 &	ZF=0)

loc_47C3F:		; CODE XREF: LBX_Terrtype_s4763F+5B2j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_47C4C	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 8	; Add

loc_47C4C:		; CODE XREF: LBX_Terrtype_s4763F+5D8j
			; LBX_Terrtype_s4763F+5FEj
			; LBX_Terrtype_s4763F+607j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47CC1	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 103h ; Compare Two Operands
jb	short loc_47CD3	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 112h ; Compare Two Operands
ja	short loc_47CD3	; Jump if Above	(CF=0 &	ZF=0)

loc_47CC1:		; CODE XREF: LBX_Terrtype_s4763F+632j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_47CD3	; Jump if Greater or Equal (SF=OF)
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_47CD3	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 10h	; Add

loc_47CD3:		; CODE XREF: LBX_Terrtype_s4763F+659j
			; LBX_Terrtype_s4763F+680j
			; LBX_Terrtype_s4763F+689j
			; LBX_Terrtype_s4763F+68Ej
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47D45	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 103h ; Compare Two Operands
jb	short loc_47D4E	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 112h ; Compare Two Operands
ja	short loc_47D4E	; Jump if Above	(CF=0 &	ZF=0)

loc_47D45:		; CODE XREF: LBX_Terrtype_s4763F+6B8j
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_47D4E	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 20h	; ' ' ; Add

loc_47D4E:		; CODE XREF: LBX_Terrtype_s4763F+6DEj
			; LBX_Terrtype_s4763F+704j
			; LBX_Terrtype_s4763F+709j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1

loc_47D5F:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47DC3	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 103h ; Compare Two Operands
jb	short loc_47DD2	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 112h ; Compare Two Operands
ja	short loc_47DD2	; Jump if Above	(CF=0 &	ZF=0)

loc_47DC3:		; CODE XREF: LBX_Terrtype_s4763F+734j
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
jl	short loc_47DD2	; Jump if Less (SF!=OF)
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_47DD2	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 40h	; '@' ; Add

loc_47DD2:		; CODE XREF: LBX_Terrtype_s4763F+75Bj
			; LBX_Terrtype_s4763F+782j
			; LBX_Terrtype_s4763F+788j
			; LBX_Terrtype_s4763F+78Dj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A4h ; '' ; Compare Two Operands
jz	short loc_47E44	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 103h ; Compare Two Operands
jb	short loc_47E4F	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 112h ; Compare Two Operands
ja	short loc_47E4F	; Jump if Above	(CF=0 &	ZF=0)

loc_47E44:		; CODE XREF: LBX_Terrtype_s4763F+7B7j
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
jl	short loc_47E4F	; Jump if Less (SF!=OF)
add	[bp+var_6], 80h	; '' ; Add

loc_47E4F:		; CODE XREF: LBX_Terrtype_s4763F+7DDj
			; LBX_Terrtype_s4763F+803j
			; LBX_Terrtype_s4763F+809j
cmp	[bp+var_6], 0	; Compare Two Operands
jle	short loc_47E84	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_47E5D:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
mov	si, [bp+var_A]
add	si, ax		; Add
mov	ax, [si+200h]
mov	[es:bx], ax

loc_47E84:		; CODE XREF: LBX_Terrtype_s4763F+401j
			; LBX_Terrtype_s4763F+814j
inc	[bp+var_2]	; Increment by 1

loc_47E87:		; CODE XREF: LBX_Terrtype_s4763F+3D9j
cmp	[bp+var_2], 3Ch	; '<' ; Compare Two Operands
jge	short loc_47E90	; Jump if Greater or Equal (SF=OF)
jmp	loc_47A1B	; Jump

loc_47E90:		; CODE XREF: LBX_Terrtype_s4763F+84Cj
inc	di		; Increment by 1

loc_47E91:		; CODE XREF: LBX_Terrtype_s4763F+3D1j
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_47E99	; Jump if Greater or Equal (SF=OF)
jmp	loc_47A13	; Jump

loc_47E99:		; CODE XREF: LBX_Terrtype_s4763F+855j
inc	[bp+var_4]	; Increment by 1

loc_47E9C:		; CODE XREF: LBX_Terrtype_s4763F+3CCj
cmp	[bp+var_4], 2	; Compare Two Operands
jge	short loc_47EA5	; Jump if Greater or Equal (SF=OF)
jmp	loc_47A0E	; Jump

loc_47EA5:		; CODE XREF: LBX_Terrtype_s4763F+861j
mov	[bp+var_4], 0
jmp	loc_4836E	; Jump

loc_47EAD:		; CODE XREF: LBX_Terrtype_s4763F+D35j
xor	di, di		; Logical Exclusive OR
jmp	loc_48363	; Jump

loc_47EB2:		; CODE XREF: LBX_Terrtype_s4763F+D29j
mov	[bp+var_2], 0
jmp	loc_48359	; Jump

loc_47EBA:		; CODE XREF: LBX_Terrtype_s4763F:loc_4835Fj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_47EE2	; Jump if Zero (ZF=1)
jmp	loc_48356	; Jump

loc_47EE2:		; CODE XREF: LBX_Terrtype_s4763F+89Ej
mov	[bp+var_6], 0
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 0	; Compare Two Operands
jge	short loc_47EF8	; Jump if Greater or Equal (SF=OF)
add	[bp+var_8], 3Ch	; '<' ; Add

loc_47EF8:		; CODE XREF: LBX_Terrtype_s4763F+8B3j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_47F72	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 25Ah ; Compare Two Operands
jb	short loc_47F6A	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]

loc_47F5F:		; Shift	Logical	Left
shl	ax, 1
add	bx, ax		; Add
cmp	[word ptr es:bx], 2FAh ; Compare Two Operands
jbe	short loc_47F72	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_47F6A:		; CODE XREF: LBX_Terrtype_s4763F+903j
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_47F72	; Jump if Less (SF!=OF)
inc	[bp+var_6]	; Increment by 1

loc_47F72:		; CODE XREF: LBX_Terrtype_s4763F+8DDj
			; LBX_Terrtype_s4763F+929j
			; LBX_Terrtype_s4763F+92Ej
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_47FED	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 25Ah ; Compare Two Operands
jb	short loc_47FE4	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_47FDD:		; Compare Two Operands
cmp	[word ptr es:bx], 2FAh
jbe	short loc_47FED	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_47FE4:		; CODE XREF: LBX_Terrtype_s4763F+97Dj
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_47FED	; Jump if Less (SF!=OF)
add	[bp+var_6], 2	; Add

loc_47FED:		; CODE XREF: LBX_Terrtype_s4763F+957j
			; LBX_Terrtype_s4763F+9A3j
			; LBX_Terrtype_s4763F+9A8j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 3Ch	; '<' ; Compare Two Operands
jl	short loc_47FFE	; Jump if Less (SF!=OF)

loc_47FFA:		; Integer Subtraction
sub	[bp+var_8], 3Ch	; '<'

loc_47FFE:		; CODE XREF: LBX_Terrtype_s4763F+9B9j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands

loc_48022:		; Jump if Zero (ZF=1)
jz	short loc_48079
mov	ax, [bp+var_4]
mov	dx, 12C0h

loc_4802A:		; Signed Multiply
imul	dx

loc_4802C:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1

loc_48035:
mov	dx, 78h	; 'x'

loc_48038:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 25Ah ; Compare Two Operands
jb	short loc_48070	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'

loc_4805E:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 2FAh ; Compare Two Operands
jbe	short loc_48079	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_48070:		; CODE XREF: LBX_Terrtype_s4763F+A09j
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_48079	; Jump if Less (SF!=OF)
add	[bp+var_6], 4	; Add

loc_48079:		; CODE XREF: LBX_Terrtype_s4763F:loc_48022j
			; LBX_Terrtype_s4763F+A2Fj
			; LBX_Terrtype_s4763F+A34j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 3Ch	; '<' ; Compare Two Operands
jl	short loc_4808A	; Jump if Less (SF!=OF)
sub	[bp+var_8], 3Ch	; '<' ; Integer Subtraction

loc_4808A:		; CODE XREF: LBX_Terrtype_s4763F+A45j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_48106	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 25Ah ; Compare Two Operands
jb	short loc_480F9	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_480DC:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 2FAh ; Compare Two Operands
jbe	short loc_48106	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_480F9:		; CODE XREF: LBX_Terrtype_s4763F+A93j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_48106	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 8	; Add

loc_48106:		; CODE XREF: LBX_Terrtype_s4763F+A6Ej
			; LBX_Terrtype_s4763F+AB8j
			; LBX_Terrtype_s4763F+AC1j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
mov	[bp+var_8], ax
cmp	[bp+var_8], 3Ch	; '<' ; Compare Two Operands
jl	short loc_48117	; Jump if Less (SF!=OF)
sub	[bp+var_8], 3Ch	; '<' ; Integer Subtraction

loc_48117:		; CODE XREF: LBX_Terrtype_s4763F+AD2j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_48192	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_4815C:		; Compare Two Operands
cmp	[word ptr es:bx], 25Ah
jb	short loc_48189	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 2FAh ; Compare Two Operands
jbe	short loc_48192	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_48189:		; CODE XREF: LBX_Terrtype_s4763F+B22j
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_48192	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 10h	; Add

loc_48192:		; CODE XREF: LBX_Terrtype_s4763F+AFCj
			; LBX_Terrtype_s4763F+B48j
			; LBX_Terrtype_s4763F+B4Dj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_4820D	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 25Ah ; Compare Two Operands
jb	short loc_48204	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 2FAh ; Compare Two Operands
jbe	short loc_4820D	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_48204:		; CODE XREF: LBX_Terrtype_s4763F+B9Dj
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_4820D	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 20h	; ' ' ; Add

loc_4820D:		; CODE XREF: LBX_Terrtype_s4763F+B77j
			; LBX_Terrtype_s4763F+BC3j
			; LBX_Terrtype_s4763F+BC8j
mov	ax, [bp+var_2]

loc_48210:		; Decrement by 1
dec	ax
mov	[bp+var_8], ax
cmp	[bp+var_8], 0	; Compare Two Operands
jge	short loc_4821E	; Jump if Greater or Equal (SF=OF)
add	[bp+var_8], 3Ch	; '<' ; Add

loc_4821E:		; CODE XREF: LBX_Terrtype_s4763F+BD9j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_48299	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left

loc_48261:		; Add
add	bx, ax
cmp	[word ptr es:bx], 25Ah ; Compare Two Operands
jb	short loc_48290	; Jump if Below	(CF=1)

loc_4826A:
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_48272:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di

loc_4827A:		; Increment by 1
inc	ax
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]

loc_48285:		; Shift	Logical	Left
shl	ax, 1
add	bx, ax		; Add
cmp	[word ptr es:bx], 2FAh ; Compare Two Operands
jbe	short loc_48299	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_48290:		; CODE XREF: LBX_Terrtype_s4763F+C29j
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_48299	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 40h	; '@' ; Add

loc_48299:		; CODE XREF: LBX_Terrtype_s4763F+C03j
			; LBX_Terrtype_s4763F+C4Fj
			; LBX_Terrtype_s4763F+C54j
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1

loc_4829D:
mov	[bp+var_8], ax

loc_482A0:		; Compare Two Operands
cmp	[bp+var_8], 0
jge	short loc_482AA	; Jump if Greater or Equal (SF=OF)
add	[bp+var_8], 3Ch	; '<' ; Add

loc_482AA:		; CODE XREF: LBX_Terrtype_s4763F+C65j
mov	ax, [bp+var_4]

loc_482AD:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_4831E	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 25Ah ; Compare Two Operands
jb	short loc_48319	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]

loc_482F7:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_48312:		; Compare Two Operands
cmp	[word ptr es:bx], 2FAh

loc_48317:		; Jump if Below	or Equal (CF=1 | ZF=1)
jbe	short loc_4831E

loc_48319:		; CODE XREF: LBX_Terrtype_s4763F+CB3j
add	[bp+var_6], 80h	; '' ; Add

loc_4831E:		; CODE XREF: LBX_Terrtype_s4763F+C8Ej
			; LBX_Terrtype_s4763F:loc_48317j
cmp	[bp+var_6], 0	; Compare Two Operands
jle	short loc_48356	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_6]

loc_48327:		; Shift	Logical	Left
shl	ax, 1
mov	bx, [bp+var_A]
add	bx, ax		; Add

loc_4832E:
mov	ax, [bx]

loc_48330:		; Add
add	ax, 258h

loc_48333:
push	ax
mov	ax, [bp+var_4]

loc_48337:
mov	dx, 12C0h

loc_4833A:		; Signed Multiply
imul	dx
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx

loc_48340:		; Add
add	bx, ax

loc_48342:
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax

loc_48356:		; CODE XREF: LBX_Terrtype_s4763F+8A0j
			; LBX_Terrtype_s4763F+CE3j
inc	[bp+var_2]	; Increment by 1

loc_48359:		; CODE XREF: LBX_Terrtype_s4763F+878j
cmp	[bp+var_2], 3Ch	; '<' ; Compare Two Operands
jge	short loc_48362	; Jump if Greater or Equal (SF=OF)

loc_4835F:		; Jump
jmp	loc_47EBA

loc_48362:		; CODE XREF: LBX_Terrtype_s4763F+D1Ej
inc	di		; Increment by 1

loc_48363:		; CODE XREF: LBX_Terrtype_s4763F+870j
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_4836B	; Jump if Greater or Equal (SF=OF)
jmp	loc_47EB2	; Jump

loc_4836B:		; CODE XREF: LBX_Terrtype_s4763F+D27j
inc	[bp+var_4]	; Increment by 1

loc_4836E:		; CODE XREF: LBX_Terrtype_s4763F+86Bj
cmp	[bp+var_4], 2	; Compare Two Operands
jge	short loc_48377	; Jump if Greater or Equal (SF=OF)
jmp	loc_47EAD	; Jump

loc_48377:		; CODE XREF: LBX_Terrtype_s4763F+D33j
mov	[bp+var_4], 0
jmp	loc_48812	; Jump

loc_4837F:		; CODE XREF: LBX_Terrtype_s4763F+11D9j
xor	di, di		; Logical Exclusive OR
jmp	loc_48807	; Jump

loc_48384:		; CODE XREF: LBX_Terrtype_s4763F+11CDj
mov	[bp+var_2], 0
jmp	loc_487FD	; Jump

loc_4838C:		; CODE XREF: LBX_Terrtype_s4763F+11C4j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
jz	short loc_483B4	; Jump if Zero (ZF=1)
jmp	loc_487FA	; Jump

loc_483B4:		; CODE XREF: LBX_Terrtype_s4763F+D70j
mov	[bp+var_6], 0
mov	ax, [bp+var_4]
mov	dx, 12C0h

loc_483BF:		; Signed Multiply
imul	dx
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'

loc_483CD:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, [bp+var_2]

loc_483D4:		; Decrement by 1
dec	ax
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands

loc_483DE:		; Jump if Zero (ZF=1)
jz	short loc_4842E
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 113h ; Compare Two Operands
jb	short loc_4843C	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add

loc_4841F:
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 123h ; Compare Two Operands
ja	short loc_4843C	; Jump if Above	(CF=0 &	ZF=0)

loc_4842E:		; CODE XREF: LBX_Terrtype_s4763F:loc_483DEj
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
jl	short loc_4843C	; Jump if Less (SF!=OF)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_4843C	; Jump if Less (SF!=OF)
inc	[bp+var_6]	; Increment by 1

loc_4843C:		; CODE XREF: LBX_Terrtype_s4763F+DC6j
			; LBX_Terrtype_s4763F+DEDj
			; LBX_Terrtype_s4763F+DF3j
			; LBX_Terrtype_s4763F+DF8j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1

loc_4844D:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
jz	short loc_484AE	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1

loc_48473:
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add

loc_4847A:
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 113h ; Compare Two Operands
jb	short loc_484B7	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 123h ; Compare Two Operands
ja	short loc_484B7	; Jump if Above	(CF=0 &	ZF=0)

loc_484AE:		; CODE XREF: LBX_Terrtype_s4763F+E21j
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_484B7	; Jump if Less (SF!=OF)
add	[bp+var_6], 2	; Add

loc_484B7:		; CODE XREF: LBX_Terrtype_s4763F+E47j
			; LBX_Terrtype_s4763F+E6Dj
			; LBX_Terrtype_s4763F+E72j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
jz	short loc_4852C	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left

loc_484FC:		; Add
add	bx, ax
cmp	[word ptr es:bx], 113h ; Compare Two Operands
jb	short loc_4853E	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
dec	ax		; Decrement by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 123h ; Compare Two Operands
ja	short loc_4853E	; Jump if Above	(CF=0 &	ZF=0)

loc_4852C:		; CODE XREF: LBX_Terrtype_s4763F+E9Dj
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_4853E	; Jump if Greater or Equal (SF=OF)
mov	ax, di
dec	ax		; Decrement by 1
jl	short loc_4853E	; Jump if Less (SF!=OF)
add	[bp+var_6], 4	; Add

loc_4853E:		; CODE XREF: LBX_Terrtype_s4763F+EC4j
			; LBX_Terrtype_s4763F+EEBj
			; LBX_Terrtype_s4763F+EF4j
			; LBX_Terrtype_s4763F+EF9j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_4855D:		; Compare Two Operands
cmp	[word ptr es:bx], 0ABh ; ''
jz	short loc_485B0	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 113h ; Compare Two Operands
jb	short loc_485BD	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 123h ; Compare Two Operands
ja	short loc_485BD	; Jump if Above	(CF=0 &	ZF=0)

loc_485B0:		; CODE XREF: LBX_Terrtype_s4763F+F23j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_485BD	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 8	; Add

loc_485BD:		; CODE XREF: LBX_Terrtype_s4763F+F49j
			; LBX_Terrtype_s4763F+F6Fj
			; LBX_Terrtype_s4763F+F78j
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
jz	short loc_48632	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 113h ; Compare Two Operands

loc_48609:		; Jump if Below	(CF=1)
jb	short loc_48644
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_48619:
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 123h ; Compare Two Operands
ja	short loc_48644	; Jump if Above	(CF=0 &	ZF=0)

loc_48632:		; CODE XREF: LBX_Terrtype_s4763F+FA3j
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
cmp	ax, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_48644	; Jump if Greater or Equal (SF=OF)
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_48644	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 10h	; Add

loc_48644:		; CODE XREF: LBX_Terrtype_s4763F:loc_48609j
			; LBX_Terrtype_s4763F+FF1j
			; LBX_Terrtype_s4763F+FFAj
			; LBX_Terrtype_s4763F+FFFj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]

loc_4865F:		; Shift	Logical	Left
shl	ax, 1
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
jz	short loc_486B6	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 113h ; Compare Two Operands
jb	short loc_486BF	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 123h ; Compare Two Operands
ja	short loc_486BF	; Jump if Above	(CF=0 &	ZF=0)

loc_486B6:		; CODE XREF: LBX_Terrtype_s4763F+1029j
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_486BF	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 20h	; ' ' ; Add

loc_486BF:		; CODE XREF: LBX_Terrtype_s4763F+104Fj
			; LBX_Terrtype_s4763F+1075j
			; LBX_Terrtype_s4763F+107Aj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
jz	short loc_48734	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 113h ; Compare Two Operands
jb	short loc_48743	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 123h ; Compare Two Operands
ja	short loc_48743	; Jump if Above	(CF=0 &	ZF=0)

loc_48734:		; CODE XREF: LBX_Terrtype_s4763F+10A5j
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
jl	short loc_48743	; Jump if Less (SF!=OF)
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_48743	; Jump if Greater or Equal (SF=OF)
add	[bp+var_6], 40h	; '@' ; Add

loc_48743:		; CODE XREF: LBX_Terrtype_s4763F+10CCj
			; LBX_Terrtype_s4763F+10F3j
			; LBX_Terrtype_s4763F+10F9j
			; LBX_Terrtype_s4763F+10FEj
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_4874B:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left

loc_48760:		; Add
add	bx, ax
cmp	[word ptr es:bx], 0ABh ; '' ; Compare Two Operands
jz	short loc_487B5	; Jump if Zero (ZF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'

loc_4877C:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 113h ; Compare Two Operands
jb	short loc_487C0	; Jump if Below	(CF=1)
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 123h ; Compare Two Operands
ja	short loc_487C0	; Jump if Above	(CF=0 &	ZF=0)

loc_487B5:		; CODE XREF: LBX_Terrtype_s4763F+1128j
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
jl	short loc_487C0	; Jump if Less (SF!=OF)
add	[bp+var_6], 80h	; '' ; Add

loc_487C0:		; CODE XREF: LBX_Terrtype_s4763F+114Ej
			; LBX_Terrtype_s4763F+1174j
			; LBX_Terrtype_s4763F+117Aj
cmp	[bp+var_6], 0	; Compare Two Operands
jle	short loc_487FA	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_A]
add	bx, ax		; Add
mov	ax, [bx+200h]
add	ax, 10h		; Add
push	ax

loc_487D8:
mov	ax, [bp+var_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply

loc_487E0:		; Load Full Pointer to ES:xx
les	bx, [dword_3A702]
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax

loc_487FA:		; CODE XREF: LBX_Terrtype_s4763F+D72j
			; LBX_Terrtype_s4763F+1185j
inc	[bp+var_2]	; Increment by 1

loc_487FD:		; CODE XREF: LBX_Terrtype_s4763F+D4Aj
cmp	[bp+var_2], 3Ch	; '<' ; Compare Two Operands
jge	short loc_48806	; Jump if Greater or Equal (SF=OF)
jmp	loc_4838C	; Jump

loc_48806:		; CODE XREF: LBX_Terrtype_s4763F+11C2j
inc	di		; Increment by 1

loc_48807:		; CODE XREF: LBX_Terrtype_s4763F+D42j
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_4880F	; Jump if Greater or Equal (SF=OF)
jmp	loc_48384	; Jump

loc_4880F:		; CODE XREF: LBX_Terrtype_s4763F+11CBj
inc	[bp+var_4]	; Increment by 1

loc_48812:		; CODE XREF: LBX_Terrtype_s4763F+D3Dj
cmp	[bp+var_4], 2	; Compare Two Operands
jge	short loc_4881B	; Jump if Greater or Equal (SF=OF)
jmp	loc_4837F	; Jump

loc_4881B:		; CODE XREF: LBX_Terrtype_s4763F+11D7j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Terrtype_s4763F ; sp-analysis failed



; Attributes: bp-based frame

proc LBX_Terrtype_s48821 far
			; CODE XREF: j_LBX_Terrtype_s48821J
			; idk_BuildingWorlds+269p

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
mov	ax, 0A00h
push	ax		; arg_0
call	EMM_CheckAllocation ; Call Procedure
pop	cx
mov	[bp+var_6], ax
mov	ax, 200h
push	ax		; int
mov	ax, 5
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	[bp+var_6]	; int
xor	ax, ax		; Logical Exclusive OR

loc_48846:		; int
push	ax
mov	ax, offset strTERRTYPE ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_2], 0
jmp	loc_48C44	; Jump

loc_4885B:		; CODE XREF: LBX_Terrtype_s48821+429j
xor	di, di		; Logical Exclusive OR
jmp	loc_48C39	; Jump

loc_48860:		; CODE XREF: LBX_Terrtype_s48821+41Dj
xor	si, si		; Logical Exclusive OR
jmp	loc_48C30	; Jump

loc_48865:		; CODE XREF: LBX_Terrtype_s48821+414j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_48880:		; Add
add	bx, ax
cmp	[word ptr es:bx], 0A2h ; '' ; Compare Two Operands
jz	short loc_4888C	; Jump if Zero (ZF=1)
jmp	loc_4893C	; default

loc_4888C:		; CODE XREF: LBX_Terrtype_s48821+66j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_4], ax
mov	bx, [bp+var_4]
dec	bx		; Decrement by 1
cmp	bx, 3		; switch 4 cases
jbe	short loc_488A5	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4893C	; default

loc_488A5:		; CODE XREF: LBX_Terrtype_s48821+7Fj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_48C5B+bx] ; switch jump

loc_488AC:		; DATA XREF: ovr051:off_48C5Bo
mov	ax, [bp+var_2]	; case 0x0
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'

loc_488BF:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
jmp	short loc_4893C	; default

loc_488D0:		; CODE XREF: LBX_Terrtype_s48821+86j
			; DATA XREF: ovr051:off_48C5Bo
mov	ax, [bp+var_2]	; case 0x1
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0B4h ; ''
jmp	short loc_4893C	; default

loc_488F4:		; CODE XREF: LBX_Terrtype_s48821+86j
			; DATA XREF: ovr051:off_48C5Bo
mov	ax, [bp+var_2]	; case 0x2
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0ACh ; ''
jmp	short loc_4893C	; default

loc_48918:		; CODE XREF: LBX_Terrtype_s48821+86j
			; DATA XREF: ovr051:off_48C5Bo
mov	ax, [bp+var_2]	; case 0x3
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0ADh ; ''
jmp	short $+2	; Jump

loc_4893C:		; CODE XREF: LBX_Terrtype_s48821+68j
			; LBX_Terrtype_s48821+81j
			; LBX_Terrtype_s48821+ADj
			; LBX_Terrtype_s48821+D1j
			; LBX_Terrtype_s48821+F5j
mov	ax, [bp+var_2]	; default
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A3h ; '' ; Compare Two Operands
jz	short loc_48963	; Jump if Zero (ZF=1)

loc_48960:		; Jump
jmp	loc_489F0

loc_48963:		; CODE XREF: LBX_Terrtype_s48821+13Dj
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
cmp	ax, 1		; Compare Two Operands
jz	short loc_48984	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_489A8	; Jump if Zero (ZF=1)
cmp	ax, 3		; Compare Two Operands
jz	short loc_489CC	; Jump if Zero (ZF=1)
jmp	short loc_489F0	; Jump

loc_48984:		; CODE XREF: LBX_Terrtype_s48821+155j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A3h ; ''
jmp	short loc_489F0	; Jump

loc_489A8:		; CODE XREF: LBX_Terrtype_s48821+15Aj
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0B7h ; ''
jmp	short loc_489F0	; Jump

loc_489CC:		; CODE XREF: LBX_Terrtype_s48821+15Fj
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0B8h ; ''
jmp	short $+2	; Jump

loc_489F0:		; CODE XREF: LBX_Terrtype_s48821:loc_48960j
			; LBX_Terrtype_s48821+161j
			; LBX_Terrtype_s48821+185j
			; LBX_Terrtype_s48821+1A9j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A5h ; '' ; Compare Two Operands
jz	short loc_48A17	; Jump if Zero (ZF=1)
jmp	loc_48AC7	; default

loc_48A17:		; CODE XREF: LBX_Terrtype_s48821+1F1j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_4], ax
mov	bx, [bp+var_4]
dec	bx		; Decrement by 1
cmp	bx, 3		; switch 4 cases
jbe	short loc_48A30	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_48AC7	; default

loc_48A30:		; CODE XREF: LBX_Terrtype_s48821+20Aj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_48C53+bx] ; switch jump

loc_48A37:		; DATA XREF: ovr051:off_48C53o
mov	ax, [bp+var_2]	; case 0x0
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A5h ; ''
jmp	short loc_48AC7	; default

loc_48A5B:		; CODE XREF: LBX_Terrtype_s48821+211j
			; DATA XREF: ovr051:off_48C53o
mov	ax, [bp+var_2]	; case 0x1
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0AEh ; ''
jmp	short loc_48AC7	; default

loc_48A7F:		; CODE XREF: LBX_Terrtype_s48821+211j
			; DATA XREF: ovr051:off_48C53o
mov	ax, [bp+var_2]	; case 0x2
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0AFh ; ''
jmp	short loc_48AC7	; default

loc_48AA3:		; CODE XREF: LBX_Terrtype_s48821+211j
			; DATA XREF: ovr051:off_48C53o
mov	ax, [bp+var_2]	; case 0x3
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0B0h ; ''
jmp	short $+2	; Jump

loc_48AC7:		; CODE XREF: LBX_Terrtype_s48821+1F3j
			; LBX_Terrtype_s48821+20Cj
			; LBX_Terrtype_s48821+238j
			; LBX_Terrtype_s48821+25Cj
			; LBX_Terrtype_s48821+280j
mov	ax, [bp+var_2]	; default
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A6h ; '' ; Compare Two Operands
jz	short loc_48AEE	; Jump if Zero (ZF=1)
jmp	loc_48B7B	; Jump

loc_48AEE:		; CODE XREF: LBX_Terrtype_s48821+2C8j
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
cmp	ax, 1		; Compare Two Operands
jz	short loc_48B0F	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jz	short loc_48B33	; Jump if Zero (ZF=1)
cmp	ax, 3		; Compare Two Operands
jz	short loc_48B57	; Jump if Zero (ZF=1)
jmp	short loc_48B7B	; Jump

loc_48B0F:		; CODE XREF: LBX_Terrtype_s48821+2E0j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A6h ; ''
jmp	short loc_48B7B	; Jump

loc_48B33:		; CODE XREF: LBX_Terrtype_s48821+2E5j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0B1h ; ''
jmp	short loc_48B7B	; Jump

loc_48B57:		; CODE XREF: LBX_Terrtype_s48821+2EAj
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0B2h ; ''
jmp	short $+2	; Jump

loc_48B7B:		; CODE XREF: LBX_Terrtype_s48821+2CAj
			; LBX_Terrtype_s48821+2ECj
			; LBX_Terrtype_s48821+310j
			; LBX_Terrtype_s48821+334j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A7h ; '' ; Compare Two Operands
jz	short loc_48BA2	; Jump if Zero (ZF=1)
jmp	loc_48C2F	; Jump

loc_48BA2:		; CODE XREF: LBX_Terrtype_s48821+37Cj
mov	ax, 3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
cmp	ax, 1		; Compare Two Operands
jz	short loc_48BC3	; Jump if Zero (ZF=1)
cmp	ax, 3		; Compare Two Operands
jz	short loc_48BE7	; Jump if Zero (ZF=1)
cmp	ax, 4		; Compare Two Operands
jz	short loc_48C0B	; Jump if Zero (ZF=1)
jmp	short loc_48C2F	; Jump

loc_48BC3:		; CODE XREF: LBX_Terrtype_s48821+394j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx

loc_48BCF:		; Add
add	bx, ax
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A7h ; ''
jmp	short loc_48C2F	; Jump

loc_48BE7:		; CODE XREF: LBX_Terrtype_s48821+399j
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0B5h ; ''
jmp	short loc_48C2F	; Jump

loc_48C0B:		; CODE XREF: LBX_Terrtype_s48821+39Ej
mov	ax, [bp+var_2]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0B6h ; ''
jmp	short $+2	; Jump

loc_48C2F:		; CODE XREF: LBX_Terrtype_s48821+37Ej
			; LBX_Terrtype_s48821+3A0j
			; LBX_Terrtype_s48821+3C4j
			; LBX_Terrtype_s48821+3E8j
inc	si		; Increment by 1

loc_48C30:		; CODE XREF: LBX_Terrtype_s48821+41j
cmp	si, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_48C38	; Jump if Greater or Equal (SF=OF)
jmp	loc_48865	; Jump

loc_48C38:		; CODE XREF: LBX_Terrtype_s48821+412j
inc	di		; Increment by 1

loc_48C39:		; CODE XREF: LBX_Terrtype_s48821+3Cj
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_48C41	; Jump if Greater or Equal (SF=OF)
jmp	loc_48860	; Jump

loc_48C41:		; CODE XREF: LBX_Terrtype_s48821+41Bj
inc	[bp+var_2]	; Increment by 1

loc_48C44:		; CODE XREF: LBX_Terrtype_s48821+37j
cmp	[bp+var_2], 2	; Compare Two Operands
jge	short loc_48C4D	; Jump if Greater or Equal (SF=OF)
jmp	loc_4885B	; Jump

loc_48C4D:		; CODE XREF: LBX_Terrtype_s48821+427j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Terrtype_s48821 ; sp-analysis failed

off_48C53 dw offset loc_48A37
			; DATA XREF: LBX_Terrtype_s48821+211r
dw offset loc_48A5B	; jump table for switch	statement
dw offset loc_48A7F
dw offset loc_48AA3
off_48C5B dw offset loc_488AC
			; DATA XREF: LBX_Terrtype_s48821+86r
dw offset loc_488D0	; jump table for switch	statement
dw offset loc_488F4
dw offset loc_48918


; Attributes: bp-based frame

proc sub_48C63 far	; CODE XREF: sub_319BEJ
			; idk_BuildingWorlds+218p
			; idk_BuildingWorlds+231p

var_D0=	word ptr -0D0h
var_96=	word ptr -96h
var_94=	word ptr -94h
var_5A=	word ptr -5Ah
var_58=	word ptr -58h
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 0D0h	; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_0]
mov	ax, 52
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 4		; Add
mov	[bp+var_4], ax
mov	ax, 32
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 4		; Add
mov	[bp+var_6], ax
mov	ax, di
mov	dx, 2400
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_6]
mov	dx, 60
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_4]	; Add
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
jz	short loc_48CB4	; Jump if Zero (ZF=1)

loc_48CAF:		; CODE XREF: sub_48C63+69j
			; sub_48C63+81j
			; sub_48C63+9Bj
			; sub_48C63+B3j
			; sub_48C63+C9j
			; sub_48C63+E1j
			; sub_48C63+FCj
			; sub_48C63+115j
			; sub_48C63+130j
			; sub_48C63+147j
			; sub_48C63+15Ej
			; sub_48C63+175j
			; sub_48C63+18Cj
			; sub_48C63+259j
			; sub_48C63+3A1j
			; sub_48C63+3B9j
			; sub_48C63+3F1j
			; sub_48C63+40Aj
			; sub_48C63+421j
			; sub_48C63+43Aj
			; sub_48C63+453j
xor	ax, ax		; Logical Exclusive OR

loc_48CB1:		; CODE XREF: sub_48C63+4A3j
jmp	loc_49109	; Jump

loc_48CB4:		; CODE XREF: sub_48C63+4Aj
push	di
mov	ax, [bp+var_6]
dec	ax		; Decrement by 1
push	ax
mov	ax, [bp+var_4]
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48CCE	; Jump if Not Zero (ZF=0)
jmp	short loc_48CAF	; Jump

loc_48CCE:		; CODE XREF: sub_48C63+67j
push	di
push	[bp+var_6]
mov	ax, [bp+var_4]
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48CE6	; Jump if Not Zero (ZF=0)
jmp	short loc_48CAF	; Jump

loc_48CE6:		; CODE XREF: sub_48C63+7Fj
push	di
mov	ax, [bp+var_6]
inc	ax		; Increment by 1
push	ax
mov	ax, [bp+var_4]
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48D00	; Jump if Not Zero (ZF=0)
jmp	short loc_48CAF	; Jump

loc_48D00:		; CODE XREF: sub_48C63+99j
push	di
mov	ax, [bp+var_6]
dec	ax		; Decrement by 1
push	ax
push	[bp+var_4]
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48D18	; Jump if Not Zero (ZF=0)
jmp	short loc_48CAF	; Jump

loc_48D18:		; CODE XREF: sub_48C63+B1j
push	di
push	[bp+var_6]
push	[bp+var_4]
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48D2E	; Jump if Not Zero (ZF=0)
jmp	short loc_48CAF	; Jump

loc_48D2E:		; CODE XREF: sub_48C63+C7j
push	di
mov	ax, [bp+var_6]
inc	ax		; Increment by 1
push	ax
push	[bp+var_4]
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48D47	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_48D47:		; CODE XREF: sub_48C63+DFj
push	di
mov	ax, [bp+var_6]
dec	ax		; Decrement by 1
push	ax
mov	ax, [bp+var_4]
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48D62	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_48D62:		; CODE XREF: sub_48C63+FAj
push	di
push	[bp+var_6]
mov	ax, [bp+var_4]
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48D7B	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_48D7B:		; CODE XREF: sub_48C63+113j
push	di
mov	ax, [bp+var_6]
inc	ax		; Increment by 1
push	ax
mov	ax, [bp+var_4]
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48D96	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_48D96:		; CODE XREF: sub_48C63+12Ej
push	di
push	[bp+var_6]
push	[bp+var_4]
nop			; No Operation
push	cs
call	near ptr sub_4D1AE ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48DAD	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_48DAD:		; CODE XREF: sub_48C63+145j
push	di
push	[bp+var_6]
push	[bp+var_4]
nop			; No Operation
push	cs
call	near ptr sub_4D1F9 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48DC4	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_48DC4:		; CODE XREF: sub_48C63+15Cj
push	di
push	[bp+var_6]
push	[bp+var_4]
nop			; No Operation
push	cs
call	near ptr sub_4CF8C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48DDB	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_48DDB:		; CODE XREF: sub_48C63+173j
push	di
push	[bp+var_6]
push	[bp+var_4]
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48DF2	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_48DF2:		; CODE XREF: sub_48C63+18Aj
mov	ax, [bp+var_4]
mov	[bp+var_58], ax
mov	ax, [bp+var_6]
mov	[bp+var_94], ax
mov	[bp+var_2], 1
mov	[bp+var_10], 0
mov	[bp+var_12], 0
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
mov	[bp+var_A], 0FFFFh
mov	ax, [bp+var_8]
mov	[bp+var_D0], ax
jmp	loc_4900D	; Jump

loc_48E2B:		; CODE XREF: sub_48C63+27Cj
			; sub_48C63+293j
			; sub_48C63+2AAj
			; sub_48C63+2C1j
			; sub_48C63+2D8j
			; sub_48C63+3B0j
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jg	short loc_48E40	; Jump if Greater (ZF=0	& SF=OF)
db 83h,7Eh,0F6h,0FFh ; <BAD>cmp	    [bp+var_A],	0FFFFh ; Compare Two Operands
jnz	short loc_48E48	; Jump if Not Zero (ZF=0)

loc_48E40:		; CODE XREF: sub_48C63+1D5j
mov	ax, [bp+var_8]
mov	[bp+var_E], ax
jmp	short loc_48E66	; Jump

loc_48E48:		; CODE XREF: sub_48C63+1DBj
			; sub_48C63+201j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_E], ax
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+3348h]
cmp	ax, [bp+var_E]	; Compare Two Operands
jnz	short loc_48E66	; Jump if Not Zero (ZF=0)
jmp	short loc_48E48	; Jump

loc_48E66:		; CODE XREF: sub_48C63+1E3j
			; sub_48C63+1FFj
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_D0]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	[bx], ax
mov	ax, [bp+var_E]
mov	[bp+var_A], ax
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_5A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	bx, [bp+var_E]
shl	bx, 1		; Shift	Logical	Left
add	ax, [bx+3334h]	; Add
mov	[bp+var_14], ax
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_96]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	bx, [bp+var_E]
shl	bx, 1		; Shift	Logical	Left
add	ax, [bx+333Eh]	; Add
mov	[bp+var_16], ax
mov	ax, [bp+var_E]
mov	[bp+var_18], ax
inc	[bp+var_12]	; Increment by 1
cmp	[bp+var_12], 1Eh ; Compare Two Operands
jle	short loc_48EBF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_48CAF	; Jump

loc_48EBF:		; CODE XREF: sub_48C63+257j
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_16]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_14]	; Add
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
jz	short loc_48EE2	; Jump if Zero (ZF=1)
jmp	loc_48E2B	; Jump

loc_48EE2:		; CODE XREF: sub_48C63+27Aj
push	di
push	[bp+var_16]
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_4D1AE ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48EF9	; Jump if Not Zero (ZF=0)
jmp	loc_48E2B	; Jump

loc_48EF9:		; CODE XREF: sub_48C63+291j
push	di
push	[bp+var_16]
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_4D1F9 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48F10	; Jump if Not Zero (ZF=0)
jmp	loc_48E2B	; Jump

loc_48F10:		; CODE XREF: sub_48C63+2A8j
push	di
push	[bp+var_16]
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_4CF8C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48F27	; Jump if Not Zero (ZF=0)
jmp	loc_48E2B	; Jump

loc_48F27:		; CODE XREF: sub_48C63+2BFj
push	di
push	[bp+var_16]
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48F3E	; Jump if Not Zero (ZF=0)
jmp	loc_48E2B	; Jump

loc_48F3E:		; CODE XREF: sub_48C63+2D6j
push	di
push	[bp+var_16]
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48F57	; Jump if Not Zero (ZF=0)
mov	[bp+var_10], 1

loc_48F57:		; CODE XREF: sub_48C63+2EDj
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_58]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bp+var_14]
mov	[bx], ax
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_94]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bp+var_16]
mov	[bx], ax
inc	[bp+var_2]	; Increment by 1
push	di
mov	ax, [bp+var_16]
dec	ax		; Decrement by 1
push	ax
push	[bp+var_14]
nop			; No Operation
push	cs

loc_48F84:		; Call Procedure
call	near ptr sub_4CF1C
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands

loc_48F8D:		; Jump if Not Zero (ZF=0)
jnz	short loc_48F94
mov	[bp+var_10], 1

loc_48F94:		; CODE XREF: sub_48C63:loc_48F8Dj
push	di
push	[bp+var_16]
mov	ax, [bp+var_14]
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48FAF	; Jump if Not Zero (ZF=0)
mov	[bp+var_10], 1

loc_48FAF:		; CODE XREF: sub_48C63+345j
push	di
push	[bp+var_16]
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add

loc_48FBE:		; Compare Two Operands
cmp	ax, 1
jnz	short loc_48FC8	; Jump if Not Zero (ZF=0)
mov	[bp+var_10], 1

loc_48FC8:		; CODE XREF: sub_48C63+35Ej
push	di
push	[bp+var_16]

loc_48FCC:
mov	ax, [bp+var_14]
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48FE3	; Jump if Not Zero (ZF=0)
mov	[bp+var_10], 1

loc_48FE3:		; CODE XREF: sub_48C63+379j
push	di
mov	ax, [bp+var_16]
inc	ax		; Increment by 1
push	ax
push	[bp+var_14]
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_48FFE	; Jump if Not Zero (ZF=0)
mov	[bp+var_10], 1

loc_48FFE:		; CODE XREF: sub_48C63+394j
cmp	[bp+var_2], 1Ch	; Compare Two Operands
jle	short loc_49007	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_48CAF	; Jump

loc_49007:		; CODE XREF: sub_48C63+39Fj
mov	ax, [bp+var_E]
mov	[bp+var_A], ax

loc_4900D:		; CODE XREF: sub_48C63+1C5j
cmp	[bp+var_10], 0	; Compare Two Operands
jnz	short loc_49016	; Jump if Not Zero (ZF=0)
jmp	loc_48E2B	; Jump

loc_49016:		; CODE XREF: sub_48C63+3AEj
cmp	[bp+var_2], 4	; Compare Two Operands
jge	short loc_4901F	; Jump if Greater or Equal (SF=OF)
jmp	loc_48CAF	; Jump

loc_4901F:		; CODE XREF: sub_48C63+3B7j
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_5A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	[bp+var_1A], ax
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_96]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	[bp+var_1C], ax
push	di
mov	ax, [bp+var_1C]
dec	ax		; Decrement by 1
push	ax
push	[bp+var_1A]
nop			; No Operation
push	cs
call	near ptr sub_4CAAF ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_49057	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_49057:		; CODE XREF: sub_48C63+3EFj
push	di
push	[bp+var_1C]
mov	ax, [bp+var_1A]
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAAF ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_49070	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_49070:		; CODE XREF: sub_48C63+408j
push	di
push	[bp+var_1C]
push	[bp+var_1A]
nop			; No Operation
push	cs
call	near ptr sub_4CAAF ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_49087	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_49087:		; CODE XREF: sub_48C63+41Fj
push	di
push	[bp+var_1C]
mov	ax, [bp+var_1A]
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CAAF ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_490A0	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_490A0:		; CODE XREF: sub_48C63+438j
push	di
mov	ax, [bp+var_1C]
inc	ax		; Increment by 1
push	ax
push	[bp+var_1A]
nop			; No Operation
push	cs
call	near ptr sub_4CAAF ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_490B9	; Jump if Not Zero (ZF=0)
jmp	loc_48CAF	; Jump

loc_490B9:		; CODE XREF: sub_48C63+451j
mov	[bp+var_C], 0
jmp	short loc_490FB	; Jump

loc_490C0:		; CODE XREF: sub_48C63+49Ej
mov	bx, [bp+var_C]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_94]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
push	ax
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
mov	si, [bp+var_C]
shl	si, 1		; Shift	Logical	Left
lea	ax, [bp+var_58]	; Load Effective Address
add	si, ax		; Add
mov	ax, [si]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 3E8h
inc	[bp+var_C]	; Increment by 1

loc_490FB:		; CODE XREF: sub_48C63+45Bj
mov	ax, [bp+var_C]
cmp	ax, [bp+var_2]	; Compare Two Operands
jl	short loc_490C0	; Jump if Less (SF!=OF)
mov	ax, 1
jmp	loc_48CB1	; Jump

loc_49109:		; CODE XREF: sub_48C63:loc_48CB1j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_48C63



; Attributes: bp-based frame

proc sub_4910F far	; CODE XREF: sub_319C3J
			; idk_BuildingWorlds+24Ap
			; idk_BuildingWorlds+254p

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
xor	di, di		; Logical Exclusive OR
jmp	loc_4A864	; Jump

loc_4911C:		; CODE XREF: sub_4910F+175Aj
xor	si, si		; Logical Exclusive OR
jmp	loc_4A85B	; Jump

loc_49121:		; CODE XREF: sub_4910F+1751j
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	[bp+var_4], ax
push	[bp+arg_0]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4915B	; Jump if Not Zero (ZF=0)
mov	[bp+var_4], 3E8h

loc_4915B:		; CODE XREF: sub_4910F+45j
cmp	[bp+var_4], 3E8h ; Compare Two Operands
jz	short loc_49165	; Jump if Zero (ZF=1)
jmp	loc_4925C	; Jump

loc_49165:		; CODE XREF: sub_4910F+51j
mov	[bp+var_2], 0
push	[bp+arg_0]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jz	short loc_49194	; Jump if Zero (ZF=1)
push	[bp+arg_0]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_49197	; Jump if Not Zero (ZF=0)

loc_49194:		; CODE XREF: sub_4910F+6Ej
inc	[bp+var_2]	; Increment by 1

loc_49197:		; CODE XREF: sub_4910F+83j
push	[bp+arg_0]
push	di
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add

loc_491A7:		; Compare Two Operands
cmp	ax, 1
jz	short loc_491C1	; Jump if Zero (ZF=1)
push	[bp+arg_0]
push	di
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_491C5	; Jump if Not Zero (ZF=0)

loc_491C1:		; CODE XREF: sub_4910F+9Bj
add	[bp+var_2], 2	; Add

loc_491C5:		; CODE XREF: sub_4910F+B0j
push	[bp+arg_0]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jz	short loc_491EF	; Jump if Zero (ZF=1)
push	[bp+arg_0]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_491F3	; Jump if Not Zero (ZF=0)

loc_491EF:		; CODE XREF: sub_4910F+C9j
add	[bp+var_2], 4	; Add

loc_491F3:		; CODE XREF: sub_4910F+DEj
push	[bp+arg_0]
push	di
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4CF1C ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jz	short loc_4921D	; Jump if Zero (ZF=1)
push	[bp+arg_0]
push	di
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_49221	; Jump if Not Zero (ZF=0)

loc_4921D:		; CODE XREF: sub_4910F+F7j
add	[bp+var_2], 8	; Add

loc_49221:		; CODE XREF: sub_4910F+10Cj
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_2]

loc_49230:
mov	cl, 3
shl	bx, cl		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [bx+3384h]
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax

loc_4925C:		; CODE XREF: sub_4910F+53j
mov	[bp+var_2], 0
push	[bp+arg_0]
mov	ax, di
dec	ax		; Decrement by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_49279	; Jump if Not Zero (ZF=0)
inc	[bp+var_2]	; Increment by 1

loc_49279:		; CODE XREF: sub_4910F+165j
push	[bp+arg_0]
push	di
mov	ax, si
inc	ax		; Increment by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_49292	; Jump if Not Zero (ZF=0)
add	[bp+var_2], 2	; Add

loc_49292:		; CODE XREF: sub_4910F+17Dj
push	[bp+arg_0]
mov	ax, di
inc	ax		; Increment by 1
push	ax
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_492AB	; Jump if Not Zero (ZF=0)
add	[bp+var_2], 4	; Add

loc_492AB:		; CODE XREF: sub_4910F+196j
push	[bp+arg_0]
push	di
mov	ax, si
dec	ax		; Decrement by 1
push	ax
nop			; No Operation
push	cs
call	near ptr sub_4D076 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_492C4	; Jump if Not Zero (ZF=0)
add	[bp+var_2], 8	; Add

loc_492C4:		; CODE XREF: sub_4910F+1AFj
cmp	[bp+var_4], 12h	; Compare Two Operands
jz	short loc_492CD	; Jump if Zero (ZF=1)
jmp	loc_49691	; Jump

loc_492CD:		; CODE XREF: sub_4910F+1B9j
mov	bx, [bp+var_2]
cmp	bx, 0Fh		; switch 16 cases
jbe	short loc_492D8	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4968E	; default

loc_492D8:		; CODE XREF: sub_4910F+1C4j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4A922+bx] ; switch jump

loc_492DF:		; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x0
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 134h
jmp	loc_4968E	; default

loc_49304:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x1
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C6h ; ''
jmp	loc_4968E	; default

loc_49329:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x2
mov	dx, 12C0h

loc_4932F:		; Signed Multiply
imul	dx
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C7h ; ''
jmp	loc_4968E	; default

loc_4934E:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x3
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C6h ; ''

loc_49370:		; CODE XREF: sub_4910F+30Dj
			; sub_4910F+355j
			; sub_4910F+3DEj
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1

loc_4938A:		; CODE XREF: sub_4910F+2E9j
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
dec	si		; Decrement by 1
jmp	loc_4968B	; Jump

loc_49397:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x4
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C8h ; ''
jmp	loc_4968E	; default

loc_493BC:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x5
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C6h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
jmp	short loc_4938A	; Jump

loc_493FA:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x6
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C8h ; ''
jmp	loc_49370	; Jump

loc_4941F:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x7
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C6h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
jmp	loc_49370	; Jump

loc_49467:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x8
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C5h ; ''
jmp	loc_4968E	; default

loc_4948C:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0x9
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C6h ; ''

loc_494AE:		; CODE XREF: sub_4910F+426j
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
dec	ax		; Decrement by 1
jmp	loc_4967F	; Jump

loc_494CB:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0xA
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C5h ; ''
jmp	loc_49370	; Jump

loc_494F0:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0xB
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C6h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
jmp	loc_494AE	; Jump

loc_49538:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0xC
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C5h ; ''
jmp	loc_495E0	; Jump

loc_4955D:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0xD
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C6h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
dec	ax		; Decrement by 1
jmp	short loc_495D7	; Jump

loc_4959B:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0xE
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C5h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1

loc_495D7:		; CODE XREF: sub_4910F+48Aj
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''

loc_495E0:		; CODE XREF: sub_4910F+44Bj
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
jmp	loc_4967F	; Jump

loc_495FD:		; CODE XREF: sub_4910F+1CBj
			; DATA XREF: ovr051:off_4A922o
mov	ax, [bp+arg_0]	; case 0xF
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C6h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1

loc_4967F:		; CODE XREF: sub_4910F+3B9j
			; sub_4910F+4EBj
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
sub	si, 2		; Integer Subtraction

loc_4968B:		; CODE XREF: sub_4910F+285j
dec	di		; Decrement by 1
jmp	short $+2	; Jump

loc_4968E:		; CODE XREF: sub_4910F+1C6j
			; sub_4910F+1F2j
			; sub_4910F+217j
			; sub_4910F+23Cj
			; sub_4910F+2AAj
			; sub_4910F+37Aj
jmp	loc_4A85A	; default

loc_49691:		; CODE XREF: sub_4910F+1BBj
cmp	[bp+var_4], 1Fh	; Compare Two Operands
jl	short loc_4969A	; Jump if Less (SF!=OF)
jmp	loc_4995E	; Jump

loc_4969A:		; CODE XREF: sub_4910F+586j
mov	bx, [bp+var_4]
sub	bx, 3		; switch 28 cases
cmp	bx, 1Bh		; Compare Two Operands
jbe	short loc_496A8	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4995B	; default

loc_496A8:		; CODE XREF: sub_4910F+594j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4A8EA+bx] ; switch jump

loc_496AF:		; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 4	; case 0x3
jnz	short loc_496D7	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0DAh ; ''

loc_496D7:		; CODE XREF: sub_4910F+5A4j
jmp	loc_4995B	; default

loc_496DA:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 4	; case 0x4
jnz	short loc_49702	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si

loc_496F9:		; Shift	Logical	Left
shl	ax, 1
add	bx, ax		; Add
mov	[word ptr es:bx], 0D9h ; ''

loc_49702:		; CODE XREF: sub_4910F+5CFj
jmp	loc_4995B	; default

loc_49705:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 4	; case 0x5
jnz	short loc_4972D	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0DBh ; ''

loc_4972D:		; CODE XREF: sub_4910F+5FAj
jmp	loc_4995B	; default

loc_49730:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 2	; case 0xA
jnz	short loc_49758	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E7h ; ''

loc_49758:		; CODE XREF: sub_4910F+625j
jmp	loc_4995B	; default

loc_4975B:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 4	; case 0xB
jnz	short loc_49783	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0DCh ; ''

loc_49783:		; CODE XREF: sub_4910F+650j
jmp	loc_4995B	; default

loc_49786:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 8	; case 0xC
jnz	short loc_497AE	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0DEh ; ''

loc_497AE:		; CODE XREF: sub_4910F+67Bj
jmp	loc_4995B	; default

loc_497B1:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 2	; case 0x10
jnz	short loc_497D9	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E5h ; ''

loc_497D9:		; CODE XREF: sub_4910F+6A6j
jmp	loc_4995B	; default

loc_497DC:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 2	; case 0x11
jnz	short loc_49804	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E8h ; ''

loc_49804:		; CODE XREF: sub_4910F+6D1j
jmp	loc_4995B	; default

loc_49807:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 8	; case 0x13
jnz	short loc_4982F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E0h ; ''

loc_4982F:		; CODE XREF: sub_4910F+6FCj
jmp	loc_4995B	; default

loc_49832:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 8	; case 0x14
jnz	short loc_4985A	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0DDh ; ''

loc_4985A:		; CODE XREF: sub_4910F+727j
jmp	loc_4995B	; default

loc_4985D:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 2	; case 0x15
jnz	short loc_49885	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E6h ; ''

loc_49885:		; CODE XREF: sub_4910F+752j
jmp	loc_4995B	; default

loc_49888:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 1	; case 0x16
jnz	short loc_498B0	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E4h ; ''

loc_498B0:		; CODE XREF: sub_4910F+77Dj
jmp	loc_4995B	; default

loc_498B3:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 8	; case 0x17
jnz	short loc_498DB	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0DFh ; ''

loc_498DB:		; CODE XREF: sub_4910F+7A8j
jmp	short loc_4995B	; default

loc_498DD:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 1	; case 0x1C
jnz	short loc_49905	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E3h ; ''

loc_49905:		; CODE XREF: sub_4910F+7D2j
jmp	short loc_4995B	; default

loc_49907:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 1	; case 0x1D
jnz	short loc_4992F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E1h ; ''

loc_4992F:		; CODE XREF: sub_4910F+7FCj
jmp	short loc_4995B	; default

loc_49931:		; CODE XREF: sub_4910F+59Bj
			; DATA XREF: ovr051:off_4A8EAo
cmp	[bp+var_2], 1	; case 0x1E
jnz	short loc_49959	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0E2h ; ''

loc_49959:		; CODE XREF: sub_4910F+826j
jmp	short $+2	; Jump

loc_4995B:		; CODE XREF: sub_4910F+596j
			; sub_4910F+59Bj
			; sub_4910F:loc_496D7j
			; sub_4910F:loc_49702j
			; sub_4910F:loc_4972Dj
			; sub_4910F:loc_49758j
			; sub_4910F:loc_49783j
			; sub_4910F:loc_497AEj
			; sub_4910F:loc_497D9j
			; sub_4910F:loc_49804j
			; sub_4910F:loc_4982Fj
			; sub_4910F:loc_4985Aj
			; sub_4910F:loc_49885j
			; sub_4910F:loc_498B0j
			; sub_4910F:loc_498DBj
			; sub_4910F:loc_49905j
			; sub_4910F:loc_4992Fj
			; DATA XREF: ovr051:off_4A8EAo
jmp	loc_4A85A	; default

loc_4995E:		; CODE XREF: sub_4910F+588j
cmp	[bp+var_4], 22h	; '"' ; Compare Two Operands
jge	short loc_49967	; Jump if Greater or Equal (SF=OF)
jmp	loc_4A136	; Jump

loc_49967:		; CODE XREF: sub_4910F+853j
cmp	[bp+var_4], 32h	; '2' ; Compare Two Operands
jle	short loc_49970	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4A136	; Jump

loc_49970:		; CODE XREF: sub_4910F+85Cj
mov	bx, [bp+var_4]
sub	bx, 22h		; switch 16 cases
cmp	bx, 0Fh		; Compare Two Operands
jbe	short loc_4997E	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4A133	; default

loc_4997E:		; CODE XREF: sub_4910F+86Aj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4A8CA+bx] ; switch jump

loc_49985:		; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 1	; case 0x22
jnz	short loc_499AD	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E9h

loc_499AD:		; CODE XREF: sub_4910F+87Aj
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_499D5	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1D9h

loc_499D5:		; CODE XREF: sub_4910F+8A2j
cmp	[bp+var_2], 9	; Compare Two Operands
jnz	short loc_499FD	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0C9h ; ''

loc_499FD:		; CODE XREF: sub_4910F+8CAj
jmp	loc_4A133	; default

loc_49A00:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 1	; case 0x23
jnz	short loc_49A28	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1EAh

loc_49A28:		; CODE XREF: sub_4910F+8F5j
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_49A50	; Jump if Not Zero (ZF=0)

loc_49A2E:
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1DAh

loc_49A50:		; CODE XREF: sub_4910F+91Dj
cmp	[bp+var_2], 9	; Compare Two Operands
jnz	short loc_49A78	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0CAh ; ''

loc_49A78:		; CODE XREF: sub_4910F+945j
jmp	loc_4A133	; default

loc_49A7B:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 1	; case 0x24
jnz	short loc_49AA3	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1EBh

loc_49AA3:		; CODE XREF: sub_4910F+970j
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_49ACB	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1DBh

loc_49ACB:		; CODE XREF: sub_4910F+998j
cmp	[bp+var_2], 9	; Compare Two Operands
jnz	short loc_49AF3	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0CBh ; ''

loc_49AF3:		; CODE XREF: sub_4910F+9C0j
jmp	loc_4A133	; default

loc_49AF6:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 1	; case 0x25
jnz	short loc_49B1E	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1ECh

loc_49B1E:		; CODE XREF: sub_4910F+9EBj
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_49B46	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1DCh

loc_49B46:		; CODE XREF: sub_4910F+A13j
cmp	[bp+var_2], 9	; Compare Two Operands
jnz	short loc_49B6E	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0CCh ; ''

loc_49B6E:		; CODE XREF: sub_4910F+A3Bj
jmp	loc_4A133	; default

loc_49B71:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 2	; case 0x26
jnz	short loc_49B99	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1EDh

loc_49B99:		; CODE XREF: sub_4910F+A66j
cmp	[bp+var_2], 4	; Compare Two Operands
jnz	short loc_49BC1	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1DDh

loc_49BC1:		; CODE XREF: sub_4910F+A8Ej
cmp	[bp+var_2], 6	; Compare Two Operands
jnz	short loc_49BE9	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0CDh ; ''

loc_49BE9:		; CODE XREF: sub_4910F+AB6j
jmp	loc_4A133	; default

loc_49BEC:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 2	; case 0x27
jnz	short loc_49C14	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1EEh

loc_49C14:		; CODE XREF: sub_4910F+AE1j
cmp	[bp+var_2], 4	; Compare Two Operands
jnz	short loc_49C3C	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1DEh

loc_49C3C:		; CODE XREF: sub_4910F+B09j
cmp	[bp+var_2], 6	; Compare Two Operands
jnz	short loc_49C64	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0CEh ; ''

loc_49C64:		; CODE XREF: sub_4910F+B31j
jmp	loc_4A133	; default

loc_49C67:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 2	; case 0x28
jnz	short loc_49C8F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1EFh

loc_49C8F:		; CODE XREF: sub_4910F+B5Cj
cmp	[bp+var_2], 4	; Compare Two Operands
jnz	short loc_49CB7	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1DFh

loc_49CB7:		; CODE XREF: sub_4910F+B84j
cmp	[bp+var_2], 6	; Compare Two Operands
jnz	short loc_49CDF	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left

loc_49CD8:		; Add
add	bx, ax
mov	[word ptr es:bx], 0CFh ; ''

loc_49CDF:		; CODE XREF: sub_4910F+BACj
jmp	loc_4A133	; default

loc_49CE2:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 2	; case 0x29
jnz	short loc_49D0A	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F0h

loc_49D0A:		; CODE XREF: sub_4910F+BD7j
cmp	[bp+var_2], 4	; Compare Two Operands
jnz	short loc_49D32	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E0h

loc_49D32:		; CODE XREF: sub_4910F+BFFj
cmp	[bp+var_2], 6	; Compare Two Operands
jnz	short loc_49D5A	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D0h ; ''

loc_49D5A:		; CODE XREF: sub_4910F+C27j
jmp	loc_4A133	; default

loc_49D5D:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 1	; case 0x2A
jnz	short loc_49D85	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E1h

loc_49D85:		; CODE XREF: sub_4910F+C52j
cmp	[bp+var_2], 2	; Compare Two Operands
jnz	short loc_49DAD	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F1h

loc_49DAD:		; CODE XREF: sub_4910F+C7Aj
cmp	[bp+var_2], 3	; Compare Two Operands
jnz	short loc_49DD5	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D1h ; ''

loc_49DD5:		; CODE XREF: sub_4910F+CA2j
jmp	loc_4A133	; default

loc_49DD8:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 1	; case 0x2B
jnz	short loc_49E00	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E2h

loc_49E00:		; CODE XREF: sub_4910F+CCDj
cmp	[bp+var_2], 2	; Compare Two Operands
jnz	short loc_49E28	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F2h

loc_49E28:		; CODE XREF: sub_4910F+CF5j
cmp	[bp+var_2], 3	; Compare Two Operands
jnz	short loc_49E50	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D2h ; ''

loc_49E50:		; CODE XREF: sub_4910F+D1Dj
jmp	loc_4A133	; default

loc_49E53:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 1	; case 0x2C
jnz	short loc_49E7B	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E3h

loc_49E7B:		; CODE XREF: sub_4910F+D48j
cmp	[bp+var_2], 2	; Compare Two Operands

loc_49E7F:		; Jump if Not Zero (ZF=0)
jnz	short loc_49EA3
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'

loc_49E94:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F3h

loc_49EA3:		; CODE XREF: sub_4910F:loc_49E7Fj
cmp	[bp+var_2], 3	; Compare Two Operands
jnz	short loc_49ECB	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D3h ; ''

loc_49ECB:		; CODE XREF: sub_4910F+D98j
jmp	loc_4A133	; default

loc_49ECE:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 1	; case 0x2D
jnz	short loc_49EF6	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h

loc_49EDA:		; Signed Multiply
imul	dx
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E4h

loc_49EF6:		; CODE XREF: sub_4910F+DC3j
cmp	[bp+var_2], 2	; Compare Two Operands
jnz	short loc_49F1E	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F4h

loc_49F1E:		; CODE XREF: sub_4910F+DEBj
cmp	[bp+var_2], 3	; Compare Two Operands
jnz	short loc_49F46	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D4h ; ''

loc_49F46:		; CODE XREF: sub_4910F+E13j
jmp	loc_4A133	; default

loc_49F49:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 4	; case 0x2E
jnz	short loc_49F71	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E5h

loc_49F71:		; CODE XREF: sub_4910F+E3Ej
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_49F99	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F5h

loc_49F99:		; CODE XREF: sub_4910F+E66j
cmp	[bp+var_2], 0Ch	; Compare Two Operands
jnz	short loc_49FC1	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D5h ; ''

loc_49FC1:		; CODE XREF: sub_4910F+E8Ej
jmp	loc_4A133	; default

loc_49FC4:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 4	; case 0x2F
jnz	short loc_49FEC	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E6h

loc_49FEC:		; CODE XREF: sub_4910F+EB9j
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_4A014	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F6h

loc_4A014:		; CODE XREF: sub_4910F+EE1j
cmp	[bp+var_2], 0Ch	; Compare Two Operands
jnz	short loc_4A03C	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D6h ; ''

loc_4A03C:		; CODE XREF: sub_4910F+F09j
jmp	loc_4A133	; default

loc_4A03F:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 4	; case 0x30
jnz	short loc_4A067	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E7h

loc_4A067:		; CODE XREF: sub_4910F+F34j
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_4A08F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F7h

loc_4A08F:		; CODE XREF: sub_4910F+F5Cj
cmp	[bp+var_2], 0Ch	; Compare Two Operands
jnz	short loc_4A0B7	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D7h ; ''

loc_4A0B7:		; CODE XREF: sub_4910F+F84j
jmp	short loc_4A133	; default

loc_4A0B9:		; CODE XREF: sub_4910F+871j
			; DATA XREF: ovr051:off_4A8CAo
cmp	[bp+var_2], 4	; case 0x31
jnz	short loc_4A0E1	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1E8h

loc_4A0E1:		; CODE XREF: sub_4910F+FAEj
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_4A109	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 1F8h

loc_4A109:		; CODE XREF: sub_4910F+FD6j
cmp	[bp+var_2], 0Ch	; Compare Two Operands
jnz	short loc_4A131	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0D8h ; ''

loc_4A131:		; CODE XREF: sub_4910F+FFEj
jmp	short $+2	; Jump

loc_4A133:		; CODE XREF: sub_4910F+86Cj
			; sub_4910F:loc_499FDj
			; sub_4910F:loc_49A78j
			; sub_4910F:loc_49AF3j
			; sub_4910F:loc_49B6Ej
			; sub_4910F:loc_49BE9j
			; sub_4910F:loc_49C64j
			; sub_4910F:loc_49CDFj
			; sub_4910F:loc_49D5Aj
			; sub_4910F:loc_49DD5j
			; sub_4910F:loc_49E50j
			; sub_4910F:loc_49ECBj
			; sub_4910F:loc_49F46j
			; sub_4910F:loc_49FC1j
			; sub_4910F:loc_4A03Cj
			; sub_4910F:loc_4A0B7j
jmp	loc_4A85A	; default

loc_4A136:		; CODE XREF: sub_4910F+855j
			; sub_4910F+85Ej
cmp	[bp+var_4], 32h	; '2' ; Compare Two Operands
jge	short loc_4A13F	; Jump if Greater or Equal (SF=OF)
jmp	loc_4A1FC	; Jump

loc_4A13F:		; CODE XREF: sub_4910F+102Bj
cmp	[bp+var_4], 41h	; 'A' ; Compare Two Operands
jle	short loc_4A148	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4A1FC	; Jump

loc_4A148:		; CODE XREF: sub_4910F+1034j
cmp	[bp+var_2], 1	; Compare Two Operands
jnz	short loc_4A179	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
add	ax, 1E7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	loc_4A1FC	; Jump

loc_4A179:		; CODE XREF: sub_4910F+103Dj
cmp	[bp+var_2], 4	; Compare Two Operands
jnz	short loc_4A1A9	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
add	ax, 1F7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	short loc_4A1FC	; Jump

loc_4A1A9:		; CODE XREF: sub_4910F+106Ej
cmp	[bp+var_2], 5	; Compare Two Operands
jnz	short loc_4A1FC	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
add	ax, 1E7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax

loc_4A1D4:
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
dec	si		; Decrement by 1
dec	di		; Decrement by 1

loc_4A1FC:		; CODE XREF: sub_4910F+102Dj
			; sub_4910F+1036j
			; sub_4910F+1067j
			; sub_4910F+1098j
			; sub_4910F+109Ej
cmp	[bp+var_4], 42h	; 'B' ; Compare Two Operands
jge	short loc_4A205	; Jump if Greater or Equal (SF=OF)
jmp	loc_4A2C2	; Jump

loc_4A205:		; CODE XREF: sub_4910F+10F1j
cmp	[bp+var_4], 51h	; 'Q' ; Compare Two Operands
jle	short loc_4A20E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4A2C2	; Jump

loc_4A20E:		; CODE XREF: sub_4910F+10FAj
cmp	[bp+var_2], 2	; Compare Two Operands
jnz	short loc_4A23F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
add	ax, 207h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	loc_4A2C2	; Jump

loc_4A23F:		; CODE XREF: sub_4910F+1103j
cmp	[bp+var_2], 8	; Compare Two Operands
jnz	short loc_4A26F	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
add	ax, 1F7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	short loc_4A2C2	; Jump

loc_4A26F:		; CODE XREF: sub_4910F+1134j
cmp	[bp+var_2], 0Ah	; Compare Two Operands
jnz	short loc_4A2C2	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]
add	ax, 1F7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
dec	si		; Decrement by 1
dec	di		; Decrement by 1

loc_4A2C2:		; CODE XREF: sub_4910F+10F3j
			; sub_4910F+10FCj
			; sub_4910F+112Dj
			; sub_4910F+115Ej
			; sub_4910F+1164j
cmp	[bp+var_4], 52h	; 'R' ; Compare Two Operands
jz	short loc_4A2DD	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 56h	; 'V' ; Compare Two Operands
jz	short loc_4A2DD	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 5Ah	; 'Z' ; Compare Two Operands
jz	short loc_4A2DD	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 5Eh	; '^' ; Compare Two Operands
jz	short loc_4A2DD	; Jump if Zero (ZF=1)
jmp	loc_4A416	; default

loc_4A2DD:		; CODE XREF: sub_4910F+11B7j
			; sub_4910F+11BDj
			; sub_4910F+11C3j
			; sub_4910F+11C9j
mov	bx, [bp+var_2]
sub	bx, 2		; switch 13 cases
cmp	bx, 0Ch		; Compare Two Operands
jbe	short loc_4A2EB	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4A416	; default

loc_4A2EB:		; CODE XREF: sub_4910F+11D7j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4A8B0+bx] ; switch jump

loc_4A2F2:		; DATA XREF: ovr051:off_4A8B0o
mov	ax, [bp+var_4]	; case 0x2
add	ax, 1B7h	; Add

loc_4A2F8:		; CODE XREF: sub_4910F+1214j
			; sub_4910F+121Cj
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	loc_4A416	; default

loc_4A31D:		; CODE XREF: sub_4910F+11DEj
			; DATA XREF: ovr051:off_4A8B0o
mov	ax, [bp+var_4]	; case 0x4
add	ax, 172h	; Add
jmp	short loc_4A2F8	; Jump

loc_4A325:		; CODE XREF: sub_4910F+11DEj
			; DATA XREF: ovr051:off_4A8B0o
mov	ax, [bp+var_4]	; case 0x8
add	ax, 1A7h	; Add
jmp	short loc_4A2F8	; Jump

loc_4A32D:		; CODE XREF: sub_4910F+11DEj
			; DATA XREF: ovr051:off_4A8B0o
mov	ax, [bp+var_4]	; case 0x6
add	ax, 172h	; Add

loc_4A333:		; CODE XREF: sub_4910F+1269j
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1
jmp	loc_4A409	; Jump

loc_4A372:		; CODE XREF: sub_4910F+11DEj
			; DATA XREF: ovr051:off_4A8B0o
mov	ax, [bp+var_4]	; case 0xA
add	ax, 1A7h	; Add
jmp	short loc_4A333	; Jump

loc_4A37A:		; CODE XREF: sub_4910F+11DEj
			; DATA XREF: ovr051:off_4A8B0o
mov	ax, [bp+var_4]	; case 0xC
add	ax, 1A7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	short loc_4A3EF	; Jump

loc_4A3A4:		; CODE XREF: sub_4910F+11DEj
			; DATA XREF: ovr051:off_4A8B0o
mov	ax, [bp+var_4]	; case 0xE
add	ax, 172h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''

loc_4A3EF:		; CODE XREF: sub_4910F+1293j
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si

loc_4A409:		; CODE XREF: sub_4910F+1260j
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
dec	si		; Decrement by 1
dec	di		; Decrement by 1
jmp	short $+2	; Jump

loc_4A416:		; CODE XREF: sub_4910F+11CBj
			; sub_4910F+11D9j
			; sub_4910F+11DEj
			; sub_4910F+120Bj
			; DATA XREF: ovr051:off_4A8B0o
cmp	[bp+var_4], 53h	; 'S' ; default
jz	short loc_4A431	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 57h	; 'W' ; Compare Two Operands
jz	short loc_4A431	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 5Bh	; '[' ; Compare Two Operands
jz	short loc_4A431	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 5Fh	; '_' ; Compare Two Operands
jz	short loc_4A431	; Jump if Zero (ZF=1)
jmp	loc_4A58F	; default

loc_4A431:		; CODE XREF: sub_4910F+130Bj
			; sub_4910F+1311j
			; sub_4910F+1317j
			; sub_4910F+131Dj
mov	bx, [bp+var_2]
dec	bx		; Decrement by 1
cmp	bx, 0Ch		; switch 13 cases
jbe	short loc_4A43D	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4A58F	; default

loc_4A43D:		; CODE XREF: sub_4910F+1329j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4A896+bx] ; switch jump

loc_4A444:		; DATA XREF: ovr051:off_4A896o
mov	ax, [bp+var_4]	; case 0x0
add	ax, 1A7h	; Add

loc_4A44A:		; CODE XREF: sub_4910F+1366j
			; sub_4910F+136Ej
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	loc_4A58F	; default

loc_4A46F:		; CODE XREF: sub_4910F+1330j
			; DATA XREF: ovr051:off_4A896o
mov	ax, [bp+var_4]	; case 0x3
add	ax, 1B7h	; Add
jmp	short loc_4A44A	; Jump

loc_4A477:		; CODE XREF: sub_4910F+1330j
			; DATA XREF: ovr051:off_4A896o
mov	ax, [bp+var_4]	; case 0x7
add	ax, 172h	; Add
jmp	short loc_4A44A	; Jump

loc_4A47F:		; CODE XREF: sub_4910F+1330j
			; DATA XREF: ovr051:off_4A896o
mov	ax, [bp+var_4]	; case 0x4
add	ax, 1A7h	; Add

loc_4A485:		; CODE XREF: sub_4910F+1409j
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
dec	si		; Decrement by 1
jmp	loc_4A58C	; Jump

loc_4A4CE:		; CODE XREF: sub_4910F+1330j
			; DATA XREF: ovr051:off_4A896o
mov	ax, [bp+var_4]	; case 0x8
add	ax, 1A7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
dec	ax		; Decrement by 1
jmp	short loc_4A580	; Jump

loc_4A512:		; CODE XREF: sub_4910F+1330j
			; DATA XREF: ovr051:off_4A896o
mov	ax, [bp+var_4]	; case 0xB
add	ax, 172h	; Add
jmp	loc_4A485	; Jump

loc_4A51B:		; CODE XREF: sub_4910F+1330j
			; DATA XREF: ovr051:off_4A896o
mov	ax, [bp+var_4]	; case 0xC
add	ax, 1A7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
mov	ax, [bp+arg_0]

loc_4A569:
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si

loc_4A580:		; CODE XREF: sub_4910F+1401j
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
sub	si, 2		; Integer Subtraction

loc_4A58C:		; CODE XREF: sub_4910F+13BCj
dec	di		; Decrement by 1
jmp	short $+2	; Jump

loc_4A58F:		; CODE XREF: sub_4910F+131Fj
			; sub_4910F+132Bj
			; sub_4910F+1330j
			; sub_4910F+135Dj
			; DATA XREF: ovr051:off_4A896o
cmp	[bp+var_4], 54h	; 'T' ; default
jz	short loc_4A5AA	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 58h	; 'X' ; Compare Two Operands
jz	short loc_4A5AA	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 5Ch	; '\' ; Compare Two Operands
jz	short loc_4A5AA	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 60h	; '`' ; Compare Two Operands
jz	short loc_4A5AA	; Jump if Zero (ZF=1)
jmp	loc_4A708	; default

loc_4A5AA:		; CODE XREF: sub_4910F+1484j
			; sub_4910F+148Aj
			; sub_4910F+1490j
			; sub_4910F+1496j
mov	bx, [bp+var_2]
dec	bx		; Decrement by 1
cmp	bx, 0Ah		; switch 11 cases
jbe	short loc_4A5B6	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4A708	; default

loc_4A5B6:		; CODE XREF: sub_4910F+14A2j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4A880+bx] ; switch jump

loc_4A5BD:		; DATA XREF: ovr051:off_4A880o
mov	ax, [bp+var_4]	; case 0x0
add	ax, 172h	; Add

loc_4A5C3:		; CODE XREF: sub_4910F+14DFj
			; sub_4910F+14E7j
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	loc_4A708	; default

loc_4A5E8:		; CODE XREF: sub_4910F+14A9j
			; DATA XREF: ovr051:off_4A880o
mov	ax, [bp+var_4]	; case 0x1
add	ax, 1A7h	; Add
jmp	short loc_4A5C3	; Jump

loc_4A5F0:		; CODE XREF: sub_4910F+14A9j
			; DATA XREF: ovr051:off_4A880o
mov	ax, [bp+var_4]	; case 0x7
add	ax, 1B7h	; Add
jmp	short loc_4A5C3	; Jump

loc_4A5F8:		; CODE XREF: sub_4910F+14A9j
			; DATA XREF: ovr051:off_4A880o
mov	ax, [bp+var_4]	; case 0x2
add	ax, 172h	; Add

loc_4A5FE:		; CODE XREF: sub_4910F+1582j
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
dec	si		; Decrement by 1
jmp	loc_4A705	; Jump

loc_4A647:		; CODE XREF: sub_4910F+14A9j
			; DATA XREF: ovr051:off_4A880o
mov	ax, [bp+var_4]	; case 0x8
add	ax, 172h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
dec	ax		; Decrement by 1
jmp	short loc_4A6F9	; Jump

loc_4A68B:		; CODE XREF: sub_4910F+14A9j
			; DATA XREF: ovr051:off_4A880o
mov	ax, [bp+var_4]	; case 0x9
add	ax, 1B7h	; Add
jmp	loc_4A5FE	; Jump

loc_4A694:		; CODE XREF: sub_4910F+14A9j
			; DATA XREF: ovr051:off_4A880o
mov	ax, [bp+var_4]	; case 0xA
add	ax, 172h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
dec	ax		; Decrement by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1

loc_4A6F9:		; CODE XREF: sub_4910F+157Aj
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
sub	si, 2		; Integer Subtraction

loc_4A705:		; CODE XREF: sub_4910F+1535j
dec	di		; Decrement by 1
jmp	short $+2	; Jump

loc_4A708:		; CODE XREF: sub_4910F+1498j
			; sub_4910F+14A4j
			; sub_4910F+14A9j
			; sub_4910F+14D6j
			; DATA XREF: ovr051:off_4A880o
cmp	[bp+var_4], 55h	; 'U' ; default
jz	short loc_4A723	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 59h	; 'Y' ; Compare Two Operands
jz	short loc_4A723	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 5Dh	; ']' ; Compare Two Operands
jz	short loc_4A723	; Jump if Zero (ZF=1)
cmp	[bp+var_4], 61h	; 'a' ; Compare Two Operands
jz	short loc_4A723	; Jump if Zero (ZF=1)
jmp	loc_4A85A	; default

loc_4A723:		; CODE XREF: sub_4910F+15FDj
			; sub_4910F+1603j
			; sub_4910F+1609j
			; sub_4910F+160Fj
mov	bx, [bp+var_2]
dec	bx		; Decrement by 1
cmp	bx, 6		; switch 7 cases
jbe	short loc_4A72F	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4A85A	; default

loc_4A72F:		; CODE XREF: sub_4910F+161Bj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4A872+bx] ; switch jump

loc_4A736:		; DATA XREF: ovr051:off_4A872o
mov	ax, [bp+var_4]	; case 0x0
add	ax, 1A7h	; Add

loc_4A73C:		; CODE XREF: sub_4910F+1658j
			; sub_4910F+1660j
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	loc_4A85A	; default

loc_4A761:		; CODE XREF: sub_4910F+1622j
			; DATA XREF: ovr051:off_4A872o
mov	ax, [bp+var_4]	; case 0x1
add	ax, 172h	; Add
jmp	short loc_4A73C	; Jump

loc_4A769:		; CODE XREF: sub_4910F+1622j
			; DATA XREF: ovr051:off_4A872o
mov	ax, [bp+var_4]	; case 0x3
add	ax, 1B7h	; Add
jmp	short loc_4A73C	; Jump

loc_4A771:		; CODE XREF: sub_4910F+1622j
			; DATA XREF: ovr051:off_4A872o
mov	ax, [bp+var_4]	; case 0x2
add	ax, 1A7h	; Add

loc_4A777:		; CODE XREF: sub_4910F+16D7j
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1
jmp	loc_4A84D	; Jump

loc_4A7B6:		; CODE XREF: sub_4910F+1622j
			; DATA XREF: ovr051:off_4A872o
mov	ax, [bp+var_4]	; case 0x4
add	ax, 1A7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
jmp	short loc_4A833	; Jump

loc_4A7E0:		; CODE XREF: sub_4910F+1622j
			; DATA XREF: ovr051:off_4A872o
mov	ax, [bp+var_4]	; case 0x5
add	ax, 1B7h	; Add
jmp	short loc_4A777	; Jump

loc_4A7E8:		; CODE XREF: sub_4910F+1622j
			; DATA XREF: ovr051:off_4A872o
mov	ax, [bp+var_4]	; case 0x6
add	ax, 1A7h	; Add
push	ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
pop	ax
mov	[es:bx], ax
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
inc	ax		; Increment by 1
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''

loc_4A833:		; CODE XREF: sub_4910F+16CFj
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
inc	ax		; Increment by 1
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si

loc_4A84D:		; CODE XREF: sub_4910F+16A4j
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A2h ; ''
dec	si		; Decrement by 1
dec	di		; Decrement by 1
jmp	short $+2	; Jump

loc_4A85A:		; CODE XREF: sub_4910F:loc_4968Ej
			; sub_4910F:loc_4995Bj
			; sub_4910F:loc_4A133j
			; sub_4910F+1611j
			; sub_4910F+161Dj
			; sub_4910F+164Fj
inc	si		; default

loc_4A85B:		; CODE XREF: sub_4910F+Fj
cmp	si, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_4A863	; Jump if Greater or Equal (SF=OF)
jmp	loc_49121	; Jump

loc_4A863:		; CODE XREF: sub_4910F+174Fj
inc	di		; Increment by 1

loc_4A864:		; CODE XREF: sub_4910F+Aj
cmp	di, 28h	; '('   ; Compare Two Operands
jge	short loc_4A86C	; Jump if Greater or Equal (SF=OF)
jmp	loc_4911C	; Jump

loc_4A86C:		; CODE XREF: sub_4910F+1758j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4910F

off_4A872 dw offset loc_4A736
			; DATA XREF: sub_4910F+1622r
dw offset loc_4A761	; jump table for switch	statement
dw offset loc_4A771
dw offset loc_4A769
dw offset loc_4A7B6
dw offset loc_4A7E0
dw offset loc_4A7E8
off_4A880 dw offset loc_4A5BD
			; DATA XREF: sub_4910F+14A9r
dw offset loc_4A5E8	; jump table for switch	statement
dw offset loc_4A5F8
dw offset loc_4A708
dw offset loc_4A708
dw offset loc_4A708
dw offset loc_4A708
dw offset loc_4A5F0
dw offset loc_4A647
dw offset loc_4A68B
dw offset loc_4A694
off_4A896 dw offset loc_4A444
			; DATA XREF: sub_4910F+1330r
dw offset loc_4A58F	; jump table for switch	statement
dw offset loc_4A58F
dw offset loc_4A46F
dw offset loc_4A47F
dw offset loc_4A58F
dw offset loc_4A58F
dw offset loc_4A477
dw offset loc_4A4CE
dw offset loc_4A58F
dw offset loc_4A58F
dw offset loc_4A512
dw offset loc_4A51B
off_4A8B0 dw offset loc_4A2F2
			; DATA XREF: sub_4910F+11DEr
dw offset loc_4A416	; jump table for switch	statement
dw offset loc_4A31D
dw offset loc_4A416
dw offset loc_4A32D
dw offset loc_4A416
dw offset loc_4A325
dw offset loc_4A416
dw offset loc_4A372
dw offset loc_4A416
dw offset loc_4A37A
dw offset loc_4A416
dw offset loc_4A3A4
off_4A8CA dw offset loc_49985
			; DATA XREF: sub_4910F+871r
dw offset loc_49A00	; jump table for switch	statement
dw offset loc_49A7B
dw offset loc_49AF6
dw offset loc_49B71
dw offset loc_49BEC
dw offset loc_49C67
dw offset loc_49CE2
dw offset loc_49D5D
dw offset loc_49DD8
dw offset loc_49E53
dw offset loc_49ECE
dw offset loc_49F49
dw offset loc_49FC4
dw offset loc_4A03F
dw offset loc_4A0B9
off_4A8EA dw offset loc_496AF
			; DATA XREF: sub_4910F+59Br
dw offset loc_496DA	; jump table for switch	statement
dw offset loc_49705
dw offset loc_4995B
dw offset loc_4995B
dw offset loc_4995B
dw offset loc_4995B
dw offset loc_49730
dw offset loc_4975B
dw offset loc_49786
dw offset loc_4995B
dw offset loc_4995B
dw offset loc_4995B
dw offset loc_497B1
dw offset loc_497DC
dw offset loc_4995B
dw offset loc_49807
dw offset loc_49832
dw offset loc_4985D
dw offset loc_49888
dw offset loc_498B3
dw offset loc_4995B
dw offset loc_4995B
dw offset loc_4995B
dw offset loc_4995B
dw offset loc_498DD
dw offset loc_49907
dw offset loc_49931
off_4A922 dw offset loc_492DF
			; DATA XREF: sub_4910F+1CBr
dw offset loc_49304	; jump table for switch	statement
dw offset loc_49329
dw offset loc_4934E
dw offset loc_49397
dw offset loc_493BC
dw offset loc_493FA
dw offset loc_4941F
dw offset loc_49467
dw offset loc_4948C
dw offset loc_494CB
dw offset loc_494F0
dw offset loc_49538
dw offset loc_4955D
dw offset loc_4959B
dw offset loc_495FD


; Attributes: bp-based frame

proc sub_4A942 far	; CODE XREF: sub_319C8J
			; idk_BuildingWorlds+1B3p
			; idk_BuildingWorlds+1BDp

var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 10h		; Integer Subtraction
push	si
push	di
mov	[bp+var_E], 0
mov	di, 1
jmp	loc_4AA39	; Jump

loc_4A955:		; CODE XREF: sub_4A942+FDj
cmp	[bp+arg_0], 0	; Compare Two Operands
jz	short loc_4A95E	; Jump if Zero (ZF=1)
jmp	loc_4A9E3	; Jump

loc_4A95E:		; CODE XREF: sub_4A942+17j
mov	ax, 9
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 0Ch		; switch 13 cases
ja	short loc_4A9E1	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4B959+bx] ; switch jump

loc_4A977:		; CODE XREF: sub_4A942:loc_4A9C5j
			; DATA XREF: ovr051:off_4B959o
mov	bx, di		; case 0x0
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 0
jmp	short loc_4A9E1	; default

loc_4A983:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
mov	bx, di		; case 0x1
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 5
jmp	short loc_4A9E1	; default

loc_4A98F:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
mov	bx, di		; case 0x2
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 6
jmp	short loc_4A9E1	; default

loc_4A99B:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
jmp	short loc_4A9D5	; case 0x3

loc_4A99D:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
jmp	short loc_4A9D5	; case 0x4

loc_4A99F:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
mov	bx, di		; case 0x5
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 9
jmp	short loc_4A9E1	; default

loc_4A9AB:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
mov	bx, di		; case 0x6
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 0Ah
jmp	short loc_4A9E1	; default

loc_4A9B7:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
jmp	short loc_4A9C9	; case 0x7

loc_4A9B9:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
mov	bx, di		; case 0x8
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 0Ch
jmp	short loc_4A9E1	; default

loc_4A9C5:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
jmp	short loc_4A977	; case 0x9

loc_4A9C7:		; CODE XREF: sub_4A942+30j
			; DATA XREF: ovr051:off_4B959o
jmp	short loc_4A9D5	; case 0xA

loc_4A9C9:		; CODE XREF: sub_4A942+30j
			; sub_4A942:loc_4A9B7j
			; DATA XREF: ovr051:off_4B959o
mov	bx, di		; case 0xB
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 0Bh
jmp	short loc_4A9E1	; default

loc_4A9D5:		; CODE XREF: sub_4A942+30j
			; sub_4A942:loc_4A99Bj
			; sub_4A942:loc_4A99Dj
			; sub_4A942:loc_4A9C7j
			; DATA XREF: ovr051:off_4B959o
mov	bx, di		; case 0xC
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 8
jmp	short $+2	; Jump

loc_4A9E1:		; CODE XREF: sub_4A942+2Cj
			; sub_4A942+3Fj
			; sub_4A942+4Bj
			; sub_4A942+57j
			; sub_4A942+67j
			; sub_4A942+73j
			; sub_4A942+81j
			; sub_4A942+91j
jmp	short loc_4AA38	; default

loc_4A9E3:		; CODE XREF: sub_4A942+19j
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 4		; switch 5 cases
ja	short loc_4AA38	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4B94F+bx] ; switch jump

loc_4A9FC:		; DATA XREF: ovr051:off_4B94Fo
mov	bx, di		; case 0x0
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 1
jmp	short loc_4AA38	; default

loc_4AA08:		; CODE XREF: sub_4A942+B5j
			; DATA XREF: ovr051:off_4B94Fo
mov	bx, di		; case 0x1
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 2
jmp	short loc_4AA38	; default

loc_4AA14:		; CODE XREF: sub_4A942+B5j
			; DATA XREF: ovr051:off_4B94Fo
mov	bx, di		; case 0x2
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 3
jmp	short loc_4AA38	; default

loc_4AA20:		; CODE XREF: sub_4A942+B5j
			; DATA XREF: ovr051:off_4B94Fo
mov	bx, di		; case 0x3
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 4
jmp	short loc_4AA38	; default

loc_4AA2C:		; CODE XREF: sub_4A942+B5j
			; DATA XREF: ovr051:off_4B94Fo
mov	bx, di		; case 0x4
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-7150h], 0Dh
jmp	short $+2	; Jump

loc_4AA38:		; CODE XREF: sub_4A942:loc_4A9E1j
			; sub_4A942+B1j
			; sub_4A942+C4j
			; sub_4A942+D0j
			; sub_4A942+DCj
			; sub_4A942+E8j
inc	di		; default

loc_4AA39:		; CODE XREF: sub_4A942+10j
cmp	di, 0C8h ; ''  ; Compare Two Operands
jge	short loc_4AA42	; Jump if Greater or Equal (SF=OF)
jmp	loc_4A955	; Jump

loc_4AA42:		; CODE XREF: sub_4A942+FBj
xor	di, di		; Logical Exclusive OR
jmp	loc_4B8E6	; Jump

loc_4AA47:		; CODE XREF: sub_4A942+35Fj
			; sub_4A942:loc_4B8F2j
inc	[bp+var_E]	; Increment by 1
mov	ax, 36h	; '6'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 3		; Add
mov	[bp+var_2], ax
mov	ax, 22h	; '"'
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 3		; Add
mov	[bp+var_4], ax
mov	[bp+var_6], 0
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_4]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_4AA99	; Jump if Not Zero (ZF=0)
mov	[bp+var_6], 1

loc_4AA99:		; CODE XREF: sub_4A942+150j
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_4]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply

loc_4AAAF:		; Add
add	bx, ax
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 2 ; Compare Two Operands
jb	short loc_4AAE9	; Jump if Below	(CF=1)
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_4]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A1h ; '' ; Compare Two Operands
ja	short loc_4AAE9	; Jump if Above	(CF=0 &	ZF=0)
mov	[bp+var_6], 1

loc_4AAE9:		; CODE XREF: sub_4A942+17Aj
			; sub_4A942+1A0j
xor	si, si		; Logical Exclusive OR
jmp	short loc_4AB29	; Jump

loc_4AAED:		; CODE XREF: sub_4A942+1EBj
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_4]
push	[bp+var_2]
call	sub_1D6D9	; Call Procedure
add	sp, 8		; Add
cmp	ax, 5		; Compare Two Operands
jge	short loc_4AB28	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_6], 1

loc_4AB28:		; CODE XREF: sub_4A942+1DFj
inc	si		; Increment by 1

loc_4AB29:		; CODE XREF: sub_4A942+1A9j
cmp	si, [word_3A4E2] ; Compare Two Operands
jl	short loc_4AAED	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4AB8D	; Jump

loc_4AB33:		; CODE XREF: sub_4A942+24Fj
mov	ax, si
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jnz	short loc_4AB8C	; Jump if Not Zero (ZF=0)
mov	ax, 3Ch	; '<'
push	ax
mov	ax, si
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4AB6E:
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_4]
push	[bp+var_2]
call	sub_1D724	; Call Procedure
add	sp, 0Ah		; Add
cmp	ax, 4		; Compare Two Operands
jge	short loc_4AB8C	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_6], 1

loc_4AB8C:		; CODE XREF: sub_4A942+206j
			; sub_4A942+243j
inc	si		; Increment by 1

loc_4AB8D:		; CODE XREF: sub_4A942+1EFj
cmp	si, [word_3A4DA] ; Compare Two Operands
jl	short loc_4AB33	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4ABEC	; Jump

loc_4AB97:		; CODE XREF: sub_4A942+2ADj
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jnz	short loc_4ABEB	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_4]
push	[bp+var_2]
call	sub_1D6D9	; Call Procedure
add	sp, 8		; Add
cmp	ax, 4		; Compare Two Operands
jge	short loc_4ABEB	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_6], 1

loc_4ABEB:		; CODE XREF: sub_4A942+26Aj
			; sub_4A942+2A2j
inc	si		; Increment by 1

loc_4ABEC:		; CODE XREF: sub_4A942+253j
cmp	si, 1Eh		; Compare Two Operands
jl	short loc_4AB97	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4AC31	; Jump

loc_4ABF5:		; CODE XREF: sub_4A942+2F2j
mov	ax, si
mov	cl, 2		; int
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4AC01:
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_4]
push	[bp+var_2]
call	sub_1D6D9	; Call Procedure
add	sp, 8		; Add
cmp	ax, 4		; Compare Two Operands
jge	short loc_4AC30	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_6], 1

loc_4AC30:		; CODE XREF: sub_4A942+2E7j
inc	si		; Increment by 1

loc_4AC31:		; CODE XREF: sub_4A942+2B1j
cmp	si, 6		; Compare Two Operands
jl	short loc_4ABF5	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4AC8F	; Jump

loc_4AC3A:		; CODE XREF: sub_4A942+350j
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jnz	short loc_4AC8E	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
push	[bp+var_4]
push	[bp+var_2]
call	sub_1D6D9	; Call Procedure
add	sp, 8		; Add
cmp	ax, 4		; Compare Two Operands
jge	short loc_4AC8E	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_6], 1

loc_4AC8E:		; CODE XREF: sub_4A942+30Dj
			; sub_4A942+345j
inc	si		; Increment by 1

loc_4AC8F:		; CODE XREF: sub_4A942+2F6j
cmp	si, 66h	; 'f'   ; Compare Two Operands
jl	short loc_4AC3A	; Jump if Less (SF!=OF)
cmp	[bp+var_E], 3E8h ; Compare Two Operands
jge	short loc_4ACA4	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_6], 1	; Compare Two Operands
jnz	short loc_4ACA4	; Jump if Not Zero (ZF=0)
jmp	loc_4AA47	; Jump

loc_4ACA4:		; CODE XREF: sub_4A942+357j
			; sub_4A942+35Dj
cmp	[bp+var_E], 3E8h ; Compare Two Operands
jl	short loc_4ACB0	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	loc_4B8F5	; Jump

loc_4ACB0:		; CODE XREF: sub_4A942+367j
push	[bp+arg_0]
push	[bp+var_4]
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4D02B ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_10], ax
cmp	[bp+arg_0], 0	; Compare Two Operands
jz	short loc_4ACCD	; Jump if Zero (ZF=1)
jmp	loc_4ADD0	; Jump

loc_4ACCD:		; CODE XREF: sub_4A942+386j
mov	ax, 9
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 0Ch		; switch 13 cases
jbe	short loc_4ACE2	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4ADCD	; default

loc_4ACE2:		; CODE XREF: sub_4A942+39Bj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4B935+bx] ; switch jump

loc_4ACE9:		; CODE XREF: sub_4A942:loc_4AD9Ej
			; DATA XREF: ovr051:off_4B935o
mov	ax, [word_3A4DA] ; case	0x0
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0
jmp	loc_4ADCD	; default

loc_4ACFF:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
mov	ax, [word_3A4DA] ; case	0x1
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 5
jmp	loc_4ADCD	; default

loc_4AD15:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
mov	ax, [word_3A4DA] ; case	0x2
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 6
jmp	loc_4ADCD	; default

loc_4AD2B:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
cmp	[bp+var_10], 1	; case 0x3
jnz	short loc_4AD46	; Jump if Not Zero (ZF=0)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 7
jmp	short loc_4AD59	; Jump

loc_4AD46:		; CODE XREF: sub_4A942+3EDj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 8

loc_4AD59:		; CODE XREF: sub_4A942+402j
jmp	short loc_4ADCD	; default

loc_4AD5B:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
jmp	short loc_4ADB8	; case 0x4

loc_4AD5D:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
mov	ax, [word_3A4DA] ; case	0x5
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 9
jmp	short loc_4ADCD	; default

loc_4AD72:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
mov	ax, [word_3A4DA] ; case	0x6
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply

loc_4AD7A:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6E2]

loc_4AD7E:		; Add
add	bx, ax
mov	[byte ptr es:bx+0Eh], 0Ah
jmp	short loc_4ADCD	; default

loc_4AD87:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
jmp	short loc_4ADA3	; case 0x7

loc_4AD89:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
mov	ax, [word_3A4DA] ; case	0x8
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0Ch
jmp	short loc_4ADCD	; default

loc_4AD9E:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
jmp	loc_4ACE9	; case 0x9

loc_4ADA1:		; CODE XREF: sub_4A942+3A2j
			; DATA XREF: ovr051:off_4B935o
jmp	short loc_4ADB8	; case 0xA

loc_4ADA3:		; CODE XREF: sub_4A942+3A2j
			; sub_4A942:loc_4AD87j
			; DATA XREF: ovr051:off_4B935o
mov	ax, [word_3A4DA] ; case	0xB
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0Bh
jmp	short loc_4ADCD	; default

loc_4ADB8:		; CODE XREF: sub_4A942+3A2j
			; sub_4A942:loc_4AD5Bj
			; sub_4A942:loc_4ADA1j
			; DATA XREF: ovr051:off_4B935o
mov	ax, [word_3A4DA] ; case	0xC
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4ADC6:
mov	[byte ptr es:bx+0Eh], 8
jmp	short $+2	; Jump

loc_4ADCD:		; CODE XREF: sub_4A942+39Dj
			; sub_4A942+3BAj
			; sub_4A942+3D0j
			; sub_4A942+3E6j
			; sub_4A942:loc_4AD59j
			; sub_4A942+42Ej
			; sub_4A942+443j
			; sub_4A942+45Aj
			; sub_4A942+474j
jmp	loc_4AE52	; default

loc_4ADD0:		; CODE XREF: sub_4A942+388j
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 4		; switch 5 cases
ja	short loc_4AE52	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4B92B+bx] ; switch jump

loc_4ADE9:		; DATA XREF: ovr051:off_4B92Bo
mov	ax, [word_3A4DA] ; case	0x0
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 1
jmp	short loc_4AE52	; default

loc_4ADFE:		; CODE XREF: sub_4A942+4A2j
			; DATA XREF: ovr051:off_4B92Bo
mov	ax, [word_3A4DA] ; case	0x1
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 2
jmp	short loc_4AE52	; default

loc_4AE13:		; CODE XREF: sub_4A942+4A2j
			; DATA XREF: ovr051:off_4B92Bo
mov	ax, [word_3A4DA] ; case	0x2
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 3
jmp	short loc_4AE52	; default

loc_4AE28:		; CODE XREF: sub_4A942+4A2j
			; DATA XREF: ovr051:off_4B92Bo
mov	ax, [word_3A4DA] ; case	0x3
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 4
jmp	short loc_4AE52	; default

loc_4AE3D:		; CODE XREF: sub_4A942+4A2j
			; DATA XREF: ovr051:off_4B92Bo
mov	ax, [word_3A4DA] ; case	0x4
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Eh], 0Dh
jmp	short $+2	; Jump

loc_4AE52:		; CODE XREF: sub_4A942:loc_4ADCDj
			; sub_4A942+49Ej
			; sub_4A942+4BAj
			; sub_4A942+4CFj
			; sub_4A942+4E4j
			; sub_4A942+4F9j
mov	ax, 4		; default
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jle	short loc_4AE9D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_2]	; Add
mov	al, [es:bx]
mov	ah, 0
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
mov	al, [bx-7150h]
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+0Eh], al

loc_4AE9D:		; CODE XREF: sub_4A942+51Dj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_2]
mov	[es:bx+0Fh], al
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+var_4]
mov	[es:bx+10h], al
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+arg_0]
mov	[es:bx+11h], al
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+12h], 5
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
push	ax
mov	ax, [word_3A4DC]
inc	ax		; Increment by 1
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
add	dl, al		; Add
inc	dl		; Increment by 1
mov	ax, [word_3A4DA]
mov	bx, 72h	; 'r'
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+14h], al
cmp	[word_3A4DC], 2	; Compare Two Operands
jle	short loc_4AF5F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4AF5F	; Jump if Not Zero (ZF=0)
mov	ax, 0Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
push	ax
mov	ax, [word_3A4DC]
inc	ax		; Increment by 1
mov	bx, 3
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
add	dl, al		; Add
mov	ax, [word_3A4DA]
mov	bx, 72h	; 'r'
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+14h], al

loc_4AF5F:		; CODE XREF: sub_4A942+5E0j
			; sub_4A942+5EFj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+14h]
cbw			; AL ->	AX (with sign)
mov	bx, 4
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
mov	[es:bx+13h], al
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+1Eh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+5Ah], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+43h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+44h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+45h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+46h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+47h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+48h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+49h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+5Bh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Ah], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Bh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+50h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Eh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Fh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Dh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+4Ch], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+51h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+52h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+53h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+54h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+55h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+56h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+57h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+58h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+59h], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+5Ch], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+1Ch], 0FFFCh
xor	si, si		; Logical Exclusive OR
jmp	short loc_4B1BB	; Jump

loc_4B1A5:		; CODE XREF: sub_4A942+87Cj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx+1Fh], 0FFh
inc	si		; Increment by 1

loc_4B1BB:		; CODE XREF: sub_4A942+861j
cmp	si, 24h	; '$'   ; Compare Two Operands
jl	short loc_4B1A5	; Jump if Less (SF!=OF)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+1Fh], 0
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+14h]
cbw			; AL ->	AX (with sign)
sub	ax, 2		; Integer Subtraction
mov	bx, ax
cmp	bx, 17h		; switch 24 cases
jbe	short loc_4B1F3	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4B2B8	; default

loc_4B1F3:		; CODE XREF: sub_4A942+8ACj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4B8FB+bx] ; switch jump

loc_4B1FA:		; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0xC
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+35h], 1

loc_4B20D:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0xB
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+25h], 1

loc_4B220:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0xA
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+24h], 1

loc_4B233:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0x8
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+42h], 1

loc_4B246:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0x6
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+28h], 1

loc_4B259:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0x5
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+3Ch], 1

loc_4B26C:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0x3
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+23h], 1

loc_4B27F:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0x2
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+3Fh], 1

loc_4B292:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0x1
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+27h], 1

loc_4B2A5:		; CODE XREF: sub_4A942+8B3j
			; DATA XREF: ovr051:off_4B8FBo
mov	ax, [word_3A4DA] ; case	0x0
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+22h], 1

loc_4B2B8:		; CODE XREF: sub_4A942+8AEj
mov	[bp+var_8], 0	; default
jmp	short loc_4B2FC	; Jump

loc_4B2BF:		; CODE XREF: sub_4A942+9DBj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
cbw			; AL ->	AX (with sign)
mov	dx, 18h
imul	dx		; Signed Multiply
mov	dx, [bp+var_8]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	dx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	dx, ax		; Add
pop	bx
add	dx, [bx+1DFAh]	; Add
mov	bx, dx
mov	[byte ptr es:bx+1Fh], 0FFh
inc	[bp+var_8]	; Increment by 1

loc_4B2FC:		; CODE XREF: sub_4A942+97Bj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
cbw			; AL ->	AX (with sign)
mov	dx, 18h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+1DF8h]
cmp	ax, [bp+var_8]	; Compare Two Operands
jg	short loc_4B2BF	; Jump if Greater (ZF=0	& SF=OF)
mov	si, 1
jmp	loc_4B404	; Jump

loc_4B325:		; CODE XREF: sub_4A942+AC7j
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
cmp	[byte ptr es:bx+1Fh], 1	; Compare Two Operands
jz	short loc_4B33F	; Jump if Zero (ZF=1)
jmp	loc_4B403	; Jump

loc_4B33F:		; CODE XREF: sub_4A942+9F8j
mov	ax, si
mov	dx, 34h	; '4'
imul	dx		; Signed Multiply
les	bx, [dword_38422] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+14h], 64h ; 'd' ; Compare Two Operands
jle	short loc_4B396	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	dx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	dx, ax		; Add
mov	ax, si
mov	bx, 34h	; '4'
push	es
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_38422] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	ax, [es:bx+14h]	; Add
mov	bx, ax
pop	es
cmp	[byte ptr es:bx+1Fh], 0FFh ; Compare Two Operands
jnz	short loc_4B394	; Jump if Not Zero (ZF=0)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx+1Fh], 0FFh

loc_4B394:		; CODE XREF: sub_4A942+A3Bj
jmp	short loc_4B403	; Jump

loc_4B396:		; CODE XREF: sub_4A942+A0Fj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	dx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	dx, ax		; Add
mov	ax, si
mov	bx, 34h	; '4'
push	es
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_38422] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	ax, [es:bx+14h]	; Add
mov	bx, ax
pop	es
cmp	[byte ptr es:bx+1Fh], 0FFh ; Compare Two Operands
jz	short loc_4B3EE	; Jump if Zero (ZF=1)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	dx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	dx, ax		; Add
mov	ax, si
mov	bx, 34h	; '4'
push	es
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_38422] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	ax, [es:bx+16h]	; Add
mov	bx, ax
pop	es
cmp	[byte ptr es:bx+1Fh], 0FFh ; Compare Two Operands
jnz	short loc_4B403	; Jump if Not Zero (ZF=0)

loc_4B3EE:		; CODE XREF: sub_4A942+A7Ej
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx+1Fh], 0FFh

loc_4B403:		; CODE XREF: sub_4A942+9FAj
			; sub_4A942:loc_4B394j
			; sub_4A942+AAAj
inc	si		; Increment by 1

loc_4B404:		; CODE XREF: sub_4A942+9E0j
cmp	si, 23h	; '#'   ; Compare Two Operands
jg	short loc_4B40C	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4B325	; Jump

loc_4B40C:		; CODE XREF: sub_4A942+AC5j
mov	si, 1
jmp	loc_4B494	; Jump

loc_4B412:		; CODE XREF: sub_4A942+B57j
mov	ax, si
mov	dx, 34h	; '4'
imul	dx		; Signed Multiply
les	bx, [dword_38422] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[word ptr es:bx+18h], 0	; Compare Two Operands
jle	short loc_4B493	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
cmp	[byte ptr es:bx+1Fh], 1	; Compare Two Operands
jnz	short loc_4B493	; Jump if Not Zero (ZF=0)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	dx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	dx, ax		; Add
mov	ax, si
mov	bx, 34h	; '4'
push	es
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_38422] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	ax, [es:bx+18h]	; Add
mov	bx, ax
pop	es
cmp	[byte ptr es:bx+1Fh], 1	; Compare Two Operands
jnz	short loc_4B493	; Jump if Not Zero (ZF=0)
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	dx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	dx, ax		; Add
mov	ax, si
mov	bx, 34h	; '4'
push	es
push	dx
imul	bx		; Signed Multiply
les	bx, [dword_38422] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	ax, [es:bx+18h]	; Add
mov	bx, ax
pop	es
mov	[byte ptr es:bx+1Fh], 0

loc_4B493:		; CODE XREF: sub_4A942+AE2j
			; sub_4A942+AF9j
			; sub_4A942+B25j
inc	si		; Increment by 1

loc_4B494:		; CODE XREF: sub_4A942+ACDj
cmp	si, 23h	; '#'   ; Compare Two Operands
jg	short loc_4B49C	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4B412	; Jump

loc_4B49C:		; CODE XREF: sub_4A942+B55j
mov	[bp+var_A], 0
mov	si, 28h	; '('
jmp	loc_4B5E9	; Jump

loc_4B4A7:		; CODE XREF: sub_4A942+CADj
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+219h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
cbw			; AL ->	AX (with sign)
pop	dx
cmp	dx, ax		; Compare Two Operands
jz	short loc_4B4D1	; Jump if Zero (ZF=1)
jmp	loc_4B5E8	; Jump

loc_4B4D1:		; CODE XREF: sub_4A942+B8Aj
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+21Ah], 0 ;	Compare	Two Operands
jz	short loc_4B534	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Ah]
mov	ah, 0
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
cmp	[byte ptr es:bx+1Fh], 1	; Compare Two Operands
jz	short loc_4B534	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Ah]
mov	ah, 0
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
cmp	[byte ptr es:bx+1Fh], 0	; Compare Two Operands
jz	short loc_4B534	; Jump if Zero (ZF=1)
jmp	loc_4B5E8	; Jump

loc_4B534:		; CODE XREF: sub_4A942+B9Dj
			; sub_4A942+BC5j
			; sub_4A942+BEDj
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+21Bh], 0 ;	Compare	Two Operands
jz	short loc_4B594	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Bh]
mov	ah, 0
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
cmp	[byte ptr es:bx+1Fh], 1	; Compare Two Operands
jz	short loc_4B594	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Bh]
mov	ah, 0
push	ax
mov	ax, [word_3A4DA]

loc_4B57F:
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
cmp	[byte ptr es:bx+1Fh], 0	; Compare Two Operands
jnz	short loc_4B5E8	; Jump if Not Zero (ZF=0)

loc_4B594:		; CODE XREF: sub_4A942+C00j
			; sub_4A942+C28j
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
test	[word ptr bx+22Ah], 20h	; Logical Compare
jnz	short loc_4B5E8	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+222h], 0 ;	Compare	Two Operands
jnz	short loc_4B5E8	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+220h], 0 ;	Compare	Two Operands
jnz	short loc_4B5E8	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+210h], 0FFh ; Compare Two Operands
jz	short loc_4B5E5	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+210h], 64h	; 'd' ; Compare Two Operands
jl	short loc_4B5E8	; Jump if Less (SF!=OF)

loc_4B5E5:		; CODE XREF: sub_4A942+C91j
mov	[bp+var_A], si

loc_4B5E8:		; CODE XREF: sub_4A942+B8Cj
			; sub_4A942+BEFj
			; sub_4A942+C50j
			; sub_4A942+C61j
			; sub_4A942+C71j
			; sub_4A942+C81j
			; sub_4A942+CA1j
inc	si		; Increment by 1

loc_4B5E9:		; CODE XREF: sub_4A942+B62j
cmp	si, 9Ah	; ''   ; Compare Two Operands
jge	short loc_4B5F2	; Jump if Greater or Equal (SF=OF)
jmp	loc_4B4A7	; Jump

loc_4B5F2:		; CODE XREF: sub_4A942+CABj
mov	[bp+var_C], 0
mov	si, 28h	; '('
jmp	loc_4B73F	; Jump

loc_4B5FD:		; CODE XREF: sub_4A942+E03j
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+219h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
cbw			; AL ->	AX (with sign)
pop	dx
cmp	dx, ax		; Compare Two Operands
jz	short loc_4B627	; Jump if Zero (ZF=1)
jmp	loc_4B73E	; Jump

loc_4B627:		; CODE XREF: sub_4A942+CE0j
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+21Ah], 0 ;	Compare	Two Operands
jz	short loc_4B68A	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Ah]
mov	ah, 0
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
cmp	[byte ptr es:bx+1Fh], 1	; Compare Two Operands
jz	short loc_4B68A	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Ah]
mov	ah, 0
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
cmp	[byte ptr es:bx+1Fh], 0	; Compare Two Operands
jz	short loc_4B68A	; Jump if Zero (ZF=1)
jmp	loc_4B73E	; Jump

loc_4B68A:		; CODE XREF: sub_4A942+CF3j
			; sub_4A942+D1Bj
			; sub_4A942+D43j
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+21Bh], 0 ;	Compare	Two Operands
jz	short loc_4B6EA	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Bh]
mov	ah, 0
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
cmp	[byte ptr es:bx+1Fh], 1	; Compare Two Operands
jz	short loc_4B6EA	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Bh]
mov	ah, 0
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
pop	ax
add	bx, ax		; Add
cmp	[byte ptr es:bx+1Fh], 0	; Compare Two Operands
jnz	short loc_4B73E	; Jump if Not Zero (ZF=0)

loc_4B6EA:		; CODE XREF: sub_4A942+D56j
			; sub_4A942+D7Ej
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
test	[word ptr bx+22Ah], 20h	; Logical Compare
jnz	short loc_4B73E	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+222h], 0 ;	Compare	Two Operands
jnz	short loc_4B73E	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+220h], 0 ;	Compare	Two Operands
jnz	short loc_4B73E	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+210h], 0 ;	Compare	Two Operands
jle	short loc_4B73E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+210h], 64h	; 'd' ; Compare Two Operands
jge	short loc_4B73E	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_C], si

loc_4B73E:		; CODE XREF: sub_4A942+CE2j
			; sub_4A942+D45j
			; sub_4A942+DA6j
			; sub_4A942+DB7j
			; sub_4A942+DC7j
			; sub_4A942+DD7j
			; sub_4A942+DE7j
			; sub_4A942+DF7j
inc	si		; Increment by 1

loc_4B73F:		; CODE XREF: sub_4A942+CB8j
cmp	si, 9Ah	; ''   ; Compare Two Operands
jge	short loc_4B748	; Jump if Greater or Equal (SF=OF)
jmp	loc_4B5FD	; Jump

loc_4B748:		; CODE XREF: sub_4A942+E01j
xor	si, si		; Logical Exclusive OR
jmp	short loc_4B79C	; Jump

loc_4B74C:		; CODE XREF: sub_4A942+E7Aj
push	[word_3A4DA]
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, 5
push	ax
push	[bp+var_A]
nop			; No Operation
push	cs
call	near ptr sub_4CB55 ; Call Procedure
add	sp, 0Ch		; Add
inc	si		; Increment by 1

loc_4B79C:		; CODE XREF: sub_4A942+E08j
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+14h]
cbw			; AL ->	AX (with sign)
mov	bx, 4
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, si		; Compare Two Operands
jle	short loc_4B7BE	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	si, 9		; Compare Two Operands
jl	short loc_4B74C	; Jump if Less (SF!=OF)

loc_4B7BE:		; CODE XREF: sub_4A942+E75j
cmp	[bp+var_C], 0	; Compare Two Operands
jnz	short loc_4B83C	; Jump if Not Zero (ZF=0)
xor	si, si		; Logical Exclusive OR
jmp	short loc_4B818	; Jump

loc_4B7C8:		; CODE XREF: sub_4A942+EF6j
push	[word_3A4DA]
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, 5
push	ax
push	[bp+var_A]
nop			; No Operation
push	cs
call	near ptr sub_4CB55 ; Call Procedure
add	sp, 0Ch		; Add
inc	si		; Increment by 1

loc_4B818:		; CODE XREF: sub_4A942+E84j
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+14h]
cbw			; AL ->	AX (with sign)
mov	bx, 4
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, si		; Compare Two Operands
jle	short loc_4B83A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	si, 9		; Compare Two Operands
jl	short loc_4B7C8	; Jump if Less (SF!=OF)

loc_4B83A:		; CODE XREF: sub_4A942+EF1j
jmp	short loc_4B8B2	; Jump

loc_4B83C:		; CODE XREF: sub_4A942+E80j
xor	si, si		; Logical Exclusive OR
jmp	short loc_4B890	; Jump

loc_4B840:		; CODE XREF: sub_4A942+F6Ej
push	[word_3A4DA]
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, 5
push	ax
push	[bp+var_C]
nop			; No Operation
push	cs
call	near ptr sub_4CB55 ; Call Procedure
add	sp, 0Ch		; Add
inc	si		; Increment by 1

loc_4B890:		; CODE XREF: sub_4A942+EFCj
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+14h]
cbw			; AL ->	AX (with sign)
mov	bx, 4
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
cmp	ax, si		; Compare Two Operands
jle	short loc_4B8B2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	si, 9		; Compare Two Operands
jl	short loc_4B840	; Jump if Less (SF!=OF)

loc_4B8B2:		; CODE XREF: sub_4A942:loc_4B83Aj
			; sub_4A942+F69j
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6E2]
add	dx, ax		; Add
push	[word ptr dword_3A6E2+2] ; int
push	dx		; int
mov	ax, [word_3A4DA]
mov	dx, 72h	; 'r'   ; int

loc_4B8CB:		; Signed Multiply
imul	dx
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
cbw			; int

loc_4B8D8:		; int
push	ax
nop			; No Operation
push	cs
call	near ptr LBX_Cityname_s4B973 ; Call Procedure
add	sp, 6		; Add

loc_4B8E1:		; Increment by 1
inc	[word_3A4DA]
inc	di		; Increment by 1

loc_4B8E6:		; CODE XREF: sub_4A942+102j
cmp	di, 0Fh		; Compare Two Operands
jge	short loc_4B8F5	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_E], 3E8h ; Compare Two Operands
jge	short loc_4B8F5	; Jump if Greater or Equal (SF=OF)

loc_4B8F2:		; Jump
jmp	loc_4AA47

loc_4B8F5:		; CODE XREF: sub_4A942+36Bj
			; sub_4A942+FA7j
			; sub_4A942+FAEj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4A942 ; sp-analysis failed

off_4B8FB dw offset loc_4B2A5
			; DATA XREF: sub_4A942+8B3r
dw offset loc_4B292	; jump table for switch	statement
dw offset loc_4B27F
dw offset loc_4B26C
dw offset loc_4B26C
dw offset loc_4B259
dw offset loc_4B246
dw offset loc_4B246
dw offset loc_4B233
dw offset loc_4B233
dw offset loc_4B220
dw offset loc_4B20D
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
dw offset loc_4B1FA
off_4B92B dw offset loc_4ADE9
			; DATA XREF: sub_4A942+4A2r
dw offset loc_4ADFE	; jump table for switch	statement
dw offset loc_4AE13
dw offset loc_4AE28
dw offset loc_4AE3D
off_4B935 dw offset loc_4ACE9
			; DATA XREF: sub_4A942+3A2r
dw offset loc_4ACFF	; jump table for switch	statement
dw offset loc_4AD15
dw offset loc_4AD2B
dw offset loc_4AD5B
dw offset loc_4AD5D
dw offset loc_4AD72
dw offset loc_4AD87
dw offset loc_4AD89
dw offset loc_4AD9E
dw offset loc_4ADA1
dw offset loc_4ADA3
dw offset loc_4ADB8
off_4B94F dw offset loc_4A9FC
			; DATA XREF: sub_4A942+B5r
dw offset loc_4AA08	; jump table for switch	statement
dw offset loc_4AA14
dw offset loc_4AA20
dw offset loc_4AA2C
off_4B959 dw offset loc_4A977
			; DATA XREF: sub_4A942+30r
dw offset loc_4A983	; jump table for switch	statement
dw offset loc_4A98F
dw offset loc_4A99B
dw offset loc_4A99D
dw offset loc_4A99F
dw offset loc_4A9AB
dw offset loc_4A9B7
dw offset loc_4A9B9
dw offset loc_4A9C5
dw offset loc_4A9C7
dw offset loc_4A9C9
dw offset loc_4A9D5


; Attributes: bp-based frame

; int __fastcall __far LBX_Cityname_s4B973(int,	int, int, int, int, int)
proc LBX_Cityname_s4B973 far
			; CODE XREF: j_LBX_Cityname_s4B973J
			; sub_43E4F+8FCp
			; sub_4A942+F99p

str1= byte ptr -18h
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si
push	di		; s2
mov	ax, 118h
push	ax		; arg_0
call	EMM_CheckAllocation ; Call Procedure
pop	cx
mov	di, ax
mov	ax, 118h
push	ax		; int
mov	ax, 1
push	ax		; int
push	[bp+arg_0]	; int
push	di		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, offset strCITYNAME ; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_2], 0

loc_4B9A7:		; CODE XREF: LBX_Cityname_s4B973+8Dj
inc	[bp+var_2]	; Increment by 1
mov	ax, 14h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_4], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_4BA29	; Jump

loc_4B9BC:		; CODE XREF: LBX_Cityname_s4B973+BAj
mov	ax, si
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6E2]
add	dx, ax		; Add
push	[word ptr dword_3A6E2+2]
push	dx
xor	ax, ax		; Logical Exclusive OR
push	ax
lea	ax, [bp+str1]	; Load Effective Address
push	ax
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
mov	ax, [bp+var_4]
mov	dx, 0Eh
imul	dx		; Signed Multiply
mov	dx, di
add	dx, ax		; int
push	dx
lea	ax, [bp+str1]	; Load Effective Address
push	ax		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_4BA28	; Jump if Not Zero (ZF=0)
cmp	[bp+var_2], 0C8h ; '' ; Compare Two Operands
jge	short loc_4BA04	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4B9A7	; Jump
jmp	short loc_4BA28	; Jump

loc_4BA04:		; CODE XREF: LBX_Cityname_s4B973+8Bj
mov	ax, 118h
push	ax		; int
mov	ax, 1
push	ax		; int
mov	ax, 0Eh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
push	ax		; int
push	di		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 34B8h	; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add

loc_4BA28:		; CODE XREF: LBX_Cityname_s4B973+84j
			; LBX_Cityname_s4B973+8Fj
inc	si		; Increment by 1

loc_4BA29:		; CODE XREF: LBX_Cityname_s4B973+47j
cmp	si, [word_3A4DA] ; Compare Two Operands
jl	short loc_4B9BC	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, [bp+var_4]
mov	dx, 0Eh
imul	dx		; Signed Multiply
mov	dx, di
add	dx, ax		; Add
push	dx
push	[bp+arg_4]
push	[bp+arg_2]
call	idk_Get_FAT_FileExtension_s14EED ; Call	Procedure
add	sp, 8		; Add
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp LBX_Cityname_s4B973 ; sp-analysis failed



; Attributes: bp-based frame

proc sub_4BA53 far	; CODE XREF: sub_319CDJ
			; idk_BuildingWorlds+1E3p
			; idk_BuildingWorlds+1EDp

var_A4=	word ptr -0A4h
var_5E=	word ptr -5Eh
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 0A4h	; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_0]
mov	[bp+var_E], 0
jmp	short loc_4BA97	; Jump

loc_4BA66:		; CODE XREF: sub_4BA53+48j
mov	[bp+var_C], 0
jmp	short loc_4BA8E	; Jump

loc_4BA6D:		; CODE XREF: sub_4BA53+3Fj
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
mov	[byte ptr es:bx], 0
inc	[bp+var_C]	; Increment by 1

loc_4BA8E:		; CODE XREF: sub_4BA53+18j
cmp	[bp+var_C], 3Ch	; '<' ; Compare Two Operands
jl	short loc_4BA6D	; Jump if Less (SF!=OF)
inc	[bp+var_E]	; Increment by 1

loc_4BA97:		; CODE XREF: sub_4BA53+11j
cmp	[bp+var_E], 28h	; '(' ; Compare Two Operands
jl	short loc_4BA66	; Jump if Less (SF!=OF)
mov	[bp+var_2], 0
jmp	loc_4BE10	; Jump

loc_4BAA5:		; CODE XREF: sub_4BA53+3C6j
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
mov	[bp+var_12], ax
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
mov	[bp+var_14], ax
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
mov	[bp+var_4], ax
jmp	loc_4BE01	; Jump

loc_4BADB:		; CODE XREF: sub_4BA53+3B7j
mov	ax, [bp+var_4]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
mov	[bp+var_16], ax
mov	ax, [bp+var_4]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
mov	[bp+var_18], ax
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
cmp	ax, di		; Compare Two Operands
jz	short loc_4BB21	; Jump if Zero (ZF=1)
jmp	loc_4BDFE	; Jump

loc_4BB21:		; CODE XREF: sub_4BA53+C9j
mov	ax, [bp+var_4]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
cmp	ax, di		; Compare Two Operands
jz	short loc_4BB3B	; Jump if Zero (ZF=1)
jmp	loc_4BDFE	; Jump

loc_4BB3B:		; CODE XREF: sub_4BA53+E3j
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+12h], 5	; Compare Two Operands
jz	short loc_4BB53	; Jump if Zero (ZF=1)
jmp	loc_4BDFE	; Jump

loc_4BB53:		; CODE XREF: sub_4BA53+FBj
mov	ax, [bp+var_4]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+12h], 5	; Compare Two Operands
jz	short loc_4BB6B	; Jump if Zero (ZF=1)
jmp	loc_4BDFE	; Jump

loc_4BB6B:		; CODE XREF: sub_4BA53+113j
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_14]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_12]	; Add
mov	al, [es:bx]
push	ax
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6F6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_18]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_16]	; Add
pop	ax
cmp	al, [es:bx]	; Compare Two Operands
jz	short loc_4BBAC	; Jump if Zero (ZF=1)
jmp	loc_4BDFE	; Jump

loc_4BBAC:		; CODE XREF: sub_4BA53+154j
push	[bp+var_18]
push	[bp+var_16]
push	[bp+var_14]
push	[bp+var_12]
call	sub_1D6D9	; Call Procedure
add	sp, 8		; Add
cmp	ax, 0Bh		; Compare Two Operands
jl	short loc_4BBC8	; Jump if Less (SF!=OF)
jmp	loc_4BDFE	; Jump

loc_4BBC8:		; CODE XREF: sub_4BA53+170j
mov	ax, 3Ch	; '<'
push	ax
lea	ax, [bp+var_A4]	; Load Effective Address
push	ax
lea	ax, [bp+var_5E]	; Load Effective Address
push	ax
push	[bp+var_18]
push	[bp+var_16]
push	[bp+var_14]
push	[bp+var_12]
call	sub_1D906	; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_8], ax
mov	[bp+var_6], 0
mov	[bp+var_A], 0
jmp	loc_4BD2E	; Jump

loc_4BBF9:		; CODE XREF: sub_4BA53+2EAj
lea	ax, [bp+var_5E]	; Load Effective Address
mov	bx, [bp+var_A]
add	bx, ax		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_C], ax
lea	ax, [bp+var_A4]	; Load Effective Address
mov	bx, [bp+var_A]
add	bx, ax		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_E], ax
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 2 ; Compare Two Operands
jb	short loc_4BC64	; Jump if Below	(CF=1)
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0A1h ; '' ; Compare Two Operands
ja	short loc_4BC64	; Jump if Above	(CF=0 &	ZF=0)
mov	[bp+var_6], 1

loc_4BC64:		; CODE XREF: sub_4BA53+1E5j
			; sub_4BA53+20Aj
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0 ; Compare Two Operands
jnz	short loc_4BC8D	; Jump if Not Zero (ZF=0)
mov	[bp+var_6], 1

loc_4BC8D:		; CODE XREF: sub_4BA53+233j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0D9h ; '' ; Compare Two Operands
jb	short loc_4BCDC	; Jump if Below	(CF=1)
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 0E8h ; '' ; Compare Two Operands
ja	short loc_4BCDC	; Jump if Above	(CF=0 &	ZF=0)
mov	[bp+var_6], 1

loc_4BCDC:		; CODE XREF: sub_4BA53+25Dj
			; sub_4BA53+282j
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 1C4h ; Compare Two Operands
jb	short loc_4BD2B	; Jump if Below	(CF=1)
mov	ax, di
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 259h ; Compare Two Operands

loc_4BD24:		; Jump if Above	(CF=0 &	ZF=0)
ja	short loc_4BD2B
mov	[bp+var_6], 1

loc_4BD2B:		; CODE XREF: sub_4BA53+2ACj
			; sub_4BA53:loc_4BD24j
inc	[bp+var_A]	; Increment by 1

loc_4BD2E:		; CODE XREF: sub_4BA53+1A3j
mov	ax, [bp+var_8]
dec	ax		; Decrement by 1
cmp	ax, [bp+var_A]	; Compare Two Operands
jle	short loc_4BD40	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_6], 0	; Compare Two Operands
jnz	short loc_4BD40	; Jump if Not Zero (ZF=0)
jmp	loc_4BBF9	; Jump

loc_4BD40:		; CODE XREF: sub_4BA53+2E2j
			; sub_4BA53+2E8j
cmp	[bp+var_6], 0	; Compare Two Operands
jz	short loc_4BD49	; Jump if Zero (ZF=1)
jmp	loc_4BDFE	; Jump

loc_4BD49:		; CODE XREF: sub_4BA53+2F1j
mov	[bp+var_A], 0
jmp	loc_4BDF2	; Jump

loc_4BD51:		; CODE XREF: sub_4BA53+3A8j
lea	ax, [bp+var_5E]	; Load Effective Address

loc_4BD54:
mov	bx, [bp+var_A]
add	bx, ax		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_C], ax
lea	ax, [bp+var_A4]	; Load Effective Address
mov	bx, [bp+var_A]
add	bx, ax		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_E], ax
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]

loc_4BD7E:
mov	dx, 3Ch	; '<'

loc_4BD81:		; Signed Multiply
imul	dx

loc_4BD83:		; Add
add	bx, ax
add	bx, [bp+var_C]	; Add
mov	al, [es:bx]
or	al, 8		; Logical Inclusive OR
push	ax
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
pop	ax
mov	[es:bx], al
cmp	di, 1		; Compare Two Operands
jnz	short loc_4BDEF	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
mov	al, [es:bx]
or	al, 10h		; Logical Inclusive OR
push	ax
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
pop	ax
mov	[es:bx], al

loc_4BDEF:		; CODE XREF: sub_4BA53+35Cj
inc	[bp+var_A]	; Increment by 1

loc_4BDF2:		; CODE XREF: sub_4BA53+2FBj
mov	ax, [bp+var_8]
dec	ax		; Decrement by 1
cmp	ax, [bp+var_A]	; Compare Two Operands
jle	short loc_4BDFE	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4BD51	; Jump

loc_4BDFE:		; CODE XREF: sub_4BA53+CBj
			; sub_4BA53+E5j
			; sub_4BA53+FDj
			; sub_4BA53+115j
			; sub_4BA53+156j
			; sub_4BA53+172j
			; sub_4BA53+2F3j
			; sub_4BA53+3A6j
inc	[bp+var_4]	; Increment by 1

loc_4BE01:		; CODE XREF: sub_4BA53+85j
mov	ax, [bp+var_4]
cmp	ax, [word_3A4DA] ; Compare Two Operands
jge	short loc_4BE0D	; Jump if Greater or Equal (SF=OF)
jmp	loc_4BADB	; Jump

loc_4BE0D:		; CODE XREF: sub_4BA53+3B5j
inc	[bp+var_2]	; Increment by 1

loc_4BE10:		; CODE XREF: sub_4BA53+4Fj
mov	ax, [bp+var_2]
cmp	ax, [word_3A4DA] ; Compare Two Operands
jge	short loc_4BE1C	; Jump if Greater or Equal (SF=OF)
jmp	loc_4BAA5	; Jump

loc_4BE1C:		; CODE XREF: sub_4BA53+3C4j
mov	[bp+var_10], 0
jmp	loc_4BF12	; Jump

loc_4BE24:		; CODE XREF: sub_4BA53+4C8j
mov	ax, [bp+var_10]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]

loc_4BE36:		; AL ->	AX (with sign)
cbw
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_10]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
push	es
les	si, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+10h]
cbw			; AL ->	AX (with sign)
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_10]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	si, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+0Fh]
cbw			; AL ->	AX (with sign)
add	bx, ax		; Add
pop	es
mov	al, [es:bx]
or	al, 8		; Logical Inclusive OR
push	ax
mov	ax, [bp+var_10]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_10]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
push	es
les	si, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+10h]
cbw			; AL ->	AX (with sign)
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_10]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	si, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+0Fh]
cbw			; AL ->	AX (with sign)
add	bx, ax		; Add
pop	es
pop	ax
mov	[es:bx], al
cmp	di, 1		; Compare Two Operands
jnz	short loc_4BF0F	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_E]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
mov	al, [es:bx]
or	al, 10h		; Logical Inclusive OR
push	ax
mov	ax, di
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4BEFE:
mov	ax, [bp+var_E]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
pop	ax
mov	[es:bx], al

loc_4BF0F:		; CODE XREF: sub_4BA53+47Cj
inc	[bp+var_10]	; Increment by 1

loc_4BF12:		; CODE XREF: sub_4BA53+3CEj
mov	ax, [bp+var_10]
cmp	ax, [word_3A4DA] ; Compare Two Operands
jge	short loc_4BF1E	; Jump if Greater or Equal (SF=OF)
jmp	loc_4BE24	; Jump

loc_4BF1E:		; CODE XREF: sub_4BA53+4C6j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4BA53



; Attributes: bp-based frame

proc sub_4BF24 far	; CODE XREF: sub_319DCJ
			; idk_BuildingWorlds+28Ep
			; idk_BuildingWorlds+298p

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
mov	si, [bp+arg_0]
call	CALL_DOS_MapMemory ; Call Procedure
mov	ax, si
mov	dx, 60h	; '`'
imul	dx		; Signed Multiply
mov	dx, [word_3A6FE]
add	dx, ax		; Add
push	[word_3A700]
push	dx
mov	ax, si
mov	dx, 3840h
imul	dx		; Signed Multiply
mov	dx, [word ptr dword_3A6D2]
add	dx, ax		; Add
add	dx, 960h	; Add
push	[word ptr dword_3A6D2+2]
push	dx
call	sub_31B80	; Call Procedure
add	sp, 8		; Add
mov	ax, si
mov	dx, 60h	; '`'
imul	dx		; Signed Multiply
mov	dx, [word_3A6FA]
add	dx, ax		; Add
push	[word_3A6FC]
push	dx
mov	ax, si
mov	dx, 3840h
imul	dx		; Signed Multiply

loc_4BF79:
mov	dx, [word ptr dword_3A6D2]
add	dx, ax		; Add

loc_4BF7F:		; Add
add	dx, 2EE0h
push	[word ptr dword_3A6D2+2]
push	dx

loc_4BF88:		; Call Procedure
call	sub_31B80
add	sp, 8		; Add
pop	si
pop	bp

locret_4BF92:		; Return Far from Procedure
retf
endp sub_4BF24



; Attributes: bp-based frame

proc sub_4BF93 far	; CODE XREF: sub_319D2J
			; idk_BuildingWorlds+1D0p
			; idk_BuildingWorlds+1DAp

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
xor	di, di		; Logical Exclusive OR
jmp	short loc_4BFE4	; Jump

loc_4BF9F:		; CODE XREF: sub_4BF93+54j
xor	si, si		; Logical Exclusive OR
jmp	short loc_4BFDE	; Jump

loc_4BFA3:		; CODE XREF: sub_4BF93+4Ej
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx], 0
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_4BFDE:		; CODE XREF: sub_4BF93+Ej
cmp	si, 3Ch	; '<'   ; Compare Two Operands
jl	short loc_4BFA3	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_4BFE4:		; CODE XREF: sub_4BF93+Aj
cmp	di, 28h	; '('   ; Compare Two Operands
jl	short loc_4BF9F	; Jump if Less (SF!=OF)
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_4BFF6	; Jump if Not Zero (ZF=0)
mov	[bp+var_C], 4
jmp	short loc_4BFFB	; Jump

loc_4BFF6:		; CODE XREF: sub_4BF93+5Aj
mov	[bp+var_C], 3

loc_4BFFB:		; CODE XREF: sub_4BF93+61j
mov	[bp+var_6], 0
jmp	loc_4C362	; Jump

loc_4C003:		; CODE XREF: sub_4BF93+3D5j
mov	[bp+var_4], 0
jmp	loc_4C353	; Jump

loc_4C00B:		; CODE XREF: sub_4BF93+3C6j
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, [bp+var_6]
add	dx, ax		; Add
mov	di, dx
mov	ax, [bp+var_C]
shl	ax, 1		; Shift	Logical	Left
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, [bp+var_4]
add	dx, ax		; Add
mov	si, dx
mov	[bp+var_A], 0
mov	[bp+var_8], 0
mov	[bp+var_2], 0
jmp	short loc_4C08F	; Jump

loc_4C042:		; CODE XREF: sub_4BF93+100j
mov	ax, [bp+var_2]
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jnz	short loc_4C08C	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
cmp	ax, si		; Compare Two Operands
jnz	short loc_4C08C	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 18h
imul	dx		; Signed Multiply
les	bx, [dword_3A6E6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
cmp	ax, di		; Compare Two Operands
jnz	short loc_4C08C	; Jump if Not Zero (ZF=0)
mov	[bp+var_8], 1

loc_4C08C:		; CODE XREF: sub_4BF93+C5j
			; sub_4BF93+DBj
			; sub_4BF93+F2j
inc	[bp+var_2]	; Increment by 1

loc_4C08F:		; CODE XREF: sub_4BF93+ADj
cmp	[bp+var_2], 66h	; 'f' ; Compare Two Operands
jl	short loc_4C042	; Jump if Less (SF!=OF)
mov	[bp+var_2], 0
jmp	short loc_4C0CF	; Jump

loc_4C09C:		; CODE XREF: sub_4BF93+140j
mov	ax, [bp+var_2]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
cmp	ax, si		; Compare Two Operands
jnz	short loc_4C0CC	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
cmp	ax, di		; Compare Two Operands
jnz	short loc_4C0CC	; Jump if Not Zero (ZF=0)
mov	[bp+var_8], 1

loc_4C0CC:		; CODE XREF: sub_4BF93+11Cj
			; sub_4BF93+132j
inc	[bp+var_2]	; Increment by 1

loc_4C0CF:		; CODE XREF: sub_4BF93+107j
cmp	[bp+var_2], 6	; Compare Two Operands
jl	short loc_4C09C	; Jump if Less (SF!=OF)
mov	[bp+var_2], 0
jmp	short loc_4C12A	; Jump

loc_4C0DC:		; CODE XREF: sub_4BF93+19Ej
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+11h]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jnz	short loc_4C127	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Fh]
cbw			; AL ->	AX (with sign)
cmp	ax, si		; Compare Two Operands
jnz	short loc_4C127	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+10h]
cbw			; AL ->	AX (with sign)
cmp	ax, di		; Compare Two Operands
jnz	short loc_4C127	; Jump if Not Zero (ZF=0)
mov	[bp+var_A], 1

loc_4C127:		; CODE XREF: sub_4BF93+15Fj
			; sub_4BF93+176j
			; sub_4BF93+18Dj
inc	[bp+var_2]	; Increment by 1

loc_4C12A:		; CODE XREF: sub_4BF93+147j
mov	ax, [bp+var_2]
cmp	ax, [word_3A4DA] ; Compare Two Operands
jl	short loc_4C0DC	; Jump if Less (SF!=OF)
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
cmp	[byte ptr es:bx], 0 ; Compare Two Operands
jz	short loc_4C155	; Jump if Zero (ZF=1)
jmp	loc_4C34D	; Jump

loc_4C155:		; CODE XREF: sub_4BF93+1BDj
cmp	[bp+var_A], 0	; Compare Two Operands
jz	short loc_4C15E	; Jump if Zero (ZF=1)
jmp	loc_4C34D	; Jump

loc_4C15E:		; CODE XREF: sub_4BF93+1C6j
cmp	[bp+var_8], 0	; Compare Two Operands
jz	short loc_4C167	; Jump if Zero (ZF=1)

loc_4C164:		; Jump
jmp	loc_4C34D

loc_4C167:		; CODE XREF: sub_4BF93+1CFj
cmp	di, 2		; Compare Two Operands
jg	short loc_4C17E	; Jump if Greater (ZF=0	& SF=OF)
cmp	di, 26h	; '&'   ; Compare Two Operands
jl	short loc_4C17E	; Jump if Less (SF!=OF)
cmp	si, 2		; Compare Two Operands
jg	short loc_4C17E	; Jump if Greater (ZF=0	& SF=OF)
cmp	si, 3Ah	; ':'   ; Compare Two Operands
jl	short loc_4C17E	; Jump if Less (SF!=OF)
jmp	loc_4C34D	; Jump

loc_4C17E:		; CODE XREF: sub_4BF93+1D7j
			; sub_4BF93+1DCj
			; sub_4BF93+1E1j
			; sub_4BF93+1E6j
push	[bp+arg_0]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D2EC ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jz	short loc_4C1B7	; Jump if Zero (ZF=1)
push	[bp+arg_0]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D02B ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jz	short loc_4C1A5	; Jump if Zero (ZF=1)
jmp	loc_4C244	; default

loc_4C1A5:		; CODE XREF: sub_4BF93+20Dj
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jz	short loc_4C1B7	; Jump if Zero (ZF=1)
jmp	loc_4C244	; default

loc_4C1B7:		; CODE XREF: sub_4BF93+1FBj
			; sub_4BF93+21Fj
mov	ax, 7
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 6		; switch 7 cases
ja	short loc_4C244	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4C371+bx] ; switch jump

loc_4C1D0:		; CODE XREF: sub_4BF93:loc_4C1F4j
			; sub_4BF93:loc_4C1F6j
			; DATA XREF: ovr051:off_4C371o
mov	ax, [bp+arg_0]	; case 0x0
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply

loc_4C1E5:		; Add
add	bx, ax
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A4h ; ''
jmp	short loc_4C244	; default

loc_4C1F4:		; CODE XREF: sub_4BF93+238j
			; DATA XREF: ovr051:off_4C371o
jmp	short loc_4C1D0	; case 0x1

loc_4C1F6:		; CODE XREF: sub_4BF93+238j
			; DATA XREF: ovr051:off_4C371o
jmp	short loc_4C1D0	; case 0x2

loc_4C1F8:		; CODE XREF: sub_4BF93+238j
			; DATA XREF: ovr051:off_4C371o
jmp	short loc_4C1FC	; case 0x3

loc_4C1FA:		; CODE XREF: sub_4BF93+238j
			; DATA XREF: ovr051:off_4C371o
jmp	short $+2	; case 0x4

loc_4C1FC:		; CODE XREF: sub_4BF93+238j
			; sub_4BF93:loc_4C1F8j
			; DATA XREF: ovr051:off_4C371o
mov	ax, [bp+arg_0]	; case 0x5
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0ABh ; ''
jmp	short loc_4C244	; default

loc_4C220:		; CODE XREF: sub_4BF93+238j
			; DATA XREF: ovr051:off_4C371o
mov	ax, [bp+arg_0]	; case 0x6
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 0A6h ; ''
jmp	short $+2	; Jump

loc_4C244:		; CODE XREF: sub_4BF93+20Fj
			; sub_4BF93+221j
			; sub_4BF93+234j
			; sub_4BF93+25Fj
			; sub_4BF93+28Bj
push	[bp+arg_0]	; default
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D02B ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4C273	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx], 40h ;	'@'

loc_4C273:		; CODE XREF: sub_4BF93+2C1j
push	[bp+arg_0]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D1AE ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4C2AC	; Jump if Not Zero (ZF=0)
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_4C46D ; Call Procedure
pop	cx
push	ax
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
pop	ax
mov	[es:bx], al

loc_4C2AC:		; CODE XREF: sub_4BF93+2F0j
push	[bp+arg_0]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D1F9 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4C2E5	; Jump if Not Zero (ZF=0)
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_4C3E1 ; Call Procedure
pop	cx
push	ax
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
pop	ax
mov	[es:bx], al

loc_4C2E5:		; CODE XREF: sub_4BF93+329j
push	[bp+arg_0]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D244 ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4C314	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx], 80h ;	''

loc_4C314:		; CODE XREF: sub_4BF93+362j
push	[bp+arg_0]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4D28F ; Call Procedure
add	sp, 6		; Add
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4C34D	; Jump if Not Zero (ZF=0)
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_4C37F ; Call Procedure
pop	cx
push	ax
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
pop	ax
mov	[es:bx], al

loc_4C34D:		; CODE XREF: sub_4BF93+1BFj
			; sub_4BF93+1C8j
			; sub_4BF93:loc_4C164j
			; sub_4BF93+1E8j
			; sub_4BF93+391j
mov	ax, [bp+var_C]
add	[bp+var_4], ax	; Add

loc_4C353:		; CODE XREF: sub_4BF93+75j
cmp	[bp+var_4], 3Ch	; '<' ; Compare Two Operands
jge	short loc_4C35C	; Jump if Greater or Equal (SF=OF)
jmp	loc_4C00B	; Jump

loc_4C35C:		; CODE XREF: sub_4BF93+3C4j
mov	ax, [bp+var_C]
add	[bp+var_6], ax	; Add

loc_4C362:		; CODE XREF: sub_4BF93+6Dj
cmp	[bp+var_6], 28h	; '(' ; Compare Two Operands
jge	short loc_4C36B	; Jump if Greater or Equal (SF=OF)
jmp	loc_4C003	; Jump

loc_4C36B:		; CODE XREF: sub_4BF93+3D3j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4BF93

off_4C371 dw offset loc_4C1D0
			; DATA XREF: sub_4BF93+238r
dw offset loc_4C1F4	; jump table for switch	statement
dw offset loc_4C1F6
dw offset loc_4C1F8
dw offset loc_4C1FA
dw offset loc_4C1FC
dw offset loc_4C220


; Attributes: bp-based frame

proc sub_4C37F far	; CODE XREF: sub_319D7J
			; sub_4BF93+398p

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di
xor	si, si		; Logical Exclusive OR
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_4C398	; Jump if Not Zero (ZF=0)
mov	ax, 9
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
jmp	short loc_4C3A5	; Jump

loc_4C398:		; CODE XREF: sub_4C37F+Bj
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 5		; Add

loc_4C3A5:		; CODE XREF: sub_4C37F+17j
mov	di, ax
mov	bx, di
dec	bx		; Decrement by 1
cmp	bx, 9		; switch 10 cases
ja	short loc_4C3C5	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4C3CD+bx] ; switch jump

loc_4C3B6:		; DATA XREF: ovr051:off_4C3CDo
mov	si, 5		; case 0x0
jmp	short loc_4C3C5	; default

loc_4C3BB:		; CODE XREF: sub_4C37F+32j
			; DATA XREF: ovr051:off_4C3CDo
mov	si, 8		; case 0x6
jmp	short loc_4C3C5	; default

loc_4C3C0:		; CODE XREF: sub_4C37F+32j
			; DATA XREF: ovr051:off_4C3CDo
mov	si, 9		; case 0x9
jmp	short $+2	; Jump

loc_4C3C5:		; CODE XREF: sub_4C37F+2Ej
			; sub_4C37F+3Aj
			; sub_4C37F+3Fj
mov	ax, si		; default
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4C37F

off_4C3CD dw offset loc_4C3B6
			; DATA XREF: sub_4C37F+32r
dw offset loc_4C3B6	; jump table for switch	statement
dw offset loc_4C3B6
dw offset loc_4C3B6
dw offset loc_4C3B6
dw offset loc_4C3B6
dw offset loc_4C3BB
dw offset loc_4C3BB
dw offset loc_4C3BB
dw offset loc_4C3C0


; Attributes: bp-based frame

proc sub_4C3E1 far	; CODE XREF: sub_319E1J
			; sub_4BF93+330p

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di
xor	si, si		; Logical Exclusive OR
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_4C3FA	; Jump if Not Zero (ZF=0)
mov	ax, 12h
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
jmp	short loc_4C407	; Jump

loc_4C3FA:		; CODE XREF: sub_4C3E1+Bj
mov	ax, 0Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 0Ah		; Add

loc_4C407:		; CODE XREF: sub_4C3E1+17j
mov	di, ax
mov	bx, di
dec	bx		; Decrement by 1
cmp	bx, 13h		; switch 20 cases
ja	short loc_4C43C	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4C445+bx] ; switch jump

loc_4C418:		; CODE XREF: sub_4C3E1:loc_4C421j
			; DATA XREF: ovr051:off_4C445o
mov	si, 1		; case 0x0
jmp	short loc_4C43C	; default

loc_4C41D:		; CODE XREF: sub_4C3E1+32j
			; DATA XREF: ovr051:off_4C445o
jmp	short loc_4C428	; case 0x5

loc_4C41F:		; CODE XREF: sub_4C3E1+32j
			; DATA XREF: ovr051:off_4C445o
jmp	short loc_4C423	; case 0x8

loc_4C421:		; CODE XREF: sub_4C3E1+32j
			; DATA XREF: ovr051:off_4C445o
jmp	short loc_4C418	; case 0xA

loc_4C423:		; CODE XREF: sub_4C3E1+32j
			; sub_4C3E1:loc_4C41Fj
			; DATA XREF: ovr051:off_4C445o
mov	si, 2		; case 0xB
jmp	short loc_4C43C	; default

loc_4C428:		; CODE XREF: sub_4C3E1+32j
			; sub_4C3E1:loc_4C41Dj
			; DATA XREF: ovr051:off_4C445o
mov	si, 3		; case 0xC
jmp	short loc_4C43C	; default

loc_4C42D:		; CODE XREF: sub_4C3E1+32j
			; DATA XREF: ovr051:off_4C445o
mov	si, 4		; case 0xD
jmp	short loc_4C43C	; default

loc_4C432:		; CODE XREF: sub_4C3E1+32j
			; DATA XREF: ovr051:off_4C445o
mov	si, 6		; case 0x11
jmp	short loc_4C43C	; default

loc_4C437:		; CODE XREF: sub_4C3E1+32j
			; DATA XREF: ovr051:off_4C445o
mov	si, 7		; case 0x13
jmp	short $+2	; Jump

loc_4C43C:		; CODE XREF: sub_4C3E1+2Ej
			; sub_4C3E1+3Aj
			; sub_4C3E1+45j
			; sub_4C3E1+4Aj
			; sub_4C3E1+4Fj
			; sub_4C3E1+54j
mov	ax, si		; default
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4C3E1

db 0
off_4C445 dw offset loc_4C418
			; DATA XREF: sub_4C3E1+32r
dw offset loc_4C418	; jump table for switch	statement
dw offset loc_4C418
dw offset loc_4C418
dw offset loc_4C418
dw offset loc_4C41D
dw offset loc_4C41D
dw offset loc_4C41D
dw offset loc_4C41F
dw offset loc_4C41F
dw offset loc_4C421
dw offset loc_4C423
dw offset loc_4C428
dw offset loc_4C42D
dw offset loc_4C42D
dw offset loc_4C42D
dw offset loc_4C42D
dw offset loc_4C432
dw offset loc_4C432
dw offset loc_4C437


; Attributes: bp-based frame

proc sub_4C46D far	; CODE XREF: sub_319E6J
			; sub_4BF93+2F7p

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di
xor	si, si		; Logical Exclusive OR
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_4C486	; Jump if Not Zero (ZF=0)
mov	ax, 12h
push	ax

loc_4C47E:		; Call Procedure
call	idk_Arg_0Fail_ElseMathyDiSi
pop	cx
jmp	short loc_4C493	; Jump

loc_4C486:		; CODE XREF: sub_4C46D+Bj
mov	ax, 0Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 0Ah		; Add

loc_4C493:		; CODE XREF: sub_4C46D+17j
mov	di, ax
mov	bx, di
dec	bx		; Decrement by 1
cmp	bx, 13h		; switch 20 cases
ja	short loc_4C4CA	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4C4D2+bx] ; switch jump

loc_4C4A4:		; CODE XREF: sub_4C46D:loc_4C4AFj
			; DATA XREF: ovr051:off_4C4D2o
mov	si, 1		; case 0x0
jmp	short loc_4C4CA	; default

loc_4C4A9:		; CODE XREF: sub_4C46D+32j
			; DATA XREF: ovr051:off_4C4D2o
jmp	short loc_4C4B1	; case 0x3

loc_4C4AB:		; CODE XREF: sub_4C46D+32j
			; DATA XREF: ovr051:off_4C4D2o
jmp	short loc_4C4B6	; case 0x5

loc_4C4AD:		; CODE XREF: sub_4C46D+32j
			; DATA XREF: ovr051:off_4C4D2o
jmp	short loc_4C4BB	; case 0x9

loc_4C4AF:		; CODE XREF: sub_4C46D+32j
			; DATA XREF: ovr051:off_4C4D2o
jmp	short loc_4C4A4	; case 0xA

loc_4C4B1:		; CODE XREF: sub_4C46D+32j
			; sub_4C46D:loc_4C4A9j
			; DATA XREF: ovr051:off_4C4D2o
mov	si, 3		; case 0xB
jmp	short loc_4C4CA	; default

loc_4C4B6:		; CODE XREF: sub_4C46D+32j
			; sub_4C46D:loc_4C4ABj
			; DATA XREF: ovr051:off_4C4D2o
mov	si, 2		; case 0xC
jmp	short loc_4C4CA	; default

loc_4C4BB:		; CODE XREF: sub_4C46D+32j
			; sub_4C46D:loc_4C4ADj
			; DATA XREF: ovr051:off_4C4D2o
mov	si, 4		; case 0xD
jmp	short loc_4C4CA	; default

loc_4C4C0:		; CODE XREF: sub_4C46D+32j
			; DATA XREF: ovr051:off_4C4D2o
mov	si, 6		; case 0xF
jmp	short loc_4C4CA	; default

loc_4C4C5:		; CODE XREF: sub_4C46D+32j
			; DATA XREF: ovr051:off_4C4D2o
mov	si, 7		; case 0x12
jmp	short $+2	; Jump

loc_4C4CA:		; CODE XREF: sub_4C46D+2Ej
			; sub_4C46D+3Aj
			; sub_4C46D+47j
			; sub_4C46D+4Cj
			; sub_4C46D+51j
			; sub_4C46D+56j
mov	ax, si		; default
jmp	short $+2	; Jump
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4C46D

off_4C4D2 dw offset loc_4C4A4
			; DATA XREF: sub_4C46D+32r
dw offset loc_4C4A4	; jump table for switch	statement
dw offset loc_4C4A4
dw offset loc_4C4A9
dw offset loc_4C4A9
dw offset loc_4C4AB
dw offset loc_4C4AB
dw offset loc_4C4AB
dw offset loc_4C4AB
dw offset loc_4C4AD
dw offset loc_4C4AF
dw offset loc_4C4B1
dw offset loc_4C4B6
dw offset loc_4C4BB
dw offset loc_4C4BB
dw offset loc_4C4C0
dw offset loc_4C4C0
dw offset loc_4C4C0
dw offset loc_4C4C5
dw offset loc_4C4C5


; Attributes: bp-based frame

proc sub_4C4FA far	; CODE XREF: sub_319EBJ
			; idk_BuildingWorlds+2A8p

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction

loc_4C500:
push	si
push	di
mov	[bp+var_2], 0
jmp	short loc_4C53D	; Jump

loc_4C509:		; CODE XREF: sub_4C4FA+47j
xor	di, di		; Logical Exclusive OR
jmp	short loc_4C535	; Jump

loc_4C50D:		; CODE XREF: sub_4C4FA+3Ej
xor	si, si		; Logical Exclusive OR

loc_4C50F:		; Jump
jmp	short loc_4C52F

loc_4C511:		; CODE XREF: sub_4C4FA+38j
mov	ax, [bp+var_2]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, si		; Add
mov	[byte ptr es:bx], 0
inc	si		; Increment by 1

loc_4C52F:		; CODE XREF: sub_4C4FA:loc_4C50Fj
cmp	si, 3Ch	; '<'   ; Compare Two Operands
jl	short loc_4C511	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_4C535:		; CODE XREF: sub_4C4FA+11j
cmp	di, 28h	; '('   ; Compare Two Operands
jl	short loc_4C50D	; Jump if Less (SF!=OF)
inc	[bp+var_2]	; Increment by 1

loc_4C53D:		; CODE XREF: sub_4C4FA+Dj
cmp	[bp+var_2], 2	; Compare Two Operands
jl	short loc_4C509	; Jump if Less (SF!=OF)
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
mov	[bp+var_2], ax
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
mov	si, ax
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
mov	di, ax
mov	[bp+var_4], 0FFFFh
jmp	short loc_4C584	; Jump

loc_4C56B:		; CODE XREF: sub_4C4FA+8Ej
mov	ax, 0Fh
push	ax
push	di
mov	ax, si
add	ax, [bp+var_4]	; Add
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
inc	[bp+var_4]	; Increment by 1

loc_4C584:		; CODE XREF: sub_4C4FA+6Fj
cmp	[bp+var_4], 1	; Compare Two Operands
jle	short loc_4C56B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_4], 0FFFFh

loc_4C58F:		; Jump
jmp	short loc_4C5AD

loc_4C591:		; CODE XREF: sub_4C4FA+B7j
mov	ax, 0Fh
push	ax
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
add	ax, [bp+var_4]	; Add
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
inc	[bp+var_4]	; Increment by 1

loc_4C5AD:		; CODE XREF: sub_4C4FA:loc_4C58Fj
cmp	[bp+var_4], 1	; Compare Two Operands
jle	short loc_4C591	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_4], 0FFFFh
jmp	short loc_4C5D6	; Jump

loc_4C5BA:		; CODE XREF: sub_4C4FA+E0j
mov	ax, 0Fh
push	ax
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
add	ax, [bp+var_4]	; Add
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
inc	[bp+var_4]	; Increment by 1

loc_4C5D6:		; CODE XREF: sub_4C4FA+BEj
cmp	[bp+var_4], 1	; Compare Two Operands
jle	short loc_4C5BA	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 8
push	ax
mov	ax, di
add	ax, 0FFFEh	; Add
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 9
push	ax

loc_4C5F9:
mov	ax, di
add	ax, 0FFFEh	; Add
push	ax
push	si
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add

loc_4C60B:
mov	ax, 1
push	ax
mov	ax, di
add	ax, 0FFFEh	; Add
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 4
push	ax
mov	ax, di
add	ax, 2		; Add
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
push	[bp+var_2]
nop			; No Operation

loc_4C636:
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 6
push	ax
mov	ax, di
add	ax, 2		; Add
push	ax
push	si
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 2
push	ax
mov	ax, di
add	ax, 2		; Add
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 8
push	ax
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
add	ax, 0FFFEh	; Add
push	ax

loc_4C67A:
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 0Ch
push	ax
push	di
mov	ax, si

loc_4C68C:		; Add
add	ax, 0FFFEh
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 4
push	ax
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
add	ax, 0FFFEh	; Add
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 1
push	ax
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
add	ax, 2		; Add
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 2
push	ax
mov	ax, di
inc	ax		; Increment by 1

loc_4C6D4:
push	ax
mov	ax, si
add	ax, 2		; Add
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add

loc_4C6E6:
mov	ax, 3
push	ax
push	di
mov	ax, si
add	ax, 2		; Add
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure

loc_4C6F9:		; Add
add	sp, 8
mov	ax, 0Dh
push	ax
mov	ax, di
dec	ax		; Decrement by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 0Eh
push	ax
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
dec	ax		; Decrement by 1
push	ax
push	[bp+var_2]

loc_4C722:		; No Operation
nop
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 7
push	ax

loc_4C72E:
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, si
inc	ax		; Increment by 1
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs
call	near ptr sub_4C75E ; Call Procedure
add	sp, 8		; Add
mov	ax, 0Bh

loc_4C744:
push	ax

loc_4C745:
mov	ax, di
dec	ax		; Decrement by 1

loc_4C748:
push	ax

loc_4C749:
mov	ax, si
inc	ax		; Increment by 1
push	ax
push	[bp+var_2]
nop			; No Operation
push	cs

loc_4C752:		; Call Procedure
call	near ptr sub_4C75E
add	sp, 8		; Add
pop	di

loc_4C759:
pop	si

loc_4C75A:
mov	sp, bp

loc_4C75C:
pop	bp

locret_4C75D:		; Return Far from Procedure
retf
endp sub_4C4FA



; Attributes: bp-based frame

proc sub_4C75E far	; CODE XREF: sub_319F0J
			; sub_4C4FA+81p
			; sub_4C4FA+AAp
			; sub_4C4FA+D3p
			; sub_4C4FA+F5p
			; sub_4C4FA+10Bp
			; sub_4C4FA+124p
			; sub_4C4FA+13Dp
			; sub_4C4FA+153p
			; sub_4C4FA+16Cp
			; sub_4C4FA+185p
			; sub_4C4FA+19Bp
			; sub_4C4FA+1B4p
			; sub_4C4FA+1CDp
			; sub_4C4FA+1E6p
			; sub_4C4FA+1FCp
			; sub_4C4FA+213p
			; sub_4C4FA+22Ap
			; sub_4C4FA+241p
			; sub_4C4FA:loc_4C752p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= byte ptr	 0Ch

push	bp

loc_4C75F:
mov	bp, sp
push	si
mov	cx, [bp+arg_2]
mov	si, [bp+arg_4]

loc_4C768:		; Logical Inclusive OR
or	cx, cx
jl	short loc_4C799	; Jump if Less (SF!=OF)
cmp	cx, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_4C799	; Jump if Greater or Equal (SF=OF)
or	si, si		; Logical Inclusive OR
jl	short loc_4C799	; Jump if Less (SF!=OF)
cmp	si, 28h	; '('   ; Compare Two Operands
jge	short loc_4C799	; Jump if Greater or Equal (SF=OF)

loc_4C77A:
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D6] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, si
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, cx		; Add
mov	al, [bp+arg_6]
mov	[es:bx], al

loc_4C799:		; CODE XREF: sub_4C75E+Cj
			; sub_4C75E+11j
			; sub_4C75E+15j
			; sub_4C75E+1Aj
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4C75E



; Attributes: bp-based frame

proc sub_4C79C far	; CODE XREF: sub_319F5J
			; idk_BuildingWorlds+271p
			; idk_BuildingWorlds+27Bp

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction

loc_4C7A2:
push	si
push	di
call	CALL_DOS_MapMemory ; Call Procedure
mov	[bp+var_2], 0

loc_4C7AE:		; Jump
jmp	loc_4CAA0

loc_4C7B1:		; CODE XREF: sub_4C79C:loc_4CAA6j
xor	di, di		; Logical Exclusive OR
jmp	loc_4CA95	; Jump

loc_4C7B6:		; CODE XREF: sub_4C79C+2FEj
mov	ax, [bp+arg_0]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_4C7C4:
mov	ax, [bp+var_2]

loc_4C7C7:
mov	dx, 78h	; 'x'

loc_4C7CA:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, di
shl	ax, 1		; Shift	Logical	Left

loc_4C7D2:		; Add
add	bx, ax
mov	ax, [es:bx]

loc_4C7D7:
mov	[bp+var_4], ax

loc_4C7DA:
mov	ax, [bp+arg_0]

loc_4C7DD:
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	ax, [bp+var_4]
mov	dx, 6
imul	dx		; Signed Multiply
push	es
les	si, [dword_378BC] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+1]
pop	es
mov	[es:bx+960h], al
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	ax, [bp+var_4]
mov	dx, 6
imul	dx		; Signed Multiply
push	es
les	si, [dword_378BC] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si]
pop	es
mov	[es:bx], al
mov	ax, [bp+arg_0]

loc_4C840:
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	ax, [bp+var_4]
mov	dx, 6
imul	dx		; Signed Multiply
push	es
les	si, [dword_378BC] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+2]
pop	es
mov	[es:bx+12C0h], al
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	ax, [bp+var_4]
mov	dx, 6
imul	dx		; Signed Multiply
push	es
les	si, [dword_378BC] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+3]
pop	es
mov	[es:bx+1C20h], al
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	ax, [bp+var_4]
mov	dx, 6
imul	dx		; Signed Multiply
push	es
les	si, [dword_378BC] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+4]
pop	es
mov	[es:bx+2580h], al
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	ax, [bp+var_4]
mov	dx, 6
imul	dx		; Signed Multiply
push	es
les	si, [dword_378BC] ; Load Full Pointer to ES:xx
add	si, ax		; Add
mov	al, [es:si+5]
pop	es
mov	[es:bx+2EE0h], al
mov	ax, [bp+arg_0]
mov	dx, 960h
imul	dx		; Signed Multiply
les	bx, [dword_3A6DA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
test	[byte ptr es:bx], 8 ; Logical Compare
jnz	short loc_4C92C	; Jump if Not Zero (ZF=0)
jmp	loc_4CA94	; Jump

loc_4C92C:		; CODE XREF: sub_4C79C+18Bj
cmp	[bp+arg_0], 0	; Compare Two Operands
jz	short loc_4C935	; Jump if Zero (ZF=1)
jmp	loc_4C9D6	; Jump

loc_4C935:		; CODE XREF: sub_4C79C+194j
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+960h], 1
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx], 1
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+12C0h],	1
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+1C20h],	1
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]

loc_4C9C4:
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+2580h],	1
jmp	loc_4CA74	; Jump

loc_4C9D6:		; CODE XREF: sub_4C79C+196j
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+960h], 0
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add

loc_4CA10:
mov	[byte ptr es:bx], 0
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+12C0h],	0
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+1C20h],	0
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+2580h],	0

loc_4CA74:		; CODE XREF: sub_4C79C+237j
mov	ax, [bp+arg_0]
mov	dx, 3840h
imul	dx		; Signed Multiply
les	bx, [dword_3A6D2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3Ch	; '<'

loc_4CA88:		; Signed Multiply
imul	dx
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr es:bx+2EE0h],	0FFh

loc_4CA94:		; CODE XREF: sub_4C79C+18Dj
inc	di		; Increment by 1

loc_4CA95:		; CODE XREF: sub_4C79C+17j
cmp	di, 3Ch	; '<'   ; Compare Two Operands
jge	short loc_4CA9D	; Jump if Greater or Equal (SF=OF)
jmp	loc_4C7B6	; Jump

loc_4CA9D:		; CODE XREF: sub_4C79C+2FCj
inc	[bp+var_2]	; Increment by 1

loc_4CAA0:		; CODE XREF: sub_4C79C:loc_4C7AEj
cmp	[bp+var_2], 28h	; '(' ; Compare Two Operands
jge	short loc_4CAA9	; Jump if Greater or Equal (SF=OF)

loc_4CAA6:		; Jump
jmp	loc_4C7B1

loc_4CAA9:		; CODE XREF: sub_4C79C+308j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4C79C



; Attributes: bp-based frame

proc sub_4CAAF far	; CODE XREF: sub_319FAJ
			; sub_48C63+3E6p
			; sub_48C63+3FFp
			; sub_48C63+416p
			; sub_48C63+42Fp
			; sub_48C63+448p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 62h	; 'b'   ; Compare Two Operands
jl	short loc_4CAED	; Jump if Less (SF!=OF)
cmp	cx, 0A1h ; ''  ; Compare Two Operands
jg	short loc_4CAED	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, 1

loc_4CAEB:		; CODE XREF: sub_4CAAF+40j
jmp	short loc_4CAF1	; Jump

loc_4CAED:		; CODE XREF: sub_4CAAF+31j
			; sub_4CAAF+37j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4CAEB	; Jump

loc_4CAF1:		; CODE XREF: sub_4CAAF:loc_4CAEBj
pop	bp
retf			; Return Far from Procedure
endp sub_4CAAF



; Attributes: bp-based frame

proc sub_4CAF3 far	; CODE XREF: sub_319FFJ
			; idk_BuildingWorlds+9Cp
			; idk_BuildingWorlds+AFp
			; idk_BuildingWorlds+C3p
			; idk_BuildingWorlds+D6p
			; idk_BuildingWorlds+EAp
			; idk_BuildingWorlds+FDp
			; idk_BuildingWorlds+111p
			; idk_BuildingWorlds:loc_436A4p
			; idk_BuildingWorlds+138p
			; idk_BuildingWorlds+147p
			; idk_BuildingWorlds+164p
			; idk_BuildingWorlds+173p
			; idk_BuildingWorlds+195p
			; idk_BuildingWorlds+1AAp
			; idk_BuildingWorlds+1C7p
			; idk_BuildingWorlds+1F7p
			; idk_BuildingWorlds+206p
			; idk_BuildingWorlds+263p
			; idk_BuildingWorlds+285p
			; idk_BuildingWorlds+2A2p

var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
mov	si, [bp+arg_0]
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
or	si, si		; Logical Inclusive OR
jnz	short loc_4CB0A	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4CB50	; Jump

loc_4CB0A:		; CODE XREF: sub_4CAF3+11j
cmp	si, 64h	; 'd'   ; Compare Two Operands
jl	short loc_4CB1C	; Jump if Less (SF!=OF)
mov	ax, 0ACh ; ''
push	ax
mov	ax, 5Eh	; '^'
push	ax
mov	ax, 0E1h ; ''
jmp	short loc_4CB3A	; Jump

loc_4CB1C:		; CODE XREF: sub_4CAF3+1Aj
mov	ax, si
mov	dx, 88h	; ''
imul	dx		; Signed Multiply
mov	bx, 64h	; 'd'
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_2], ax
mov	ax, 0ACh ; ''
push	ax
mov	ax, 5Eh	; '^'
push	ax
mov	ax, [bp+var_2]
add	ax, 5Ah	; 'Z'   ; Add

loc_4CB3A:		; CODE XREF: sub_4CAF3+27j
push	ax
mov	ax, 59h	; 'Y'
push	ax
mov	ax, 5Ah	; 'Z'
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
call	sub_2E303	; Call Procedure

loc_4CB50:		; CODE XREF: sub_4CAF3+15j
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4CAF3



; Attributes: bp-based frame

proc sub_4CB55 far	; CODE XREF: sub_31A04J
			; sub_43E4F+9DEp
			; sub_43E4F+ABCp
			; sub_43E4F+B07p
			; sub_4A942+E53p
			; sub_4A942+ECFp
			; sub_4A942+F47p

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= byte ptr	 0Ah
arg_6= byte ptr	 0Ch
arg_8= byte ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_4CB66	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	loc_4CE31	; Jump

loc_4CB66:		; CODE XREF: sub_4CB55+Aj
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [bp+arg_4]
mov	[es:bx], al
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [bp+arg_6]
mov	[es:bx+1], al
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [bp+arg_8]
mov	[es:bx+2], al
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+arg_2]
mov	[es:bx+3], al
mov	ax, [bp+arg_0]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+215h]
mov	dx, [word_3A4D8]
mov	cl, 5
shl	dx, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, dx		; Add
mov	[es:bx+4], al
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [byte ptr bp+arg_0]
mov	[es:bx+5], al
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+6], 0FFh
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+7], 0
mov	ax, [bp+arg_0]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+215h]
mov	dx, [word_3A4D8]
mov	cl, 5
shl	dx, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, dx		; Add
mov	[es:bx+8], al
mov	ax, [bp+arg_0]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+21Fh]
mov	dx, [word_3A4D8]
mov	cl, 5
shl	dx, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, dx		; Add
mov	[es:bx+16h], al
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+9], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Ah], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Bh], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Ch], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+0Eh], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+11h], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+12h], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+1Ah], 0

loc_4CCDF:
mov	[word ptr es:bx+18h], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+10h], 0
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+1Ch], 0FFh
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+17h], 0
mov	ax, [bp+arg_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6964h], 0 ; Compare Two Operands
jz	short loc_4CD3E	; Jump if Zero (ZF=1)
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+17h], 1

loc_4CD3E:		; CODE XREF: sub_4CB55+1D5j
cmp	[bp+arg_A], 0	; Compare Two Operands
jge	short loc_4CD47	; Jump if Greater or Equal (SF=OF)
jmp	loc_4CE2D	; Jump

loc_4CD47:		; CODE XREF: sub_4CB55+1EDj
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+24h], 0	; Compare Two Operands
jle	short loc_4CD82	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [word_33AF6]
mov	[es:bx+0Eh], ax

loc_4CD70:
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Ch], 1

loc_4CD82:		; CODE XREF: sub_4CB55+205j
mov	ax, [bp+var_2]
mov	dx, 72h	; 'r'
imul	dx		; Signed Multiply
les	bx, [dword_3A6E2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+26h], 0	; Compare Two Operands
jle	short loc_4CDBD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [word_33AF8]
mov	[es:bx+0Eh], ax
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Ch], 2

loc_4CDBD:		; CODE XREF: sub_4CB55+240j
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
cmp	[byte ptr es:bx+0Ch], 3	; Compare Two Operands
jle	short loc_4CDF7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [word_33AFA]
mov	[es:bx+0Eh], ax
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[byte ptr es:bx+0Ch], 3

loc_4CDF7:		; CODE XREF: sub_4CB55+27Aj
mov	ax, [bp+arg_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6965h], 0 ; Compare Two Operands
jle	short loc_4CE2D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [word_3A4D8]
mov	cl, 5
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+0Ch]
inc	al		; Increment by 1
mov	dx, [word_3A4D8]
mov	cl, 5
shl	dx, cl		; Shift	Logical	Left
les	bx, [dword_38608] ; Load Full Pointer to ES:xx
add	bx, dx		; Add
mov	[es:bx+0Ch], al

loc_4CE2D:		; CODE XREF: sub_4CB55+1EFj
			; sub_4CB55+2B1j
inc	[word_3A4D8]	; Increment by 1

loc_4CE31:		; CODE XREF: sub_4CB55+Ej
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4CB55



; Attributes: bp-based frame

proc sub_4CE35 far	; CODE XREF: sub_31A09J
			; idk_BuildingWorlds+2ADp

var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
xor	si, si		; Logical Exclusive OR
jmp	loc_4CF0E	; Jump

loc_4CE42:		; CODE XREF: sub_4CE35+DEj
xor	di, di		; Logical Exclusive OR
jmp	loc_4CF05	; Jump

loc_4CE47:		; CODE XREF: sub_4CE35+D5j
mov	[bp+var_2], 0
jmp	loc_4CEFB	; Jump

loc_4CE4F:		; CODE XREF: sub_4CE35+CCj
mov	ax, si
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx

loc_4CE5A:		; Add
add	bx, ax
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add

loc_4CE6C:		; Compare Two Operands
cmp	[word ptr es:bx], 0
jnz	short loc_4CEA3	; Jump if Not Zero (ZF=0)
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4CEA3	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 259h

loc_4CEA3:		; CODE XREF: sub_4CE35+3Bj
			; sub_4CE35+4Aj
mov	ax, si
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
cmp	[word ptr es:bx], 2FAh ; Compare Two Operands
jnz	short loc_4CEF8	; Jump if Not Zero (ZF=0)
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4CEF8	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, di
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	[word ptr es:bx], 553h

loc_4CEF8:		; CODE XREF: sub_4CE35+90j
			; sub_4CE35+9Fj
inc	[bp+var_2]	; Increment by 1

loc_4CEFB:		; CODE XREF: sub_4CE35+17j
cmp	[bp+var_2], 3Ch	; '<' ; Compare Two Operands
jg	short loc_4CF04	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4CE4F	; Jump

loc_4CF04:		; CODE XREF: sub_4CE35+CAj
inc	di		; Increment by 1

loc_4CF05:		; CODE XREF: sub_4CE35+Fj
cmp	di, 28h	; '('   ; Compare Two Operands
jg	short loc_4CF0D	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4CE47	; Jump

loc_4CF0D:		; CODE XREF: sub_4CE35+D3j
inc	si		; Increment by 1

loc_4CF0E:		; CODE XREF: sub_4CE35+Aj
cmp	si, 2		; Compare Two Operands
jge	short loc_4CF16	; Jump if Greater or Equal (SF=OF)
jmp	loc_4CE42	; Jump

loc_4CF16:		; CODE XREF: sub_4CE35+DCj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4CE35



; Attributes: bp-based frame

proc sub_4CF1C far	; CODE XREF: sub_31A0EJ
			; sub_438C4:loc_43968p
			; sub_438C4+BCp
			; sub_438C4+D4p
			; sub_438C4+ECp
			; sub_46406:loc_465DCp
			; sub_46406+2CAp
			; sub_48C63+5Ep
			; sub_48C63+76p
			; sub_48C63+90p
			; sub_48C63+A8p
			; sub_48C63+BEp
			; sub_48C63+D6p
			; sub_48C63+F1p
			; sub_48C63+10Ap
			; sub_48C63+125p
			; sub_48C63:loc_48F84p
			; sub_48C63+33Cp
			; sub_48C63+355p
			; sub_48C63+370p
			; sub_48C63+38Bp
			; sub_4910F+65p
			; sub_4910F+92p
			; sub_4910F+C0p
			; sub_4910F+EEp

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'

loc_4CF33:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide

loc_4CF48:
mov	cx, dx
cmp	cx, 1		; Compare Two Operands
jnz	short loc_4CF53	; Jump if Not Zero (ZF=0)

loc_4CF4F:		; CODE XREF: sub_4CF1C:loc_4CF88j
xor	ax, ax		; Logical Exclusive OR

loc_4CF51:		; CODE XREF: sub_4CF1C+6Aj
jmp	short loc_4CF8A	; Jump

loc_4CF53:		; CODE XREF: sub_4CF1C+31j
cmp	cx, 0A2h ; ''  ; Compare Two Operands
jge	short loc_4CF5B	; Jump if Greater or Equal (SF=OF)

loc_4CF59:		; Jump
jmp	short loc_4CF83

loc_4CF5B:		; CODE XREF: sub_4CF1C+3Bj
cmp	cx, 0C4h ; ''  ; Compare Two Operands
jle	short loc_4CF69	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 0E9h ; ''  ; Compare Two Operands
jge	short loc_4CF69	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4CF83	; Jump

loc_4CF69:		; CODE XREF: sub_4CF1C+43j
			; sub_4CF1C+49j
cmp	cx, 1C3h	; Compare Two Operands
jle	short loc_4CF77	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 1D4h	; Compare Two Operands
jge	short loc_4CF77	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4CF83	; Jump

loc_4CF77:		; CODE XREF: sub_4CF1C+51j
			; sub_4CF1C+57j
cmp	cx, 1D8h	; Compare Two Operands
jle	short loc_4CF88	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 25Ah	; Compare Two Operands

loc_4CF81:		; Jump if Greater or Equal (SF=OF)
jge	short loc_4CF88

loc_4CF83:		; CODE XREF: sub_4CF1C:loc_4CF59j
			; sub_4CF1C+4Bj
			; sub_4CF1C+59j
mov	ax, 1
jmp	short loc_4CF51	; Jump

loc_4CF88:		; CODE XREF: sub_4CF1C+5Fj
			; sub_4CF1C:loc_4CF81j
jmp	short loc_4CF4F	; Jump

loc_4CF8A:		; CODE XREF: sub_4CF1C:loc_4CF51j
pop	bp
retf			; Return Far from Procedure
endp sub_4CF1C



; Attributes: bp-based frame

proc sub_4CF8C far	; CODE XREF: sub_31A13J
			; sub_438C4+17Cp
			; sub_48C63+16Ap
			; sub_48C63+2B6p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_4CF8D:
mov	bp, sp
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_4CFDD	; Jump

loc_4CF93:		; CODE XREF: sub_4CF8C+54j
mov	ax, cx
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)

loc_4CFA4:		; Compare Two Operands
cmp	ax, [bp+arg_0]

loc_4CFA7:		; Jump if Not Zero (ZF=0)
jnz	short loc_4CFDC

loc_4CFA9:
mov	ax, cx
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply

loc_4CFB0:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6F2]
add	bx, ax		; Add

loc_4CFB6:
mov	al, [es:bx+1]

loc_4CFBA:		; AL ->	AX (with sign)
cbw

loc_4CFBB:		; Compare Two Operands
cmp	ax, [bp+arg_2]

loc_4CFBE:		; Jump if Not Zero (ZF=0)
jnz	short loc_4CFDC
mov	ax, cx
mov	dx, 30h	; '0'
imul	dx		; Signed Multiply
les	bx, [dword_3A6F2] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_4]	; Compare Two Operands
jnz	short loc_4CFDC	; Jump if Not Zero (ZF=0)
mov	ax, 1

loc_4CFDA:		; CODE XREF: sub_4CF8C+58j
jmp	short loc_4CFE6	; Jump

loc_4CFDC:		; CODE XREF: sub_4CF8C:loc_4CFA7j
			; sub_4CF8C:loc_4CFBEj
			; sub_4CF8C+49j
inc	cx		; Increment by 1

loc_4CFDD:		; CODE XREF: sub_4CF8C+5j
cmp	cx, 1Eh		; Compare Two Operands
jl	short loc_4CF93	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4CFDA	; Jump

loc_4CFE6:		; CODE XREF: sub_4CF8C:loc_4CFDAj
pop	bp
retf			; Return Far from Procedure
endp sub_4CF8C



; Attributes: bp-based frame

proc sub_4CFE8 far	; CODE XREF: sub_31A18J
			; sub_438C4+15Fp

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
xor	dx, dx		; Logical Exclusive OR
jmp	short loc_4D020	; Jump

loc_4CFEF:		; CODE XREF: sub_4CFE8+3Bj
mov	ax, dx
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_0]	; Compare Two Operands
jnz	short loc_4D01F	; Jump if Not Zero (ZF=0)
mov	ax, dx
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EA] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+arg_2]	; Compare Two Operands
jnz	short loc_4D01F	; Jump if Not Zero (ZF=0)
mov	ax, 1

loc_4D01D:		; CODE XREF: sub_4CFE8+3Fj
jmp	short loc_4D029	; Jump

loc_4D01F:		; CODE XREF: sub_4CFE8+1Aj
			; sub_4CFE8+30j
inc	dx		; Increment by 1

loc_4D020:		; CODE XREF: sub_4CFE8+5j
cmp	dx, 6		; Compare Two Operands
jl	short loc_4CFEF	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D01D	; Jump

loc_4D029:		; CODE XREF: sub_4CFE8:loc_4D01Dj
pop	bp
retf			; Return Far from Procedure
endp sub_4CFE8



; Attributes: bp-based frame

proc sub_4D02B far	; CODE XREF: sub_31A54J
			; sub_43E4F+546p
			; sub_4A942+379p
			; sub_4BF93+204p
			; sub_4BF93+2B8p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 0A3h ; ''  ; Compare Two Operands
jz	short loc_4D06B	; Jump if Zero (ZF=1)
cmp	cx, 0B7h ; ''  ; Compare Two Operands
jz	short loc_4D06B	; Jump if Zero (ZF=1)
cmp	cx, 0B8h ; ''  ; Compare Two Operands
jnz	short loc_4D070	; Jump if Not Zero (ZF=0)

loc_4D06B:		; CODE XREF: sub_4D02B+32j
			; sub_4D02B+38j
mov	ax, 1

loc_4D06E:		; CODE XREF: sub_4D02B+47j
jmp	short loc_4D074	; Jump

loc_4D070:		; CODE XREF: sub_4D02B+3Ej
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D06E	; Jump

loc_4D074:		; CODE XREF: sub_4D02B:loc_4D06Ej
pop	bp
retf			; Return Far from Procedure
endp sub_4D02B



; Attributes: bp-based frame

proc sub_4D076 far	; CODE XREF: sub_31A1DJ
			; sub_48C63+181p
			; sub_48C63+2E4p
			; sub_4910F+3Cp
			; sub_4910F+7Ap
			; sub_4910F+A7p
			; sub_4910F+D5p
			; sub_4910F+103p
			; sub_4910F+15Cp
			; sub_4910F+174p
			; sub_4910F+18Dp
			; sub_4910F+1A6p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 0B8h ; ''  ; Compare Two Operands
jle	short loc_4D0B5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 0C6h ; ''  ; Compare Two Operands
jge	short loc_4D0B5	; Jump if Greater or Equal (SF=OF)

loc_4D0B0:		; CODE XREF: sub_4D076+4Bj
			; sub_4D076+59j
			; sub_4D076+61j
mov	ax, 1

loc_4D0B3:		; CODE XREF: sub_4D076+65j
jmp	short loc_4D0DD	; Jump

loc_4D0B5:		; CODE XREF: sub_4D076+32j
			; sub_4D076+38j
cmp	cx, 0E8h ; ''  ; Compare Two Operands
jle	short loc_4D0C3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 103h	; Compare Two Operands
jge	short loc_4D0C3	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4D0B0	; Jump

loc_4D0C3:		; CODE XREF: sub_4D076+43j
			; sub_4D076+49j
cmp	cx, 1D3h	; Compare Two Operands
jle	short loc_4D0D1	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 1D9h	; Compare Two Operands
jge	short loc_4D0D1	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4D0B0	; Jump

loc_4D0D1:		; CODE XREF: sub_4D076+51j
			; sub_4D076+57j
cmp	cx, 3E8h	; Compare Two Operands
jnz	short loc_4D0D9	; Jump if Not Zero (ZF=0)
jmp	short loc_4D0B0	; Jump

loc_4D0D9:		; CODE XREF: sub_4D076+5Fj
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D0B3	; Jump

loc_4D0DD:		; CODE XREF: sub_4D076:loc_4D0B3j
pop	bp
retf			; Return Far from Procedure
endp sub_4D076



; Attributes: bp-based frame

proc sub_4D0DF far	; CODE XREF: sub_31A22J

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 0C8h ; ''  ; Compare Two Operands
jle	short loc_4D11E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 0E9h ; ''  ; Compare Two Operands
jge	short loc_4D11E	; Jump if Greater or Equal (SF=OF)

loc_4D119:		; CODE XREF: sub_4D0DF+4Bj
			; sub_4D0DF+59j
mov	ax, 1

loc_4D11C:		; CODE XREF: sub_4D0DF+5Dj
jmp	short loc_4D13E	; Jump

loc_4D11E:		; CODE XREF: sub_4D0DF+32j
			; sub_4D0DF+38j
cmp	cx, 1C3h	; Compare Two Operands
jle	short loc_4D12C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 1D4h	; Compare Two Operands
jge	short loc_4D12C	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4D119	; Jump

loc_4D12C:		; CODE XREF: sub_4D0DF+43j
			; sub_4D0DF+49j
cmp	cx, 1D8h	; Compare Two Operands
jle	short loc_4D13A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 259h	; Compare Two Operands
jge	short loc_4D13A	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4D119	; Jump

loc_4D13A:		; CODE XREF: sub_4D0DF+51j
			; sub_4D0DF+57j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D11C	; Jump

loc_4D13E:		; CODE XREF: sub_4D0DF:loc_4D11Cj
pop	bp
retf			; Return Far from Procedure
endp sub_4D0DF



; Attributes: bp-based frame

proc sub_4D140 far	; CODE XREF: sub_31A27J

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 1		; Compare Two Operands
jle	short loc_4D17E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 0A2h ; ''  ; Compare Two Operands
jge	short loc_4D17E	; Jump if Greater or Equal (SF=OF)

loc_4D179:		; CODE XREF: sub_4D140+4Aj
			; sub_4D140+58j
			; sub_4D140+66j
mov	ax, 1

loc_4D17C:		; CODE XREF: sub_4D140+6Aj
jmp	short loc_4D1AC	; Jump

loc_4D17E:		; CODE XREF: sub_4D140+31j
			; sub_4D140+37j
cmp	cx, 0C8h ; ''  ; Compare Two Operands
jle	short loc_4D18C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 0E9h ; ''  ; Compare Two Operands
jge	short loc_4D18C	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4D179	; Jump

loc_4D18C:		; CODE XREF: sub_4D140+42j
			; sub_4D140+48j
cmp	cx, 1C3h	; Compare Two Operands
jle	short loc_4D19A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 1D4h	; Compare Two Operands
jge	short loc_4D19A	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4D179	; Jump

loc_4D19A:		; CODE XREF: sub_4D140+50j
			; sub_4D140+56j
cmp	cx, 1D8h	; Compare Two Operands
jle	short loc_4D1A8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 259h	; Compare Two Operands
jge	short loc_4D1A8	; Jump if Greater or Equal (SF=OF)
jmp	short loc_4D179	; Jump

loc_4D1A8:		; CODE XREF: sub_4D140+5Ej
			; sub_4D140+64j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D17C	; Jump

loc_4D1AC:		; CODE XREF: sub_4D140:loc_4D17Cj
pop	bp
retf			; Return Far from Procedure
endp sub_4D140



; Attributes: bp-based frame

proc sub_4D1AE far	; CODE XREF: sub_31A2CJ
			; sub_48C63+13Cp
			; sub_48C63+288p
			; sub_4BF93+2E7p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 0A4h ; ''  ; Compare Two Operands
jz	short loc_4D1EE	; Jump if Zero (ZF=1)
cmp	cx, 102h	; Compare Two Operands
jle	short loc_4D1F3	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 113h	; Compare Two Operands
jge	short loc_4D1F3	; Jump if Greater or Equal (SF=OF)

loc_4D1EE:		; CODE XREF: sub_4D1AE+32j
mov	ax, 1

loc_4D1F1:		; CODE XREF: sub_4D1AE+47j
jmp	short loc_4D1F7	; Jump

loc_4D1F3:		; CODE XREF: sub_4D1AE+38j
			; sub_4D1AE+3Ej
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D1F1	; Jump

loc_4D1F7:		; CODE XREF: sub_4D1AE:loc_4D1F1j
pop	bp
retf			; Return Far from Procedure
endp sub_4D1AE



; Attributes: bp-based frame

proc sub_4D1F9 far	; CODE XREF: sub_31A31J
			; sub_48C63+153p
			; sub_48C63+29Fp
			; sub_4BF93+320p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 0ABh ; ''  ; Compare Two Operands
jz	short loc_4D239	; Jump if Zero (ZF=1)
cmp	cx, 112h	; Compare Two Operands
jle	short loc_4D23E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 124h	; Compare Two Operands
jge	short loc_4D23E	; Jump if Greater or Equal (SF=OF)

loc_4D239:		; CODE XREF: sub_4D1F9+32j
mov	ax, 1

loc_4D23C:		; CODE XREF: sub_4D1F9+47j
jmp	short loc_4D242	; Jump

loc_4D23E:		; CODE XREF: sub_4D1F9+38j
			; sub_4D1F9+3Ej
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D23C	; Jump

loc_4D242:		; CODE XREF: sub_4D1F9:loc_4D23Cj
pop	bp
retf			; Return Far from Procedure
endp sub_4D1F9



; Attributes: bp-based frame

proc sub_4D244 far	; CODE XREF: sub_31A36J
			; sub_4BF93+359p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 0B1h ; ''  ; Compare Two Operands
jz	short loc_4D284	; Jump if Zero (ZF=1)
cmp	cx, 0B2h ; ''  ; Compare Two Operands
jz	short loc_4D284	; Jump if Zero (ZF=1)
cmp	cx, 0A6h ; ''  ; Compare Two Operands
jnz	short loc_4D289	; Jump if Not Zero (ZF=0)

loc_4D284:		; CODE XREF: sub_4D244+32j
			; sub_4D244+38j
mov	ax, 1

loc_4D287:		; CODE XREF: sub_4D244+47j
jmp	short loc_4D28D	; Jump

loc_4D289:		; CODE XREF: sub_4D244+3Ej
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D287	; Jump

loc_4D28D:		; CODE XREF: sub_4D244:loc_4D287j
pop	bp
retf			; Return Far from Procedure
endp sub_4D244



; Attributes: bp-based frame

proc sub_4D28F far	; CODE XREF: sub_31A3BJ
			; LBX_Terrtype_s472C7+1ECp
			; LBX_Terrtype_s472C7+20Dp
			; LBX_Terrtype_s472C7+22Dp
			; LBX_Terrtype_s472C7+252p
			; LBX_Terrtype_s472C7+275p
			; LBX_Terrtype_s472C7+29Dp
			; LBX_Terrtype_s472C7+2C0p
			; LBX_Terrtype_s472C7+2E5p
			; sub_48C63+2CDp
			; sub_4BF93+388p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 0A5h ; ''  ; Compare Two Operands
jz	short loc_4D2E1	; Jump if Zero (ZF=1)
cmp	cx, 0AEh ; ''  ; Compare Two Operands
jz	short loc_4D2E1	; Jump if Zero (ZF=1)
cmp	cx, 0AFh ; ''  ; Compare Two Operands
jz	short loc_4D2E1	; Jump if Zero (ZF=1)
cmp	cx, 0B0h ; ''  ; Compare Two Operands
jz	short loc_4D2E1	; Jump if Zero (ZF=1)
cmp	cx, 123h	; Compare Two Operands
jle	short loc_4D2E6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	cx, 1C4h	; Compare Two Operands
jge	short loc_4D2E6	; Jump if Greater or Equal (SF=OF)

loc_4D2E1:		; CODE XREF: sub_4D28F+32j
			; sub_4D28F+38j
			; sub_4D28F+3Ej
			; sub_4D28F+44j
mov	ax, 1

loc_4D2E4:		; CODE XREF: sub_4D28F+59j
jmp	short loc_4D2EA	; Jump

loc_4D2E6:		; CODE XREF: sub_4D28F+4Aj
			; sub_4D28F+50j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D2E4	; Jump

loc_4D2EA:		; CODE XREF: sub_4D28F:loc_4D2E4j
pop	bp
retf			; Return Far from Procedure
endp sub_4D28F



; Attributes: bp-based frame

proc sub_4D2EC far	; CODE XREF: sub_31A40J
			; sub_4BF93+1F2p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	ax, [es:bx]
mov	bx, 2FAh
xor	dx, dx		; Logical Exclusive OR
div	bx		; Unsigned Divide
mov	cx, dx
cmp	cx, 0A2h ; ''  ; Compare Two Operands
jz	short loc_4D337	; Jump if Zero (ZF=1)
cmp	cx, 0ACh ; ''  ; Compare Two Operands
jz	short loc_4D337	; Jump if Zero (ZF=1)
cmp	cx, 0ADh ; ''  ; Compare Two Operands
jz	short loc_4D337	; Jump if Zero (ZF=1)
cmp	cx, 0B4h ; ''  ; Compare Two Operands
jz	short loc_4D337	; Jump if Zero (ZF=1)
cmp	cx, 1		; Compare Two Operands
jnz	short loc_4D33C	; Jump if Not Zero (ZF=0)

loc_4D337:		; CODE XREF: sub_4D2EC+32j
			; sub_4D2EC+38j
			; sub_4D2EC+3Ej
			; sub_4D2EC+44j
mov	ax, 1

loc_4D33A:		; CODE XREF: sub_4D2EC+52j
jmp	short loc_4D340	; Jump

loc_4D33C:		; CODE XREF: sub_4D2EC+49j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4D33A	; Jump

loc_4D340:		; CODE XREF: sub_4D2EC:loc_4D33Aj
pop	bp
retf			; Return Far from Procedure
endp sub_4D2EC



; Attributes: bp-based frame

proc sub_4D342 far	; CODE XREF: sub_31A45J
			; sub_4D448+44p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	si
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+arg_4]
mov	dx, 12C0h
imul	dx		; Signed Multiply
les	bx, [dword_3A702] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	ax, [bp+arg_2]
mov	dx, 78h	; 'x'
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+arg_0]
shl	ax, 1		; Shift	Logical	Left
add	bx, ax		; Add
mov	si, [es:bx]
or	si, si		; Logical Inclusive OR
jnz	short loc_4D373	; Jump if Not Zero (ZF=0)

loc_4D36E:		; CODE XREF: sub_4D342+37j
			; sub_4D342+79j
			; sub_4D342+8Ej
xor	ax, ax		; Logical Exclusive OR

loc_4D370:		; CODE XREF: sub_4D342+D2j
jmp	loc_4D417	; Jump

loc_4D373:		; CODE XREF: sub_4D342+2Aj
cmp	si, 259h	; Compare Two Operands
jl	short loc_4D37E	; Jump if Less (SF!=OF)
jmp	short loc_4D36E	; Jump
jmp	loc_4D412	; default

loc_4D37E:		; CODE XREF: sub_4D342+35j
cmp	si, 1		; Compare Two Operands
jnz	short loc_4D389	; Jump if Not Zero (ZF=0)
mov	cx, 3
jmp	loc_4D412	; default

loc_4D389:		; CODE XREF: sub_4D342+3Fj
cmp	si, 0A2h ; ''  ; Compare Two Operands
jge	short loc_4D394	; Jump if Greater or Equal (SF=OF)
mov	cx, 1
jmp	short loc_4D412	; default

loc_4D394:		; CODE XREF: sub_4D342+4Bj
cmp	si, 1D8h	; Compare Two Operands
jle	short loc_4D39F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	cx, 1
jmp	short loc_4D412	; default

loc_4D39F:		; CODE XREF: sub_4D342+56j
cmp	si, 1D3h	; Compare Two Operands
jle	short loc_4D3AA	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	cx, 4
jmp	short loc_4D412	; default

loc_4D3AA:		; CODE XREF: sub_4D342+61j
cmp	si, 1C3h	; Compare Two Operands
jle	short loc_4D3B5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	cx, 1
jmp	short loc_4D412	; default

loc_4D3B5:		; CODE XREF: sub_4D342+6Cj
cmp	si, 123h	; Compare Two Operands
jle	short loc_4D3BF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	short loc_4D36E	; Jump
jmp	short loc_4D412	; default

loc_4D3BF:		; CODE XREF: sub_4D342+77j
cmp	si, 112h	; Compare Two Operands
jle	short loc_4D3CA	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	cx, 1
jmp	short loc_4D412	; default

loc_4D3CA:		; CODE XREF: sub_4D342+81j
cmp	si, 102h	; Compare Two Operands
jle	short loc_4D3D4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	short loc_4D36E	; Jump
jmp	short loc_4D412	; default

loc_4D3D4:		; CODE XREF: sub_4D342+8Cj
cmp	si, 0B8h ; ''  ; Compare Two Operands
jle	short loc_4D3DF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	cx, 4
jmp	short loc_4D412	; default

loc_4D3DF:		; CODE XREF: sub_4D342+96j
mov	bx, si
sub	bx, 0A2h	; switch 23 cases
cmp	bx, 16h		; Compare Two Operands
ja	short loc_4D412	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4D41A+bx] ; switch jump

loc_4D3F1:		; DATA XREF: ovr051:off_4D41Ao
mov	cx, 3		; case 0xA2
jmp	short loc_4D412	; default

loc_4D3F6:		; CODE XREF: sub_4D342+AAj
			; DATA XREF: ovr051:off_4D41Ao
jmp	short loc_4D40D	; case 0xA3

loc_4D3F8:		; CODE XREF: sub_4D342+AAj
			; DATA XREF: ovr051:off_4D41Ao
jmp	short loc_4D409	; case 0xA4

loc_4D3FA:		; CODE XREF: sub_4D342+AAj
			; DATA XREF: ovr051:off_4D41Ao
jmp	short loc_4D409	; case 0xA5

loc_4D3FC:		; CODE XREF: sub_4D342+AAj
			; DATA XREF: ovr051:off_4D41Ao
jmp	short loc_4D409	; case 0xA6

loc_4D3FE:		; CODE XREF: sub_4D342+AAj
			; DATA XREF: ovr051:off_4D41Ao
jmp	short loc_4D409	; case 0xA7

loc_4D400:		; CODE XREF: sub_4D342+AAj
			; DATA XREF: ovr051:off_4D41Ao
jmp	short $+2	; case 0xA8

loc_4D402:		; CODE XREF: sub_4D342+AAj
			; DATA XREF: ovr051:off_4D41Ao
mov	cx, 4		; case 0xA9
jmp	short loc_4D412	; default

loc_4D407:		; CODE XREF: sub_4D342+AAj
			; DATA XREF: ovr051:off_4D41Ao
jmp	short $+2	; case 0xAA

loc_4D409:		; CODE XREF: sub_4D342+AAj
			; sub_4D342:loc_4D3F8j
			; sub_4D342:loc_4D3FAj
			; sub_4D342:loc_4D3FCj
			; sub_4D342:loc_4D3FEj
			; DATA XREF: ovr051:off_4D41Ao
xor	cx, cx		; case 0xB3
jmp	short loc_4D412	; default

loc_4D40D:		; CODE XREF: sub_4D342+AAj
			; sub_4D342:loc_4D3F6j
			; DATA XREF: ovr051:off_4D41Ao
mov	cx, 1		; case 0xAB
jmp	short $+2	; Jump

loc_4D412:		; CODE XREF: sub_4D342+39j
			; sub_4D342+44j
			; sub_4D342+50j
			; sub_4D342+5Bj
			; sub_4D342+66j
			; sub_4D342+71j
			; sub_4D342+7Bj
			; sub_4D342+86j
			; sub_4D342+90j
			; sub_4D342+9Bj
			; sub_4D342+A6j
			; sub_4D342+B2j
			; sub_4D342+C3j
			; sub_4D342+C9j
mov	ax, cx		; default
jmp	loc_4D370	; Jump

loc_4D417:		; CODE XREF: sub_4D342:loc_4D370j
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4D342

off_4D41A dw offset loc_4D3F1
			; DATA XREF: sub_4D342+AAr
dw offset loc_4D3F6	; jump table for switch	statement
dw offset loc_4D3F8
dw offset loc_4D3FA
dw offset loc_4D3FC
dw offset loc_4D3FE
dw offset loc_4D400
dw offset loc_4D402
dw offset loc_4D407
dw offset loc_4D40D
dw offset loc_4D3F1
dw offset loc_4D3F1
dw offset loc_4D3FA
dw offset loc_4D3FA
dw offset loc_4D3FA
dw offset loc_4D3FC
dw offset loc_4D3FC
dw offset loc_4D409
dw offset loc_4D3F1
dw offset loc_4D3FE
dw offset loc_4D3FE
dw offset loc_4D3F6
dw offset loc_4D3F6


; Attributes: bp-based frame

proc sub_4D448 far	; CODE XREF: sub_31A4AJ
			; sub_43E4F+255p

var_66=	word ptr -66h
var_34=	word ptr -34h
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 66h		; Integer Subtraction
push	si
push	di
lea	ax, [bp+var_66]	; Load Effective Address
push	ax
lea	ax, [bp+var_34]	; Load Effective Address
push	ax
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_4D4A9 ; Call Procedure
add	sp, 0Ah		; Add
mov	[bp+var_2], ax
xor	di, di		; Logical Exclusive OR
xor	si, si		; Logical Exclusive OR
jmp	short loc_4D495	; Jump

loc_4D472:		; CODE XREF: sub_4D448+50j
push	[bp+arg_4]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_66]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_34]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
push	cs
call	near ptr sub_4D342 ; Call Procedure
add	sp, 6		; Add
add	di, ax		; Add
inc	si		; Increment by 1

loc_4D495:		; CODE XREF: sub_4D448+28j
cmp	si, [bp+var_2]	; Compare Two Operands
jl	short loc_4D472	; Jump if Less (SF!=OF)
mov	ax, di
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4D448



; Attributes: bp-based frame

proc sub_4D4A9 far	; CODE XREF: sub_31A4FJ
			; sub_4D448+1Bp

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
xor	si, si		; Logical Exclusive OR
mov	cx, 0FFFEh
jmp	short loc_4D526	; Jump

loc_4D4B8:		; CODE XREF: sub_4D4A9+80j
mov	ax, [bp+arg_2]
add	ax, cx		; Add
mov	[bp+var_6], ax
cmp	[bp+var_6], 0	; Compare Two Operands
word_4D4C4 dw 5F7Ch	; DATA XREF: sub_30E8D+26r
word_4D4C6 dw 7E83h	; DATA XREF: sub_30E8D+2Ar
db 0FAh, 28h, 7Dh, 59h,	0C7h, 46h, 2 dup(0FEh)
word_4D4D0 dw 0C7FFh	; DATA XREF: sub_30E8D+39w
word_4D4D2 dw 0FC46h	; DATA XREF: sub_30E8D+15r
db 2, 0, 83h, 0F9h, 0FEh, 74h, 5, 83h
word_4D4DC dw 2F9h	; DATA XREF: sub_30E8D+41w
			; sub_30E8D+4Bw
jnz	short loc_4D4EA	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 0FFFFh
mov	[bp+var_4], 1

loc_4D4EA:		; CODE XREF: sub_4D4A9+35j
mov	di, [bp+var_2]
jmp	short loc_4D520	; Jump

loc_4D4EF:		; CODE XREF: sub_4D4A9+7Aj
mov	ax, [bp+arg_0]
add	ax, di		; Add
mov	dx, ax
or	dx, dx		; Logical Inclusive OR
jge	short loc_4D4FD	; Jump if Greater or Equal (SF=OF)
add	dx, 3Ch	; '<'   ; Add

loc_4D4FD:		; CODE XREF: sub_4D4A9+4Fj
cmp	dx, 3Ch	; '<'   ; Compare Two Operands
jl	short loc_4D505	; Jump if Less (SF!=OF)
sub	dx, 3Ch	; '<'   ; Integer Subtraction

loc_4D505:		; CODE XREF: sub_4D4A9+57j
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_6]
add	bx, ax		; Add
mov	[bx], dx
mov	ax, si
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_8]
add	bx, ax		; Add
mov	ax, [bp+var_6]
mov	[bx], ax
inc	si		; Increment by 1
inc	di		; Increment by 1

loc_4D520:		; CODE XREF: sub_4D4A9+44j
cmp	di, [bp+var_4]	; Compare Two Operands
jle	short loc_4D4EF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
inc	cx		; Increment by 1

loc_4D526:		; CODE XREF: sub_4D4A9+Dj
cmp	cx, 2		; Compare Two Operands
jle	short loc_4D4B8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4D4A9 ; sp-analysis failed

; [00000005 BYTES: COLLAPSED FUNCTION filebuf::terminate(void).	PRESS KEYPAD "+" TO EXPAND]

; Segment type:	Pure code
segment	ovr052 para public 'OVERLAY' use16
assume cs:ovr052
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_4D540 far	; CODE XREF: sub_31A80J

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp

loc_4D541:
mov	bp, sp

loc_4D543:		; Integer Subtraction
sub	sp, 0Ch

loc_4D546:
mov	ax, [word ptr unk_3A4D6]

loc_4D549:
mov	bx, 4

loc_4D54C:		; AX ->	DX:AX (with sign)
cwd

loc_4D54D:		; Signed Divide
idiv	bx

loc_4D54F:		; int
or	dx, dx

loc_4D551:		; Jump if Zero (ZF=1)
jz	short loc_4D557

loc_4D553:		; Logical Exclusive OR
xor	ax, ax

loc_4D555:		; Jump
jmp	short loc_4D5A3

loc_4D557:		; CODE XREF: sub_4D540:loc_4D551j
mov	[bp+var_C], 6

loc_4D55C:
mov	[bp+var_A], 0

loc_4D561:
mov	[bp+var_8], 0

loc_4D566:
mov	[bp+var_6], 0

loc_4D56B:
mov	[bp+var_4], 13Fh

loc_4D570:
mov	[bp+var_2], 0C7h ; ''

loc_4D575:		; Load Effective Address
lea	ax, [bp+var_C]
push	ax

loc_4D579:
mov	ax, 1

loc_4D57C:
push	ax

loc_4D57D:		; Call Procedure
call	wtf_s23F3E
pop	cx
pop	cx

loc_4D584:		; int
mov	ax, 8
push	ax		; int

loc_4D588:		; Call Procedure
call	j_OVR_SaveGame_MagicSet
pop	cx

loc_4D58E:
mov	ax, 1F54h
push	ax

loc_4D592:
mov	ax, 1
push	ax

loc_4D596:		; Call Procedure
call	wtf_s23F3E
pop	cx

loc_4D59C:
pop	cx

loc_4D59D:
mov	[word_3AD5C], 0

loc_4D5A3:		; CODE XREF: sub_4D540:loc_4D555j
mov	sp, bp

loc_4D5A5:
pop	bp

locret_4D5A6:		; Return Far from Procedure
retf
endp sub_4D540

ends ovr052


; Segment type:	Pure code
segment	ovr053 para public 'OVERLAY' use16
assume cs:ovr053
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_4D5B0 far	; CODE XREF: sub_31AB0J

var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp

loc_4D5B1:
mov	bp, sp

loc_4D5B3:		; Integer Subtraction
sub	sp, 0Eh

loc_4D5B6:
push	si

loc_4D5B7:
push	di

loc_4D5B8:		; Call Procedure
call	sub_19454

loc_4D5BD:
mov	ax, 34C9h

loc_4D5C0:
push	ax

loc_4D5C1:		; Logical Exclusive OR
xor	ax, ax

loc_4D5C3:
push	ax

loc_4D5C4:		; Call Procedure
call	sub_19399

loc_4D5C9:
pop	cx

loc_4D5CA:
pop	cx

loc_4D5CB:		; No Operation
nop

loc_4D5CC:
push	cs

loc_4D5CD:		; Call Procedure
call	near ptr sub_50356

loc_4D5D0:		; argPtrBuffer_EMS
push	[idk_LBX_w37EBE]

loc_4D5D4:		; Logical Exclusive OR
xor	ax, ax

loc_4D5D6:		; argEntryNumber
push	ax

loc_4D5D7:
mov	ax, 3530h
push	ax		; argLbxFileName

loc_4D5DB:		; Call Procedure
call	LBX_Load_Entry_0_1

loc_4D5E0:		; Add
add	sp, 6

loc_4D5E3:
mov	[word_3ADA2], ax

loc_4D5E6:		; arg4_Int
push	[idk_LBX_w37EBE]

loc_4D5EA:
mov	ax, 1

loc_4D5ED:		; argFileName
push	ax

loc_4D5EE:
mov	ax, 3530h

loc_4D5F1:		; argEntryNumber
push	ax

loc_4D5F2:		; Call Procedure
call	LBX_Load_Entry_0_2

loc_4D5F7:		; Add
add	sp, 6

loc_4D5FA:
mov	[word_3ADA0], ax

loc_4D5FD:		; arg4_Int
push	[idk_LBX_w37EBE]

loc_4D601:
mov	ax, 3
push	ax		; argFileName

loc_4D605:
mov	ax, 3530h

loc_4D608:		; argEntryNumber
push	ax

loc_4D609:		; Call Procedure
call	LBX_Load_Entry_0_2

loc_4D60E:		; Add
add	sp, 6

loc_4D611:
mov	[word_3AD9E], ax

loc_4D614:		; arg4_Int
push	[idk_LBX_w37EBE]

loc_4D618:
mov	ax, 4
push	ax		; argFileName

loc_4D61C:
mov	ax, 3530h
push	ax		; argEntryNumber

loc_4D620:		; Call Procedure
call	LBX_Load_Entry_0_2
add	sp, 6		; Add

loc_4D628:
mov	[word_3AD9C], ax

loc_4D62B:		; Call Procedure
call	sub_1E525

loc_4D630:
mov	ax, [bp+arg_0]
mov	[word_3AE1E], ax
mov	ax, 0Fh

loc_4D639:		; int
push	ax

loc_4D63A:
mov	ax, 4
push	ax		; int

loc_4D63E:
mov	ax, 4

loc_4D641:		; int
push	ax

loc_4D642:		; Call Procedure
call	idk_PalFnt_s1AB64

loc_4D647:		; Add
add	sp, 6
push	[bp+arg_0]

loc_4D64D:
mov	ax, 0A6h ; ''

loc_4D650:
push	ax
call	sub_1B984	; Call Procedure
pop	cx
pop	cx
mov	si, ax

loc_4D65A:
mov	ax, si

loc_4D65C:		; Add
add	ax, 22h	; '"'
mov	[bp+var_2], ax

loc_4D662:
mov	ax, [word_351F2]

loc_4D665:		; Add
add	ax, 44h	; 'D'

loc_4D668:
mov	[word_3AE22], ax

loc_4D66B:
mov	ax, 0C8h ; ''

loc_4D66E:		; Integer Subtraction
sub	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right

loc_4D676:		; Add
add	ax, [word_351F4]
mov	[word_3AE20], ax

loc_4D67D:		;
call	setFlagsMaybeMouseEGA ;	mov	word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, 0FFFFh
push	ax

loc_4D686:
mov	ax, 3539h
push	ax
push	[word_3AD9E]

loc_4D68E:
mov	ax, 3538h
push	ax

loc_4D692:
mov	ax, [word_3AE20]

loc_4D695:		; Add
add	ax, si

loc_4D697:		; Add
add	ax, 0Fh
push	ax

loc_4D69B:
mov	ax, [word_3AE22]

loc_4D69E:		; Add
add	ax, 65h	; 'e'

loc_4D6A1:
push	ax

loc_4D6A2:		; Call Procedure
call	sub_298BB

loc_4D6A7:		; Add
add	sp, 0Ch

loc_4D6AA:
mov	[bp+var_6], ax

loc_4D6AD:
mov	ax, 0FFFFh

loc_4D6B0:
push	ax
mov	ax, 353Bh
push	ax
push	[word_3AD9C]
mov	ax, 3538h
push	ax
mov	ax, [word_3AE20]

loc_4D6C0:		; Add
add	ax, si
add	ax, 0Fh		; Add
push	ax

loc_4D6C6:
mov	ax, [word_3AE22]
add	ax, 12h		; Add
push	ax
call	sub_298BB	; Call Procedure
add	sp, 0Ch		; Add

loc_4D6D5:
mov	[bp+var_8], ax

loc_4D6D8:
mov	ax, 0FFFFh
push	ax
mov	ax, 3538h
push	ax
mov	ax, [word_3AE20]
add	ax, 3Fh	; '?'   ; Add
push	ax
mov	ax, [word_3AE22]
add	ax, 0B9h ; ''  ; Add
push	ax

loc_4D6EE:
push	[word_3AE20]
push	[word_3AE22]
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_C], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 353Dh
push	ax
mov	ax, 0C7h ; ''

loc_4D70C:
push	ax

loc_4D70D:
mov	ax, 13Fh
push	ax

loc_4D711:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_4D714:		; Logical Exclusive OR
xor	ax, ax

loc_4D716:
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_A], ax
mov	ax, 1

loc_4D725:
push	ax
mov	ax, seg	stub053
push	ax
mov	ax, 25h	; '%'
push	ax

loc_4D72E:		; Call Procedure
call	sub_2E1FB
add	sp, 6		; Add

loc_4D736:		; Logical Exclusive OR
xor	di, di
jmp	short loc_4D779	; Jump

loc_4D73A:		; CODE XREF: sub_4D5B0+1CBj
call	sub_2B97A	; Call Procedure
push	ax		; x

loc_4D740:		; Call Procedure
call	_abs
pop	cx
mov	[bp+var_4], ax
db 83h,7Eh,0FCh,0FFh ; <BAD>cmp	    [bp+var_4],	0FFFFh ; Compare Two Operands
jz	short loc_4D757	; Jump if Zero (ZF=1)

loc_4D74F:
mov	ax, [bp+var_4]
cmp	ax, [bp+var_8]	; Compare Two Operands
jnz	short loc_4D75F	; Jump if Not Zero (ZF=0)

loc_4D757:		; CODE XREF: sub_4D5B0+19Dj
mov	di, 1
mov	[bp+var_E], 0

loc_4D75F:		; CODE XREF: sub_4D5B0+1A5j
mov	ax, [bp+var_4]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_4D76F	; Jump if Not Zero (ZF=0)
mov	di, 1
mov	[bp+var_E], 1

loc_4D76F:		; CODE XREF: sub_4D5B0+1B5j
nop			; No Operation
push	cs
call	near ptr sub_4D7A1 ; Call Procedure
call	sub_31929	; Call Procedure

loc_4D779:		; CODE XREF: sub_4D5B0+188j
or	di, di		; Logical Inclusive OR
jz	short loc_4D73A	; Jump if Zero (ZF=1)
call	sub_2E257	; Call Procedure

loc_4D782:		;
call	setFlagsMaybeMouseEGA ;	mov	word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh

loc_4D787:		; Call Procedure
call	sub_194C2
call	idk_ScrnPos_0_319_0_199	; Call Procedure
nop			; No Operation
push	cs

loc_4D793:		; Call Procedure
call	near ptr sub_503A0
mov	ax, [bp+var_E]
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4D5B0



; Attributes: bp-based frame

proc sub_4D7A1 far	; CODE XREF: sub_31AB5J
			; sub_4D5B0+1C1p
push	bp
mov	bp, sp
push	si
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
mov	ax, 4

loc_4D7B0:		; int
push	ax
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
push	[word_3AE1E]

loc_4D7BD:
mov	ax, 0A6h ; ''
push	ax
call	sub_1B984	; Call Procedure
pop	cx
pop	cx
mov	si, ax
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure

loc_4D7CF:
mov	ax, [word_3AE20]
add	ax, si		; Add
add	ax, 0Ch		; Add
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_4D7DF:		; Logical Exclusive OR
xor	ax, ax
push	ax
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
push	[word_3ADA2]
push	[word_3AE20]
push	[word_3AE22]

loc_4D7F6:		; Call Procedure
call	idk_VidLib_s1F743
add	sp, 6		; Add

loc_4D7FE:		; Call Procedure
call	idk_ScrnPos_0_319_0_199
push	[word_3ADA0]
mov	ax, [word_3AE20]
add	ax, si		; Add
add	ax, 0Ah		; Add
push	ax
push	[word_3AE22]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
mov	ax, 34C4h
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh

loc_4D82E:		; int
push	ax
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add

loc_4D83F:		; Logical Exclusive OR
xor	ax, ax
push	ax

loc_4D842:
push	[word_3AE1E]
mov	ax, 0A6h ; ''
push	ax

loc_4D84A:
mov	ax, [word_3AE20]
add	ax, 0Ah		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, 0Ah		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, 0A6h ; ''
push	ax
mov	ax, [word_3AE20]

loc_4D86E:		; Add
add	ax, 0Ah
push	ax
mov	ax, [word_3AE22]
add	ax, 9		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 12h
push	ax
call	sub_193DD	; Call Procedure
pop	cx
mov	ax, 34C9h
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR

loc_4D8B0:
push	ax

loc_4D8B1:
push	[word_3AE1E]
mov	ax, 0A6h ; ''
push	ax

loc_4D8B9:
mov	ax, [word_3AE20]
add	ax, 9		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, 9		; Add
push	ax

loc_4D8C7:		; Call Procedure
call	sub_1B0AD
add	sp, 0Ah		; Add
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4D7A1



; Attributes: bp-based frame

proc sub_4D8D2 far	; CODE XREF: sub_31ABAJ

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	[word_3AE24], 1

loc_4D8DB:
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_4D8FA ; Call Procedure
pop	cx
pop	bp
retf			; Return Far from Procedure
endp sub_4D8D2



; Attributes: bp-based frame

proc sub_4D8E6 far	; CODE XREF: sub_31ABFJ

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	[word_3AE24], 0
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_4D8FA ; Call Procedure
pop	cx
pop	bp
retf			; Return Far from Procedure
endp sub_4D8E6



; Attributes: bp-based frame

proc sub_4D8FA far	; CODE XREF: sub_31AC4J
			; sub_4D8D2+Ep
			; sub_4D8E6+Ep

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
mov	si, [bp+arg_0]

loc_4D904:		; No Operation
nop

loc_4D905:
push	cs
call	near ptr sub_50356 ; Call Procedure
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS

loc_4D90D:
mov	ax, 26h	; '&'
push	ax		; argEntryNumber
mov	ax, 3530h
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure

loc_4D91A:		; Add
add	sp, 6
mov	[word_3ADD8], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 27h	; '''
push	ax		; argFileName

loc_4D928:
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure

loc_4D931:		; Add
add	sp, 6
mov	[word_3ADD6], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 31h	; '1'
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADD4], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 32h	; '2'
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADD2], ax
call	sub_2E22B	; Call Procedure
call	sub_19454	; Call Procedure
mov	ax, 34C9h
push	ax

loc_4D973:		; Logical Exclusive OR
xor	ax, ax

loc_4D975:
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_4D97D:		; Call Procedure
call	sub_1E525
mov	[word_3AE1E], si
mov	ax, 4
push	ax		; int

loc_4D98A:
mov	ax, 4
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure

loc_4D997:		; Add
add	sp, 6
push	si
mov	ax, 0A6h ; ''
push	ax

loc_4D99F:		; Call Procedure
call	sub_1B984

loc_4D9A4:
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_2]

loc_4D9AC:		; Add
add	ax, 21h	; '!'
mov	[bp+var_4], ax
mov	[word_3AE22], 44h ; 'D'

loc_4D9B8:
mov	ax, 0C8h ; ''
sub	ax, [bp+var_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[word_3AE20], ax
mov	ax, 1
push	ax

loc_4D9CA:
mov	ax, seg	stub053
push	ax
mov	ax, 39h	; '9'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
mov	[bp+var_6], 0
call	@filebuf@terminate$qv ;	filebuf::terminate(void)
call	sub_27CC0	; Call Procedure
call	sub_194C2	; Call Procedure

loc_4D9EE:		; Call Procedure
call	idk_ScrnPos_0_319_0_199
call	sub_2E23E	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_503A0 ; Call Procedure
pop	si

loc_4D9FE:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4D8FA



; Attributes: bp-based frame

proc sub_4DA02 far	; CODE XREF: sub_31AC9J
push	bp
mov	bp, sp
push	si

loc_4DA06:
mov	ax, 4
push	ax		; int
mov	ax, 4
push	ax		; int
mov	ax, 4
push	ax		; int

loc_4DA12:		; Call Procedure
call	idk_PalFnt_s1AB64

loc_4DA17:		; Add
add	sp, 6

loc_4DA1A:
push	[word_3AE1E]

loc_4DA1E:
mov	ax, 0A6h ; ''
push	ax

loc_4DA22:		; Call Procedure
call	sub_1B984
pop	cx
pop	cx

loc_4DA29:
mov	si, ax

loc_4DA2B:		; Call Procedure
call	VGA_MathThenSetVarToVgaLoc
mov	ax, [word_3AE20]
add	ax, si		; Add
add	ax, 0Ch		; Add
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
cmp	[word_3AE24], 0	; Compare Two Operands
jnz	short loc_4DA58	; Jump if Not Zero (ZF=0)
push	[word_3ADD8]
jmp	short loc_4DA5C	; Jump

loc_4DA58:		; CODE XREF: sub_4DA02+4Ej
push	[word_3ADD4]

loc_4DA5C:		; CODE XREF: sub_4DA02+54j
push	[word_3AE20]
push	[word_3AE22]
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
call	idk_ScrnPos_0_319_0_199	; Call Procedure
cmp	[word_3AE24], 0	; Compare Two Operands
jnz	short loc_4DA7D	; Jump if Not Zero (ZF=0)

loc_4DA78:
mov	ax, 34D8h
jmp	short loc_4DA80	; Jump

loc_4DA7D:		; CODE XREF: sub_4DA02+74j
mov	ax, 34DDh

loc_4DA80:		; CODE XREF: sub_4DA02+79j
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax		; int
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, 2
push	ax
push	[word_3AE1E]
mov	ax, 0A6h ; ''
push	ax
mov	ax, [word_3AE20]
add	ax, 0Bh		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, 0Bh		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 2
push	ax
push	[word_3AE1E]
mov	ax, 0A6h ; ''
push	ax
mov	ax, [word_3AE20]
add	ax, 0Bh		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, 0Ah		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0B8h ; ''
push	ax
call	sub_193DD	; Call Procedure
pop	cx
mov	ax, 4
push	ax		; int
mov	ax, 4
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, 2
push	ax
push	[word_3AE1E]
mov	ax, 0A6h ; ''
push	ax
mov	ax, [word_3AE20]
add	ax, 0Ah		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, 0Ah		; Add
push	ax

loc_4DB1C:		; Call Procedure
call	sub_1B0AD
add	sp, 0Ah		; Add
cmp	[word_3AE24], 0	; Compare Two Operands
jnz	short loc_4DB31	; Jump if Not Zero (ZF=0)
push	[word_3ADD6]
jmp	short loc_4DB35	; Jump

loc_4DB31:		; CODE XREF: sub_4DA02+127j
push	[word_3ADD2]

loc_4DB35:		; CODE XREF: sub_4DA02+12Dj
mov	ax, [word_3AE20]
add	ax, si		; Add
add	ax, 0Ah		; Add
push	ax
push	[word_3AE22]
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
pop	si
pop	bp

locret_4DB4C:		; Return Far from Procedure
retf
endp sub_4DA02



; Attributes: bp-based frame

proc sub_4DB4D far	; CODE XREF: sub_31ACEJ

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di
call	sub_19454	; Call Procedure
call	sub_1E525	; Call Procedure
call	sub_1E65C	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_50356 ; Call Procedure
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
mov	ax, 5
push	ax		; argEntryNumber

loc_4DB71:
mov	ax, 3530h
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure

loc_4DB7A:		; Add
add	sp, 6
mov	[word_3AE1A], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 6

loc_4DB87:		; argFileName
push	ax

loc_4DB88:
mov	ax, 3530h
push	ax		; argEntryNumber

loc_4DB8C:		; Call Procedure
call	LBX_Load_Entry_0_2
add	sp, 6		; Add
mov	[word_3AE18], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 7
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3AE16], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 9
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3AE14], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 8
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3AE12], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 0Ah
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3AE10], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 0Bh
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3AE0E], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 20h	; ' '
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADE4], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 21h	; '!'
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADE2], ax

loc_4DC38:		; arg4_Int
push	[idk_LBX_w37EBE]
mov	ax, 22h	; '"'
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADE0], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 23h	; '#'
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADDE], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 24h	; '$'
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADDC], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 25h	; '%'
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADDA], ax
xor	si, si		; Logical Exclusive OR
jmp	short loc_4DCD3	; Jump

loc_4DC98:		; CODE XREF: sub_4DB4D+189j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 0Ch		; Add
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-6F16h], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 16h
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-6F2Ah], ax
inc	si		; Increment by 1

loc_4DCD3:		; CODE XREF: sub_4DB4D+149j
cmp	si, 5		; Compare Two Operands
jl	short loc_4DC98	; Jump if Less (SF!=OF)
mov	si, 5
jmp	short loc_4DCFE	; Jump

loc_4DCDD:		; CODE XREF: sub_4DB4D+1B4j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6F20h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-6F16h], ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6F34h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-6F2Ah], ax
inc	si		; Increment by 1

loc_4DCFE:		; CODE XREF: sub_4DB4D+18Ej
cmp	si, 0Ah		; Compare Two Operands
jl	short loc_4DCDD	; Jump if Less (SF!=OF)
mov	ax, [bp+arg_4]
mov	[word_3AD98], ax
mov	ax, [bp+arg_0]
mov	[word_3AD88], ax

loc_4DD0F:
mov	ax, [bp+arg_2]
mov	[word_3AD86], ax
mov	ax, [bp+arg_6]
mov	[word_3AD84], ax
mov	[word_3AD8A], 0
mov	[word_3AD8C], 0
push	[bp+arg_6]

loc_4DD2A:
push	[word_3AD86]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_4E751 ; Call Procedure
add	sp, 6		; Add
mov	ax, 1
push	ax
mov	ax, seg	stub053

loc_4DD40:
push	ax
mov	ax, 43h	; 'C'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
mov	[bp+var_2], 0
mov	[bp+var_4], 0FC18h
mov	[bp+var_6], 0FC18h
xor	si, si		; Logical Exclusive OR
jmp	short loc_4DD6B	; Jump

loc_4DD60:		; CODE XREF: sub_4DB4D+221j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[word ptr bx-6FA0h], 0FC18h
inc	si		; Increment by 1

loc_4DD6B:		; CODE XREF: sub_4DB4D+211j
cmp	si, 0Ah		; Compare Two Operands
jl	short loc_4DD60	; Jump if Less (SF!=OF)
mov	[bp+var_8], 0FC18h
jmp	loc_4E00E	; Jump

loc_4DD78:		; CODE XREF: sub_4DB4D+4C7j
call	sub_2B97A	; Call Procedure
mov	di, ax

loc_4DD7F:		; Compare Two Operands
cmp	di, [bp+var_8]
jnz	short loc_4DD8E	; Jump if Not Zero (ZF=0)
mov	[bp+var_2], 1
mov	[bp+var_A], 0FFFFh

loc_4DD8E:		; CODE XREF: sub_4DB4D+235j
xor	si, si		; Logical Exclusive OR
jmp	short loc_4DDAB	; Jump

loc_4DD92:		; CODE XREF: sub_4DB4D+268j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
cmp	[bx-6FA0h], di	; Compare Two Operands
jnz	short loc_4DDAA	; Jump if Not Zero (ZF=0)

loc_4DD9C:
mov	[bp+var_2], 1
mov	ax, si
add	ax, [word_3AD8A] ; Add
mov	[bp+var_A], ax

loc_4DDAA:		; CODE XREF: sub_4DB4D+24Dj
inc	si		; Increment by 1

loc_4DDAB:		; CODE XREF: sub_4DB4D+243j
cmp	si, [word_3AD88] ; Compare Two Operands

loc_4DDAF:		; Jump if Greater or Equal (SF=OF)
jge	short loc_4DDB7

loc_4DDB1:		; Compare Two Operands
cmp	si, [word_3AD9A]
jl	short loc_4DD92	; Jump if Less (SF!=OF)

loc_4DDB7:		; CODE XREF: sub_4DB4D:loc_4DDAFj
cmp	di, [bp+var_4]	; Compare Two Operands

loc_4DDBA:		; Jump if Not Zero (ZF=0)
jnz	short loc_4DDC0
dec	[word_3AD8A]	; Decrement by 1

loc_4DDC0:		; CODE XREF: sub_4DB4D:loc_4DDBAj
cmp	di, [bp+var_6]	; Compare Two Operands
jnz	short loc_4DDC9	; Jump if Not Zero (ZF=0)
inc	[word_3AD8A]	; Increment by 1

loc_4DDC9:		; CODE XREF: sub_4DB4D+276j
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_4E031 ; Call Procedure

loc_4DDD3:		;
call	setFlagsMaybeMouseEGA ;	mov	word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	[bp+var_4], 0FC18h
mov	[bp+var_6], 0FC18h
xor	si, si		; Logical Exclusive OR
jmp	short loc_4DDF1	; Jump

loc_4DDE6:		; CODE XREF: sub_4DB4D+2A7j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_4DDEA:
mov	[word ptr bx-6FA0h], 0FC18h

loc_4DDF0:		; Increment by 1
inc	si

loc_4DDF1:		; CODE XREF: sub_4DB4D+297j
cmp	si, 0Ah		; Compare Two Operands
jl	short loc_4DDE6	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	loc_4DF05	; Jump

loc_4DDFB:		; CODE XREF: sub_4DB4D+3C4j
cmp	[word_3AD98], 1	; Compare Two Operands
jz	short loc_4DE05	; Jump if Zero (ZF=1)
db 0E9h,7Fh,0 ;	<BAD>jmp     loc_4DE84 ; Jump

loc_4DE05:		; CODE XREF: sub_4DB4D+2B3j
mov	ax, 0FFFFh
push	ax
mov	ax, 3538h
push	ax
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, si
inc	dx		; Increment by 1
imul	dx		; Signed Multiply
push	ax
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
pop	ax
add	dx, ax		; Add
dec	dx		; Decrement by 1
push	dx
push	[word_3AE12]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD92]
sub	dx, ax		; Integer Subtraction

loc_4DE42:
push	dx
push	[word_3AE16]

loc_4DE47:		; Call Procedure
call	sub_1FB29
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx
push	[word_3AE0E]
call	sub_1FB15	; Call Procedure

loc_4DE7E:
pop	cx
pop	dx
add	dx, ax		; Add
jmp	short loc_4DEF3	; Jump

loc_4DE84:		; CODE XREF: sub_4DB4D+2B5j
mov	ax, 0FFFFh
push	ax
mov	ax, 3538h
push	ax
push	[word_3ADFA]

loc_4DE90:		; Call Procedure
call	sub_1FB29
pop	cx
mov	dx, si
inc	dx		; Increment by 1
imul	dx		; Signed Multiply
push	ax
push	[word_3AE16]

loc_4DEA0:		; Call Procedure
call	sub_1FB29
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
pop	ax
add	dx, ax		; Add
dec	dx		; Decrement by 1
push	dx

loc_4DEB1:
push	[word_3AE12]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD92]
sub	dx, ax		; Integer Subtraction
push	dx
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add

loc_4DEF3:		; CODE XREF: sub_4DB4D+335j
push	dx
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx-6FA0h], ax
inc	si		; Increment by 1

loc_4DF05:		; CODE XREF: sub_4DB4D+2ABj
cmp	si, [word_3AD88] ; Compare Two Operands
jge	short loc_4DF14	; Jump if Greater or Equal (SF=OF)
cmp	si, [word_3AD9A] ; Compare Two Operands

loc_4DF0F:		; Jump if Greater or Equal (SF=OF)
jge	short loc_4DF14
jmp	loc_4DDFB	; Jump

loc_4DF14:		; CODE XREF: sub_4DB4D+3BCj
			; sub_4DB4D:loc_4DF0Fj
cmp	[word_3AD98], 1	; Compare Two Operands
jz	short loc_4DF1E	; Jump if Zero (ZF=1)
jmp	loc_4DFC5	; Jump

loc_4DF1E:		; CODE XREF: sub_4DB4D+3CCj
cmp	[word_3AD8A], 0	; Compare Two Operands

loc_4DF23:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_4DF68
mov	ax, 0FFFFh
push	ax
mov	ax, 3538h
push	ax

loc_4DF2D:
push	[word_3ADE4]
mov	ax, 3538h
push	ax
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
add	dx, 3		; Add
push	dx
push	[word_3AE1A]

loc_4DF4D:		; Call Procedure
call	sub_1FB15
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
add	dx, 4		; Add
push	dx
call	sub_298BB	; Call Procedure
add	sp, 0Ch		; Add
mov	[bp+var_4], ax

loc_4DF68:		; CODE XREF: sub_4DB4D:loc_4DF23j
mov	ax, [word_3AD8A]
add	ax, [bp+arg_0]	; Add

loc_4DF6E:		; Compare Two Operands
cmp	ax, [word_3AD9A]
jge	short loc_4DFC5	; Jump if Greater or Equal (SF=OF)
mov	ax, 0FFFFh
push	ax
mov	ax, 3538h
push	ax
push	[word_3ADE2]
mov	ax, 3538h
push	ax
push	[word_3AE14]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD90]
sub	dx, ax		; Integer Subtraction
db 83h,0C2h,0FEh ; <BAD>add	dx, 0FFFEh ; Add
push	dx
push	[word_3ADE2]
call	sub_1FB29	; Call Procedure
pop	cx
pop	dx
sub	dx, ax		; Integer Subtraction
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
add	dx, 4		; Add
push	dx
call	sub_298BB	; Call Procedure

loc_4DFBF:		; Add
add	sp, 0Ch
mov	[bp+var_6], ax

loc_4DFC5:		; CODE XREF: sub_4DB4D+3CEj
			; sub_4DB4D+425j
mov	ax, 0FFFFh
push	ax

loc_4DFC9:
mov	ax, 3538h

loc_4DFCC:
push	ax
push	[word_3AD90]
push	[word_3AD92]
push	[word_3AD94]
push	[word_3AD96]
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_C], ax
mov	ax, 0FFFFh
push	ax
mov	ax, 353Dh
push	ax
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_8], ax
call	sub_31929	; Call Procedure

loc_4E00E:		; CODE XREF: sub_4DB4D+228j
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_4E017	; Jump if Not Zero (ZF=0)
jmp	loc_4DD78	; Jump

loc_4E017:		; CODE XREF: sub_4DB4D+4C5j
call	sub_2E257	; Call Procedure
call	sub_194C2	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_503A0 ; Call Procedure
mov	ax, [bp+var_A]
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4DB4D



; Attributes: bp-based frame

proc sub_4E031 far	; CODE XREF: sub_31AD3J
			; sub_4DB4D+283p
push	bp
mov	bp, sp
push	si
push	di
call	sub_27AFB	; Call Procedure

loc_4E03B:
mov	di, ax
cmp	di, [word_3AD9A] ; Compare Two Operands
jg	short loc_4E049	; Jump if Greater (ZF=0	& SF=OF)
cmp	di, [word_3AD88] ; Compare Two Operands
jle	short loc_4E04B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_4E049:		; CODE XREF: sub_4E031+10j
xor	di, di		; Logical Exclusive OR

loc_4E04B:		; CODE XREF: sub_4E031+16j
or	di, di		; Logical Inclusive OR
jle	short loc_4E055	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, di
dec	ax		; Decrement by 1
mov	[word_3AD8C], ax

loc_4E055:		; CODE XREF: sub_4E031+1Cj
call	sub_1E69F	; Call Procedure
push	[word_3AD90]
push	[word_3AD92]
push	[word_3AD94]
push	[word_3AD96]
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
push	[word_3AE1A]
push	[word_3AD94]
push	[word_3AD96]
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3AE16]
push	[word_3AD94]
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3AD90]
mov	ax, [word_3AD92]
add	ax, 0FFFBh	; Add
push	ax
push	[word_3AD94]
push	[word_3AD96]
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
cmp	[word_3AD98], 0	; Compare Two Operands
jz	short loc_4E0CC	; Jump if Zero (ZF=1)
jmp	loc_4E25F	; Jump

loc_4E0CC:		; CODE XREF: sub_4E031+96j
xor	si, si		; Logical Exclusive OR
jmp	loc_4E199	; Jump

loc_4E0D1:		; CODE XREF: sub_4E031+170j
cmp	si, [word_3AD8C] ; Compare Two Operands
jnz	short loc_4E0EF	; Jump if Not Zero (ZF=0)
mov	ax, 1
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F16h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
mov	ax, 1
jmp	short loc_4E103	; Jump

loc_4E0EF:		; CODE XREF: sub_4E031+A4j
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F16h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR

loc_4E103:		; CODE XREF: sub_4E031+BCj
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F2Ah]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F16h]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F2Ah]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3ADFA]

loc_4E172:		; Call Procedure
call	sub_1FB29
pop	cx
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add
push	dx
push	[word_3AE12]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD92]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
inc	si		; Increment by 1

loc_4E199:		; CODE XREF: sub_4E031+9Dj
mov	ax, [word_3AD88]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jle	short loc_4E1A4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4E0D1	; Jump

loc_4E1A4:		; CODE XREF: sub_4E031+16Ej
mov	ax, [word_3AD88]
dec	ax		; Decrement by 1
cmp	ax, [word_3AD8C] ; Compare Two Operands
jnz	short loc_4E1C2	; Jump if Not Zero (ZF=0)
mov	ax, 1
push	ax
push	[word_3AE0C]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
mov	ax, 1
jmp	short loc_4E1D2	; Jump

loc_4E1C2:		; CODE XREF: sub_4E031+17Bj
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE0C]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR

loc_4E1D2:		; CODE XREF: sub_4E031+18Fj
push	ax
push	[word_3ADF8]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
push	[word_3AE0C]

loc_4E1E2:
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD88]
dec	dx		; Decrement by 1
imul	dx		; Signed Multiply
push	ax
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
pop	ax
add	dx, ax		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3ADF8]
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD88]
dec	dx		; Decrement by 1
imul	dx		; Signed Multiply
push	ax
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
pop	ax
add	dx, ax		; Add
push	dx
push	[word_3AE12]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD92]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
jmp	loc_4E519	; Jump

loc_4E25F:		; CODE XREF: sub_4E031+98j
xor	si, si		; Logical Exclusive OR
jmp	loc_4E33A	; Jump

loc_4E264:		; CODE XREF: sub_4E031+311j
cmp	si, [word_3AD8C] ; Compare Two Operands
jnz	short loc_4E282	; Jump if Not Zero (ZF=0)
mov	ax, 1
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F16h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
mov	ax, 1
jmp	short loc_4E296	; Jump

loc_4E282:		; CODE XREF: sub_4E031+237j
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F16h]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR

loc_4E296:		; CODE XREF: sub_4E031+24Fj
push	ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_4E29B:
push	[word ptr bx-6F2Ah]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F16h]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx
push	[word_3AE0E]
call	sub_1FB15	; Call Procedure
pop	cx
pop	dx
add	dx, ax		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F2Ah]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]

loc_4E30C:		; Add
add	dx, ax
push	dx
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add
push	dx
push	[word_3AE12]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD92]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
inc	si		; Increment by 1

loc_4E33A:		; CODE XREF: sub_4E031+230j
mov	ax, [word_3AD88]
dec	ax		; Decrement by 1
cmp	ax, si		; Compare Two Operands
jle	short loc_4E345	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4E264	; Jump

loc_4E345:		; CODE XREF: sub_4E031+30Fj
mov	ax, [word_3AD88]

loc_4E348:		; Decrement by 1
dec	ax
cmp	ax, [word_3AD8C] ; Compare Two Operands
jnz	short loc_4E363	; Jump if Not Zero (ZF=0)
mov	ax, 1
push	ax
push	[word_3AE0C]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
mov	ax, 1
jmp	short loc_4E373	; Jump

loc_4E363:		; CODE XREF: sub_4E031+31Cj
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE0C]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR

loc_4E373:		; CODE XREF: sub_4E031+330j
push	ax
push	[word_3ADF8]
call	sub_1FA6E	; Call Procedure
pop	cx
pop	cx
push	[word_3AE0C]
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD88]
dec	dx		; Decrement by 1
imul	dx		; Signed Multiply
push	ax
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
pop	ax
add	dx, ax		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]

loc_4E3B7:		; Add
add	dx, ax
push	dx
push	[word_3AE0E]
call	sub_1FB15	; Call Procedure
pop	cx
pop	dx
add	dx, ax		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3ADF8]
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD88]
dec	dx		; Decrement by 1
imul	dx		; Signed Multiply
push	ax
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
pop	ax
add	dx, ax		; Add
push	dx
push	[word_3AE12]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD92]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3AE0E]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3ADE0]
call	sub_1FB29	; Call Procedure
pop	cx
pop	dx
add	dx, ax		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx

loc_4E448:		; Call Procedure
call	idk_VidLib_s1F743
add	sp, 6		; Add
push	[word_3ADDC]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
add	dx, 3		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
add	dx, 4		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3ADDA]
push	[word_3AE14]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD90]
sub	dx, ax		; Integer Subtraction
db 83h,0C2h,0FEh ; <BAD>add	dx, 0FFFEh ; Add
push	dx
push	[word_3ADDA]
call	sub_1FB29	; Call Procedure
pop	cx
pop	dx
sub	dx, ax		; Integer Subtraction
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]

loc_4E4B8:		; Add
add	dx, ax
add	dx, 4		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3ADE0]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3ADDE]
push	[word_3AE14]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD90]
sub	dx, ax		; Integer Subtraction
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add

loc_4E519:		; CODE XREF: sub_4E031+22Bj
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3AD90]
push	[word_3AD92]
push	[word_3AD94]
push	[word_3AD96]
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
push	[word_3AE14]

loc_4E53E:
push	[word_3AE14]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD90]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3AE18]

loc_4E56D:
push	[word_3AE18]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD90]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
push	dx
push	[word_3AD96]
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
push	[word_3AE12]
push	[word_3AD94]
push	[word_3AE12]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD92]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add

loc_4E5AD:
push	[word_3AE10]
push	[word_3AE10]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD90]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
push	dx
push	[word_3AE10]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD92]
sub	dx, ax		; Integer Subtraction
inc	dx		; Increment by 1
push	dx
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
mov	ax, 34D3h

loc_4E5E0:
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0FBh ; ''
push	ax
call	sub_193DD	; Call Procedure
pop	cx
push	[word_3AD84]	; int
mov	ax, [word_3AD94]
add	ax, 5		; Add
push	ax		; int
mov	ax, [word_3AD96]
add	ax, [word_3AD92] ; Add
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
inc	ax		; Increment by 1
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
mov	ax, 34CEh
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 14h
push	ax

loc_4E62A:		; Call Procedure
call	sub_193DD
pop	cx
push	[word_3AD84]	; int
mov	ax, [word_3AD94]
add	ax, 4		; Add
push	ax		; int
mov	ax, [word_3AD96]
add	ax, [word_3AD92] ; Add
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
call	idk_ScrnPos_0_319_0_199	; Call Procedure
mov	ax, 1
push	ax
mov	ax, 4
push	ax
call	sub_1922A	; Call Procedure
pop	cx
pop	cx
xor	si, si		; Logical Exclusive OR
jmp	loc_4E73E	; Jump

loc_4E669:		; CODE XREF: sub_4E031+719j
cmp	si, [word_3AD8C] ; Compare Two Operands
jnz	short loc_4E67E	; Jump if Not Zero (ZF=0)
mov	ax, 0B2h ; ''
push	ax
call	idk_SetConfigMomFlagValue_s1930B ; Call	Procedure
pop	cx
mov	ax, 0B6h ; ''
jmp	short loc_4E68B	; Jump

loc_4E67E:		; CODE XREF: sub_4E031+63Cj
mov	ax, 0B6h ; ''
push	ax
call	idk_SetConfigMomFlagValue_s1930B ; Call	Procedure
pop	cx
mov	ax, 35h	; '5'

loc_4E68B:		; CODE XREF: sub_4E031+64Bj
push	ax
call	sub_193DD	; Call Procedure
pop	cx
cmp	[word_3AD98], 1	; Compare Two Operands
jnz	short loc_4E6ED	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_4E69B:		; Add
add	ax, [word_3AD8A]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [word_3AD86]
add	bx, ax		; Add
push	[word ptr bx]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add
add	dx, 2		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add
push	dx
push	[word_3AE0E]
call	sub_1FB15	; Call Procedure
pop	cx
pop	dx
add	dx, ax		; Add
jmp	short loc_4E731	; Jump

loc_4E6ED:		; CODE XREF: sub_4E031+666j
mov	ax, si
add	ax, [word_3AD8A] ; Add
shl	ax, 1		; Shift	Logical	Left
mov	bx, [word_3AD86]
add	bx, ax		; Add
push	[word ptr bx]
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
mov	dx, [word_3AD94]
add	dx, ax		; Add
push	dx
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
imul	si		; Signed Multiply
pop	dx
add	dx, ax		; Add
add	dx, 2		; Add
push	dx
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, [word_3AD96]
add	dx, ax		; Add

loc_4E731:		; CODE XREF: sub_4E031+6BAj
add	dx, 4		; Add
push	dx
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
inc	si		; Increment by 1

loc_4E73E:		; CODE XREF: sub_4E031+635j
cmp	si, [word_3AD88] ; Compare Two Operands
jge	short loc_4E74D	; Jump if Greater or Equal (SF=OF)
cmp	si, [word_3AD9A] ; Compare Two Operands
jge	short loc_4E74D	; Jump if Greater or Equal (SF=OF)
jmp	loc_4E669	; Jump

loc_4E74D:		; CODE XREF: sub_4E031+711j
			; sub_4E031+717j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4E031



; Attributes: bp-based frame

proc sub_4E751 far	; CODE XREF: sub_31AD8J
			; sub_4DB4D+1E6p

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
mov	[word_3AD9A], 0
jmp	short loc_4E765	; Jump

loc_4E761:		; CODE XREF: sub_4E751+23j
inc	[word_3AD9A]	; Increment by 1

loc_4E765:		; CODE XREF: sub_4E751+Ej
mov	ax, [word_3AD9A]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_2]
add	bx, ax		; Add
mov	bx, [bx]
cmp	[byte ptr bx], 0 ; Compare Two Operands
jnz	short loc_4E761	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
xor	si, si		; Logical Exclusive OR
xor	di, di		; Logical Exclusive OR
jmp	short loc_4E7B3	; Jump

loc_4E78A:		; CODE XREF: sub_4E751+66j
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_2]
add	bx, ax		; Add
push	[word ptr bx]
call	sub_1AF46	; Call Procedure
pop	cx
cmp	ax, si		; Compare Two Operands
jle	short loc_4E7B2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, di
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_2]
add	bx, ax		; Add
push	[word ptr bx]
call	sub_1AF46	; Call Procedure
pop	cx
mov	si, ax

loc_4E7B2:		; CODE XREF: sub_4E751+4Cj
inc	di		; Increment by 1

loc_4E7B3:		; CODE XREF: sub_4E751+37j
cmp	di, [word_3AD9A] ; Compare Two Operands
jl	short loc_4E78A	; Jump if Less (SF!=OF)
cmp	[word_3AD98], 0	; Compare Two Operands
jz	short loc_4E7CC	; Jump if Zero (ZF=1)
push	[word_3AE0E]
call	sub_1FB15	; Call Procedure
pop	cx
add	si, ax		; Add

loc_4E7CC:		; CODE XREF: sub_4E751+6Dj
push	[bp+arg_4]
call	sub_1AF46	; Call Procedure
pop	cx
mov	[bp+var_6], ax
cmp	[bp+var_6], si	; Compare Two Operands
jle	short loc_4E7E0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	si, [bp+var_6]

loc_4E7E0:		; CODE XREF: sub_4E751+8Aj
add	si, 8		; Add
push	[word_3AE1A]
call	sub_1FB15	; Call Procedure
pop	cx
mov	dx, si
add	dx, ax		; Add
push	dx
push	[word_3AE12]
call	sub_1FB15	; Call Procedure
pop	cx
pop	dx
add	dx, ax		; Add

loc_4E7FF:
mov	[bp+var_2], dx
push	[word_3ADFA]
call	sub_1FB29	; Call Procedure
pop	cx
imul	[bp+arg_0]	; Signed Multiply
push	ax
push	[word_3AE16]
call	sub_1FB29	; Call Procedure
pop	cx
pop	dx
add	dx, ax		; Add
push	dx
push	[word_3AE14]
call	sub_1FB29	; Call Procedure
pop	cx
pop	dx
add	dx, ax		; Add
mov	[bp+var_4], dx
mov	ax, 140h
sub	ax, [bp+var_2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right

loc_4E839:
mov	[word_3AD96], ax
mov	ax, 0C8h ; ''
sub	ax, [bp+var_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[word_3AD94], ax
mov	ax, [word_3AD96]
add	ax, [bp+var_2]	; Add
dec	ax		; Decrement by 1
mov	[word_3AD92], ax
mov	ax, [word_3AD94]
add	ax, [bp+var_4]	; Add
dec	ax		; Decrement by 1
mov	[word_3AD90], ax
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4E751



; 3 calls
;
;     ;	Attributes: thunk
;     j_idk_ResourceLbx	proc far
; 000 jmp     idk_ResourceLbx ;	Jump
;     j_idk_ResourceLbx	endp
;
;
; sub_4E9F4 proc far
; ...
; 00A mov     di, [bp+arg_4]
; 00A mov     si, [bp+arg_A]
; 00A push    si
; 00C push    di
; 00E push    cs
; 010 call    near ptr idk_ResourceLbx ; Call Procedure
; ...
;
; sub_4EF74 proc far:
; ...
; 00A mov     di, [bp+arg_4]
; 00A mov     si, [bp+arg_A]
; 00A push    si
; 00C push    di
; 00E push    cs
; 010 call    near ptr idk_ResourceLbx ; Call Procedure
; ...
;
; Attributes: bp-based frame

proc idk_ResourceLbx far
			; CODE XREF: j_idk_ResourceLbxJ
			; sub_4E9F4+11p
			; sub_4EF74+11p

arg_SI=	word ptr  6
arg_DI=	word ptr  8

push	bp
mov	bp, sp
push	si
nop			; No Operation
push	cs
call	near ptr sub_50356 ; Call Procedure
mov	ax, [idk_LBX_w37EBE]
add	ax, 1500	; Add
cmp	ax, [bp+arg_DI]	; Compare Two Operands
jnb	short loc_4E87D	; Jump if Not Below (CF=0)
mov	ax, 1
jmp	short loc_4E880	; Jump

loc_4E87D:		; CODE XREF: idk_ResourceLbx+12j
mov	ax, 1500

loc_4E880:		; CODE XREF: idk_ResourceLbx+17j
push	ax		; argValue
mov	ax, 10
push	ax		; argOffset
push	[idk_LBX_w37EBE] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
mov	bx, [bp+arg_SI]
cmp	bx, 3		; switch 4 cases
jbe	short loc_4E89C	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_4E9C1	; default

loc_4E89C:		; CODE XREF: idk_ResourceLbx+33j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4E9EC+bx] ; switch jump

loc_4E8A3:		; DATA XREF: ovr053:off_4E9ECo
push	[idk_LBX_w37EBE] ; case	0x0
mov	ax, 2Eh	; '.'

loc_4E8AA:		; argFileName
push	ax
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADC6], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Fh	; '/'
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADBE], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 30h	; '0'
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADB6], ax
jmp	loc_4E9C1	; default

loc_4E8EB:		; CODE XREF: idk_ResourceLbx+3Aj
			; DATA XREF: ovr053:off_4E9ECo
push	[idk_LBX_w37EBE] ; case	0x1
mov	ax, 2Bh	; '+'
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADC8], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Ch	; ','
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADC0], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Dh	; '-'
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADB8], ax
jmp	loc_4E9C1	; default

loc_4E933:		; CODE XREF: idk_ResourceLbx+3Aj
			; DATA XREF: ovr053:off_4E9ECo
push	[idk_LBX_w37EBE] ; case	0x2
mov	ax, 28h	; '('
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADCA], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 29h	; ')'
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADC2], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 2Ah	; '*'
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADBA], ax
jmp	short loc_4E9C1	; default

loc_4E97A:		; CODE XREF: idk_ResourceLbx+3Aj
			; DATA XREF: ovr053:off_4E9ECo
push	[idk_LBX_w37EBE] ; case	0x3
mov	ax, 38h	; '8'
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADCC], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 39h	; '9'
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADC4], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 3Ah	; ':'
push	ax		; argFileName
mov	ax, 3530h
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[word_3ADBC], ax
jmp	short $+2	; Jump

loc_4E9C1:		; CODE XREF: idk_ResourceLbx+35j
			; idk_ResourceLbx+84j
			; idk_ResourceLbx+CCj
			; idk_ResourceLbx+114j
xor	si, si		; default
jmp	short loc_4E9E4	; Jump

loc_4E9C5:		; CODE XREF: idk_ResourceLbx+183j
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, si
add	ax, 51		; Add
push	ax		; argFileName
mov	ax, offset strRESOURCE ; "RESOURCE"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	[bx+5C28h], ax
inc	si		; Increment by 1

loc_4E9E4:		; CODE XREF: idk_ResourceLbx+15Fj
cmp	si, 5		; Compare Two Operands
jl	short loc_4E9C5	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp idk_ResourceLbx

off_4E9EC dw offset loc_4E8A3
			; DATA XREF: idk_ResourceLbx+3Ar
dw offset loc_4E8EB	; jump table for switch	statement
dw offset loc_4E933
dw offset loc_4E97A


; Attributes: bp-based frame

proc sub_4E9F4 far	; CODE XREF: sub_31AE2J

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_4]
mov	si, [bp+arg_A]
push	si
push	di
push	cs
call	near ptr idk_ResourceLbx ; Call	Procedure
pop	cx
pop	cx
mov	[word_3AE1C], 3
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [word_3866E] ; Compare Two Operands
jge	short loc_4EA26	; Jump if Greater or Equal (SF=OF)
mov	[word_3AE1C], 2

loc_4EA26:		; CODE XREF: sub_4E9F4+2Aj
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [word_38672] ; Compare Two Operands
jge	short loc_4EA3C	; Jump if Greater or Equal (SF=OF)
mov	[word_3AE1C], 4

loc_4EA3C:		; CODE XREF: sub_4E9F4+40j
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [word_3866A] ; Compare Two Operands
jge	short loc_4EA52	; Jump if Greater or Equal (SF=OF)
mov	[word_3AE1C], 0

loc_4EA52:		; CODE XREF: sub_4E9F4+56j
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [word_3866C] ; Compare Two Operands
jge	short loc_4EA68	; Jump if Greater or Equal (SF=OF)
mov	[word_3AE1C], 1

loc_4EA68:		; CODE XREF: sub_4E9F4+6Cj
mov	bx, [word_3AE1C]
cmp	bx, 4		; switch 5 cases
ja	short loc_4EAA0	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4EC0D+bx] ; switch jump

loc_4EA78:		; DATA XREF: ovr053:off_4EC0Do
mov	[word_3AE1C], 0	; case 0x2
jmp	short loc_4EAA0	; default

loc_4EA80:		; CODE XREF: sub_4E9F4+7Fj
			; DATA XREF: ovr053:off_4EC0Do
mov	[word_3AE1C], 1	; case 0x4
jmp	short loc_4EAA0	; default

loc_4EA88:		; CODE XREF: sub_4E9F4+7Fj
			; DATA XREF: ovr053:off_4EC0Do
mov	[word_3AE1C], 2	; case 0x3
jmp	short loc_4EAA0	; default

loc_4EA90:		; CODE XREF: sub_4E9F4+7Fj
			; DATA XREF: ovr053:off_4EC0Do
mov	[word_3AE1C], 3	; case 0x0
jmp	short loc_4EAA0	; default

loc_4EA98:		; CODE XREF: sub_4E9F4+7Fj
			; DATA XREF: ovr053:off_4EC0Do
mov	[word_3AE1C], 4	; case 0x1
jmp	short $+2	; Jump

loc_4EAA0:		; CODE XREF: sub_4E9F4+7Bj
			; sub_4E9F4+8Aj
			; sub_4E9F4+92j
			; sub_4E9F4+9Aj
			; sub_4E9F4+A2j
mov	ax, [bp+arg_16]	; default
mov	[word_3ADCE], ax
mov	[word_3ADD0], 0
call	sub_19454	; Call Procedure
cmp	[word_351F6], 2	; Compare Two Operands
jnz	short loc_4EABD	; Jump if Not Zero (ZF=0)
call	sub_1E525	; Call Procedure

loc_4EABD:		; CODE XREF: sub_4E9F4+C2j
cmp	[bp+arg_18], 1	; Compare Two Operands
jnz	short loc_4EAE2	; Jump if Not Zero (ZF=0)
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, 3
push	ax
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_18579	; Call Procedure
add	sp, 0Ah		; Add

loc_4EAE2:		; CODE XREF: sub_4E9F4+CDj
call	sub_1E65C	; Call Procedure
mov	ax, [bp+arg_6]
mov	[word_3AE1E], ax
mov	[word_3ADB0], si
mov	ax, [bp+arg_10]
mov	[word_3ADAE], ax
mov	[word_3ADB2], di
mov	ax, [bp+arg_8]
mov	[word_3ADAC], ax
mov	ax, [bp+arg_C]
mov	[word_3ADAA], ax
mov	ax, [bp+arg_E]
mov	[word_3ADA8], ax
mov	ax, [bp+arg_12]
mov	[word_3ADA4], ax
mov	ax, [bp+arg_14]
mov	[word_3ADA6], ax
mov	[word_3ADD0], 0
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_6]
mov	ax, 0AFh ; ''
push	ax
call	sub_1B9E2	; Call Procedure
add	sp, 6		; Add
mov	[bp+var_2], ax
mov	ax, [bp+var_2]
add	ax, 60h	; '`'   ; Add
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+arg_0]
sub	dx, ax		; Integer Subtraction
mov	[word_3AE22], dx
mov	ax, [bp+arg_2]
mov	[word_3AE20], ax
mov	ax, 1
push	ax
mov	ax, seg	stub053
push	ax
mov	ax, 57h	; 'W'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
mov	bx, [word_3ADB2]
shl	bx, 1		; Shift	Logical	Left
push	[word_3ADC6+bx]
call	sub_1F61E	; Call Procedure
pop	cx
or	si, si		; Logical Inclusive OR
jz	short loc_4EB8B	; Jump if Zero (ZF=1)
push	si
call	sub_1F61E	; Call Procedure
pop	cx

loc_4EB8B:		; CODE XREF: sub_4E9F4+18Ej
mov	ax, 255
push	ax		; argCount
mov	ax, 224
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx
mov	ax, 198
push	ax
mov	ax, 198
push	ax
call	idk_Set_FontsLbx1_256arr_to_0 ;	Call Procedure
pop	cx
pop	cx
call	sub_1BF5C	; Call Procedure
call	idk_SetPalette_s1C4F4 ;	Call Procedure
mov	[bp+var_4], 0
cmp	[word_351F6], 1	; Compare Two Operands
jnz	short loc_4EBCB	; Jump if Not Zero (ZF=0)
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_4EC17 ; Call Procedure
jmp	short loc_4EBD0	; Jump

loc_4EBCB:		; CODE XREF: sub_4E9F4+1C9j
call	sub_27CC0	; Call Procedure

loc_4EBD0:		; CODE XREF: sub_4E9F4+1D5j
mov	ax, 223
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx
mov	ax, 0C6h ; ''
push	ax
mov	ax, 0C6h ; ''
push	ax
call	idk_Set_FontsLbx1_256arr_to_0 ;	Call Procedure
pop	cx
pop	cx
call	sub_1BF5C	; Call Procedure
call	sub_2E257	; Call Procedure
call	sub_194C2	; Call Procedure
call	idk_ScrnPos_0_319_0_199	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_503A0 ; Call Procedure
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4E9F4

db 0
off_4EC0D dw offset loc_4EA90
			; DATA XREF: sub_4E9F4+7Fr
dw offset loc_4EA98	; jump table for switch	statement
dw offset loc_4EA78
dw offset loc_4EA88
dw offset loc_4EA80


; Attributes: bp-based frame

proc sub_4EC17 far	; CODE XREF: sub_31AE7J
			; sub_4E9F4+1D2p
			; sub_4EF74+1E6p
push	bp
mov	bp, sp
push	si
push	di
cmp	[word_3ADB2], 2	; Compare Two Operands
jnz	short loc_4EC28	; Jump if Not Zero (ZF=0)
mov	si, 32h	; '2'
jmp	short loc_4EC2A	; Jump

loc_4EC28:		; CODE XREF: sub_4EC17+Aj
xor	si, si		; Logical Exclusive OR

loc_4EC2A:		; CODE XREF: sub_4EC17+Fj
cmp	[word_3ADCE], 1	; Compare Two Operands
jnz	short loc_4EC53	; Jump if Not Zero (ZF=0)
push	[word_3ADD0]
mov	ax, 0Bh
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_PAL_s1C76E ; Call Procedure
add	sp, 6		; Add
mov	ax, [word_3ADD0]
inc	ax		; Increment by 1
mov	bx, 0Bh
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[word_3ADD0], dx

loc_4EC53:		; CODE XREF: sub_4EC17+18j
cmp	[word_3ADCE], 2	; Compare Two Operands
jnz	short loc_4EC7C	; Jump if Not Zero (ZF=0)
push	[word_3ADD0]
mov	ax, 8
push	ax
mov	ax, 0F7h ; ''
push	ax
call	idk_VGA_PAL_s1C76E ; Call Procedure
add	sp, 6		; Add
mov	ax, [word_3ADD0]
inc	ax		; Increment by 1
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[word_3ADD0], dx

loc_4EC7C:		; CODE XREF: sub_4EC17+41j
call	sub_1E69F	; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, 0AFh ; ''
push	ax
call	sub_1B9E2	; Call Procedure
add	sp, 6		; Add
mov	di, ax
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, 0C7h ; ''
push	ax
mov	ax, di
add	ax, [word_3AE22] ; Add
add	ax, si		; Add
add	ax, 0Ch		; Add
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
mov	bx, [word_3ADB2]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F4Ah]
push	[word_3AE20]
push	[word_3AE22]
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
cmp	[word_3ADB2], 2	; Compare Two Operands
jnz	short loc_4ED08	; Jump if Not Zero (ZF=0)
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+5C28h]
mov	ax, [word_3AE20]
add	ax, 0FFEDh	; Add
push	ax
mov	ax, [word_3AE22]
add	ax, 0FFE9h	; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add

loc_4ED08:		; CODE XREF: sub_4EC17+CFj
call	idk_ScrnPos_0_319_0_199	; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, [word_3AE20]

loc_4ED13:		; Add
add	ax, 37h	; '7'
push	ax
mov	ax, [word_3AE22]
add	ax, di		; Add
add	ax, si		; Add
add	ax, 3Eh	; '>'   ; Add
push	ax
push	[word_3AE20]
mov	ax, [word_3AE22]
add	ax, di		; Add
add	ax, si		; Add
add	ax, 0Ch		; Add
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
cmp	[word_3ADAC], 0	; Compare Two Operands
jnz	short loc_4ED4C	; Jump if Not Zero (ZF=0)
mov	bx, [word_3ADB2]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F52h]
jmp	short loc_4ED56	; Jump

loc_4ED4C:		; CODE XREF: sub_4EC17+127j
mov	bx, [word_3ADB2]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F5Ah]

loc_4ED56:		; CODE XREF: sub_4EC17+133j
push	[word_3AE20]
mov	ax, [word_3AE22]
add	ax, di		; Add
add	ax, si		; Add
add	ax, 0Ch		; Add
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
cmp	[word_3ADB0], 0	; Compare Two Operands
jz	short loc_4EDA6	; Jump if Zero (ZF=1)
push	[word_37EBC]
push	[word_3ADB0]

loc_4ED7C:		; Call Procedure
call	sub_1F8FD
pop	cx
pop	cx

loc_4ED83:
push	[word_37EBC]
mov	ax, [word_3AE20]
add	ax, [word_3ADA8] ; Add
push	ax
mov	ax, [word_3AE22]
add	ax, di		; Add
add	ax, [word_3ADAA] ; Add
add	ax, si		; Add
add	ax, 10h		; Add
push	ax
call	sub_21014	; Call Procedure
add	sp, 6		; Add

loc_4EDA6:		; CODE XREF: sub_4EC17+15Bj
cmp	[word_3ADAE], 0	; Compare Two Operands
jz	short loc_4EDDF	; Jump if Zero (ZF=1)
push	[word_37EBC]
push	[word_3ADAE]
call	sub_1F8FD	; Call Procedure
pop	cx
pop	cx
push	[word_37EBC]
mov	ax, [word_3AE20]
add	ax, [word_3ADA6] ; Add
push	ax
mov	ax, [word_3AE22]
add	ax, di		; Add
add	ax, [word_3ADA4] ; Add
add	ax, si		; Add
add	ax, 10h		; Add
push	ax
call	sub_21014	; Call Procedure
add	sp, 6		; Add

loc_4EDDF:		; CODE XREF: sub_4EC17+194j
cmp	[word_3ADB2], 3	; Compare Two Operands
jz	short loc_4EDE9	; Jump if Zero (ZF=1)
jmp	loc_4EE73	; Jump

loc_4EDE9:		; CODE XREF: sub_4EC17+1CDj
mov	ax, 34C4h
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax		; int
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, [word_3AE20]
add	ax, 9		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, si		; Add
add	ax, 0Bh		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, [word_3AE20]
add	ax, 9		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, si		; Add
add	ax, 0Ah		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
mov	ax, 15h
push	ax
call	sub_193DD	; Call Procedure
pop	cx
jmp	loc_4EEFB	; Jump

loc_4EE73:		; CODE XREF: sub_4EC17+1CFj
mov	ax, [word_3ADB2]
mov	dx, 5
imul	dx		; Signed Multiply
add	ax, 34E8h	; Add
push	ax

loc_4EE7F:
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax		; int
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, [word_3AE20]
add	ax, 9		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, si		; Add
add	ax, 0Bh		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, [word_3AE20]
add	ax, 9		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, si		; Add
add	ax, 0Ah		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, [word_3ADB2]
mov	dx, 5
imul	dx		; Signed Multiply
add	ax, 34FCh	; Add
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_4EEFB:		; CODE XREF: sub_4EC17+259j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, [word_3AE20]
add	ax, 8		; Add
push	ax
mov	ax, [word_3AE22]
add	ax, si		; Add
add	ax, 0Ah		; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
cmp	[word_3ADCE], 1	; Compare Two Operands
jnz	short loc_4EF47	; Jump if Not Zero (ZF=0)
push	[word_3ADD0]
mov	ax, 0Bh
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_PAL_s1C76E ; Call Procedure
add	sp, 6		; Add
mov	ax, [word_3ADD0]
inc	ax		; Increment by 1
mov	bx, 0Bh
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[word_3ADD0], dx

loc_4EF47:		; CODE XREF: sub_4EC17+30Cj
cmp	[word_3ADCE], 2	; Compare Two Operands
jnz	short loc_4EF70	; Jump if Not Zero (ZF=0)
push	[word_3ADD0]
mov	ax, 8
push	ax
mov	ax, 0F7h ; ''
push	ax
call	idk_VGA_PAL_s1C76E ; Call Procedure
add	sp, 6		; Add
mov	ax, [word_3ADD0]
inc	ax		; Increment by 1
mov	bx, 8
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[word_3ADD0], dx

loc_4EF70:		; CODE XREF: sub_4EC17+335j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4EC17



; Attributes: bp-based frame

proc sub_4EF74 far	; CODE XREF: sub_31AECJ

var_4= word ptr	-4
var_2= word ptr	-2
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_4]
mov	si, [bp+arg_A]
push	si
push	di
push	cs
call	near ptr idk_ResourceLbx ; Call	Procedure
pop	cx
pop	cx
mov	[bp+arg_18], 0
mov	[word_3AE1C], 3
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [word_3866E] ; Compare Two Operands
jge	short loc_4EFAB	; Jump if Greater or Equal (SF=OF)
mov	[word_3AE1C], 2

loc_4EFAB:		; CODE XREF: sub_4EF74+2Fj
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [word_38672] ; Compare Two Operands
jge	short loc_4EFC1	; Jump if Greater or Equal (SF=OF)
mov	[word_3AE1C], 4

loc_4EFC1:		; CODE XREF: sub_4EF74+45j
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [word_3866A] ; Compare Two Operands
jge	short loc_4EFD7	; Jump if Greater or Equal (SF=OF)
mov	[word_3AE1C], 0

loc_4EFD7:		; CODE XREF: sub_4EF74+5Bj
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [word_3866C] ; Compare Two Operands
jge	short loc_4EFED	; Jump if Greater or Equal (SF=OF)
mov	[word_3AE1C], 1

loc_4EFED:		; CODE XREF: sub_4EF74+71j
mov	bx, [word_3AE1C]
cmp	bx, 4		; switch 5 cases
ja	short loc_4F025	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_4F1A1+bx] ; switch jump

loc_4EFFD:		; DATA XREF: ovr053:off_4F1A1o
mov	[word_3AE1C], 0	; case 0x2
jmp	short loc_4F025	; default

loc_4F005:		; CODE XREF: sub_4EF74+84j
			; DATA XREF: ovr053:off_4F1A1o
mov	[word_3AE1C], 1	; case 0x4
jmp	short loc_4F025	; default

loc_4F00D:		; CODE XREF: sub_4EF74+84j
			; DATA XREF: ovr053:off_4F1A1o
mov	[word_3AE1C], 2	; case 0x3
jmp	short loc_4F025	; default

loc_4F015:		; CODE XREF: sub_4EF74+84j
			; DATA XREF: ovr053:off_4F1A1o
mov	[word_3AE1C], 3	; case 0x0
jmp	short loc_4F025	; default

loc_4F01D:		; CODE XREF: sub_4EF74+84j
			; DATA XREF: ovr053:off_4F1A1o
mov	[word_3AE1C], 4	; case 0x1
jmp	short $+2	; Jump

loc_4F025:		; CODE XREF: sub_4EF74+80j
			; sub_4EF74+8Fj
			; sub_4EF74+97j
			; sub_4EF74+9Fj
			; sub_4EF74+A7j
mov	ax, [bp+arg_16]	; default
mov	[word_3ADCE], ax
mov	[word_3ADD0], 0
call	sub_19454	; Call Procedure
cmp	[word_351F6], 2	; Compare Two Operands
jnz	short loc_4F042	; Jump if Not Zero (ZF=0)
call	sub_1E525	; Call Procedure

loc_4F042:		; CODE XREF: sub_4EF74+C7j
cmp	[bp+arg_18], 1	; Compare Two Operands
jnz	short loc_4F067	; Jump if Not Zero (ZF=0)
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, 3
push	ax
mov	ax, 0C7h ; ''
push	ax
mov	ax, 13Fh
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_18579	; Call Procedure
add	sp, 0Ah		; Add

loc_4F067:		; CODE XREF: sub_4EF74+D2j
call	sub_1E65C	; Call Procedure
mov	ax, [bp+arg_6]
mov	[word_3AE1E], ax
mov	[word_3ADB0], si
mov	ax, [bp+arg_10]
mov	[word_3ADAE], ax
mov	[word_3ADB2], di
mov	ax, [bp+arg_8]
mov	[word_3ADAC], ax
mov	ax, [bp+arg_C]
mov	[word_3ADAA], ax
mov	ax, [bp+arg_E]
mov	[word_3ADA8], ax
mov	ax, [bp+arg_12]
mov	[word_3ADA4], ax
mov	ax, [bp+arg_14]
mov	[word_3ADA6], ax
mov	[word_3ADD0], 0
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+arg_6]
mov	ax, 0AFh ; ''
push	ax
call	sub_1B9E2	; Call Procedure
add	sp, 6		; Add
mov	[bp+var_2], ax
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx+3510h], 0 ; Compare Two Operands
jge	short loc_4F0E6	; Jump if Greater or Equal (SF=OF)
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, 6
sub	ax, [bx+3510h]	; Integer Subtraction
mov	[word_3AE22], ax
jmp	short loc_4F0EC	; Jump

loc_4F0E6:		; CODE XREF: sub_4EF74+15Ej
mov	[word_3AE22], 6

loc_4F0EC:		; CODE XREF: sub_4EF74+170j
mov	ax, [bp+arg_2]
mov	[word_3AE20], ax
mov	ax, 1
push	ax
mov	ax, seg	stub053
push	ax
mov	ax, 61h	; 'a'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
mov	bx, [word_3ADB2]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F4Ah]
call	sub_1F61E	; Call Procedure
pop	cx
or	si, si		; Logical Inclusive OR
jz	short loc_4F121	; Jump if Zero (ZF=1)
push	si
call	sub_1F61E	; Call Procedure
pop	cx

loc_4F121:		; CODE XREF: sub_4EF74+1A4j
call	idk_SetPalette_s1C4F4 ;	Call Procedure
mov	ax, 243
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx
mov	ax, 0C6h ; ''
push	ax
mov	ax, 0C6h ; ''
push	ax
call	idk_Set_FontsLbx1_256arr_to_0 ;	Call Procedure
pop	cx
pop	cx
call	sub_1BF5C	; Call Procedure
mov	[bp+var_4], 0

loc_4F14D:		; Compare Two Operands
cmp	[word_351F6], 1
jnz	short loc_4F15F	; Jump if Not Zero (ZF=0)
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
push	cs
call	near ptr sub_4EC17 ; Call Procedure
jmp	short loc_4F164	; Jump

loc_4F15F:		; CODE XREF: sub_4EF74+1DEj
call	sub_27CC0	; Call Procedure

loc_4F164:		; CODE XREF: sub_4EF74+1E9j
mov	ax, 223
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx
mov	ax, 0C6h ; ''
push	ax
mov	ax, 0C6h ; ''
push	ax
call	idk_Set_FontsLbx1_256arr_to_0 ;	Call Procedure
pop	cx
pop	cx
call	sub_1BF5C	; Call Procedure
call	sub_2E257	; Call Procedure
call	sub_194C2	; Call Procedure
call	idk_ScrnPos_0_319_0_199	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_503A0 ; Call Procedure
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4EF74

db 0
off_4F1A1 dw offset loc_4F015
			; DATA XREF: sub_4EF74+84r
dw offset loc_4F01D	; jump table for switch	statement
dw offset loc_4EFFD
dw offset loc_4F00D
dw offset loc_4F005


; Attributes: bp-based frame

proc sub_4F1AB far	; CODE XREF: sub_31AF1J
push	bp
mov	bp, sp
push	si
push	di
cmp	[word_3ADCE], 1	; Compare Two Operands
jnz	short loc_4F1D9	; Jump if Not Zero (ZF=0)
push	[word_3ADD0]

loc_4F1BB:
mov	ax, 0Bh
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_PAL_s1C76E ; Call Procedure
add	sp, 6		; Add
mov	ax, [word_3ADD0]
inc	ax		; Increment by 1
mov	bx, 0Bh
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[word_3ADD0], dx

loc_4F1D9:		; CODE XREF: sub_4F1AB+Aj
call	sub_1E69F	; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, 0AFh ; ''
push	ax
call	sub_1B9E2	; Call Procedure
add	sp, 6		; Add
mov	di, ax
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, di
add	ax, [word_3AE22] ; Add
add	ax, [bx+3524h]	; Add
mov	si, ax
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, 0C7h ; ''
push	ax
push	si
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
mov	bx, [word_3ADB2]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F4Ah]
push	[word_3AE20]
push	[word_3AE22]
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+5C28h]
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_3AE20]
add	ax, [bx+351Ah]	; Add
push	ax
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_3AE22]
add	ax, [bx+3510h]	; Add
dec	ax		; Decrement by 1
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
call	idk_ScrnPos_0_319_0_199	; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, [word_3AE20]
add	ax, 37h	; '7'   ; Add
push	ax
mov	ax, si
add	ax, 2Fh	; '/'   ; Add
push	ax
push	[word_3AE20]
mov	ax, si
add	ax, 2		; Add
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
cmp	[word_3ADAC], 0	; Compare Two Operands
jnz	short loc_4F2AE	; Jump if Not Zero (ZF=0)
mov	bx, [word_3ADB2]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F52h]
jmp	short loc_4F2B8	; Jump

loc_4F2AE:		; CODE XREF: sub_4F1AB+F5j
mov	bx, [word_3ADB2]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-6F5Ah]

loc_4F2B8:		; CODE XREF: sub_4F1AB+101j
push	[word_3AE20]
mov	ax, si
inc	ax		; Increment by 1
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
cmp	[word_3ADB0], 0	; Compare Two Operands
jz	short loc_4F2FC	; Jump if Zero (ZF=1)
push	[word_37EBC]
push	[word_3ADB0]
call	sub_1F8FD	; Call Procedure
pop	cx
pop	cx
push	[word_37EBC]
mov	ax, [word_3AE20]
add	ax, [word_3ADA8] ; Add
push	ax
mov	ax, si
add	ax, [word_3ADAA] ; Add
add	ax, 7		; Add
push	ax
call	sub_21014	; Call Procedure
add	sp, 6		; Add

loc_4F2FC:		; CODE XREF: sub_4F1AB+122j
cmp	[word_3ADAE], 0	; Compare Two Operands
jz	short loc_4F32F	; Jump if Zero (ZF=1)
push	[word_37EBC]
push	[word_3ADAE]
call	sub_1F8FD	; Call Procedure
pop	cx
pop	cx
push	[word_37EBC]
mov	ax, [word_3AE20]
add	ax, [word_3ADA6] ; Add
push	ax
mov	ax, [word_3ADA4]
add	ax, si		; Add
add	ax, 7		; Add
push	ax
call	sub_21014	; Call Procedure
add	sp, 6		; Add

loc_4F32F:		; CODE XREF: sub_4F1AB+156j
mov	ax, [word_3ADB2]
mov	dx, 5
imul	dx		; Signed Multiply
add	ax, 34E8h	; Add
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 0Fh
push	ax		; int
mov	ax, 0Fh
push	ax		; int
mov	ax, 4
push	ax		; int
call	idk_PalFnt_s1AB64 ; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, [word_3AE20]
add	ax, 9		; Add
push	ax
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_3AE22]
add	ax, [bx+3524h]	; Add
inc	ax		; Increment by 1
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, [word_3AE20]
add	ax, 9		; Add
push	ax
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_3AE22]
add	ax, [bx+3524h]	; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
mov	ax, [word_3ADB2]
mov	dx, 5
imul	dx		; Signed Multiply
add	ax, 34FCh	; Add
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word_3AE1E]
mov	ax, di
inc	ax		; Increment by 1
push	ax
mov	ax, [word_3AE20]
add	ax, 8		; Add
push	ax
mov	bx, [word_3AE1C]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [word_3AE22]
add	ax, [bx+3524h]	; Add
push	ax
call	sub_1B0AD	; Call Procedure
add	sp, 0Ah		; Add
cmp	[word_3ADCE], 1	; Compare Two Operands
jnz	short loc_4F413	; Jump if Not Zero (ZF=0)
push	[word_3ADD0]
mov	ax, 0Bh
push	ax
mov	ax, 0F4h ; ''
push	ax
call	idk_VGA_PAL_s1C76E ; Call Procedure
add	sp, 6		; Add
mov	ax, [word_3ADD0]
inc	ax		; Increment by 1
mov	bx, 0Bh
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[word_3ADD0], dx

loc_4F413:		; CODE XREF: sub_4F1AB+244j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4F1AB



; Attributes: bp-based frame

proc sub_4F417 far	; CODE XREF: sub_31AF6J

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h

push	bp
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]
mov	di, [bp+arg_2]
push	[bp+arg_10]
push	[bp+arg_E]
push	[bp+arg_C]
push	[bp+arg_A]
push	[bp+arg_8]
push	[bp+arg_6]
push	[bp+arg_4]
push	di
push	si
push	[bp+arg_6]
push	[bp+arg_4]
push	di
push	si
nop			; No Operation
push	cs
call	near ptr sub_4F44D ; Call Procedure
add	sp, 1Ah		; Add
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_4F417



; Attributes: bp-based frame

proc sub_4F44D far	; CODE XREF: sub_31AFBJ
			; sub_4F417+2Cp

var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh

push	bp
mov	bp, sp
sub	sp, 18h		; Integer Subtraction
push	si
push	di
mov	ax, [bp+arg_18]
mov	[FLAG_w3AD5E], ax
mov	ax, [bp+arg_0]
mov	[word_3AD6E], ax
mov	ax, [bp+arg_2]
mov	[word_3AD6C], ax
mov	ax, [bp+arg_4]
mov	[word_3AD6A], ax
mov	ax, [bp+arg_6]
mov	[word_3AD68], ax
mov	ax, [bp+arg_10]
mov	[word_3AD66], ax
mov	ax, [bp+arg_12]
mov	[word_3AD64], ax
mov	ax, [bp+arg_14]
mov	[word_3AD62], ax
mov	ax, [bp+arg_16]
mov	[word_3AD60], ax
cmp	[MagSet_18], 0	; Compare Two Operands
jnz	short yesEqual	; Jump Not Zero	/ Jump Equal
call	j_@filebuf@terminate$qv_1 ; filebuf::terminate(void)
xor	ax, ax		; Logical Exclusive OR
jmp	loc_4F7AD	; Jump

yesEqual:		; CODE XREF: sub_4F44D+43j
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, [bp+arg_8]
cmp	ax, [bp+arg_C]	; Compare Two Operands
jle	short loc_4F4B8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+arg_C]	; Load Effective Address
push	ax
lea	ax, [bp+arg_8]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F4B8:		; CODE XREF: sub_4F44D+5Aj
mov	ax, [bp+arg_A]
cmp	ax, [bp+arg_E]	; Compare Two Operands
jle	short loc_4F4CF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+arg_E]	; Load Effective Address
push	ax
lea	ax, [bp+arg_A]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F4CF:		; CODE XREF: sub_4F44D+71j
mov	ax, [bp+arg_10]
cmp	ax, [bp+arg_14]	; Compare Two Operands
jle	short loc_4F4E6	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+arg_14]	; Load Effective Address
push	ax
lea	ax, [bp+arg_10]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F4E6:		; CODE XREF: sub_4F44D+88j
mov	ax, [bp+arg_12]
cmp	ax, [bp+arg_16]	; Compare Two Operands
jle	short loc_4F4FD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+arg_16]	; Load Effective Address
push	ax
lea	ax, [bp+arg_12]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F4FD:		; CODE XREF: sub_4F44D+9Fj
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[idk_AddrEmsHandle]
call	DOS_MapMemory	; DOS -	LIM EMS	- MAP MEMORY
			;   argEmsHandle
			;   argEmsPageNumber
pop	cx
pop	cx
mov	ax, [EMM_PageFrameSegmentAddress]
mov	[bp+var_6], ax
push	[idk_LBX_w37EBE]
call	idk_LoadSw10_StoreSw14 ; Call Procedure
pop	cx
mov	ax, 0C35h
push	ax
push	[idk_LBX_w37EBE]
call	sub_14AF8	; Call Procedure
pop	cx
pop	cx
mov	di, ax
mov	ax, [bp+arg_E]
sub	ax, [bp+arg_A]	; Integer Subtraction
mov	dx, [bp+arg_C]
sub	dx, [bp+arg_8]	; Integer Subtraction
imul	dx		; Signed Multiply
add	ax, 32		; Add
mov	[bp+var_14], ax
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_8]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	ax, [bp+arg_E]
sub	ax, [bp+arg_A]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_2], ax
push	di
push	[bp+var_2]
push	[bp+var_4]
call	hrmStoreSWSB	; Call Procedure
add	sp, 6		; Add
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_8]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_16], ax
mov	ax, [bp+arg_E]
sub	ax, [bp+arg_A]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_18], ax
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
push	[bp+arg_E]
push	[bp+arg_C]
push	[bp+arg_A]
push	[bp+arg_8]
mov	ax, di
inc	ax		; Increment by 1
push	ax
call	_idk_EGA_s1E04D	; Call Procedure
add	sp, 0Ah		; Add
push	[bp+var_14]	; int
push	di		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	[bp+var_6]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ah		; Add
call	sub_1E525	; Call Procedure
call	sub_1E65C	; Call Procedure
call	j_@filebuf@terminate$qv_0 ; filebuf::terminate(void)
xor	si, si		; Logical Exclusive OR
jmp	loc_4F79B	; Jump

loc_4F5BD:		; CODE XREF: sub_4F44D+353j
call	_f020105_bios_timeofday	; Call Procedure
call	sub_1E69F	; Call Procedure
mov	ax, [bp+arg_8]
sub	ax, [bp+arg_10]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_10]	; Add
mov	[bp+var_C], ax
mov	ax, [bp+arg_A]
sub	ax, [bp+arg_12]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_12]	; Add
mov	[bp+var_E], ax
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_14]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_14]	; Add
mov	[bp+var_10], ax
mov	ax, [bp+arg_E]
sub	ax, [bp+arg_16]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_16]	; Add
mov	[bp+var_12], ax
mov	ax, [bp+var_C]
cmp	ax, [bp+var_10]	; Compare Two Operands
jle	short loc_4F62E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+var_10]	; Load Effective Address
push	ax
lea	ax, [bp+var_C]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F62E:		; CODE XREF: sub_4F44D+1D0j
mov	ax, [bp+var_E]
cmp	ax, [bp+var_12]	; Compare Two Operands
jle	short loc_4F645	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+var_12]	; Load Effective Address
push	ax
lea	ax, [bp+var_E]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F645:		; CODE XREF: sub_4F44D+1E7j
mov	ax, [bp+var_10]
sub	ax, [bp+var_C]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	ax, [bp+var_12]
sub	ax, [bp+var_E]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_2], ax
mov	ax, [bp+var_4]
mov	dx, 100
imul	dx		; Signed Multiply
xor	dx, dx		; Logical Exclusive OR
div	[bp+var_16]	; Unsigned Divide
mov	[bp+var_8], ax
mov	ax, [bp+var_2]
mov	dx, 100
imul	dx		; Signed Multiply
xor	dx, dx		; Logical Exclusive OR
div	[bp+var_18]	; Unsigned Divide
mov	[bp+var_A], ax
push	[bp+var_A]
push	[bp+var_8]
push	di
call	sub_21829	; Call Procedure
add	sp, 6		; Add
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, [bp+arg_0]
sub	ax, [bp+arg_10]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_10]	; Add
mov	[bp+var_C], ax
mov	ax, [bp+arg_2]
sub	ax, [bp+arg_12]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_12]	; Add
mov	[bp+var_E], ax
mov	ax, [bp+arg_4]
sub	ax, [bp+arg_14]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_14]	; Add
mov	[bp+var_10], ax
mov	ax, [bp+arg_6]
sub	ax, [bp+arg_16]	; Integer Subtraction
imul	si		; Signed Multiply
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_16]	; Add
mov	[bp+var_12], ax
mov	ax, [bp+var_C]
cmp	ax, [bp+var_10]	; Compare Two Operands
jle	short loc_4F6F4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+var_10]	; Load Effective Address
push	ax
lea	ax, [bp+var_C]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F6F4:		; CODE XREF: sub_4F44D+296j
mov	ax, [bp+var_E]
cmp	ax, [bp+var_12]	; Compare Two Operands
jle	short loc_4F70B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
lea	ax, [bp+var_12]	; Load Effective Address
push	ax
lea	ax, [bp+var_E]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F70B:		; CODE XREF: sub_4F44D+2ADj
mov	ax, [bp+var_10]
sub	ax, [bp+var_C]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	ax, [bp+var_12]
sub	ax, [bp+var_E]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_2], ax
or	si, si		; Logical Inclusive OR
jz	short loc_4F762	; Jump if Zero (ZF=1)
cmp	[FLAG_w3AD5E], 0 ; Compare Two Operands
jz	short loc_4F762	; Jump if Zero (ZF=1)
mov	ax, 186
push	ax
mov	ax, 187
push	ax
mov	ax, 186
push	ax
mov	ax, 185
push	ax
mov	ax, 181
push	ax
mov	ax, 180
push	ax
push	[bp+var_12]
push	[bp+var_10]
push	[bp+var_E]
push	[bp+var_C]
push	[bp+arg_16]
push	[bp+arg_14]
push	[bp+arg_12]
push	[bp+arg_10]
nop			; No Operation
push	cs
call	near ptr sub_4F808 ; Call Procedure
add	sp, 28		; Add

loc_4F762:		; CODE XREF: sub_4F44D+2D4j
			; sub_4F44D+2DBj
push	di
push	[bp+var_E]
push	[bp+var_C]
call	sub_21014	; Call Procedure
add	sp, 6		; Add
call	sub_2E303	; Call Procedure
cmp	si, 4		; Compare Two Operands
jz	short loc_4F790	; Jump if Zero (ZF=1)
push	[bp+var_14]	; int
push	[bp+var_6]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	di		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ah		; Add

loc_4F790:		; CODE XREF: sub_4F44D+32Cj
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
inc	si		; Increment by 1

loc_4F79B:		; CODE XREF: sub_4F44D+16Dj
cmp	si, 5		; Compare Two Operands
jge	short loc_4F7A3	; Jump if Greater or Equal (SF=OF)
jmp	loc_4F5BD	; Jump

loc_4F7A3:		; CODE XREF: sub_4F44D+351j
push	[idk_LBX_w37EBE]
call	idk_LoadSw14_StoreSw10 ; Call Procedure
pop	cx

loc_4F7AD:		; CODE XREF: sub_4F44D+4Cj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4F44D



; Attributes: bp-based frame

proc sub_4F7B3 far	; CODE XREF: sub_31B00J
push	bp
mov	bp, sp
cmp	[FLAG_w3AD5E], 0 ; Compare Two Operands
jnz	short loc_4F7C1	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_4F806	; Jump

loc_4F7C1:		; CODE XREF: sub_4F7B3+8j
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
mov	ax, 0BAh ; ''
push	ax
mov	ax, 0BBh ; ''
push	ax
mov	ax, 0BAh ; ''
push	ax
mov	ax, 0B9h ; ''
push	ax
mov	ax, 0B5h ; ''
push	ax
mov	ax, 0B4h ; ''
push	ax
push	[word_3AD68]
push	[word_3AD6A]
push	[word_3AD6C]
push	[word_3AD6E]
push	[word_3AD60]
push	[word_3AD62]
push	[word_3AD64]
push	[word_3AD66]
nop			; No Operation
push	cs
call	near ptr sub_4F808 ; Call Procedure
add	sp, 1Ch		; Add

loc_4F806:		; CODE XREF: sub_4F7B3+Cj
pop	bp
retf			; Return Far from Procedure
endp sub_4F7B3



; Attributes: bp-based frame

proc sub_4F808 far	; CODE XREF: sub_31B05J
			; sub_4F44D+30Fp
			; sub_4F7B3+4Dp

var_AE=	word ptr -0AEh
var_A2=	word ptr -0A2h
var_72=	word ptr -72h
var_4E=	word ptr -4Eh
var_42=	word ptr -42h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh
arg_1A=	word ptr  20h

push	bp
mov	bp, sp
sub	sp, 0A2h	; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_0]
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
call	sub_1CC35	; Call Procedure
mov	[bp+var_10], dx
mov	[bp+var_12], ax
mov	ax, 1
mov	dx, offset unk_3A5FD
push	ax
push	dx
call	sub_1CC24	; Call Procedure
pop	cx
pop	cx
mov	[bp+var_A], 0
jmp	loc_4F941	; Jump

loc_4F83B:		; CODE XREF: sub_4F808+13Fj
mov	[bp+var_C], 0
jmp	loc_4F935	; Jump

loc_4F843:		; CODE XREF: sub_4F808+133j
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4F87F	; Jump if Not Zero (ZF=0)
lea	ax, [bp+arg_10]	; Load Effective Address
push	ax
lea	ax, [bp+arg_12]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+arg_14]	; Load Effective Address
push	ax
lea	ax, [bp+arg_16]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx
lea	ax, [bp+arg_18]	; Load Effective Address
push	ax
lea	ax, [bp+arg_1A]	; Load Effective Address
push	ax
call	sub_1CFBD	; Call Procedure
pop	cx
pop	cx

loc_4F87F:		; CODE XREF: sub_4F808+48j
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4F8A4	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, [bp+var_C]	; Add
lea	dx, [bp+var_A2]	; Load Effective Address
add	ax, dx		; Add
mov	dl, [byte ptr bp+arg_12]
jmp	short loc_4F8B8	; Jump

loc_4F8A4:		; CODE XREF: sub_4F808+84j
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, [bp+var_C]	; Add
lea	dx, [bp+var_A2]	; Load Effective Address
add	ax, dx		; Add
mov	dl, [byte ptr bp+arg_10]

loc_4F8B8:		; CODE XREF: sub_4F808+9Aj
mov	bx, ax
mov	[bx], dl
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4F8E0	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, [bp+var_C]	; Add
lea	dx, [bp+var_72]	; Load Effective Address
add	ax, dx		; Add
mov	dl, [byte ptr bp+arg_16]
jmp	short loc_4F8F3	; Jump

loc_4F8E0:		; CODE XREF: sub_4F808+C1j
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, [bp+var_C]	; Add
lea	dx, [bp+var_72]	; Load Effective Address
add	ax, dx		; Add
mov	dl, [byte ptr bp+arg_14]

loc_4F8F3:		; CODE XREF: sub_4F808+D6j
mov	bx, ax
mov	[bx], dl
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_4F91B	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, [bp+var_C]	; Add
lea	dx, [bp+var_42]	; Load Effective Address
add	ax, dx		; Add
mov	dl, [byte ptr bp+arg_1A]
jmp	short loc_4F92E	; Jump

loc_4F91B:		; CODE XREF: sub_4F808+FCj
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, [bp+var_C]	; Add
lea	dx, [bp+var_42]	; Load Effective Address
add	ax, dx		; Add
mov	dl, [byte ptr bp+arg_18]

loc_4F92E:		; CODE XREF: sub_4F808+111j
mov	bx, ax
mov	[bx], dl
inc	[bp+var_C]	; Increment by 1

loc_4F935:		; CODE XREF: sub_4F808+38j
cmp	[bp+var_C], 0Ch	; Compare Two Operands
jge	short loc_4F93E	; Jump if Greater or Equal (SF=OF)
jmp	loc_4F843	; Jump

loc_4F93E:		; CODE XREF: sub_4F808+131j
inc	[bp+var_A]	; Increment by 1

loc_4F941:		; CODE XREF: sub_4F808+30j
cmp	[bp+var_A], 4	; Compare Two Operands
jge	short loc_4F94A	; Jump if Greater or Equal (SF=OF)
jmp	loc_4F83B	; Jump

loc_4F94A:		; CODE XREF: sub_4F808+13Dj
mov	ax, [bp+arg_2]
cmp	ax, [bp+arg_A]	; Compare Two Operands
jl	short loc_4F955	; Jump if Less (SF!=OF)
jmp	loc_4FCAB	; Jump

loc_4F955:		; CODE XREF: sub_4F808+148j
cmp	di, [bp+arg_8]	; Compare Two Operands
jl	short loc_4F95D	; Jump if Less (SF!=OF)
jmp	loc_4FA78	; Jump

loc_4F95D:		; CODE XREF: sub_4F808+150j
mov	si, di
jmp	loc_4FA6D	; Jump

loc_4F962:		; CODE XREF: sub_4F808+26Aj
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	dx, [bp+arg_A]
sub	dx, [bp+arg_2]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_2]	; Add
mov	[bp+var_4], ax
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	dx, [bp+arg_E]
sub	dx, [bp+arg_6]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_6]	; Add
mov	[bp+var_8], ax
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, si
sub	dx, di		; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_4]	; Add
mov	[bp+var_6], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_4]
push	[bp+var_6]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_8]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	si
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_4]
push	[bp+var_6]
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
add	si, 2		; Add

loc_4FA6D:		; CODE XREF: sub_4F808+157j
cmp	si, [bp+arg_8]	; Compare Two Operands
jge	short loc_4FA75	; Jump if Greater or Equal (SF=OF)
jmp	loc_4F962	; Jump

loc_4FA75:		; CODE XREF: sub_4F808+268j
jmp	loc_4FCA8	; Jump

loc_4FA78:		; CODE XREF: sub_4F808+152j
mov	ax, [bp+arg_4]
cmp	ax, [bp+arg_C]	; Compare Two Operands
jg	short loc_4FA83	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4FBAA	; Jump

loc_4FA83:		; CODE XREF: sub_4F808+276j
mov	ax, [bp+arg_4]
add	ax, 0FFFEh	; Add
mov	si, ax
jmp	loc_4FB9F	; Jump

loc_4FA8E:		; CODE XREF: sub_4F808+39Cj
mov	ax, si
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, [bp+arg_A]
sub	dx, [bp+arg_2]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_2]	; Add
mov	[bp+var_4], ax
mov	ax, si
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, [bp+arg_E]
sub	dx, [bp+arg_6]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_6]	; Add
mov	[bp+var_8], ax
mov	ax, [bp+arg_8]
sub	ax, di		; Integer Subtraction
mov	dx, si
sub	dx, [bp+arg_4]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, di		; Add
mov	[bp+var_2], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_2]
push	[bp+var_4]
push	[bp+var_2]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	si
push	[bp+var_8]
push	[bp+var_2]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_2]
push	[bp+var_4]
push	[bp+var_2]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	si
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
sub	si, 2		; Integer Subtraction

loc_4FB9F:		; CODE XREF: sub_4F808+283j
cmp	si, [bp+arg_C]	; Compare Two Operands
jle	short loc_4FBA7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4FA8E	; Jump

loc_4FBA7:		; CODE XREF: sub_4F808+39Aj
jmp	loc_4FCA8	; Jump

loc_4FBAA:		; CODE XREF: sub_4F808+278j
mov	ax, [bp+arg_2]
mov	[bp+var_E], ax
jmp	loc_4FC9D	; Jump

loc_4FBB3:		; CODE XREF: sub_4F808+49Dj
mov	ax, [bp+var_E]
sub	ax, [bp+arg_2]	; Integer Subtraction
mov	dx, [bp+arg_8]
sub	dx, di		; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_A]
sub	bx, [bp+arg_2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, di		; Add
mov	[bp+var_2], ax
mov	ax, [bp+var_E]
sub	ax, [bp+arg_2]	; Integer Subtraction
mov	dx, [bp+arg_C]
sub	dx, [bp+arg_4]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_A]
sub	bx, [bp+arg_2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_4]	; Add
mov	[bp+var_6], ax
mov	ax, [bp+arg_E]
sub	ax, [bp+arg_6]	; Integer Subtraction
mov	dx, [bp+var_E]
sub	dx, [bp+arg_2]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_A]
sub	bx, [bp+arg_2]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_6]	; Add
mov	[bp+var_8], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_2]
push	[bp+var_E]
push	[bp+var_2]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_E]
push	[bp+var_6]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_E]
push	[bp+var_6]
push	[bp+var_E]
push	[bp+var_2]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
add	[bp+var_E], 2	; Add

loc_4FC9D:		; CODE XREF: sub_4F808+3A8j
mov	ax, [bp+var_E]
cmp	ax, [bp+arg_A]	; Compare Two Operands
jge	short loc_4FCA8	; Jump if Greater or Equal (SF=OF)
jmp	loc_4FBB3	; Jump

loc_4FCA8:		; CODE XREF: sub_4F808:loc_4FA75j
			; sub_4F808:loc_4FBA7j
			; sub_4F808+49Bj
jmp	loc_501F0	; Jump

loc_4FCAB:		; CODE XREF: sub_4F808+14Aj
mov	ax, [bp+arg_6]
cmp	ax, [bp+arg_E]	; Compare Two Operands
jg	short loc_4FCB6	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_50007	; Jump

loc_4FCB6:		; CODE XREF: sub_4F808+4A9j
cmp	di, [bp+arg_8]	; Compare Two Operands
jl	short loc_4FCBE	; Jump if Less (SF!=OF)
jmp	loc_4FDD9	; Jump

loc_4FCBE:		; CODE XREF: sub_4F808+4B1j
mov	si, di
jmp	loc_4FDCE	; Jump

loc_4FCC3:		; CODE XREF: sub_4F808+5CBj
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	dx, [bp+arg_A]
sub	dx, [bp+arg_2]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_2]	; Add
mov	[bp+var_4], ax
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	dx, [bp+arg_E]
sub	dx, [bp+arg_6]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_6]	; Add
mov	[bp+var_8], ax
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, si
sub	dx, di		; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_4]	; Add
mov	[bp+var_6], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_4]
push	[bp+var_6]
call	sub_18903	; Call Procedure

loc_4FD3E:		; Add
add	sp, 0Eh
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax

loc_4FD48:
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_4]
push	[bp+var_6]
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax

loc_4FD76:
mov	ax, 4

loc_4FD79:
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	si
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax

loc_4FDA3:
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx

loc_4FDAD:
mov	dx, 0Ch

loc_4FDB0:		; Signed Multiply
imul	dx
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax

loc_4FDB9:
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_8]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
add	si, 2		; Add

loc_4FDCE:		; CODE XREF: sub_4F808+4B8j
cmp	si, [bp+arg_8]	; Compare Two Operands
jge	short loc_4FDD6	; Jump if Greater or Equal (SF=OF)
jmp	loc_4FCC3	; Jump

loc_4FDD6:		; CODE XREF: sub_4F808+5C9j
jmp	loc_50004	; Jump

loc_4FDD9:		; CODE XREF: sub_4F808+4B3j
mov	ax, [bp+arg_4]
cmp	ax, [bp+arg_C]	; Compare Two Operands
jg	short loc_4FDE4	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_4FF03	; Jump

loc_4FDE4:		; CODE XREF: sub_4F808+5D7j
mov	ax, [bp+arg_4]

loc_4FDE7:		; Add
add	ax, 0FFFEh
mov	si, ax
jmp	loc_4FEF8	; Jump

loc_4FDEF:		; CODE XREF: sub_4F808+6F5j
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	dx, [bp+arg_A]
sub	dx, [bp+arg_2]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]

loc_4FDFE:		; Integer Subtraction
sub	bx, di
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_2]	; Add
mov	[bp+var_4], ax
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	dx, [bp+arg_E]

loc_4FE10:		; Integer Subtraction
sub	dx, [bp+arg_6]

loc_4FE13:		; Signed Multiply
imul	dx
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_6]	; Add

loc_4FE20:
mov	[bp+var_8], ax

loc_4FE23:
mov	ax, [bp+arg_8]
sub	ax, di		; Integer Subtraction

loc_4FE28:
mov	dx, si

loc_4FE2A:		; Integer Subtraction
sub	dx, [bp+arg_4]

loc_4FE2D:		; Signed Multiply
imul	dx

loc_4FE2F:
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, di		; Add
mov	[bp+var_2], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_2]
push	[bp+var_4]
push	[bp+var_2]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR

loc_4FE6F:
push	ax

loc_4FE70:
mov	ax, 0Ch

loc_4FE73:
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch

loc_4FE81:		; Signed Multiply
imul	dx
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_4]
push	si
push	[bp+var_4]
push	[bp+var_2]

loc_4FE93:		; Call Procedure
call	sub_18903

loc_4FE98:		; Add
add	sp, 0Eh
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_4FE9E:
mov	ax, 0Ch

loc_4FEA1:
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_4]
push	si
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address

loc_4FEE2:		; Add
add	ax, dx
push	ax
push	[bp+var_8]
push	si
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
sub	si, 2		; Integer Subtraction

loc_4FEF8:		; CODE XREF: sub_4F808+5E4j
cmp	si, [bp+arg_C]	; Compare Two Operands
jle	short loc_4FF00	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4FDEF	; Jump

loc_4FF00:		; CODE XREF: sub_4F808+6F3j
jmp	loc_50004	; Jump

loc_4FF03:		; CODE XREF: sub_4F808+5D9j
mov	ax, [bp+arg_6]
add	ax, 0FFFEh	; Add
mov	[bp+var_E], ax
jmp	loc_4FFF9	; Jump

loc_4FF0F:		; CODE XREF: sub_4F808+7F9j
mov	ax, [bp+var_E]
sub	ax, [bp+arg_6]	; Integer Subtraction
mov	dx, [bp+arg_8]
sub	dx, di		; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_E]
sub	bx, [bp+arg_6]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, di		; Add
mov	[bp+var_2], ax
mov	ax, [bp+var_E]
sub	ax, [bp+arg_6]	; Integer Subtraction
mov	dx, [bp+arg_C]
sub	dx, [bp+arg_4]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_E]
sub	bx, [bp+arg_6]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_4]	; Add
mov	[bp+var_6], ax
mov	ax, [bp+arg_A]
sub	ax, [bp+arg_2]	; Integer Subtraction
mov	dx, [bp+var_E]
sub	dx, [bp+arg_6]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_E]
sub	bx, [bp+arg_6]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_2]	; Add
mov	[bp+var_4], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_E]
push	[bp+var_2]
push	[bp+var_4]
push	[bp+var_2]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_E]
push	[bp+var_6]
push	[bp+var_4]
push	[bp+var_6]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_E]
push	[bp+var_6]
push	[bp+var_E]
push	[bp+var_2]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
sub	[bp+var_E], 2	; Integer Subtraction

loc_4FFF9:		; CODE XREF: sub_4F808+704j
mov	ax, [bp+var_E]

loc_4FFFC:		; Compare Two Operands
cmp	ax, [bp+arg_E]
jle	short loc_50004	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_4FF0F	; Jump

loc_50004:		; CODE XREF: sub_4F808:loc_4FDD6j
			; sub_4F808:loc_4FF00j
			; sub_4F808+7F7j
jmp	loc_501F0	; Jump

loc_50007:		; CODE XREF: sub_4F808+4ABj
cmp	di, [bp+arg_8]	; Compare Two Operands
jl	short loc_5000F	; Jump if Less (SF!=OF)
jmp	loc_500F9	; Jump

loc_5000F:		; CODE XREF: sub_4F808+802j
mov	si, di
jmp	loc_500EE	; Jump

loc_50014:		; CODE XREF: sub_4F808+8EBj
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	dx, [bp+arg_A]
sub	dx, [bp+arg_2]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_2]	; Add
mov	[bp+var_4], ax
mov	ax, si
sub	ax, di		; Integer Subtraction
mov	dx, [bp+arg_E]
sub	dx, [bp+arg_6]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_6]	; Add
mov	[bp+var_8], ax
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, si
sub	dx, di		; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_8]
sub	bx, di		; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_4]	; Add
mov	[bp+var_6], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4

loc_5006C:
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_4]
push	[bp+var_6]
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_8]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	si
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
add	si, 2		; Add

loc_500EE:		; CODE XREF: sub_4F808+809j
cmp	si, [bp+arg_8]	; Compare Two Operands
jge	short loc_500F6	; Jump if Greater or Equal (SF=OF)
jmp	loc_50014	; Jump

loc_500F6:		; CODE XREF: sub_4F808+8E9j
jmp	loc_501F0	; Jump

loc_500F9:		; CODE XREF: sub_4F808+804j
mov	ax, [bp+arg_4]
add	ax, 0FFFEh	; Add
mov	si, ax
jmp	loc_501E8	; Jump

loc_50104:		; CODE XREF: sub_4F808+9E5j
mov	ax, si
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, [bp+arg_A]
sub	dx, [bp+arg_2]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_2]	; Add
mov	[bp+var_4], ax
mov	ax, si
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, [bp+arg_E]
sub	dx, [bp+arg_6]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_6]	; Add
mov	[bp+var_8], ax
mov	ax, [bp+arg_C]
sub	ax, [bp+arg_4]	; Integer Subtraction
mov	dx, si
sub	dx, [bp+arg_4]	; Integer Subtraction
imul	dx		; Signed Multiply
mov	bx, [bp+arg_C]
sub	bx, [bp+arg_4]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
add	ax, [bp+arg_4]	; Add
mov	[bp+var_6], ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_4]
push	[bp+var_6]
push	[bp+var_4]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_4E]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_8]
push	si
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Ch
push	ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	dx, 0Ch
imul	dx		; Signed Multiply
lea	dx, [bp+var_AE]	; Load Effective Address
add	ax, dx		; Add
push	ax
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_4]
push	[bp+var_6]
call	sub_18903	; Call Procedure
add	sp, 0Eh		; Add
sub	si, 2		; Integer Subtraction

loc_501E8:		; CODE XREF: sub_4F808+8F9j
cmp	si, [bp+arg_C]	; Compare Two Operands
jle	short loc_501F0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_50104	; Jump

loc_501F0:		; CODE XREF: sub_4F808:loc_4FCA8j
			; sub_4F808:loc_50004j
			; sub_4F808:loc_500F6j
			; sub_4F808+9E3j
push	[bp+var_10]
push	[bp+var_12]
call	sub_1CC24	; Call Procedure
pop	cx
pop	cx
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_4F808



; Attributes: bp-based frame

proc sub_50203 far	; CODE XREF: sub_31B0AJ

var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
argOffset= dword ptr  0Ah
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 0Ch		; Integer Subtraction
push	si
push	di		; arg2_SI
mov	si, [word ptr bp+argOffset+2]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_4], ax
mov	ax, 2
push	ax
push	[word ptr bp+argOffset]	; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_2], ax
mov	ax, [bp+var_4]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+arg_0]
sub	dx, ax		; Integer Subtraction
mov	di, dx
mov	ax, [bp+arg_2]
sub	ax, [bp+var_2]	; Integer Subtraction
mov	[bp+var_6], ax
mov	ax, di
add	ax, [bp+var_4]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
mov	ax, [bp+var_6]
add	ax, [bp+var_2]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_A], ax
cmp	di, 5		; Compare Two Operands
jge	short loc_50270	; Jump if Greater or Equal (SF=OF)
mov	di, 5
mov	ax, [bp+var_4]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
add	ax, 4		; Add
mov	[bp+var_8], ax

loc_50270:		; CODE XREF: sub_50203+5Aj
cmp	[bp+var_6], 5	; Compare Two Operands
jge	short loc_50289	; Jump if Greater or Equal (SF=OF)
mov	[bp+var_6], 5
mov	ax, [bp+var_2]
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
add	ax, 4		; Add
mov	[bp+var_A], ax

loc_50289:		; CODE XREF: sub_50203+71j
cmp	[bp+var_8], 13Bh ; Compare Two Operands
jle	short loc_5029E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_8], 13Bh
mov	ax, 13Bh
sub	ax, [bp+var_4]	; Integer Subtraction
inc	ax		; Increment by 1
mov	di, ax

loc_5029E:		; CODE XREF: sub_50203+8Bj
cmp	[bp+var_A], 13Bh ; Compare Two Operands
jle	short loc_502B4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_A], 13Bh
mov	ax, 13Bh
sub	ax, [bp+var_2]	; Integer Subtraction
inc	ax		; Increment by 1
mov	[bp+var_6], ax

loc_502B4:		; CODE XREF: sub_50203+A0j
cmp	[word_3523E], si ; Compare Two Operands
jle	short loc_502BE	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[word_3523E], si

loc_502BE:		; CODE XREF: sub_50203+B5j
cmp	[word_3523E], si ; Compare Two Operands
jnz	short loc_502D3	; Jump if Not Zero (ZF=0)
mov	bx, [bp+arg_8]
mov	[bx], di
mov	bx, [bp+arg_A]
mov	ax, [bp+var_6]
mov	[bx], ax
jmp	short loc_50341	; Jump

loc_502D3:		; CODE XREF: sub_50203+BFj
mov	ax, si
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, [word_3523E]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, di
sub	ax, [bp+arg_0]	; Integer Subtraction
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
add	ax, [bp+arg_0]	; Add
mov	bx, [bp+arg_8]
mov	[bx], ax
mov	ax, si
cwd			; AX ->	DX:AX (with sign)
push	dx
push	ax
mov	ax, [word_3523E]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_6]
sub	ax, [bp+arg_2]	; Integer Subtraction
push	dx
cwd			; AX ->	DX:AX (with sign)
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
add	ax, [bp+arg_2]	; Add
mov	bx, [bp+arg_A]
mov	[bx], ax
mov	ax, [word_3523E]
mov	dx, 64h	; 'd'
imul	dx		; Signed Multiply
cwd			; AX ->	DX:AX (with sign)
idiv	si		; Signed Divide
mov	[bp+var_C], ax
push	[bp+var_C]
push	[bp+var_C]
push	[word ptr bp+argOffset]
call	sub_21829	; Call Procedure
add	sp, 6		; Add

loc_50341:		; CODE XREF: sub_50203+CEj
inc	[word_3523E]	; Increment by 1
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_50203



; Attributes: bp-based frame

proc sub_5034B far	; CODE XREF: sub_31B0FJ
push	bp
mov	bp, sp
mov	[word_3523E], 1
pop	bp
retf			; Return Far from Procedure
endp sub_5034B



; Attributes: bp-based frame

proc sub_50356 far	; CODE XREF: sub_31B14J
			; sub_4D5B0:loc_4D5CDp
			; sub_4D8FA+Cp
			; sub_4DB4D+19p
			; idk_ResourceLbx+6p
push	bp
mov	bp, sp
push	si
call	sub_31CAA	; Call Procedure
mov	si, ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 8000h
push	ax
push	dx		; int
push	[idk_LBX_w37EBE] ; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	si		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ch		; Add
xor	ax, ax		; Logical Exclusive OR
mov	dx, 8000h
push	ax
push	dx		; int
mov	ax, [idk_LBX_w37EBE]
add	ax, 800h	; Add
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, si
add	ax, 800h	; Add
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ch		; Add
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_50356



; Attributes: bp-based frame

proc sub_503A0 far	; CODE XREF: sub_31B19J
			; sub_4D5B0:loc_4D793p
			; sub_4D8FA+100p
			; sub_4DB4D+4D6p
			; sub_4E9F4+20Fp
			; sub_4EF74+223p
push	bp
mov	bp, sp
push	si
call	sub_31CAA	; Call Procedure
mov	si, ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 8000h
push	ax
push	dx		; int
push	si		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	[idk_LBX_w37EBE] ; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ch		; Add
xor	ax, ax		; Logical Exclusive OR
mov	dx, 8000h
push	ax
push	dx		; int
mov	ax, si
add	ax, 800h	; Add
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, [idk_LBX_w37EBE]
add	ax, 800h	; Add
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ch		; Add
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_503A0

ends ovr053


; Segment type:	Pure code
segment	ovr054 para public 'OVERLAY' use16
assume cs:ovr054
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_503F0 far	; CODE XREF: sub_31B40J
			; sub_50E46+1EAp

var_AA=	word ptr -0AAh
var_A8=	word ptr -0A8h
var_A6=	word ptr -0A6h
var_A4=	word ptr -0A4h
var_A2=	word ptr -0A2h
var_9A=	word ptr -9Ah
var_98=	word ptr -98h
var_96=	word ptr -96h
var_94=	word ptr -94h
var_92=	word ptr -92h
var_8A=	word ptr -8Ah
var_88=	word ptr -88h
var_86=	word ptr -86h
var_7A=	word ptr -7Ah
var_78=	word ptr -78h
var_76=	word ptr -76h
var_6A=	word ptr -6Ah
var_68=	word ptr -68h
var_66=	word ptr -66h
var_5A=	word ptr -5Ah
var_58=	word ptr -58h
var_56=	word ptr -56h
var_4A=	word ptr -4Ah
var_48=	word ptr -48h
var_46=	word ptr -46h
var_44=	word ptr -44h
var_42=	word ptr -42h
var_3A=	word ptr -3Ah
var_38=	word ptr -38h
var_36=	word ptr -36h
var_34=	word ptr -34h
var_32=	word ptr -32h
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_17=	byte ptr -17h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h

push	bp

loc_503F1:
mov	bp, sp

loc_503F3:		; Integer Subtraction
sub	sp, 0AAh

loc_503F7:
push	si

loc_503F8:
push	di

loc_503F9:
mov	di, [bp+arg_8]

loc_503FC:
mov	ax, di

loc_503FE:		; Two's Complement Negation
neg	ax

loc_50400:		; Decrement by 1
dec	ax

loc_50401:
mov	[bp+var_2A], ax

loc_50404:
mov	ax, di

loc_50406:		; Two's Complement Negation
neg	ax

loc_50408:
mov	[bp+var_28], ax

loc_5040B:
mov	ax, di

loc_5040D:		; Two's Complement Negation
neg	ax

loc_5040F:		; Increment by 1
inc	ax

loc_50410:
mov	[bp+var_26], ax

loc_50413:
mov	[bp+var_24], 0FFFFh

loc_50418:
mov	[bp+var_22], 1

loc_5041D:
mov	ax, di

loc_5041F:		; Decrement by 1
dec	ax

loc_50420:
mov	[bp+var_20], ax

loc_50423:
mov	[bp+var_1E], di

loc_50426:
mov	ax, di
inc	ax		; Increment by 1

loc_50429:
mov	[bp+var_1C], ax

loc_5042C:
mov	ax, di

loc_5042E:		; Two's Complement Negation
neg	ax

loc_50430:
mov	[bp+var_3A], ax

loc_50433:
mov	ax, di

loc_50435:		; Two's Complement Negation
neg	ax
inc	ax		; Increment by 1

loc_50438:
mov	[bp+var_38], ax

loc_5043B:
mov	[bp+var_36], 1

loc_50440:
mov	[bp+var_34], di
mov	ax, di
inc	ax		; Increment by 1

loc_50446:
mov	[bp+var_32], ax
mov	ax, di

loc_5044B:		; Two's Complement Negation
neg	ax
dec	ax		; Decrement by 1

loc_5044E:
mov	[bp+var_4A], ax

loc_50451:
mov	ax, di

loc_50453:		; Two's Complement Negation
neg	ax

loc_50455:
mov	[bp+var_48], ax

loc_50458:
mov	[bp+var_46], 0FFFFh
mov	[bp+var_44], di

loc_50460:
mov	ax, di

loc_50462:		; Decrement by 1
dec	ax

loc_50463:
mov	[bp+var_42], ax

loc_50466:
mov	[bp+var_5A], 1
mov	[bp+var_58], di

loc_5046E:
mov	ax, di

loc_50470:		; Increment by 1
inc	ax
mov	[bp+var_56], ax
mov	[bp+var_6A], 0FFFFh

loc_50479:
mov	[bp+var_68], di

loc_5047C:
mov	ax, di
dec	ax		; Decrement by 1

loc_5047F:
mov	[bp+var_66], ax

loc_50482:
mov	[bp+var_7A], 1
mov	ax, di

loc_50489:		; Two's Complement Negation
neg	ax
mov	[bp+var_78], ax

loc_5048E:
mov	ax, di

loc_50490:		; Two's Complement Negation
neg	ax
inc	ax		; Increment by 1
mov	[bp+var_76], ax

loc_50496:
mov	[bp+var_8A], 0FFFFh
mov	ax, di

loc_5049E:		; Two's Complement Negation
neg	ax
mov	[bp+var_88], ax

loc_504A4:
mov	ax, di
neg	ax		; Two's Complement Negation
dec	ax		; Decrement by 1

loc_504A9:
mov	[bp+var_86], ax

loc_504AD:
mov	[bp+var_9A], 0FFFFh

loc_504B3:
mov	[bp+var_98], 1
mov	[bp+var_96], di

loc_504BD:
mov	ax, di
dec	ax		; Decrement by 1
mov	[bp+var_94], ax
mov	ax, di
inc	ax		; Increment by 1

loc_504C7:
mov	[bp+var_92], ax

loc_504CB:
mov	[bp+var_AA], 0FFFFh

loc_504D1:
mov	[bp+var_A8], 1

loc_504D7:
mov	ax, di
neg	ax		; Two's Complement Negation

loc_504DB:
mov	[bp+var_A6], ax

loc_504DF:
mov	ax, di

loc_504E1:		; Two's Complement Negation
neg	ax
dec	ax		; Decrement by 1

loc_504E4:
mov	[bp+var_A4], ax

loc_504E8:
mov	ax, di

loc_504EA:		; Two's Complement Negation
neg	ax
inc	ax		; Increment by 1

loc_504ED:
mov	[bp+var_A2], ax
mov	[bp+var_1A], 0
mov	ax, [bp+arg_6]
imul	di		; Signed Multiply
add	ax, [bp+arg_4]	; Add
add	ax, [bp+arg_C]	; Add
mov	bx, ax
cmp	[byte ptr bx], 0FFh ; Compare Two Operands
jnz	short loc_5050D	; Jump if Not Zero (ZF=0)

loc_50508:		; CODE XREF: sub_503F0+12Fj
			; sub_503F0+6D5j
xor	ax, ax		; Logical Exclusive OR

loc_5050A:		; CODE XREF: sub_503F0+71Dj
jmp	loc_50B10	; Jump

loc_5050D:		; CODE XREF: sub_503F0+116j
mov	ax, [bp+arg_2]
imul	di		; Signed Multiply
add	ax, [bp+arg_0]	; Add

loc_50515:		; Add
add	ax, [bp+arg_C]

loc_50518:
mov	bx, ax
cmp	[byte ptr bx], 0FFh ; Compare Two Operands
jnz	short loc_50521	; Jump if Not Zero (ZF=0)
jmp	short loc_50508	; Jump

loc_50521:		; CODE XREF: sub_503F0+12Dj
mov	ax, di
imul	[bp+arg_A]	; Signed Multiply
mov	[bp+var_16], ax
mov	[bp+var_2], 0

loc_5052E:		; Jump
jmp	short loc_5053F

loc_50530:		; CODE XREF: sub_503F0+155j
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_2]
mov	[bx-6D3Eh], ax
inc	[bp+var_2]	; Increment by 1

loc_5053F:		; CODE XREF: sub_503F0:loc_5052Ej
mov	ax, [bp+var_2]
cmp	ax, [bp+var_16]	; Compare Two Operands
jl	short loc_50530	; Jump if Less (SF!=OF)
mov	[bp+var_2], 0

loc_5054C:		; Jump
jmp	short loc_50559

loc_5054E:		; CODE XREF: sub_503F0+16Fj
mov	bx, [bp+var_2]

loc_50551:
mov	[byte ptr bx-6E20h], 0FFh

loc_50556:		; Increment by 1
inc	[bp+var_2]

loc_50559:		; CODE XREF: sub_503F0:loc_5054Cj
mov	ax, [bp+var_2]
cmp	ax, [bp+var_16]	; Compare Two Operands
jl	short loc_5054E	; Jump if Less (SF!=OF)
mov	ax, [bp+arg_2]
imul	di		; Signed Multiply
mov	bx, [bp+arg_0]
add	bx, ax		; Add
mov	[byte ptr bx-6E20h], 0

loc_50570:
mov	[bp+var_4], 1

loc_50575:		; Jump
jmp	loc_50A7D

loc_50578:		; CODE XREF: sub_503F0+693j
mov	[bp+var_4], 0
mov	ax, di
add	ax, 0FFFEh	; Add
mov	[bp+var_E], ax
mov	ax, [bp+arg_A]

loc_50588:		; Add
add	ax, 0FFFEh
mov	[bp+var_12], ax
xor	si, si		; Logical Exclusive OR
mov	bx, [bp+arg_C]
add	bx, si		; Add
mov	al, [bx]
mov	ah, 0

loc_50599:
mov	[bp+var_14], ax

loc_5059C:		; Compare Two Operands
cmp	[bp+var_14], 0FFh

loc_505A1:		; Jump if Zero (ZF=1)
jz	short loc_50611
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
mov	[bp+var_8], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_5060C	; Jump

loc_505B2:		; CODE XREF: sub_503F0:loc_5060Fj
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_5A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax

loc_505C2:
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_5060B	; Jump if Zero (ZF=1)

loc_505D5:
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add
mov	[bp+var_17], al
mov	al, [si-6E20h]
cmp	al, [bp+var_17]	; Compare Two Operands
jbe	short loc_5060B	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]

loc_505EE:
mov	[bx-6D3Eh], ax
mov	al, [bp+var_17]
mov	[si-6E20h], al

loc_505F9:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_505FD:
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands
jz	short loc_5060B	; Jump if Zero (ZF=1)

loc_50606:
mov	[bp+var_4], 1

loc_5060B:		; CODE XREF: sub_503F0+1E3j
			; sub_503F0+1F5j
			; sub_503F0+214j
inc	cx		; Increment by 1

loc_5060C:		; CODE XREF: sub_503F0+1C0j
cmp	cx, 3		; Compare Two Operands

loc_5060F:		; Jump if Less (SF!=OF)
jl	short loc_505B2

loc_50611:		; CODE XREF: sub_503F0:loc_505A1j
inc	si		; Increment by 1

loc_50612:
mov	[bp+var_C], 0
jmp	loc_506A0	; Jump

loc_5061A:		; CODE XREF: sub_503F0+2B8j
mov	bx, [bp+arg_C]
add	bx, si		; Add
mov	al, [bx]
mov	ah, 0
mov	[bp+var_14], ax
cmp	[bp+var_14], 0FFh ; Compare Two	Operands
jz	short loc_5069C	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]

loc_50635:
mov	[bp+var_8], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_50697	; Jump

loc_5063C:		; CODE XREF: sub_503F0+2AAj
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_9A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_50696	; Jump if Zero (ZF=1)
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add
mov	[bp+var_17], al
mov	al, [si-6E20h]

loc_5066D:		; Compare Two Operands
cmp	al, [bp+var_17]
jbe	short loc_50696	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]
mov	[bx-6D3Eh], ax
mov	al, [bp+var_17]
mov	[si-6E20h], al
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands
jz	short loc_50696	; Jump if Zero (ZF=1)
mov	[bp+var_4], 1

loc_50696:		; CODE XREF: sub_503F0+26Ej
			; sub_503F0+280j
			; sub_503F0+29Fj
inc	cx		; Increment by 1

loc_50697:		; CODE XREF: sub_503F0+24Aj
cmp	cx, 5		; Compare Two Operands
jl	short loc_5063C	; Jump if Less (SF!=OF)

loc_5069C:		; CODE XREF: sub_503F0+23Bj
inc	si		; Increment by 1
inc	[bp+var_C]	; Increment by 1

loc_506A0:		; CODE XREF: sub_503F0+227j
mov	ax, [bp+var_C]
cmp	ax, [bp+var_E]	; Compare Two Operands
jge	short loc_506AB	; Jump if Greater or Equal (SF=OF)
jmp	loc_5061A	; Jump

loc_506AB:		; CODE XREF: sub_503F0+2B6j
mov	bx, [bp+arg_C]

loc_506AE:		; Add
add	bx, si
mov	al, [bx]
mov	ah, 0
mov	[bp+var_14], ax
cmp	[bp+var_14], 0FFh ; Compare Two	Operands
jz	short loc_5072C	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
mov	[bp+var_8], ax

loc_506C9:		; Logical Exclusive OR
xor	cx, cx
jmp	short loc_50727	; Jump

loc_506CD:		; CODE XREF: sub_503F0+33Aj
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_6A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_50726	; Jump if Zero (ZF=1)

loc_506F0:
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add
mov	[bp+var_17], al

loc_506F9:
mov	al, [si-6E20h]
cmp	al, [bp+var_17]	; Compare Two Operands
jbe	short loc_50726	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_50706:
mov	ax, [bp+var_6]
mov	[bx-6D3Eh], ax
mov	al, [bp+var_17]

loc_50710:
mov	[si-6E20h], al

loc_50714:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands
jz	short loc_50726	; Jump if Zero (ZF=1)
mov	[bp+var_4], 1

loc_50726:		; CODE XREF: sub_503F0+2FEj
			; sub_503F0+310j
			; sub_503F0+32Fj
inc	cx		; Increment by 1

loc_50727:		; CODE XREF: sub_503F0+2DBj
cmp	cx, 3		; Compare Two Operands
jl	short loc_506CD	; Jump if Less (SF!=OF)

loc_5072C:		; CODE XREF: sub_503F0+2CCj
inc	si		; Increment by 1
mov	[bp+var_A], 0
jmp	loc_508D4	; Jump

loc_50735:		; CODE XREF: sub_503F0+4ECj
mov	bx, [bp+arg_C]

loc_50738:		; Add
add	bx, si
mov	al, [bx]
mov	ah, 0
mov	[bp+var_14], ax
cmp	[bp+var_14], 0FFh ; Compare Two	Operands
jz	short loc_507B6	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
mov	[bp+var_8], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_507B1	; Jump

loc_50757:		; CODE XREF: sub_503F0:loc_507B4j
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_3A]	; Load Effective Address
add	bx, ax		; Add

loc_50760:
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_507B0	; Jump if Zero (ZF=1)
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add

loc_50780:
mov	[bp+var_17], al

loc_50783:
mov	al, [si-6E20h]
cmp	al, [bp+var_17]	; Compare Two Operands
jbe	short loc_507B0	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]
mov	[bx-6D3Eh], ax
mov	al, [bp+var_17]
mov	[si-6E20h], al
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands
jz	short loc_507B0	; Jump if Zero (ZF=1)
mov	[bp+var_4], 1

loc_507B0:		; CODE XREF: sub_503F0+388j
			; sub_503F0+39Aj
			; sub_503F0+3B9j
inc	cx		; Increment by 1

loc_507B1:		; CODE XREF: sub_503F0+365j
cmp	cx, 5		; Compare Two Operands

loc_507B4:		; Jump if Less (SF!=OF)
jl	short loc_50757

loc_507B6:		; CODE XREF: sub_503F0+356j
inc	si		; Increment by 1
mov	[bp+var_C], 0

loc_507BC:		; Jump
jmp	loc_50844

loc_507BF:		; CODE XREF: sub_503F0+45Cj
mov	bx, [bp+arg_C]
add	bx, si		; Add
mov	al, [bx]
mov	ah, 0

loc_507C8:
mov	[bp+var_14], ax
cmp	[bp+var_14], 0FFh ; Compare Two	Operands
jz	short loc_50840	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_507D6:
mov	ax, [bx-6D3Eh]
mov	[bp+var_8], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_5083B	; Jump

loc_507E1:		; CODE XREF: sub_503F0+44Ej
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_2A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_5083A	; Jump if Zero (ZF=1)
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add
mov	[bp+var_17], al
mov	al, [si-6E20h]
cmp	al, [bp+var_17]	; Compare Two Operands
jbe	short loc_5083A	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]
mov	[bx-6D3Eh], ax
mov	al, [bp+var_17]
mov	[si-6E20h], al
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands
jz	short loc_5083A	; Jump if Zero (ZF=1)
mov	[bp+var_4], 1

loc_5083A:		; CODE XREF: sub_503F0+412j
			; sub_503F0+424j
			; sub_503F0+443j
inc	cx		; Increment by 1

loc_5083B:		; CODE XREF: sub_503F0+3EFj
cmp	cx, 8		; Compare Two Operands
jl	short loc_507E1	; Jump if Less (SF!=OF)

loc_50840:		; CODE XREF: sub_503F0+3E0j
inc	si		; Increment by 1
inc	[bp+var_C]	; Increment by 1

loc_50844:		; CODE XREF: sub_503F0:loc_507BCj
mov	ax, [bp+var_C]
cmp	ax, [bp+var_E]	; Compare Two Operands
jge	short loc_5084F	; Jump if Greater or Equal (SF=OF)
jmp	loc_507BF	; Jump

loc_5084F:		; CODE XREF: sub_503F0+45Aj
mov	bx, [bp+arg_C]
add	bx, si		; Add
mov	al, [bx]
mov	ah, 0
mov	[bp+var_14], ax

loc_5085B:		; Compare Two Operands
cmp	[bp+var_14], 0FFh
jz	short loc_508D0	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
mov	[bp+var_8], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_508CB	; Jump

loc_50871:		; CODE XREF: sub_503F0+4DEj
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_508CA	; Jump if Zero (ZF=1)
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add
mov	[bp+var_17], al
mov	al, [si-6E20h]
cmp	al, [bp+var_17]	; Compare Two Operands
jbe	short loc_508CA	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]
mov	[bx-6D3Eh], ax
mov	al, [bp+var_17]
mov	[si-6E20h], al

loc_508B8:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands
jz	short loc_508CA	; Jump if Zero (ZF=1)
mov	[bp+var_4], 1

loc_508CA:		; CODE XREF: sub_503F0+4A2j
			; sub_503F0+4B4j
			; sub_503F0+4D3j
inc	cx		; Increment by 1

loc_508CB:		; CODE XREF: sub_503F0+47Fj
cmp	cx, 5		; Compare Two Operands
jl	short loc_50871	; Jump if Less (SF!=OF)

loc_508D0:		; CODE XREF: sub_503F0+470j
inc	si		; Increment by 1
inc	[bp+var_A]	; Increment by 1

loc_508D4:		; CODE XREF: sub_503F0+342j
mov	ax, [bp+var_A]
cmp	ax, [bp+var_12]	; Compare Two Operands
jge	short loc_508DF	; Jump if Greater or Equal (SF=OF)
jmp	loc_50735	; Jump

loc_508DF:		; CODE XREF: sub_503F0+4EAj
mov	bx, [bp+arg_C]
add	bx, si		; Add
mov	al, [bx]
mov	ah, 0
mov	[bp+var_14], ax
cmp	[bp+var_14], 0FFh ; Compare Two	Operands
jz	short loc_50960	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
mov	[bp+var_8], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_5095B	; Jump

loc_50901:		; CODE XREF: sub_503F0+56Ej
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_7A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_5095A	; Jump if Zero (ZF=1)
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add
mov	[bp+var_17], al
mov	al, [si-6E20h]
cmp	al, [bp+var_17]	; Compare Two Operands
jbe	short loc_5095A	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]
mov	[bx-6D3Eh], ax
mov	al, [bp+var_17]
mov	[si-6E20h], al
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands
jz	short loc_5095A	; Jump if Zero (ZF=1)
mov	[bp+var_4], 1

loc_5095A:		; CODE XREF: sub_503F0+532j
			; sub_503F0+544j
			; sub_503F0+563j
inc	cx		; Increment by 1

loc_5095B:		; CODE XREF: sub_503F0+50Fj
cmp	cx, 3		; Compare Two Operands
jl	short loc_50901	; Jump if Less (SF!=OF)

loc_50960:		; CODE XREF: sub_503F0+500j
inc	si		; Increment by 1
mov	[bp+var_C], 0
jmp	loc_509EF	; Jump

loc_50969:		; CODE XREF: sub_503F0+607j
mov	bx, [bp+arg_C]
add	bx, si		; Add
mov	al, [bx]
mov	ah, 0
mov	[bp+var_14], ax
cmp	[bp+var_14], 0FFh ; Compare Two	Operands
jz	short loc_509EB	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
mov	[bp+var_8], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_509E6	; Jump

loc_5098B:		; CODE XREF: sub_503F0+5F9j
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_AA]	; Load Effective Address
add	bx, ax		; Add
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_509E5	; Jump if Zero (ZF=1)
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add
mov	[bp+var_17], al
mov	al, [si-6E20h]
cmp	al, [bp+var_17]	; Compare Two Operands
jbe	short loc_509E5	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]
mov	[bx-6D3Eh], ax

loc_509CC:
mov	al, [bp+var_17]
mov	[si-6E20h], al
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands
jz	short loc_509E5	; Jump if Zero (ZF=1)
mov	[bp+var_4], 1

loc_509E5:		; CODE XREF: sub_503F0+5BDj
			; sub_503F0+5CFj
			; sub_503F0+5EEj
inc	cx		; Increment by 1

loc_509E6:		; CODE XREF: sub_503F0+599j
cmp	cx, 5		; Compare Two Operands
jl	short loc_5098B	; Jump if Less (SF!=OF)

loc_509EB:		; CODE XREF: sub_503F0+58Aj
inc	si		; Increment by 1
inc	[bp+var_C]	; Increment by 1

loc_509EF:		; CODE XREF: sub_503F0+576j
mov	ax, [bp+var_C]
cmp	ax, [bp+var_E]	; Compare Two Operands
jge	short loc_509FA	; Jump if Greater or Equal (SF=OF)
jmp	loc_50969	; Jump

loc_509FA:		; CODE XREF: sub_503F0+605j
mov	bx, [bp+arg_C]
add	bx, si		; Add
mov	al, [bx]
mov	ah, 0
mov	[bp+var_14], ax
cmp	[bp+var_14], 0FFh ; Compare Two	Operands
jz	short loc_50A7C	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
mov	[bp+var_8], ax
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_50A77	; Jump

loc_50A1C:		; CODE XREF: sub_503F0+68Aj
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_8A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, si
add	ax, [bx]	; Add
mov	[bp+var_6], ax
mov	bx, [bp+var_6]
mov	al, [bx-6E20h]
mov	ah, 0
mov	[bp+var_10], ax
cmp	[bp+var_10], 0FFh ; Compare Two	Operands
jz	short loc_50A76	; Jump if Zero (ZF=1)
mov	al, [byte ptr bp+var_10]
add	al, [byte ptr bp+var_14] ; Add
mov	[bp+var_17], al
mov	al, [si-6E20h]
cmp	al, [bp+var_17]	; Compare Two Operands
jbe	short loc_50A76	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_6]
mov	[bx-6D3Eh], ax
mov	al, [bp+var_17]
mov	[si-6E20h], al
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6D3Eh]
cmp	ax, [bp+var_8]	; Compare Two Operands

loc_50A6F:		; Jump if Zero (ZF=1)
jz	short loc_50A76
mov	[bp+var_4], 1

loc_50A76:		; CODE XREF: sub_503F0+64Ej
			; sub_503F0+660j
			; sub_503F0:loc_50A6Fj
inc	cx		; Increment by 1

loc_50A77:		; CODE XREF: sub_503F0+62Aj
cmp	cx, 3		; Compare Two Operands
jl	short loc_50A1C	; Jump if Less (SF!=OF)

loc_50A7C:		; CODE XREF: sub_503F0+61Bj
inc	si		; Increment by 1

loc_50A7D:		; CODE XREF: sub_503F0:loc_50575j
cmp	[bp+var_4], 1	; Compare Two Operands
jnz	short loc_50A86	; Jump if Not Zero (ZF=0)
jmp	loc_50578	; Jump

loc_50A86:		; CODE XREF: sub_503F0+691j
mov	[bp+var_1A], 0
mov	ax, [bp+arg_6]
imul	di		; Signed Multiply
mov	dx, [bp+arg_4]
add	dx, ax		; Add
mov	si, dx
jmp	short loc_50AAD	; Jump

loc_50A99:		; CODE XREF: sub_503F0+6C5j
mov	bx, [bp+var_1A]
shl	bx, 1		; Shift	Logical	Left
mov	[bx-6EE8h], si
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	si, [bx-6D3Eh]
inc	[bp+var_1A]	; Increment by 1

loc_50AAD:		; CODE XREF: sub_503F0+6A7j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
cmp	[bx-6D3Eh], si	; Compare Two Operands
jnz	short loc_50A99	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_2]
imul	di		; Signed Multiply
mov	dx, [bp+arg_0]
add	dx, ax		; Add
cmp	dx, si		; Compare Two Operands
jz	short loc_50AC8	; Jump if Zero (ZF=1)
jmp	loc_50508	; Jump

loc_50AC8:		; CODE XREF: sub_503F0+6D3j
mov	[bp+var_2], 0
jmp	short loc_50B02	; Jump

loc_50ACF:		; CODE XREF: sub_503F0+718j
mov	bx, [bp+var_1A]
dec	bx		; Decrement by 1
sub	bx, [bp+var_2]	; Integer Subtraction
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6EE8h]
cwd			; AX ->	DX:AX (with sign)
idiv	di		; Signed Divide

loc_50ADF:
mov	bx, [bp+arg_E]
add	bx, [bp+var_2]	; Add
mov	[bx], dl
mov	bx, [bp+var_1A]
dec	bx		; Decrement by 1
sub	bx, [bp+var_2]	; Integer Subtraction
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-6EE8h]
cwd			; AX ->	DX:AX (with sign)
idiv	di		; Signed Divide
mov	bx, [bp+arg_10]
add	bx, [bp+var_2]	; Add
mov	[bx], al
inc	[bp+var_2]	; Increment by 1

loc_50B02:		; CODE XREF: sub_503F0+6DDj
mov	ax, [bp+var_2]
cmp	ax, [bp+var_1A]	; Compare Two Operands
jl	short loc_50ACF	; Jump if Less (SF!=OF)
mov	ax, [bp+var_1A]
jmp	loc_5050A	; Jump

loc_50B10:		; CODE XREF: sub_503F0:loc_5050Aj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_503F0



; Attributes: bp-based frame

proc sub_50B16 far	; CODE XREF: sub_31B45J

var_72=	word ptr -72h
var_70=	word ptr -70h
var_4E=	word ptr -4Eh
var_4C=	word ptr -4Ch
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_1E=	word ptr -1Eh
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= dword ptr  0Eh
arg_C= word ptr	 12h
arg_E= word ptr	 14h
arg_10=	word ptr  16h
arg_12=	word ptr  18h
arg_14=	word ptr  1Ah
arg_16=	word ptr  1Ch
arg_18=	word ptr  1Eh

push	bp
mov	bp, sp
sub	sp, 72h		; Integer Subtraction
push	si
push	di
add	[bp+arg_16], 6	; Add
mov	ax, [bp+arg_6]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_8]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+arg_4]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_50B3D	; Jump if Not Zero (ZF=0)

loc_50B38:		; CODE XREF: sub_50B16+124j
			; sub_50B16+1B1j
			; sub_50B16+20Aj
xor	ax, ax		; Logical Exclusive OR

loc_50B3A:		; CODE XREF: sub_50B16+CEj
			; sub_50B16+327j
jmp	loc_50E40	; Jump

loc_50B3D:		; CODE XREF: sub_50B16+20j
mov	ax, [bp+arg_0]
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_4], ax
mov	ax, [bp+arg_2]
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_6], ax
mov	ax, [bp+arg_4]
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_8], ax
mov	ax, [bp+arg_6]
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_A], ax
mov	ax, [bp+var_4]
cmp	ax, [bp+var_8]	; Compare Two Operands
jnz	short loc_50BE7	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_6]
cmp	ax, [bp+var_A]	; Compare Two Operands
jnz	short loc_50BE7	; Jump if Not Zero (ZF=0)
push	[word ptr bp+arg_8+2]
push	[word ptr bp+arg_8]
push	[bp+arg_12]
push	[bp+arg_10]
push	[bp+arg_6]
push	[bp+arg_4]
push	[bp+arg_2]
push	[bp+arg_0]
nop			; No Operation
push	cs
call	near ptr sub_50E46 ; Call Procedure
add	sp, 10h		; Add
mov	[bp+var_12], ax
cmp	[bp+var_12], 0	; Compare Two Operands
jz	short loc_50BE7	; Jump if Zero (ZF=1)
xor	di, di		; Logical Exclusive OR
jmp	short loc_50BDC	; Jump

loc_50BAA:		; CODE XREF: sub_50B16+C9j
mov	bx, [bp+arg_12]
add	bx, di		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_8]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	si, [bp+arg_10]

loc_50BBF:		; Add
add	si, di
mov	al, [si]
cbw			; AL ->	AX (with sign)
add	bx, ax		; Add
mov	al, [es:bx]
mov	bx, [bp+arg_14]
add	bx, di		; Add
mov	[bx], al
mov	bx, [bp+arg_14]
add	bx, di		; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
sub	[bp+arg_16], ax	; Integer Subtraction
inc	di		; Increment by 1

loc_50BDC:		; CODE XREF: sub_50B16+92j
cmp	di, [bp+var_12]	; Compare Two Operands
jl	short loc_50BAA	; Jump if Less (SF!=OF)
mov	ax, [bp+var_12]
jmp	loc_50B3A	; Jump

loc_50BE7:		; CODE XREF: sub_50B16+5Dj
			; sub_50B16+65j
			; sub_50B16+8Ej
cmp	[bp+arg_18], 1	; Compare Two Operands
jnz	short loc_50C0F	; Jump if Not Zero (ZF=0)
mov	ax, 0Ch

loc_50BF0:
push	ax
lea	ax, [bp+var_72]	; Load Effective Address
push	ax
lea	ax, [bp+var_4E]	; Load Effective Address
push	ax
push	[bp+var_A]
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_4]
call	sub_1D906	; Call Procedure
add	sp, 0Eh		; Add
jmp	short loc_50C31	; Jump

loc_50C0F:		; CODE XREF: sub_50B16+D5j
push	[bp+arg_E]
push	[bp+arg_C]
lea	ax, [bp+var_72]	; Load Effective Address
push	ax
lea	ax, [bp+var_4E]	; Load Effective Address
push	ax
push	[bp+var_A]
push	[bp+var_8]
push	[bp+var_6]
push	[bp+var_4]
nop			; No Operation
push	cs
call	near ptr sub_510F4 ; Call Procedure
add	sp, 10h		; Add

loc_50C31:		; CODE XREF: sub_50B16+F7j
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_50C3D	; Jump if Not Zero (ZF=0)
jmp	loc_50B38	; Jump

loc_50C3D:		; CODE XREF: sub_50B16+122j
mov	ax, [bp+arg_0]
mov	[bp+var_C], ax
mov	ax, [bp+arg_2]
mov	[bp+var_E], ax
mov	[bp+var_10], 0
mov	[bp+var_14], 0
jmp	loc_50E16	; Jump

loc_50C56:		; CODE XREF: sub_50B16+316j
			; sub_50B16+321j
mov	ax, [bp+var_2]
add	ax, 0FFFEh	; Add
cmp	ax, [bp+var_14]	; Compare Two Operands
jg	short loc_50C74	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [bp+arg_4]
mov	[bp+var_1E], ax
mov	ax, [bp+arg_6]
mov	[bp+var_28], ax
mov	[bp+var_2A], 1
jmp	short loc_50CC1	; Jump

loc_50C74:		; CODE XREF: sub_50B16+149j
push	[word ptr bp+arg_8+2]
push	[word ptr bp+arg_8]
lea	ax, [bp+var_28]	; Load Effective Address
push	ax
lea	ax, [bp+var_1E]	; Load Effective Address
push	ax
lea	ax, [bp+var_70]	; Load Effective Address
mov	bx, [bp+var_14]
add	bx, ax		; Add
mov	al, [bx]
mov	ah, 0
push	ax
lea	ax, [bp+var_4C]	; Load Effective Address
mov	bx, [bp+var_14]
add	bx, ax		; Add
mov	al, [bx]
mov	ah, 0
push	ax
lea	ax, [bp+var_72+1] ; Load Effective Address
mov	bx, [bp+var_14]
add	bx, ax		; Add
mov	al, [bx]
mov	ah, 0
push	ax
lea	ax, [bp+var_4E+1] ; Load Effective Address
mov	bx, [bp+var_14]
add	bx, ax		; Add
mov	al, [bx]
mov	ah, 0
push	ax
nop			; No Operation
push	cs
call	near ptr sub_5173F ; Call Procedure
add	sp, 10h		; Add
mov	[bp+var_2A], ax

loc_50CC1:		; CODE XREF: sub_50B16+15Cj
cmp	[bp+var_2A], 0	; Compare Two Operands
jnz	short loc_50CCA	; Jump if Not Zero (ZF=0)
jmp	loc_50B38	; Jump

loc_50CCA:		; CODE XREF: sub_50B16+1AFj
mov	[bp+var_12], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_50D0F	; Jump

loc_50CD3:		; CODE XREF: sub_50B16+202j
push	[word ptr bp+arg_8+2]
push	[word ptr bp+arg_8]
mov	ax, [bp+arg_12]
add	ax, [bp+var_10]	; Add
push	ax
mov	ax, [bp+arg_10]
add	ax, [bp+var_10]	; Add
push	ax
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_28]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]

loc_50CF2:
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1E]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
push	[bp+var_E]
push	[bp+var_C]
nop			; No Operation
push	cs
call	near ptr sub_50E46 ; Call Procedure
add	sp, 10h		; Add
mov	[bp+var_12], ax
inc	di		; Increment by 1

loc_50D0F:		; CODE XREF: sub_50B16+1BBj
cmp	di, [bp+var_2A]	; Compare Two Operands
jge	short loc_50D1A	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_12], 0	; Compare Two Operands
jz	short loc_50CD3	; Jump if Zero (ZF=1)

loc_50D1A:		; CODE XREF: sub_50B16+1FCj
cmp	[bp+var_12], 0	; Compare Two Operands
jnz	short loc_50D23	; Jump if Not Zero (ZF=0)
jmp	loc_50B38	; Jump

loc_50D23:		; CODE XREF: sub_50B16+208j
xor	di, di		; Logical Exclusive OR
jmp	short loc_50D65	; Jump

loc_50D27:		; CODE XREF: sub_50B16+252j
mov	bx, [bp+var_10]
add	bx, di		; Add
add	bx, [bp+arg_12]	; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_8]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	si, [bp+var_10]
add	si, di		; Add
add	si, [bp+arg_10]	; Add
mov	al, [si]
cbw			; AL ->	AX (with sign)
add	bx, ax		; Add
mov	al, [es:bx]
mov	bx, [bp+var_10]

loc_50D4F:		; Add
add	bx, di
add	bx, [bp+arg_14]	; Add
mov	[bx], al
mov	bx, [bp+var_10]
add	bx, di		; Add
add	bx, [bp+arg_14]	; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
sub	[bp+arg_16], ax	; Integer Subtraction
inc	di		; Increment by 1

loc_50D65:		; CODE XREF: sub_50B16+20Fj
cmp	di, [bp+var_12]	; Compare Two Operands
jl	short loc_50D27	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
add	ax, 0FFFEh	; Add
cmp	ax, [bp+var_14]	; Compare Two Operands
jg	short loc_50D9D	; Jump if Greater (ZF=0	& SF=OF)
mov	bx, [bp+var_10]
add	bx, [bp+var_12]	; Add
add	bx, [bp+arg_10]	; Add

loc_50D7E:
mov	al, [bx-1]
cbw			; AL ->	AX (with sign)
mov	[bp+var_C], ax
mov	bx, [bp+var_10]
add	bx, [bp+var_12]	; Add
add	bx, [bp+arg_12]	; Add
mov	al, [bx-1]
cbw			; AL ->	AX (with sign)
mov	[bp+var_E], ax

loc_50D95:
mov	ax, [bp+var_12]
add	[bp+var_10], ax	; Add
jmp	short loc_50E13	; Jump

loc_50D9D:		; CODE XREF: sub_50B16+25Dj
mov	bx, [bp+arg_10]
add	bx, [bp+var_10]	; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_C], ax
mov	bx, [bp+arg_12]
add	bx, [bp+var_10]	; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_E], ax
inc	[bp+var_10]	; Increment by 1
xor	di, di		; Logical Exclusive OR
jmp	short loc_50DD8	; Jump

loc_50DBC:		; CODE XREF: sub_50B16+2E0j
			; sub_50B16+2FBj
mov	bx, [bp+arg_10]

loc_50DBF:		; Add
add	bx, [bp+var_10]

loc_50DC2:
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_C], ax
mov	bx, [bp+arg_12]
add	bx, [bp+var_10]	; Add
mov	al, [bx]
cbw			; AL ->	AX (with sign)
mov	[bp+var_E], ax
inc	[bp+var_10]	; Increment by 1
inc	di		; Increment by 1

loc_50DD8:		; CODE XREF: sub_50B16+2A4j
cmp	di, [bp+var_12]	; Compare Two Operands
jge	short loc_50E13	; Jump if Greater or Equal (SF=OF)
lea	ax, [bp+var_4E+1] ; Load Effective Address
mov	bx, [bp+var_14]
add	bx, ax		; Add
mov	al, [bx]
mov	ah, 0
push	ax
mov	ax, [bp+var_C]
mov	bx, 5

loc_50DF0:		; AX ->	DX:AX (with sign)
cwd
idiv	bx		; Signed Divide
pop	dx
cmp	dx, ax		; Compare Two Operands
jnz	short loc_50DBC	; Jump if Not Zero (ZF=0)
lea	ax, [bp+var_72+1] ; Load Effective Address
mov	bx, [bp+var_14]

loc_50DFE:		; Add
add	bx, ax
mov	al, [bx]
mov	ah, 0
push	ax

loc_50E05:
mov	ax, [bp+var_E]
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
pop	dx
cmp	dx, ax		; Compare Two Operands
jnz	short loc_50DBC	; Jump if Not Zero (ZF=0)

loc_50E13:		; CODE XREF: sub_50B16+285j
			; sub_50B16+2C5j
inc	[bp+var_14]	; Increment by 1

loc_50E16:		; CODE XREF: sub_50B16+13Dj
cmp	[bp+arg_16], 0	; Compare Two Operands
jle	short loc_50E3A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_50E1C:
mov	ax, [bp+var_14]

loc_50E1F:		; Compare Two Operands
cmp	ax, [bp+var_2]
jg	short loc_50E3A	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [bp+var_C]
cmp	ax, [bp+arg_4]	; Compare Two Operands
jz	short loc_50E2F	; Jump if Zero (ZF=1)
jmp	loc_50C56	; Jump

loc_50E2F:		; CODE XREF: sub_50B16+314j
mov	ax, [bp+var_E]

loc_50E32:		; Compare Two Operands
cmp	ax, [bp+arg_6]
jz	short loc_50E3A	; Jump if Zero (ZF=1)
jmp	loc_50C56	; Jump

loc_50E3A:		; CODE XREF: sub_50B16+304j
			; sub_50B16+30Cj
			; sub_50B16+31Fj
mov	ax, [bp+var_10]
jmp	loc_50B3A	; Jump

loc_50E40:		; CODE XREF: sub_50B16:loc_50B3Aj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_50B16



; Attributes: bp-based frame

proc sub_50E46 far	; CODE XREF: sub_31B4AJ
			; sub_50B16+81p
			; sub_50B16+1EFp

var_F8=	word ptr -0F8h
var_EE=	word ptr -0EEh
var_62=	word ptr -62h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= dword ptr  12h

push	bp
mov	bp, sp
sub	sp, 0F8h	; Integer Subtraction
push	si
push	di
mov	ax, [bp+arg_0]
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_4], ax
mov	ax, [bp+arg_2]
mov	bx, 5
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	[bp+var_6], ax
mov	ax, [bp+var_4]
dec	ax		; Decrement by 1
mov	dx, 5
imul	dx		; Signed Multiply
mov	[bp+var_8], ax
mov	ax, [bp+var_6]
dec	ax		; Decrement by 1
mov	dx, 5
imul	dx		; Signed Multiply

loc_50E7C:
mov	[bp+var_A], ax
mov	ax, [bp+arg_0]
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_10], ax
mov	ax, [bp+arg_2]
sub	ax, [bp+var_A]	; Integer Subtraction

loc_50E8E:
mov	[bp+var_14], ax
mov	ax, [bp+arg_4]
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_12], ax
mov	ax, [bp+arg_6]
sub	ax, [bp+var_A]	; Integer Subtraction
mov	[bp+var_16], ax
cmp	[bp+var_10], 0Fh ; Compare Two Operands
jle	short loc_50EB5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+arg_0]
add	ax, 0FFC4h	; Add
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_10], ax

loc_50EB5:		; CODE XREF: sub_50E46+61j
cmp	[bp+var_12], 0Fh ; Compare Two Operands
jle	short loc_50EC7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+arg_4]
add	ax, 0FFC4h	; Add
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_12], ax

loc_50EC7:		; CODE XREF: sub_50E46+73j
cmp	[bp+var_10], 0	; Compare Two Operands
jge	short loc_50ED9	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+arg_0]
add	ax, 3Ch	; '<'   ; Add
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_10], ax

loc_50ED9:		; CODE XREF: sub_50E46+85j
cmp	[bp+var_12], 0	; Compare Two Operands
jge	short loc_50EEB	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+arg_4]
add	ax, 3Ch	; '<'   ; Add
sub	ax, [bp+var_8]	; Integer Subtraction
mov	[bp+var_12], ax

loc_50EEB:		; CODE XREF: sub_50E46+97j
mov	[bp+var_2], 0Fh
xor	di, di		; Logical Exclusive OR
jmp	short loc_50F2B	; Jump

loc_50EF4:		; CODE XREF: sub_50E46+E8j
xor	si, si		; Logical Exclusive OR
jmp	short loc_50F25	; Jump

loc_50EF8:		; CODE XREF: sub_50E46+E2j
mov	ax, di
add	ax, [bp+var_A]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
add	bx, [bp+var_8]	; Add
mov	al, [es:bx]
push	ax
mov	ax, di
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, si		; Add
lea	dx, [bp+var_F8]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
pop	ax
mov	[bx], al
inc	si		; Increment by 1

loc_50F25:		; CODE XREF: sub_50E46+B0j
cmp	si, [bp+var_2]	; Compare Two Operands
jl	short loc_50EF8	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_50F2B:		; CODE XREF: sub_50E46+ACj
cmp	di, [bp+var_2]	; Compare Two Operands
jl	short loc_50EF4	; Jump if Less (SF!=OF)
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_50F74	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_50F6F	; Jump

loc_50F3A:		; CODE XREF: sub_50E46+12Cj
xor	si, si		; Logical Exclusive OR
jmp	short loc_50F69	; Jump

loc_50F3E:		; CODE XREF: sub_50E46+126j
mov	ax, di
add	ax, [bp+var_A]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
mov	al, [es:bx+37h]
push	ax
mov	ax, di
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, si		; Add
lea	dx, [bp+var_F8]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
pop	ax
mov	[bx], al
inc	si		; Increment by 1

loc_50F69:		; CODE XREF: sub_50E46+F6j
cmp	si, 5		; Compare Two Operands
jl	short loc_50F3E	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_50F6F:		; CODE XREF: sub_50E46+F2j
cmp	di, [bp+var_2]	; Compare Two Operands
jl	short loc_50F3A	; Jump if Less (SF!=OF)

loc_50F74:		; CODE XREF: sub_50E46+EEj
cmp	[bp+var_4], 0Bh	; Compare Two Operands
jnz	short loc_50FB7	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_50FB2	; Jump

loc_50F7E:		; CODE XREF: sub_50E46+16Fj
xor	si, si		; Logical Exclusive OR
jmp	short loc_50FAC	; Jump

loc_50F82:		; CODE XREF: sub_50E46+169j
mov	ax, di
add	ax, [bp+var_A]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, si		; Add
mov	al, [es:bx]
push	ax
mov	ax, di
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, si		; Add
lea	dx, [bp+var_EE]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
pop	ax
mov	[bx], al
inc	si		; Increment by 1

loc_50FAC:		; CODE XREF: sub_50E46+13Aj
cmp	si, 5		; Compare Two Operands
jl	short loc_50F82	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_50FB2:		; CODE XREF: sub_50E46+136j
cmp	di, [bp+var_2]	; Compare Two Operands
jl	short loc_50F7E	; Jump if Less (SF!=OF)

loc_50FB7:		; CODE XREF: sub_50E46+132j
cmp	[bp+var_6], 0	; Compare Two Operands
jnz	short loc_50FE5	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_50FE0	; Jump

loc_50FC1:		; CODE XREF: sub_50E46+19Dj
xor	si, si		; Logical Exclusive OR
jmp	short loc_50FDA	; Jump

loc_50FC5:		; CODE XREF: sub_50E46+197j
mov	ax, di
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, si		; Add
lea	dx, [bp+var_F8]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
mov	[byte ptr bx], 0FFh
inc	si		; Increment by 1

loc_50FDA:		; CODE XREF: sub_50E46+17Dj
cmp	si, [bp+var_2]	; Compare Two Operands
jl	short loc_50FC5	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_50FE0:		; CODE XREF: sub_50E46+179j
cmp	di, 5		; Compare Two Operands
jl	short loc_50FC1	; Jump if Less (SF!=OF)

loc_50FE5:		; CODE XREF: sub_50E46+175j
cmp	[bp+var_6], 7	; Compare Two Operands
jnz	short loc_51012	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_5100D	; Jump

loc_50FEF:		; CODE XREF: sub_50E46+1CAj
xor	si, si		; Logical Exclusive OR
jmp	short loc_51007	; Jump

loc_50FF3:		; CODE XREF: sub_50E46+1C4j
mov	ax, di
mov	dx, 0Fh
imul	dx		; Signed Multiply
add	ax, si		; Add
lea	dx, [bp+var_62]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
mov	[byte ptr bx], 0FFh
inc	si		; Increment by 1

loc_51007:		; CODE XREF: sub_50E46+1ABj
cmp	si, [bp+var_2]	; Compare Two Operands
jl	short loc_50FF3	; Jump if Less (SF!=OF)
inc	di		; Increment by 1

loc_5100D:		; CODE XREF: sub_50E46+1A7j
cmp	di, 5		; Compare Two Operands
jl	short loc_50FEF	; Jump if Less (SF!=OF)

loc_51012:		; CODE XREF: sub_50E46+1A3j
push	[bp+arg_A]
push	[bp+arg_8]
lea	ax, [bp+var_F8]	; Load Effective Address
push	ax
push	[bp+var_2]
push	[bp+var_2]

loc_51023:
push	[bp+var_16]
push	[bp+var_12]
push	[bp+var_14]
push	[bp+var_10]
push	cs
call	near ptr sub_503F0 ; Call Procedure
add	sp, 12h		; Add
mov	[bp+var_C], ax
mov	[bp+var_E], 0

loc_5103E:		; Jump
jmp	loc_510DE

loc_51041:		; CODE XREF: sub_50E46+2A0j
mov	bx, [bp+arg_8]
add	bx, [bp+var_E]	; Add
mov	al, [bx]
add	al, [byte ptr bp+var_8]	; Add
mov	bx, [bp+arg_8]
add	bx, [bp+var_E]	; Add
mov	[bx], al
mov	bx, [bp+arg_8]
add	bx, [bp+var_E]	; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jge	short loc_51071	; Jump if Greater or Equal (SF=OF)
mov	bx, [bp+arg_8]
add	bx, [bp+var_E]	; Add
mov	al, [bx]
add	al, 3Ch	; '<'   ; Add
mov	bx, [bp+arg_8]
add	bx, [bp+var_E]	; Add
mov	[bx], al

loc_51071:		; CODE XREF: sub_50E46+217j
mov	bx, [bp+arg_8]
add	bx, [bp+var_E]	; Add
cmp	[byte ptr bx], 3Ch ; '<' ; Compare Two Operands
jl	short loc_5108E	; Jump if Less (SF!=OF)
mov	bx, [bp+arg_8]
add	bx, [bp+var_E]	; Add
mov	al, [bx]
add	al, 0C4h ; ''  ; Add
mov	bx, [bp+arg_8]
add	bx, [bp+var_E]	; Add
mov	[bx], al

loc_5108E:		; CODE XREF: sub_50E46+234j
mov	bx, [bp+arg_A]
add	bx, [bp+var_E]	; Add
mov	al, [bx]
add	al, [byte ptr bp+var_A]	; Add
mov	bx, [bp+arg_A]
add	bx, [bp+var_E]	; Add
mov	[bx], al
mov	bx, [bp+arg_A]
add	bx, [bp+var_E]	; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jge	short loc_510BE	; Jump if Greater or Equal (SF=OF)
mov	bx, [bp+arg_A]

loc_510AF:		; Add
add	bx, [bp+var_E]
mov	al, [bx]
add	al, 28h	; '('   ; Add
mov	bx, [bp+arg_A]
add	bx, [bp+var_E]	; Add
mov	[bx], al

loc_510BE:		; CODE XREF: sub_50E46+264j
mov	bx, [bp+arg_A]
add	bx, [bp+var_E]	; Add
cmp	[byte ptr bx], 28h ; '(' ; Compare Two Operands
jl	short loc_510DB	; Jump if Less (SF!=OF)
mov	bx, [bp+arg_A]
add	bx, [bp+var_E]	; Add
mov	al, [bx]
add	al, 0D8h ; ''  ; Add
mov	bx, [bp+arg_A]
add	bx, [bp+var_E]	; Add
mov	[bx], al

loc_510DB:		; CODE XREF: sub_50E46+281j
inc	[bp+var_E]	; Increment by 1

loc_510DE:		; CODE XREF: sub_50E46:loc_5103Ej
mov	ax, [bp+var_E]
cmp	ax, [bp+var_C]	; Compare Two Operands
jge	short loc_510E9	; Jump if Greater or Equal (SF=OF)
jmp	loc_51041	; Jump

loc_510E9:		; CODE XREF: sub_50E46+29Ej
mov	ax, [bp+var_C]
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_50E46



; Attributes: bp-based frame

proc sub_510F4 far	; CODE XREF: sub_31B4FJ
			; sub_50B16+115p

var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= dword ptr  12h

push	bp
mov	bp, sp
sub	sp, 24h		; Integer Subtraction
push	si
push	di
mov	[bp+var_2], 0
mov	si, 92C2h
mov	di, 91E0h
mov	[bp+var_24], 9118h
mov	ax, [bp+arg_0]
cmp	ax, [bp+arg_4]	; Compare Two Operands
jnz	short loc_51132	; Jump if Not Zero (ZF=0)
mov	ax, [bp+arg_2]
cmp	ax, [bp+arg_6]	; Compare Two Operands
jnz	short loc_51132	; Jump if Not Zero (ZF=0)
mov	bx, [bp+arg_8]
mov	al, [byte ptr bp+arg_0]
mov	[bx], al
mov	bx, [bp+arg_A]
mov	al, [byte ptr bp+arg_2]

loc_5112A:
mov	[bx], al
mov	ax, 1

loc_5112F:		; CODE XREF: sub_510F4:loc_516AFj
			; sub_510F4+642j
jmp	loc_51739	; Jump

loc_51132:		; CODE XREF: sub_510F4+1Ej
			; sub_510F4+26j
mov	[bp+var_14], 0
jmp	short loc_51146	; Jump

loc_51139:		; CODE XREF: sub_510F4+56j
mov	bx, [bp+var_14]
shl	bx, 1		; Shift	Logical	Left

loc_5113E:
mov	ax, [bp+var_14]
mov	[bx+si], ax
inc	[bp+var_14]	; Increment by 1

loc_51146:		; CODE XREF: sub_510F4+43j
cmp	[bp+var_14], 60h ; '`' ; Compare Two Operands
jl	short loc_51139	; Jump if Less (SF!=OF)

loc_5114C:
mov	[bp+var_14], 0
jmp	short loc_5115C	; Jump

loc_51153:		; CODE XREF: sub_510F4+6Cj
mov	bx, [bp+var_14]
mov	[byte ptr bx+di], 0FFh
inc	[bp+var_14]	; Increment by 1

loc_5115C:		; CODE XREF: sub_510F4+5Dj
cmp	[bp+var_14], 60h ; '`' ; Compare Two Operands
jl	short loc_51153	; Jump if Less (SF!=OF)
mov	ax, [bp+arg_2]
mov	dx, 0Ch
imul	dx		; Signed Multiply
mov	bx, [bp+arg_0]
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr bx], 0
mov	ax, [bp+arg_6]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	ax, [bp+arg_4]	; Add
mov	[bp+var_6], ax
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, [bp+var_6]	; Add
mov	al, [es:bx]
mov	ah, 0
mov	[bp+var_22], ax
mov	ax, [bp+var_22]
and	ax, 1		; Logical AND
mov	[bp+var_A], ax

loc_51199:
mov	ax, [bp+var_22]
and	ax, 4		; Logical AND
mov	[bp+var_C], ax
mov	ax, [bp+var_22]
and	ax, 2		; Logical AND
mov	[bp+var_E], ax
mov	ax, [bp+var_22]

loc_511AE:		; Logical AND
and	ax, 8
mov	[bp+var_10], ax
test	[bp+var_22], 10h ; Logical Compare
jz	short loc_511C4	; Jump if Zero (ZF=1)
mov	ax, [bp+var_22]
or	ax, 1		; Logical Inclusive OR
mov	[bp+var_22], ax

loc_511C4:		; CODE XREF: sub_510F4+C5j
test	[bp+var_22], 40h ; Logical Compare
jz	short loc_511D4	; Jump if Zero (ZF=1)
mov	ax, [bp+var_22]
or	ax, 4		; Logical Inclusive OR
mov	[bp+var_22], ax

loc_511D4:		; CODE XREF: sub_510F4+D5j
test	[bp+var_22], 80h ; Logical Compare
jz	short loc_511E4	; Jump if Zero (ZF=1)
mov	ax, [bp+var_22]
or	ax, 8		; Logical Inclusive OR
mov	[bp+var_22], ax

loc_511E4:		; CODE XREF: sub_510F4+E5j
test	[bp+var_22], 20h ; Logical Compare
jz	short loc_511F4	; Jump if Zero (ZF=1)
mov	ax, [bp+var_22]
or	ax, 2		; Logical Inclusive OR
mov	[bp+var_22], ax

loc_511F4:		; CODE XREF: sub_510F4+F5j
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx

loc_511F7:		; Add
add	bx, [bp+var_6]
mov	al, [byte ptr bp+var_22]
mov	[es:bx], al

loc_51200:
mov	[bp+var_1E], 1
jmp	loc_5160F	; Jump

loc_51208:		; CODE XREF: sub_510F4+521j
mov	[bp+var_1E], 0

loc_5120D:
mov	[bp+var_18], 0Ah
mov	[bp+var_1A], 8
xor	cx, cx		; Logical Exclusive OR
mov	[bp+var_1C], 0
jmp	loc_51604	; Jump

loc_51221:		; CODE XREF: sub_510F4:loc_5160Cj
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, cx		; Add
mov	al, [es:bx]
mov	ah, 0
mov	[bp+var_12], ax
test	[bp+var_12], 1	; Logical Compare
jz	short loc_5127C	; Jump if Zero (ZF=1)
mov	ax, cx
add	ax, 0FFF4h	; Add
mov	[bp+var_8], ax

loc_5123D:
mov	bx, [bp+var_8]

loc_51240:
mov	al, [bx+di]

loc_51242:
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0

loc_5124E:		; Compare Two Operands
cmp	ax, [bp+var_4]
jle	short loc_5127C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]

loc_51263:
mov	[bx+si], ax

loc_51265:
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]

loc_51272:		; Compare Two Operands
cmp	ax, [bp+var_20]
jz	short loc_5127C	; Jump if Zero (ZF=1)

loc_51277:
mov	[bp+var_1E], 1

loc_5127C:		; CODE XREF: sub_510F4+13Fj
			; sub_510F4+15Dj
			; sub_510F4+181j
test	[bp+var_12], 4	; Logical Compare

loc_51281:		; Jump if Zero (ZF=1)
jz	short loc_512CA
mov	ax, cx
add	ax, 0Ch		; Add
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_512CA	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx

loc_512AC:		; Shift	Logical	Left
shl	bx, 1

loc_512AE:
mov	ax, [bp+var_8]

loc_512B1:
mov	[bx+si], ax
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al

loc_512BA:
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left

loc_512BE:
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_512CA	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_512CA:		; CODE XREF: sub_510F4:loc_51281j
			; sub_510F4+1ABj
			; sub_510F4+1CFj
test	[bp+var_12], 8	; Logical Compare
jz	short loc_51318	; Jump if Zero (ZF=1)
mov	ax, cx

loc_512D3:		; Add
add	ax, 0Bh

loc_512D6:
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1

loc_512E1:
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_51318	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
mov	[bp+var_20], ax

loc_512F8:
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]
mov	[bx+si], ax
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_51318	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_51318:		; CODE XREF: sub_510F4+1DBj
			; sub_510F4+1F9j
			; sub_510F4+21Dj
test	[bp+var_12], 2	; Logical Compare
jz	short loc_51364	; Jump if Zero (ZF=1)
mov	ax, cx
inc	ax		; Increment by 1
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]

loc_5132A:
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_51364	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]
mov	[bx+si], ax
mov	bx, cx
mov	al, [byte ptr bp+var_4]

loc_51352:
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_51364	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_51364:		; CODE XREF: sub_510F4+229j
			; sub_510F4+245j
			; sub_510F4+269j
inc	cx		; Increment by 1
mov	[bp+var_16], 0
jmp	loc_514B2	; Jump

loc_5136D:		; CODE XREF: sub_510F4+3C6j
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, cx		; Add
mov	al, [es:bx]
mov	ah, 0
mov	[bp+var_12], ax
test	[bp+var_12], 1	; Logical Compare
jz	short loc_513C8	; Jump if Zero (ZF=1)
mov	ax, cx
add	ax, 0FFF4h	; Add
mov	[bp+var_8], ax

loc_51389:
mov	bx, [bp+var_8]
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_513C8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left

loc_513AC:
mov	ax, [bp+var_8]
mov	[bx+si], ax
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_513C8	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_513C8:		; CODE XREF: sub_510F4+28Bj
			; sub_510F4+2A9j
			; sub_510F4+2CDj
test	[bp+var_12], 4	; Logical Compare
jz	short loc_51416	; Jump if Zero (ZF=1)
mov	ax, cx
add	ax, 0Ch		; Add
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_51416	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx

loc_513EF:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]
mov	[bx+si], ax
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_51416	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_51416:		; CODE XREF: sub_510F4+2D9j
			; sub_510F4+2F7j
			; sub_510F4+31Bj
test	[bp+var_12], 8	; Logical Compare

loc_5141B:		; Jump if Zero (ZF=1)
jz	short loc_51462

loc_5141D:
mov	ax, cx
dec	ax		; Decrement by 1

loc_51420:
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_51462	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx

loc_51444:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bp+var_8]
mov	[bx+si], ax
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_51462	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_51462:		; CODE XREF: sub_510F4:loc_5141Bj
			; sub_510F4+343j
			; sub_510F4+367j
test	[bp+var_12], 2	; Logical Compare
jz	short loc_514AE	; Jump if Zero (ZF=1)
mov	ax, cx
inc	ax		; Increment by 1
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_514AE	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]

loc_5148B:
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]
mov	[bx+si], ax

loc_51497:
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_514AE	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_514AE:		; CODE XREF: sub_510F4+373j
			; sub_510F4+38Fj
			; sub_510F4+3B3j
inc	cx		; Increment by 1
inc	[bp+var_16]	; Increment by 1

loc_514B2:		; CODE XREF: sub_510F4+276j
mov	ax, [bp+var_16]

loc_514B5:		; Compare Two Operands
cmp	ax, [bp+var_18]
jge	short loc_514BD	; Jump if Greater or Equal (SF=OF)
jmp	loc_5136D	; Jump

loc_514BD:		; CODE XREF: sub_510F4+3C4j
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, cx		; Add
mov	al, [es:bx]
mov	ah, 0
mov	[bp+var_12], ax
test	[bp+var_12], 1	; Logical Compare
jz	short loc_51518	; Jump if Zero (ZF=1)
mov	ax, cx

loc_514D3:		; Add
add	ax, 0FFF4h
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]

loc_514DE:
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0

loc_514EA:		; Compare Two Operands
cmp	ax, [bp+var_4]
jle	short loc_51518	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]
mov	[bx+si], ax
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al

loc_51508:
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_51518	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_51518:		; CODE XREF: sub_510F4+3DBj
			; sub_510F4+3F9j
			; sub_510F4+41Dj
test	[bp+var_12], 4	; Logical Compare
jz	short loc_51566	; Jump if Zero (ZF=1)
mov	ax, cx
add	ax, 0Ch		; Add
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_51566	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx

loc_5153F:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]
mov	[bx+si], ax

loc_5154F:
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]

loc_5155C:		; Compare Two Operands
cmp	ax, [bp+var_20]
jz	short loc_51566	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_51566:		; CODE XREF: sub_510F4+429j
			; sub_510F4+447j
			; sub_510F4+46Bj
test	[bp+var_12], 8	; Logical Compare
jz	short loc_515B2	; Jump if Zero (ZF=1)
mov	ax, cx
dec	ax		; Decrement by 1
mov	[bp+var_8], ax
mov	bx, [bp+var_8]

loc_51576:
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_515B2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_8]
mov	[bx+si], ax

loc_5159B:
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_515B2	; Jump if Zero (ZF=1)

loc_515AD:
mov	[bp+var_1E], 1

loc_515B2:		; CODE XREF: sub_510F4+477j
			; sub_510F4+493j
			; sub_510F4+4B7j
test	[bp+var_12], 2	; Logical Compare
jz	short loc_51600	; Jump if Zero (ZF=1)
mov	ax, cx
add	ax, 0FFF5h	; Add
mov	[bp+var_8], ax
mov	bx, [bp+var_8]
mov	al, [bx+di]
mov	ah, 0
inc	ax		; Increment by 1

loc_515C9:
mov	[bp+var_4], ax
mov	bx, cx
mov	al, [bx+di]
mov	ah, 0
cmp	ax, [bp+var_4]	; Compare Two Operands
jle	short loc_51600	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left

loc_515DB:
mov	ax, [bx+si]
mov	[bp+var_20], ax
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left

loc_515E4:
mov	ax, [bp+var_8]
mov	[bx+si], ax
mov	bx, cx
mov	al, [byte ptr bp+var_4]
mov	[bx+di], al
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+si]
cmp	ax, [bp+var_20]	; Compare Two Operands
jz	short loc_51600	; Jump if Zero (ZF=1)
mov	[bp+var_1E], 1

loc_51600:		; CODE XREF: sub_510F4+4C3j
			; sub_510F4+4E1j
			; sub_510F4+505j
inc	cx		; Increment by 1
inc	[bp+var_1C]	; Increment by 1

loc_51604:		; CODE XREF: sub_510F4+12Aj
mov	ax, [bp+var_1C]
cmp	ax, [bp+var_1A]	; Compare Two Operands
jge	short loc_5160F	; Jump if Greater or Equal (SF=OF)

loc_5160C:		; Jump
jmp	loc_51221

loc_5160F:		; CODE XREF: sub_510F4+111j
			; sub_510F4+516j
cmp	[bp+var_1E], 1	; Compare Two Operands
jnz	short loc_51618	; Jump if Not Zero (ZF=0)
jmp	loc_51208	; Jump

loc_51618:		; CODE XREF: sub_510F4+51Fj
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx

loc_5161B:		; Add
add	bx, [bp+var_6]

loc_5161E:
mov	al, [es:bx]

loc_51621:		; Logical AND
and	al, 0FEh
add	al, [byte ptr bp+var_A]	; Add

loc_51626:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_C]
add	bx, [bp+var_6]	; Add
mov	[es:bx], al
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, [bp+var_6]	; Add
mov	al, [es:bx]
and	al, 0FBh	; Logical AND

loc_5163A:		; Add
add	al, [byte ptr bp+var_C]
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, [bp+var_6]	; Add

loc_51643:
mov	[es:bx], al
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, [bp+var_6]	; Add

loc_5164C:
mov	al, [es:bx]
and	al, 0FDh	; Logical AND
add	al, [byte ptr bp+var_E]	; Add

loc_51654:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_C]
add	bx, [bp+var_6]	; Add
mov	[es:bx], al
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, [bp+var_6]	; Add
mov	al, [es:bx]
and	al, 0F7h	; Logical AND

loc_51668:		; Add
add	al, [byte ptr bp+var_10]

loc_5166B:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_C]
add	bx, [bp+var_6]	; Add
mov	[es:bx], al
mov	[bp+var_2], 0
mov	ax, [bp+arg_6]
mov	dx, 0Ch
imul	dx		; Signed Multiply
mov	dx, [bp+arg_4]
add	dx, ax		; Add
mov	cx, dx
jmp	short loc_5169F	; Jump

loc_5168A:		; CODE XREF: sub_510F4+5B1j
mov	ax, [bp+var_2]
shl	ax, 1		; Shift	Logical	Left

loc_5168F:
mov	bx, [bp+var_24]
add	bx, ax		; Add
mov	[bx], cx

loc_51696:
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
mov	cx, [bx+si]
inc	[bp+var_2]	; Increment by 1

loc_5169F:		; CODE XREF: sub_510F4+594j
mov	bx, cx
shl	bx, 1		; Shift	Logical	Left
cmp	[bx+si], cx	; Compare Two Operands
jnz	short loc_5168A	; Jump if Not Zero (ZF=0)
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_516B2	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR

loc_516AF:		; Jump
jmp	loc_5112F

loc_516B2:		; CODE XREF: sub_510F4+5B7j
mov	bx, [bp+arg_8]

loc_516B5:
mov	al, [byte ptr bp+arg_0]
mov	[bx], al

loc_516BA:
mov	bx, [bp+arg_A]
mov	al, [byte ptr bp+arg_2]
mov	[bx], al

loc_516C2:
mov	[bp+var_14], 0
jmp	short loc_5172A	; Jump

loc_516C9:		; CODE XREF: sub_510F4+63Cj
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1
sub	ax, [bp+var_14]	; Integer Subtraction
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_24]
add	bx, ax		; Add

loc_516D7:
mov	ax, [bx]
mov	bx, 0Ch

loc_516DC:		; AX ->	DX:AX (with sign)
cwd

loc_516DD:		; Signed Divide
idiv	bx
mov	bx, [bp+var_14]
add	bx, [bp+arg_8]	; Add
mov	[bx+1],	dl

loc_516E8:
mov	bx, [bp+var_14]
add	bx, [bp+arg_8]	; Add
cmp	[byte ptr bx+1], 0 ; Compare Two Operands
jge	short loc_51708	; Jump if Greater or Equal (SF=OF)
mov	bx, [bp+var_14]
add	bx, [bp+arg_8]	; Add

loc_516FA:
mov	al, [bx+1]
add	al, 0Ch		; Add
mov	bx, [bp+var_14]
add	bx, [bp+arg_8]	; Add

loc_51705:
mov	[bx+1],	al

loc_51708:		; CODE XREF: sub_510F4+5FEj
mov	ax, [bp+var_2]
dec	ax		; Decrement by 1

loc_5170C:		; Integer Subtraction
sub	ax, [bp+var_14]
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+var_24]
add	bx, ax		; Add
mov	ax, [bx]
mov	bx, 0Ch
cwd			; AX ->	DX:AX (with sign)
idiv	bx		; Signed Divide
mov	bx, [bp+var_14]
add	bx, [bp+arg_A]	; Add
mov	[bx+1],	al

loc_51727:		; Increment by 1
inc	[bp+var_14]

loc_5172A:		; CODE XREF: sub_510F4+5D3j
mov	ax, [bp+var_14]
cmp	ax, [bp+var_2]	; Compare Two Operands
jl	short loc_516C9	; Jump if Less (SF!=OF)

loc_51732:
mov	ax, [bp+var_2]
inc	ax		; Increment by 1
jmp	loc_5112F	; Jump

loc_51739:		; CODE XREF: sub_510F4:loc_5112Fj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_510F4



; Attributes: bp-based frame

proc sub_5173F far	; CODE XREF: sub_31B54J
			; sub_50B16+1A2p

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= dword ptr  12h

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	ax, [bp+arg_0]

loc_5174A:
mov	dx, 5
imul	dx		; Signed Multiply
mov	[bp+var_2], ax
mov	ax, [bp+arg_2]
mov	dx, 5
imul	dx		; Signed Multiply
mov	[bp+var_4], ax
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+arg_6]
cmp	ax, [bp+arg_2]	; Compare Two Operands
jz	short loc_5176A	; Jump if Zero (ZF=1)
jmp	loc_51821	; Jump

loc_5176A:		; CODE XREF: sub_5173F+26j
mov	ax, [bp+arg_4]
cmp	ax, [bp+arg_0]	; Compare Two Operands
jl	short loc_5177E	; Jump if Less (SF!=OF)
cmp	[bp+arg_0], 0	; Compare Two Operands
jnz	short loc_517CD	; Jump if Not Zero (ZF=0)
cmp	[bp+arg_4], 0Bh	; Compare Two Operands

loc_5177C:		; Jump if Not Zero (ZF=0)
jnz	short loc_517CD

loc_5177E:		; CODE XREF: sub_5173F+31j
xor	di, di		; Logical Exclusive OR

loc_51780:		; Jump
jmp	short loc_517C6

loc_51782:		; CODE XREF: sub_5173F+8Aj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left

loc_51786:
mov	ax, [bx+3540h]
add	ax, [bp+var_4]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_2]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_517C5	; Jump if Zero (ZF=1)
mov	ax, cx
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_8]
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	[bx], ax
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_4]
add	ax, [bx+3540h]	; Add
mov	dx, cx
shl	dx, 1		; Shift	Logical	Left
mov	bx, [bp+arg_A]
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_517C5:		; CODE XREF: sub_5173F+5Fj
inc	di		; Increment by 1

loc_517C6:		; CODE XREF: sub_5173F:loc_51780j
cmp	di, 5		; Compare Two Operands
jl	short loc_51782	; Jump if Less (SF!=OF)
jmp	short loc_5181E	; Jump

loc_517CD:		; CODE XREF: sub_5173F+37j
			; sub_5173F:loc_5177Cj
xor	di, di		; Logical Exclusive OR
jmp	short loc_51819	; Jump

loc_517D1:		; CODE XREF: sub_5173F+DDj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+3540h]
add	ax, [bp+var_4]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_2]	; Add
cmp	[byte ptr es:bx+4], 0FFh ; Compare Two Operands
jz	short loc_51818	; Jump if Zero (ZF=1)

loc_517F0:
mov	ax, cx
shl	ax, 1		; Shift	Logical	Left

loc_517F4:
mov	bx, [bp+arg_8]
add	bx, ax		; Add
mov	ax, [bp+var_2]
add	ax, 4		; Add
mov	[bx], ax
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+3540h]
add	ax, [bp+var_4]	; Add
mov	dx, cx
shl	dx, 1		; Shift	Logical	Left
mov	bx, [bp+arg_A]
add	bx, dx		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_51818:		; CODE XREF: sub_5173F+AFj
inc	di		; Increment by 1

loc_51819:		; CODE XREF: sub_5173F+90j
cmp	di, 5		; Compare Two Operands
jl	short loc_517D1	; Jump if Less (SF!=OF)

loc_5181E:		; CODE XREF: sub_5173F+8Cj
jmp	loc_518CF	; Jump

loc_51821:		; CODE XREF: sub_5173F+28j
mov	ax, [bp+arg_6]
cmp	ax, [bp+arg_2]	; Compare Two Operands
jle	short loc_51880	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_51879	; Jump

loc_5182D:		; CODE XREF: sub_5173F+13Dj
mov	ax, [bp+var_4]
add	ax, 4		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	dx, [bp+arg_C]	; Load Full Pointer to ES:xx
add	dx, ax		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
add	dx, [bx+3540h]	; Add
add	dx, [bp+var_2]	; Add
mov	bx, dx
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51878	; Jump if Zero (ZF=1)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+3540h]
add	ax, [bp+var_2]	; Add
mov	dx, cx
shl	dx, 1		; Shift	Logical	Left
mov	bx, [bp+arg_8]
add	bx, dx		; Add
mov	[bx], ax
mov	ax, cx
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_A]
add	bx, ax		; Add
mov	ax, [bp+var_4]
add	ax, 4		; Add
mov	[bx], ax
inc	cx		; Increment by 1

loc_51878:		; CODE XREF: sub_5173F+10Fj
inc	si		; Increment by 1

loc_51879:		; CODE XREF: sub_5173F+ECj
cmp	si, 5		; Compare Two Operands
jl	short loc_5182D	; Jump if Less (SF!=OF)
jmp	short loc_518CF	; Jump

loc_51880:		; CODE XREF: sub_5173F+E8j
xor	si, si		; Logical Exclusive OR
jmp	short loc_518CA	; Jump

loc_51884:		; CODE XREF: sub_5173F+18Ej
mov	ax, [bp+var_4]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	dx, [bp+arg_C]	; Load Full Pointer to ES:xx

loc_5188F:		; Add
add	dx, ax
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_51895:		; Add
add	dx, [bx+3540h]
add	dx, [bp+var_2]	; Add

loc_5189C:
mov	bx, dx

loc_5189E:		; Compare Two Operands
cmp	[byte ptr es:bx], 0FFh
jz	short loc_518C9	; Jump if Zero (ZF=1)
mov	bx, si

loc_518A6:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bx+3540h]
add	ax, [bp+var_2]	; Add
mov	dx, cx
shl	dx, 1		; Shift	Logical	Left
mov	bx, [bp+arg_8]
add	bx, dx		; Add
mov	[bx], ax
mov	ax, cx
shl	ax, 1		; Shift	Logical	Left
mov	bx, [bp+arg_A]
add	bx, ax		; Add
mov	ax, [bp+var_4]

loc_518C6:
mov	[bx], ax
inc	cx		; Increment by 1

loc_518C9:		; CODE XREF: sub_5173F+163j
inc	si		; Increment by 1

loc_518CA:		; CODE XREF: sub_5173F+143j
cmp	si, 5		; Compare Two Operands
jl	short loc_51884	; Jump if Less (SF!=OF)

loc_518CF:		; CODE XREF: sub_5173F:loc_5181Ej
			; sub_5173F+13Fj
mov	ax, cx
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_5173F

ends ovr054


; Segment type:	Pure code
segment	ovr055 para public 'OVERLAY' use16
assume cs:ovr055
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_518E0 far	; CODE XREF: sub_31B80J

var_86=	word ptr -86h
var_76=	word ptr -76h
var_66=	word ptr -66h
var_60=	word ptr -60h
var_42=	word ptr -42h
var_24=	byte ptr -24h
var_1D=	byte ptr -1Dh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= dword ptr  6
arg_4= dword ptr  0Ah

push	bp

loc_518E1:
mov	bp, sp

loc_518E3:		; Integer Subtraction
sub	sp, 86h

loc_518E7:
push	si

loc_518E8:
push	di

loc_518E9:		; Logical Exclusive OR
xor	si, si

loc_518EB:
mov	[bp+var_2], 0

loc_518F0:		; Jump
jmp	loc_52189

loc_518F3:		; CODE XREF: sub_518E0:loc_5218Fj
mov	[bp+var_6], 0

loc_518F8:
mov	[bp+var_4], 0

loc_518FD:		; Jump
jmp	loc_5217A

loc_51900:		; CODE XREF: sub_518E0+8A0j
mov	[bp+var_1D], 0

loc_51904:		; Compare Two Operands
cmp	[bp+var_2], 0

loc_51908:		; Jump if Not Zero (ZF=0)
jnz	short loc_5190D

loc_5190A:		; Jump
jmp	loc_51AFC

loc_5190D:		; CODE XREF: sub_518E0:loc_51908j
mov	ax, si

loc_5190F:
mov	dx, 3Ch	; '<'

loc_51912:		; Signed Multiply
imul	dx

loc_51914:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_0]

loc_51917:		; Add
add	bx, ax

loc_51919:		; Add
add	bx, [bp+var_6]

loc_5191C:		; Compare Two Operands
cmp	[byte ptr es:bx], 0FFh

loc_51920:		; Jump if Zero (ZF=1)
jz	short loc_51957
mov	ax, si

loc_51924:		; Decrement by 1
dec	ax

loc_51925:
mov	dx, 3Ch	; '<'

loc_51928:		; Signed Multiply
imul	dx

loc_5192A:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_0]

loc_5192D:		; Add
add	bx, ax

loc_5192F:		; Add
add	bx, [bp+var_6]

loc_51932:		; Compare Two Operands
cmp	[byte ptr es:bx], 0FFh

loc_51936:		; Jump if Not Zero (ZF=0)
jnz	short loc_5194F

loc_51938:
mov	ax, si
dec	ax		; Decrement by 1

loc_5193B:
mov	dx, 3Ch	; '<'

loc_5193E:		; Signed Multiply
imul	dx

loc_51940:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_0]

loc_51943:		; Add
add	bx, ax

loc_51945:		; Add
add	bx, [bp+var_6]

loc_51948:		; Compare Two Operands
cmp	[byte ptr es:bx+1], 0FFh
jz	short loc_51957	; Jump if Zero (ZF=1)

loc_5194F:		; CODE XREF: sub_518E0:loc_51936j
mov	al, [bp+var_1D]

loc_51952:		; Logical Inclusive OR
or	al, 1

loc_51954:
mov	[bp+var_1D], al

loc_51957:		; CODE XREF: sub_518E0:loc_51920j
			; sub_518E0+6Dj
mov	ax, [bp+var_6]

loc_5195A:		; Increment by 1
inc	ax
mov	[bp+var_E], ax

loc_5195E:		; Jump
jmp	short loc_519C4

loc_51960:		; CODE XREF: sub_518E0+F3j
mov	ax, si

loc_51962:
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply

loc_51967:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_0]

loc_5196A:		; Add
add	bx, ax

loc_5196C:		; Add
add	bx, [bp+var_E]

loc_5196F:		; Compare Two Operands
cmp	[byte ptr es:bx], 0FFh
jz	short loc_519C1	; Jump if Zero (ZF=1)

loc_51975:
mov	ax, si
dec	ax		; Decrement by 1

loc_51978:
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply

loc_5197D:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_0]

loc_51980:		; Add
add	bx, ax
add	bx, [bp+var_E]	; Add
cmp	[byte ptr es:bx-1], 0FFh ; Compare Two Operands

loc_5198A:		; Jump if Not Zero (ZF=0)
jnz	short loc_519B9
mov	ax, si

loc_5198E:		; Decrement by 1
dec	ax
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply

loc_51994:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_0]
add	bx, ax		; Add

loc_51999:		; Add
add	bx, [bp+var_E]

loc_5199C:		; Compare Two Operands
cmp	[byte ptr es:bx], 0FFh

loc_519A0:		; Jump if Not Zero (ZF=0)
jnz	short loc_519B9
mov	ax, si
dec	ax		; Decrement by 1

loc_519A5:
mov	dx, 3Ch	; '<'

loc_519A8:		; Signed Multiply
imul	dx
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx

loc_519AD:		; Add
add	bx, ax

loc_519AF:		; Add
add	bx, [bp+var_E]
cmp	[byte ptr es:bx+1], 0FFh ; Compare Two Operands

loc_519B7:		; Jump if Zero (ZF=1)
jz	short loc_519C1

loc_519B9:		; CODE XREF: sub_518E0:loc_5198Aj
			; sub_518E0:loc_519A0j
mov	al, [bp+var_1D]
or	al, 1		; Logical Inclusive OR

loc_519BE:
mov	[bp+var_1D], al

loc_519C1:		; CODE XREF: sub_518E0+93j
			; sub_518E0:loc_519B7j
inc	[bp+var_E]	; Increment by 1

loc_519C4:		; CODE XREF: sub_518E0:loc_5195Ej
mov	ax, [bp+var_6]

loc_519C7:		; Add
add	ax, 4

loc_519CA:		; Compare Two Operands
cmp	ax, [bp+var_E]

loc_519CD:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_519D5

loc_519CF:		; Logical Compare
test	[bp+var_1D], 1
jz	short loc_51960	; Jump if Zero (ZF=1)

loc_519D5:		; CODE XREF: sub_518E0:loc_519CDj
mov	ax, si

loc_519D7:
mov	dx, 3Ch	; '<'

loc_519DA:		; Signed Multiply
imul	dx

loc_519DC:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_0]

loc_519DF:		; Add
add	bx, ax
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx+4], 0FFh ; Compare Two Operands
jz	short loc_51A27	; Jump if Zero (ZF=1)
test	[bp+var_1D], 1	; Logical Compare
jnz	short loc_51A27	; Jump if Not Zero (ZF=0)
mov	ax, si
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx+4], 0FFh ; Compare Two Operands

loc_51A06:		; Jump if Not Zero (ZF=0)
jnz	short loc_51A1F

loc_51A08:
mov	ax, si
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx+3], 0FFh ; Compare Two Operands
jz	short loc_51A27	; Jump if Zero (ZF=1)

loc_51A1F:		; CODE XREF: sub_518E0:loc_51A06j
mov	al, [bp+var_1D]
or	al, 1		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51A27:		; CODE XREF: sub_518E0+109j
			; sub_518E0+10Fj
			; sub_518E0+13Dj
test	[bp+var_1D], 1	; Logical Compare
jz	short loc_51A35	; Jump if Zero (ZF=1)
mov	al, [bp+var_1D]
or	al, 10h		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51A35:		; CODE XREF: sub_518E0+14Bj
mov	[bp+var_16], 0

loc_51A3A:
mov	[bp+var_14], 0

loc_51A3F:		; Jump
jmp	short loc_51A7B

loc_51A41:		; CODE XREF: sub_518E0+19Fj
xor	di, di		; Logical Exclusive OR
jmp	short loc_51A73	; Jump

loc_51A45:		; CODE XREF: sub_518E0+196j
mov	ax, si
add	ax, [bp+var_14]	; Add
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
add	bx, di		; Add
mov	al, [es:bx]
push	ax

loc_51A5E:
mov	ax, [bp+var_14]
mov	dx, 5
imul	dx		; Signed Multiply

loc_51A66:		; Add
add	ax, di
lea	dx, [bp+var_42]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
pop	ax
mov	[bx], al
inc	di		; Increment by 1

loc_51A73:		; CODE XREF: sub_518E0+163j
cmp	di, 5		; Compare Two Operands
jl	short loc_51A45	; Jump if Less (SF!=OF)
inc	[bp+var_14]	; Increment by 1

loc_51A7B:		; CODE XREF: sub_518E0:loc_51A3Fj
cmp	[bp+var_14], 7	; Compare Two Operands
jl	short loc_51A41	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 7	; Compare Two Operands
jnz	short loc_51A95	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_51A90	; Jump

loc_51A8B:		; CODE XREF: sub_518E0+1B3j
mov	[bp+di+var_24],	0FFh
inc	di		; Increment by 1

loc_51A90:		; CODE XREF: sub_518E0+1A9j
cmp	di, 5		; Compare Two Operands
jl	short loc_51A8B	; Jump if Less (SF!=OF)

loc_51A95:		; CODE XREF: sub_518E0+1A5j
mov	[bp+var_10], 0
jmp	short loc_51AE2	; Jump

loc_51A9C:		; CODE XREF: sub_518E0+20Cj
mov	[bp+var_1A], 0
jmp	short loc_51AD3	; Jump

loc_51AA3:		; CODE XREF: sub_518E0+1FDj
lea	ax, [bp+var_86]	; Load Effective Address
push	ax
lea	ax, [bp+var_76]	; Load Effective Address
push	ax
lea	ax, [bp+var_42]	; Load Effective Address
push	ax

loc_51AB0:
mov	ax, 7
push	ax
mov	ax, 5
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+var_1A]
mov	ax, 4
push	ax
push	[bp+var_10]

loc_51AC5:		; Call Procedure
call	sub_31B40
add	sp, 12h		; Add
add	[bp+var_16], ax	; Add
inc	[bp+var_1A]	; Increment by 1

loc_51AD3:		; CODE XREF: sub_518E0+1C1j
cmp	[bp+var_1A], 5	; Compare Two Operands
jge	short loc_51ADF	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_51AA3	; Jump if Zero (ZF=1)

loc_51ADF:		; CODE XREF: sub_518E0+1F7j
inc	[bp+var_10]	; Increment by 1

loc_51AE2:		; CODE XREF: sub_518E0+1BAj
cmp	[bp+var_10], 5	; Compare Two Operands
jge	short loc_51AEE	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_51A9C	; Jump if Zero (ZF=1)

loc_51AEE:		; CODE XREF: sub_518E0+206j
cmp	[bp+var_16], 0	; Compare Two Operands
jnz	short loc_51AFC	; Jump if Not Zero (ZF=0)
mov	al, [bp+var_1D]
and	al, 0FEh	; Logical AND
mov	[bp+var_1D], al

loc_51AFC:		; CODE XREF: sub_518E0:loc_5190Aj
			; sub_518E0+212j
cmp	[bp+var_2], 7	; Compare Two Operands

loc_51B00:		; Jump if Not Zero (ZF=0)
jnz	short loc_51B05
jmp	loc_51D0C	; Jump

loc_51B05:		; CODE XREF: sub_518E0:loc_51B00j
mov	ax, si
add	ax, 4		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51B56	; Jump if Zero (ZF=1)
mov	ax, si
add	ax, 5		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply

loc_51B27:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_0]
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51B4E	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 5		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx+1], 0FFh ; Compare Two Operands
jz	short loc_51B56	; Jump if Zero (ZF=1)

loc_51B4E:		; CODE XREF: sub_518E0+253j
mov	al, [bp+var_1D]
or	al, 4		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51B56:		; CODE XREF: sub_518E0+23Bj
			; sub_518E0+26Cj
mov	ax, [bp+var_6]
inc	ax		; Increment by 1
mov	[bp+var_E], ax

loc_51B5D:		; Jump
jmp	short loc_51BCC

loc_51B5F:		; CODE XREF: sub_518E0+2FBj
mov	ax, si
add	ax, 4		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_E]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51BC9	; Jump if Zero (ZF=1)
mov	ax, si
add	ax, 5		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_E]	; Add
cmp	[byte ptr es:bx-1], 0FFh ; Compare Two Operands
jnz	short loc_51BC1	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 5		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx

loc_51B9D:		; Add
add	bx, ax
add	bx, [bp+var_E]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51BC1	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 5		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_E]	; Add
cmp	[byte ptr es:bx+1], 0FFh ; Compare Two Operands
jz	short loc_51BC9	; Jump if Zero (ZF=1)

loc_51BC1:		; CODE XREF: sub_518E0+2AEj
			; sub_518E0+2C6j
mov	al, [bp+var_1D]

loc_51BC4:		; Logical Inclusive OR
or	al, 4
mov	[bp+var_1D], al

loc_51BC9:		; CODE XREF: sub_518E0+295j
			; sub_518E0+2DFj
inc	[bp+var_E]	; Increment by 1

loc_51BCC:		; CODE XREF: sub_518E0:loc_51B5Dj
mov	ax, [bp+var_6]
add	ax, 4		; Add
cmp	ax, [bp+var_E]	; Compare Two Operands
jle	short loc_51BDD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
test	[bp+var_1D], 4	; Logical Compare
jz	short loc_51B5F	; Jump if Zero (ZF=1)

loc_51BDD:		; CODE XREF: sub_518E0+2F5j
mov	ax, si

loc_51BDF:		; Add
add	ax, 4

loc_51BE2:
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx

loc_51BEA:		; Add
add	bx, ax
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx+4], 0FFh ; Compare Two Operands
jz	short loc_51C36	; Jump if Zero (ZF=1)
test	[bp+var_1D], 4	; Logical Compare
jnz	short loc_51C36	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 5		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx+4], 0FFh ; Compare Two Operands
jnz	short loc_51C2E	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 5		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx+3], 0FFh ; Compare Two Operands
jz	short loc_51C36	; Jump if Zero (ZF=1)

loc_51C2E:		; CODE XREF: sub_518E0+333j
mov	al, [bp+var_1D]
or	al, 4		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51C36:		; CODE XREF: sub_518E0+314j
			; sub_518E0+31Aj
			; sub_518E0+34Cj
test	[bp+var_1D], 4	; Logical Compare
jz	short loc_51C44	; Jump if Zero (ZF=1)
mov	al, [bp+var_1D]
or	al, 40h		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51C44:		; CODE XREF: sub_518E0+35Aj
mov	[bp+var_16], 0
mov	[bp+var_14], 0
jmp	short loc_51C8A	; Jump

loc_51C50:		; CODE XREF: sub_518E0+3AEj
xor	di, di		; Logical Exclusive OR
jmp	short loc_51C82	; Jump

loc_51C54:		; CODE XREF: sub_518E0+3A5j
mov	ax, si
add	ax, [bp+var_14]	; Add
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
add	bx, di		; Add
mov	al, [es:bx]
push	ax
mov	ax, [bp+var_14]
mov	dx, 5
imul	dx		; Signed Multiply
add	ax, di		; Add
lea	dx, [bp+var_42]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
pop	ax
mov	[bx], al
inc	di		; Increment by 1

loc_51C82:		; CODE XREF: sub_518E0+372j
cmp	di, 5		; Compare Two Operands
jl	short loc_51C54	; Jump if Less (SF!=OF)
inc	[bp+var_14]	; Increment by 1

loc_51C8A:		; CODE XREF: sub_518E0+36Ej
cmp	[bp+var_14], 7	; Compare Two Operands
jl	short loc_51C50	; Jump if Less (SF!=OF)
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_51CA4	; Jump if Not Zero (ZF=0)
xor	di, di		; Logical Exclusive OR
jmp	short loc_51C9F	; Jump

loc_51C9A:		; CODE XREF: sub_518E0+3C2j
mov	[byte ptr bp+di+var_42], 0FFh
inc	di		; Increment by 1

loc_51C9F:		; CODE XREF: sub_518E0+3B8j
cmp	di, 5		; Compare Two Operands
jl	short loc_51C9A	; Jump if Less (SF!=OF)

loc_51CA4:		; CODE XREF: sub_518E0+3B4j
mov	[bp+var_10], 0
jmp	short loc_51CF2	; Jump

loc_51CAB:		; CODE XREF: sub_518E0+41Cj
mov	[bp+var_1A], 0
jmp	short loc_51CE3	; Jump

loc_51CB2:		; CODE XREF: sub_518E0+40Dj
lea	ax, [bp+var_86]	; Load Effective Address
push	ax
lea	ax, [bp+var_76]	; Load Effective Address

loc_51CBA:
push	ax
lea	ax, [bp+var_42]	; Load Effective Address
push	ax
mov	ax, 7
push	ax
mov	ax, 5
push	ax

loc_51CC7:
mov	ax, 6
push	ax
push	[bp+var_1A]
mov	ax, 2

loc_51CD1:
push	ax
push	[bp+var_10]
call	sub_31B40	; Call Procedure
add	sp, 12h		; Add
add	[bp+var_16], ax	; Add
inc	[bp+var_1A]	; Increment by 1

loc_51CE3:		; CODE XREF: sub_518E0+3D0j
cmp	[bp+var_1A], 5	; Compare Two Operands
jge	short loc_51CEF	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_51CB2	; Jump if Zero (ZF=1)

loc_51CEF:		; CODE XREF: sub_518E0+407j
inc	[bp+var_10]	; Increment by 1

loc_51CF2:		; CODE XREF: sub_518E0+3C9j
cmp	[bp+var_10], 5	; Compare Two Operands
jge	short loc_51CFE	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_51CAB	; Jump if Zero (ZF=1)

loc_51CFE:		; CODE XREF: sub_518E0+416j
cmp	[bp+var_16], 0	; Compare Two Operands
jnz	short loc_51D0C	; Jump if Not Zero (ZF=0)
mov	al, [bp+var_1D]
and	al, 0FBh	; Logical AND
mov	[bp+var_1D], al

loc_51D0C:		; CODE XREF: sub_518E0+222j
			; sub_518E0+422j
mov	ax, [bp+var_6]
dec	ax		; Decrement by 1
mov	[bp+var_18], ax
cmp	[bp+var_18], 0	; Compare Two Operands
jge	short loc_51D1D	; Jump if Greater or Equal (SF=OF)
add	[bp+var_18], 3Ch ; '<' ; Add

loc_51D1D:		; CODE XREF: sub_518E0+437j
mov	ax, si

loc_51D1F:
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51D65	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51D5D	; Jump if Not Zero (ZF=0)
mov	ax, si
inc	ax		; Increment by 1

loc_51D4A:
mov	dx, 3Ch	; '<'

loc_51D4D:		; Signed Multiply
imul	dx
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51D65	; Jump if Zero (ZF=1)

loc_51D5D:		; CODE XREF: sub_518E0+465j
mov	al, [bp+var_1D]
or	al, 8		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51D65:		; CODE XREF: sub_518E0+450j
			; sub_518E0+47Bj
mov	ax, si
inc	ax		; Increment by 1
mov	[bp+var_C], ax
jmp	short loc_51DD2	; Jump

loc_51D6D:		; CODE XREF: sub_518E0+500j
mov	ax, [bp+var_C]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51DCF	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx

loc_51D8F:		; Add
add	bx, ax
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51DC7	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_C]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_51DA7:		; Add
add	bx, [bp+var_18]
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51DC7	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_C]
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51DCF	; Jump if Zero (ZF=1)

loc_51DC7:		; CODE XREF: sub_518E0+4B8j
			; sub_518E0+4CEj
mov	al, [bp+var_1D]
or	al, 8		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51DCF:		; CODE XREF: sub_518E0+4A1j
			; sub_518E0+4E5j
inc	[bp+var_C]	; Increment by 1

loc_51DD2:		; CODE XREF: sub_518E0+48Bj
mov	ax, si
add	ax, 4		; Add
cmp	ax, [bp+var_C]	; Compare Two Operands
jle	short loc_51DE2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
test	[bp+var_1D], 8	; Logical Compare
jz	short loc_51D6D	; Jump if Zero (ZF=1)

loc_51DE2:		; CODE XREF: sub_518E0+4FAj
mov	ax, si
add	ax, 4		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51E38	; Jump if Zero (ZF=1)
test	[bp+var_1D], 8	; Logical Compare
jnz	short loc_51E38	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 4		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51E30	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 3		; Add
mov	dx, 3Ch	; '<'

loc_51E20:		; Signed Multiply
imul	dx
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51E38	; Jump if Zero (ZF=1)

loc_51E30:		; CODE XREF: sub_518E0+536j
mov	al, [bp+var_1D]
or	al, 8		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51E38:		; CODE XREF: sub_518E0+518j
			; sub_518E0+51Ej
			; sub_518E0+54Ej
test	[bp+var_1D], 8	; Logical Compare
jz	short loc_51E46	; Jump if Zero (ZF=1)
mov	al, [bp+var_1D]
or	al, 80h		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51E46:		; CODE XREF: sub_518E0+55Cj
mov	[bp+var_16], 0
mov	[bp+var_14], 0
jmp	short loc_51E8C	; Jump

loc_51E52:		; CODE XREF: sub_518E0:loc_51E90j
xor	di, di		; Logical Exclusive OR
jmp	short loc_51E84	; Jump

loc_51E56:		; CODE XREF: sub_518E0+5A7j
mov	ax, si
add	ax, [bp+var_14]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
add	bx, di		; Add
mov	al, [es:bx-1]
push	ax
mov	ax, [bp+var_14]
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, di		; Add
lea	dx, [bp+var_66]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
pop	ax
mov	[bx], al
inc	di		; Increment by 1

loc_51E84:		; CODE XREF: sub_518E0+574j
cmp	di, 7		; Compare Two Operands
jl	short loc_51E56	; Jump if Less (SF!=OF)
inc	[bp+var_14]	; Increment by 1

loc_51E8C:		; CODE XREF: sub_518E0+570j
cmp	[bp+var_14], 5	; Compare Two Operands

loc_51E90:		; Jump if Less (SF!=OF)
jl	short loc_51E52
cmp	[bp+var_4], 0	; Compare Two Operands
jnz	short loc_51ECF	; Jump if Not Zero (ZF=0)
mov	[bp+var_14], 0
jmp	short loc_51EC9	; Jump

loc_51E9F:		; CODE XREF: sub_518E0+5EDj
mov	ax, [bp+var_14]
mov	dx, 7
imul	dx		; Signed Multiply
lea	dx, [bp+var_66]	; Load Effective Address
add	ax, dx		; Add
push	ax
mov	ax, si
add	ax, [bp+var_14]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_51EBC:		; Add
add	bx, [bp+var_6]
mov	al, [es:bx+3Bh]
pop	bx
mov	[bx], al
inc	[bp+var_14]	; Increment by 1

loc_51EC9:		; CODE XREF: sub_518E0+5BDj
cmp	[bp+var_14], 5	; Compare Two Operands
jl	short loc_51E9F	; Jump if Less (SF!=OF)

loc_51ECF:		; CODE XREF: sub_518E0+5B6j
mov	[bp+var_12], 0
jmp	short loc_51F1C	; Jump

loc_51ED6:		; CODE XREF: sub_518E0+646j
mov	[bp+var_1C], 0
jmp	short loc_51F0D	; Jump

loc_51EDD:		; CODE XREF: sub_518E0+637j
lea	ax, [bp+var_86]	; Load Effective Address
push	ax
lea	ax, [bp+var_76]	; Load Effective Address
push	ax
lea	ax, [bp+var_66]	; Load Effective Address
push	ax
mov	ax, 5
push	ax
mov	ax, 7
push	ax
push	[bp+var_1C]
xor	ax, ax		; Logical Exclusive OR
push	ax
push	[bp+var_12]
mov	ax, 4
push	ax
call	sub_31B40	; Call Procedure
add	sp, 12h		; Add
add	[bp+var_16], ax	; Add
inc	[bp+var_1C]	; Increment by 1

loc_51F0D:		; CODE XREF: sub_518E0+5FBj
cmp	[bp+var_1C], 5	; Compare Two Operands
jge	short loc_51F19	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_51EDD	; Jump if Zero (ZF=1)

loc_51F19:		; CODE XREF: sub_518E0+631j
inc	[bp+var_12]	; Increment by 1

loc_51F1C:		; CODE XREF: sub_518E0+5F4j
cmp	[bp+var_12], 5	; Compare Two Operands

loc_51F20:		; Jump if Greater or Equal (SF=OF)
jge	short loc_51F28
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_51ED6	; Jump if Zero (ZF=1)

loc_51F28:		; CODE XREF: sub_518E0:loc_51F20j
cmp	[bp+var_16], 0	; Compare Two Operands
jnz	short loc_51F36	; Jump if Not Zero (ZF=0)
mov	al, [bp+var_1D]
and	al, 0F7h	; Logical AND
mov	[bp+var_1D], al

loc_51F36:		; CODE XREF: sub_518E0+64Cj
mov	ax, [bp+var_6]
inc	ax		; Increment by 1
mov	[bp+var_18], ax
cmp	[bp+var_18], 3Ch ; '<' ; Compare Two Operands
jl	short loc_51F47	; Jump if Less (SF!=OF)
sub	[bp+var_18], 3Ch ; '<' ; Integer Subtraction

loc_51F47:		; CODE XREF: sub_518E0+661j
mov	ax, si
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51F8F	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_51F68:		; Add
add	bx, [bp+var_18]
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51F87	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_51F73:		; DATA XREF: __exec+CEr
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51F8F	; Jump if Zero (ZF=1)

loc_51F87:		; CODE XREF: sub_518E0+68Fj
mov	al, [bp+var_1D]
or	al, 2		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51F8F:		; CODE XREF: sub_518E0+67Aj
			; sub_518E0+6A5j
mov	ax, si
inc	ax		; Increment by 1
mov	[bp+var_C], ax
jmp	short loc_51FFC	; Jump

loc_51F97:		; CODE XREF: sub_518E0+72Aj
mov	ax, [bp+var_C]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51FF9	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
dec	ax		; Decrement by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51FF1	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_C]
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_51FF1	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_C]
inc	ax		; Increment by 1
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_51FF9	; Jump if Zero (ZF=1)

loc_51FF1:		; CODE XREF: sub_518E0+6E2j
			; sub_518E0+6F8j
mov	al, [bp+var_1D]
or	al, 2		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_51FF9:		; CODE XREF: sub_518E0+6CBj
			; sub_518E0+70Fj
inc	[bp+var_C]	; Increment by 1

loc_51FFC:		; CODE XREF: sub_518E0+6B5j
mov	ax, si
add	ax, 4		; Add
cmp	ax, [bp+var_C]	; Compare Two Operands
jle	short loc_5200C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
test	[bp+var_1D], 2	; Logical Compare
jz	short loc_51F97	; Jump if Zero (ZF=1)

loc_5200C:		; CODE XREF: sub_518E0+724j
mov	ax, si
add	ax, 4		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_52062	; Jump if Zero (ZF=1)
test	[bp+var_1D], 2	; Logical Compare
jnz	short loc_52062	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 4		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jnz	short loc_5205A	; Jump if Not Zero (ZF=0)
mov	ax, si
add	ax, 3		; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_18]	; Add
cmp	[byte ptr es:bx], 0FFh ; Compare Two Operands
jz	short loc_52062	; Jump if Zero (ZF=1)

loc_5205A:		; CODE XREF: sub_518E0+760j
mov	al, [bp+var_1D]
or	al, 2		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_52062:		; CODE XREF: sub_518E0+742j
			; sub_518E0+748j
			; sub_518E0+778j
test	[bp+var_1D], 2	; Logical Compare
jz	short loc_52070	; Jump if Zero (ZF=1)
mov	al, [bp+var_1D]
or	al, 20h		; Logical Inclusive OR
mov	[bp+var_1D], al

loc_52070:		; CODE XREF: sub_518E0+786j
mov	[bp+var_16], 0
mov	[bp+var_14], 0
jmp	short loc_520B6	; Jump

loc_5207C:		; CODE XREF: sub_518E0+7DAj
xor	di, di		; Logical Exclusive OR
jmp	short loc_520AE	; Jump

loc_52080:		; CODE XREF: sub_518E0+7D1j
mov	ax, si
add	ax, [bp+var_14]	; Add
mov	dx, 3Ch	; '<'
imul	dx		; Signed Multiply
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
add	bx, di		; Add
mov	al, [es:bx-1]
push	ax
mov	ax, [bp+var_14]
mov	dx, 7
imul	dx		; Signed Multiply
add	ax, di		; Add
lea	dx, [bp+var_66]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
pop	ax
mov	[bx], al
inc	di		; Increment by 1

loc_520AE:		; CODE XREF: sub_518E0+79Ej
cmp	di, 7		; Compare Two Operands
jl	short loc_52080	; Jump if Less (SF!=OF)
inc	[bp+var_14]	; Increment by 1

loc_520B6:		; CODE XREF: sub_518E0+79Aj
cmp	[bp+var_14], 5	; Compare Two Operands
jl	short loc_5207C	; Jump if Less (SF!=OF)
cmp	[bp+var_4], 0Bh	; Compare Two Operands
jnz	short loc_520F5	; Jump if Not Zero (ZF=0)
mov	[bp+var_14], 0
jmp	short loc_520EF	; Jump

loc_520C9:		; CODE XREF: sub_518E0+813j
mov	ax, [bp+var_14]

loc_520CC:
mov	dx, 7
imul	dx		; Signed Multiply
lea	dx, [bp+var_60]	; Load Effective Address
add	ax, dx		; Add
push	ax
mov	ax, si
add	ax, [bp+var_14]	; Add
mov	dx, 3Ch	; '<'

loc_520DF:		; Signed Multiply
imul	dx
les	bx, [bp+arg_0]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
pop	bx
mov	[bx], al
inc	[bp+var_14]	; Increment by 1

loc_520EF:		; CODE XREF: sub_518E0+7E7j
cmp	[bp+var_14], 5	; Compare Two Operands
jl	short loc_520C9	; Jump if Less (SF!=OF)

loc_520F5:		; CODE XREF: sub_518E0+7E0j
mov	[bp+var_12], 0
jmp	short loc_52143	; Jump

loc_520FC:		; CODE XREF: sub_518E0+86Dj
mov	[bp+var_1C], 0
jmp	short loc_52134	; Jump

loc_52103:		; CODE XREF: sub_518E0+85Ej
lea	ax, [bp+var_86]	; Load Effective Address
push	ax
lea	ax, [bp+var_76]	; Load Effective Address
push	ax
lea	ax, [bp+var_66]	; Load Effective Address
push	ax
mov	ax, 5
push	ax
mov	ax, 7
push	ax
push	[bp+var_1C]
mov	ax, 6
push	ax

loc_5211F:
push	[bp+var_12]
mov	ax, 2
push	ax
call	sub_31B40	; Call Procedure
add	sp, 12h		; Add
add	[bp+var_16], ax	; Add
inc	[bp+var_1C]	; Increment by 1

loc_52134:		; CODE XREF: sub_518E0+821j
cmp	[bp+var_1C], 5	; Compare Two Operands
jge	short loc_52140	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_52103	; Jump if Zero (ZF=1)

loc_52140:		; CODE XREF: sub_518E0+858j
inc	[bp+var_12]	; Increment by 1

loc_52143:		; CODE XREF: sub_518E0+81Aj
cmp	[bp+var_12], 5	; Compare Two Operands
jge	short loc_5214F	; Jump if Greater or Equal (SF=OF)
cmp	[bp+var_16], 0	; Compare Two Operands
jz	short loc_520FC	; Jump if Zero (ZF=1)

loc_5214F:		; CODE XREF: sub_518E0+867j
cmp	[bp+var_16], 0	; Compare Two Operands
jnz	short loc_5215D	; Jump if Not Zero (ZF=0)
mov	al, [bp+var_1D]
and	al, 0FDh	; Logical AND
mov	[bp+var_1D], al

loc_5215D:		; CODE XREF: sub_518E0+873j
mov	ax, [bp+var_2]
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_4]	; Add
mov	al, [bp+var_1D]
mov	[es:bx], al
add	[bp+var_6], 5	; Add
inc	[bp+var_4]	; Increment by 1

loc_5217A:		; CODE XREF: sub_518E0:loc_518FDj
cmp	[bp+var_4], 0Ch	; Compare Two Operands
jge	short loc_52183	; Jump if Greater or Equal (SF=OF)
jmp	loc_51900	; Jump

loc_52183:		; CODE XREF: sub_518E0+89Ej
add	si, 5		; Add
inc	[bp+var_2]	; Increment by 1

loc_52189:		; CODE XREF: sub_518E0:loc_518F0j
cmp	[bp+var_2], 8	; Compare Two Operands
jge	short loc_52192	; Jump if Greater or Equal (SF=OF)

loc_5218F:		; Jump
jmp	loc_518F3

loc_52192:		; CODE XREF: sub_518E0+8ADj
mov	[bp+var_A], 0
jmp	loc_522D1	; Jump

loc_5219A:		; CODE XREF: sub_518E0+9F7j
mov	[bp+var_8], 0
jmp	loc_522C5	; Jump

loc_521A2:		; CODE XREF: sub_518E0+9EBj
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
test	[byte ptr es:bx], 1 ; Logical Compare
jz	short loc_521EA	; Jump if Zero (ZF=1)
cmp	[bp+var_A], 0	; Compare Two Operands
jz	short loc_521EA	; Jump if Zero (ZF=1)
mov	ax, [bp+var_A]
dec	ax		; Decrement by 1
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
mov	al, [es:bx]
or	al, 4		; Logical Inclusive OR
push	ax
mov	ax, [bp+var_A]
dec	ax		; Decrement by 1
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx

loc_521E1:		; Add
add	bx, ax
add	bx, [bp+var_8]	; Add
pop	ax
mov	[es:bx], al

loc_521EA:		; CODE XREF: sub_518E0+8D6j
			; sub_518E0+8DCj
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
test	[byte ptr es:bx], 4 ; Logical Compare
jz	short loc_52232	; Jump if Zero (ZF=1)
cmp	[bp+var_A], 7	; Compare Two Operands
jge	short loc_52232	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_A]
inc	ax		; Increment by 1
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
mov	al, [es:bx]
or	al, 1		; Logical Inclusive OR
push	ax
mov	ax, [bp+var_A]
inc	ax		; Increment by 1
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
pop	ax
mov	[es:bx], al

loc_52232:		; CODE XREF: sub_518E0+91Ej
			; sub_518E0+924j
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add

loc_5223F:		; Add
add	bx, [bp+var_8]
test	[byte ptr es:bx], 8 ; Logical Compare
jz	short loc_5227A	; Jump if Zero (ZF=1)
cmp	[bp+var_8], 0	; Compare Two Operands
jz	short loc_5227A	; Jump if Zero (ZF=1)
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
mov	al, [es:bx-1]
or	al, 2		; Logical Inclusive OR
push	ax
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply

loc_5226D:		; Load Full Pointer to ES:xx
les	bx, [bp+arg_4]
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
pop	ax
mov	[es:bx-1], al

loc_5227A:		; CODE XREF: sub_518E0+966j
			; sub_518E0+96Cj
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
test	[byte ptr es:bx], 2 ; Logical Compare
jz	short loc_522C2	; Jump if Zero (ZF=1)
cmp	[bp+var_A], 0Bh	; Compare Two Operands
jge	short loc_522C2	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
mov	al, [es:bx+1]
or	al, 8		; Logical Inclusive OR
push	ax
mov	ax, [bp+var_A]
mov	dx, 0Ch
imul	dx		; Signed Multiply
les	bx, [bp+arg_4]	; Load Full Pointer to ES:xx
add	bx, ax		; Add
add	bx, [bp+var_8]	; Add
pop	ax
mov	[es:bx+1], al

loc_522C2:		; CODE XREF: sub_518E0+9AEj
			; sub_518E0+9B4j
inc	[bp+var_8]	; Increment by 1

loc_522C5:		; CODE XREF: sub_518E0+8BFj
cmp	[bp+var_8], 0Ch	; Compare Two Operands
jge	short loc_522CE	; Jump if Greater or Equal (SF=OF)
jmp	loc_521A2	; Jump

loc_522CE:		; CODE XREF: sub_518E0+9E9j
inc	[bp+var_A]	; Increment by 1

loc_522D1:		; CODE XREF: sub_518E0+8B7j
cmp	[bp+var_A], 8	; Compare Two Operands
jge	short loc_522DA	; Jump if Greater or Equal (SF=OF)
jmp	loc_5219A	; Jump

loc_522DA:		; CODE XREF: sub_518E0+9F5j
pop	di
pop	si
mov	sp, bp

loc_522DE:
pop	bp
retf			; Return Far from Procedure
endp sub_518E0

ends ovr055


; Segment type:	Pure code
segment	ovr056 para public 'OVERLAY' use16
assume cs:ovr056
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_522E0 far	; CODE XREF: sub_31BB0J
push	bp

loc_522E1:
mov	bp, sp

loc_522E3:
push	si

loc_522E4:
push	di

loc_522E5:		; No Operation
nop

loc_522E6:
push	cs

loc_522E7:		; Call Procedure
call	near ptr sub_5301E

loc_522EA:
mov	di, 1

loc_522ED:		; Jump
jmp	loc_52386

loc_522F0:		; CODE XREF: sub_522E0:loc_5238Cj
xor	si, si		; Logical Exclusive OR

loc_522F2:		; Jump
jmp	loc_5237D

loc_522F5:		; CODE XREF: sub_522E0+A2j
mov	ax, di

loc_522F7:
mov	dx, 82h	; ''

loc_522FA:		; Signed Multiply
imul	dx

loc_522FC:
mov	dx, si

loc_522FE:		; Shift	Logical	Left
shl	dx, 1

loc_52300:		; Add
add	ax, dx

loc_52302:
mov	bx, si

loc_52304:		; Shift	Logical	Left
shl	bx, 1

loc_52306:
mov	dx, [bx+2C6Ah]

loc_5230A:
mov	bx, ax

loc_5230C:
mov	[bx-75BEh], dx

loc_52310:
mov	ax, di

loc_52312:
mov	dx, 82h	; ''
imul	dx		; Signed Multiply

loc_52317:
mov	dx, si

loc_52319:		; Shift	Logical	Left
shl	dx, 1

loc_5231B:		; Add
add	ax, dx

loc_5231D:
mov	bx, si

loc_5231F:		; Shift	Logical	Left
shl	bx, 1

loc_52321:
mov	dx, [bx+2C84h]

loc_52325:
mov	bx, ax

loc_52327:
mov	[bx-75A4h], dx

loc_5232B:
mov	ax, di

loc_5232D:
mov	dx, 82h	; ''

loc_52330:		; Signed Multiply
imul	dx

loc_52332:
mov	dx, si
shl	dx, 1		; Shift	Logical	Left

loc_52336:		; Add
add	ax, dx

loc_52338:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_5233C:
mov	dx, [bx+2C9Eh]

loc_52340:
mov	bx, ax

loc_52342:
mov	[bx-758Ah], dx

loc_52346:
mov	ax, di

loc_52348:
mov	dx, 82h	; ''

loc_5234B:		; Signed Multiply
imul	dx
mov	dx, si

loc_5234F:		; Shift	Logical	Left
shl	dx, 1

loc_52351:		; Add
add	ax, dx

loc_52353:
mov	bx, si
shl	bx, 1		; Shift	Logical	Left

loc_52357:
mov	dx, [bx+2CB8h]
mov	bx, ax

loc_5235D:
mov	[bx-7570h], dx

loc_52361:
mov	ax, di

loc_52363:
mov	dx, 82h	; ''
imul	dx		; Signed Multiply

loc_52368:
mov	dx, si

loc_5236A:		; Shift	Logical	Left
shl	dx, 1

loc_5236C:		; Add
add	ax, dx

loc_5236E:
mov	bx, si

loc_52370:		; Shift	Logical	Left
shl	bx, 1

loc_52372:
mov	dx, [bx+2CD2h]

loc_52376:
mov	bx, ax

loc_52378:
mov	[bx-7556h], dx
inc	si		; Increment by 1

loc_5237D:		; CODE XREF: sub_522E0:loc_522F2j
cmp	si, 0Dh		; Compare Two Operands

loc_52380:		; Jump if Greater or Equal (SF=OF)
jge	short loc_52385
jmp	loc_522F5	; Jump

loc_52385:		; CODE XREF: sub_522E0:loc_52380j
inc	di		; Increment by 1

loc_52386:		; CODE XREF: sub_522E0:loc_522EDj
cmp	di, [word_3A4E2] ; Compare Two Operands

loc_5238A:		; Jump if Greater or Equal (SF=OF)
jge	short loc_5238F

loc_5238C:		; Jump
jmp	loc_522F0

loc_5238F:		; CODE XREF: sub_522E0:loc_5238Aj
nop			; No Operation

loc_52390:
push	cs
call	near ptr sub_53A06 ; Call Procedure

loc_52394:
mov	[byte_3A14C], 0

loc_52399:
mov	[word_39E40], 0

loc_5239F:
pop	di

loc_523A0:
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_522E0



; Attributes: bp-based frame

proc sub_523A3 far	; CODE XREF: sub_31BB5J
push	bp
mov	bp, sp
push	si

loc_523A7:
mov	ax, 64h	; 'd'
push	ax

loc_523AB:		; Call Procedure
call	sub_319FF
pop	cx
nop			; No Operation
push	cs
call	near ptr sub_5266E ; Call Procedure
nop			; No Operation

loc_523B7:
push	cs
call	near ptr sub_5474D ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_52CE7 ; Call Procedure

loc_523C0:		; No Operation
nop
push	cs

loc_523C2:		; Call Procedure
call	near ptr sub_52C4D

loc_523C5:		; No Operation
nop
push	cs

loc_523C7:		; Call Procedure
call	near ptr sub_52792
nop			; No Operation

loc_523CB:
push	cs

loc_523CC:		; Call Procedure
call	near ptr sub_526A6
nop			; No Operation

loc_523D0:
push	cs

loc_523D1:		; Call Procedure
call	near ptr sub_54DC9
xor	si, si		; Logical Exclusive OR

loc_523D6:		; Jump
jmp	short loc_523F9

loc_523D8:		; CODE XREF: sub_523A3+5Aj
mov	ax, si

loc_523DA:
mov	dx, 72h	; 'r'

loc_523DD:		; Signed Multiply
imul	dx

loc_523DF:		; Load Full Pointer to ES:xx
les	bx, [dword_3A6E2]
add	bx, ax		; Add
mov	al, [es:bx+0Eh]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[byte_38625+bx], al
inc	si		; Increment by 1

loc_523F9:		; CODE XREF: sub_523A3:loc_523D6j
cmp	si, [word_3A4E2] ; Compare Two Operands
jl	short loc_523D8	; Jump if Less (SF!=OF)
nop			; No Operation
push	cs
call	near ptr sub_5244A ; Call Procedure

loc_52404:
mov	ax, 5

loc_52407:		; Integer Subtraction
sub	ax, [word_3A4DC]
mov	dx, 25

loc_5240E:		; Signed Multiply
imul	dx
mov	[word_38966], ax
mov	si, 1
jmp	short loc_52441	; Jump

loc_52418:		; CODE XREF: sub_523A3+A2j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word_38966+bx], 96h ; ''
mov	ax, 28h	; '('
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
add	ax, 50h	; 'P'   ; Add
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
mov	bx, [word_3772A]
add	bx, dx		; Add
mov	[bx], ax
inc	si		; Increment by 1

loc_52441:		; CODE XREF: sub_523A3+73j
cmp	si, [word_3A4E2] ; Compare Two Operands
jl	short loc_52418	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_523A3



; Attributes: bp-based frame

proc sub_5244A far	; CODE XREF: sub_31BFBJ
			; sub_523A3+5Ep

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
push	si
push	di
mov	[word_38468], 0
xor	di, di		; Logical Exclusive OR
jmp	loc_5265F	; Jump

loc_5245D:		; CODE XREF: sub_5244A+21Bj
mov	ax, di
inc	ax		; Increment by 1

loc_52460:
mov	si, ax
jmp	loc_52655	; Jump

loc_52465:		; CODE XREF: sub_5244A+211j
xor	cx, cx		; Logical Exclusive OR

loc_52467:
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6962h]
mov	[bp+var_2], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_5247E:
mov	bx, ax
mov	ax, [bx+6962h]
cmp	ax, [bp+var_2]	; Compare Two Operands
jle	short loc_52499	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_52490:
mov	bx, ax
mov	ax, [bx+6962h]
mov	[bp+var_2], ax

loc_52499:		; CODE XREF: sub_5244A+3Dj
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_524A2:
mov	ax, [bx+6960h]
mov	[bp+var_4], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_524B2:
mov	ax, [bx+6960h]
add	[bp+var_4], ax	; Add
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_524C2:
mov	ax, [bx+695Eh]
mov	[bp+var_6], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Eh]
cmp	ax, [bp+var_6]	; Compare Two Operands
jle	short loc_524EB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h

loc_524E0:		; Signed Multiply
imul	dx
mov	bx, ax
mov	ax, [bx+695Eh]
mov	[bp+var_6], ax

loc_524EB:		; CODE XREF: sub_5244A+8Fj
xor	cx, cx		; Logical Exclusive OR
cmp	[bp+var_4], 0	; Compare Two Operands
jle	short loc_52504	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_2], 0	; Compare Two Operands
jle	short loc_52504	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_4]
add	ax, [bp+var_2]	; Add

loc_524FF:
mov	dx, 5
jmp	short loc_52511	; Jump

loc_52504:		; CODE XREF: sub_5244A+A7j
			; sub_5244A+ADj
mov	ax, [bp+var_4]
shl	ax, 1		; Shift	Logical	Left
add	cx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 3

loc_52511:		; CODE XREF: sub_5244A+B8j
imul	dx		; Signed Multiply
sub	cx, ax		; Integer Subtraction

loc_52515:
mov	ax, [bp+var_6]
shl	ax, 1		; Shift	Logical	Left
sub	cx, ax		; Integer Subtraction
mov	ax, si

loc_5251E:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_52525:
mov	ax, [bx+695Ch]
mov	[bp+var_8], ax
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ch]
mov	[bp+var_A], ax
mov	ax, [bp+var_A]
cmp	ax, [bp+var_8]	; Compare Two Operands
jge	short loc_5254A	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_A]
mov	[bp+var_8], ax

loc_5254A:		; CODE XREF: sub_5244A+F8j
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	cx, ax		; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Eh]

loc_5255E:
mov	[bp+var_8], ax
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Eh]
mov	[bp+var_A], ax
mov	ax, [bp+var_A]
cmp	ax, [bp+var_8]	; Compare Two Operands
jge	short loc_5257F	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_A]
mov	[bp+var_8], ax

loc_5257F:		; CODE XREF: sub_5244A+12Dj
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	cx, ax		; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_5258F:
mov	ax, [bx+695Ah]
mov	[bp+var_8], ax
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_5259D:
mov	bx, ax
mov	ax, [bx+695Ah]
mov	[bp+var_A], ax
mov	ax, [bp+var_A]
cmp	ax, [bp+var_8]	; Compare Two Operands
jge	short loc_525B4	; Jump if Greater or Equal (SF=OF)
mov	ax, [bp+var_A]
mov	[bp+var_8], ax

loc_525B4:		; CODE XREF: sub_5244A+162j
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	cx, ax		; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6960h]

loc_525C8:
mov	[bp+var_8], ax
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6960h]

loc_525D8:
mov	[bp+var_A], ax
mov	ax, [bp+var_A]

loc_525DE:		; Compare Two Operands
cmp	ax, [bp+var_8]

loc_525E1:		; Jump if Greater or Equal (SF=OF)
jge	short loc_525E9
mov	ax, [bp+var_A]
mov	[bp+var_8], ax

loc_525E9:		; CODE XREF: sub_5244A:loc_525E1j
mov	ax, [bp+var_8]
shl	ax, 1		; Shift	Logical	Left
add	cx, ax		; Add
db 83h,0F9h,0A6h ; <BAD>cmp	cx, 0FFA6h ; Compare Two Operands
jge	short loc_525F8	; Jump if Greater or Equal (SF=OF)
mov	cx, 0FFA6h

loc_525F8:		; CODE XREF: sub_5244A+1A9j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, si		; Add
mov	bx, ax
mov	[bx+6A52h], cl
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, di		; Add
mov	bx, ax
mov	[bx+6A52h], cl
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, si		; Add

loc_5261F:
mov	bx, ax
mov	[bx+6A82h], cl
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, di		; Add
mov	bx, ax
mov	[bx+6A82h], cl
mov	ax, di
mov	dx, 4C8h

loc_52639:		; Signed Multiply
imul	dx

loc_5263B:		; Add
add	ax, si
mov	bx, ax
mov	[byte ptr bx+6DB0h], 0
mov	ax, si
mov	dx, 4C8h

loc_52649:		; Signed Multiply
imul	dx
add	ax, di		; Add
mov	bx, ax
mov	[byte ptr bx+6DB0h], 0
inc	si		; Increment by 1

loc_52655:		; CODE XREF: sub_5244A+18j
cmp	si, [word_3A4E2] ; Compare Two Operands
jge	short loc_5265E	; Jump if Greater or Equal (SF=OF)
jmp	loc_52465	; Jump

loc_5265E:		; CODE XREF: sub_5244A+20Fj
inc	di		; Increment by 1

loc_5265F:		; CODE XREF: sub_5244A+10j
cmp	di, [word_3A4E2] ; Compare Two Operands
jge	short loc_52668	; Jump if Greater or Equal (SF=OF)
jmp	loc_5245D	; Jump

loc_52668:		; CODE XREF: sub_5244A+219j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_5244A



; Attributes: bp-based frame

proc sub_5266E far	; CODE XREF: sub_31BBAJ
			; sub_523A3+10p
push	bp
mov	bp, sp
xor	cx, cx		; Logical Exclusive OR
jmp	short loc_52689	; Jump

loc_52675:		; CODE XREF: sub_5266E+1Fj
mov	ax, cx
mov	dx, 32h	; '2'
imul	dx		; Signed Multiply
les	bx, [dword_381C0] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	[word ptr es:bx+22h], 0
inc	cx		; Increment by 1

loc_52689:		; CODE XREF: sub_5266E+5j
cmp	cx, 8Ah	; ''   ; Compare Two Operands
jl	short loc_52675	; Jump if Less (SF!=OF)

loc_5268F:		; Logical Exclusive OR
xor	cx, cx
jmp	short loc_5269E	; Jump

loc_52693:		; CODE XREF: sub_5266E+34j
les	bx, [dword_381C4] ; Load Full Pointer to ES:xx
add	bx, cx		; Add
mov	[byte ptr es:bx], 0
inc	cx		; Increment by 1

loc_5269E:		; CODE XREF: sub_5266E+23j
cmp	cx, 0FAh ; ''  ; Compare Two Operands
jl	short loc_52693	; Jump if Less (SF!=OF)

loc_526A4:
pop	bp

locret_526A5:		; Return Far from Procedure
retf
endp sub_5266E



; Attributes: bp-based frame

proc sub_526A6 far	; CODE XREF: sub_31BBFJ
			; sub_523A3:loc_523CCp
push	bp
mov	bp, sp
push	si
xor	si, si		; Logical Exclusive OR

loc_526AC:		; Jump
jmp	loc_52786

loc_526AF:		; CODE XREF: sub_526A6+E6j
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx

loc_526B9:		; Add
add	bx, ax
mov	al, [es:bx+2]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_526C8:
mov	bx, ax
pop	ax
mov	[bx+6932h], ax
mov	ax, si

loc_526D1:
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_526E7:
mov	bx, ax
pop	ax
mov	[bx+692Eh], ax
mov	ax, si
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
les	bx, [dword_3A6EE] ; Load Full Pointer to ES:xx
add	bx, ax		; Add
mov	al, [es:bx+1]
cbw			; AL ->	AX (with sign)
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax

loc_5270A:
mov	[bx+6930h], ax
les	bx, [dword_3833C] ; Load Full Pointer to ES:xx
mov	ax, [es:bx+1E10h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_5271F:
mov	bx, ax
pop	ax
mov	[bx+6922h], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ah], 0Bh ; Compare Two Operands
jz	short loc_52776	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h

loc_5273B:		; Signed Multiply
imul	dx
mov	bx, ax
cmp	[word ptr bx+695Ch], 0Bh ; Compare Two Operands
jz	short loc_52776	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h

loc_5274B:		; Signed Multiply
imul	dx

loc_5274D:
mov	bx, ax
cmp	[word ptr bx+695Eh], 0Bh ; Compare Two Operands
jz	short loc_52776	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6960h], 0Bh ; Compare Two Operands
jz	short loc_52776	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6962h], 0Bh ; Compare Two Operands
jnz	short loc_52785	; Jump if Not Zero (ZF=0)

loc_52776:		; CODE XREF: sub_526A6+8Ej
			; sub_526A6+9Ej
			; sub_526A6+AEj
			; sub_526A6+BEj
mov	ax, si
mov	dx, 4C8h

loc_5277B:		; Signed Multiply
imul	dx
mov	bx, ax
sub	[word ptr bx+6922h], 0BB8h ; Integer Subtraction

loc_52785:		; CODE XREF: sub_526A6+CEj
inc	si		; Increment by 1

loc_52786:		; CODE XREF: sub_526A6:loc_526ACj
cmp	si, [word_3A4E2] ; Compare Two Operands
jge	short loc_5278F	; Jump if Greater or Equal (SF=OF)
jmp	loc_526AF	; Jump

loc_5278F:		; CODE XREF: sub_526A6+E4j
pop	si

loc_52790:
pop	bp
retf			; Return Far from Procedure
endp sub_526A6



; Attributes: bp-based frame

proc sub_52792 far	; CODE XREF: sub_31BC4J
			; sub_523A3:loc_523C7p

var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 26h		; Integer Subtraction
push	si
push	di

loc_5279A:
mov	[bp+var_8], 0

loc_5279F:
mov	ax, [word_3866A]
mov	[bp+var_2], ax
mov	si, 1

loc_527A8:		; Jump
jmp	short loc_527C6

loc_527AA:		; CODE XREF: sub_52792+37j
mov	bx, si

loc_527AC:		; Shift	Logical	Left
shl	bx, 1
mov	ax, [bx+695Ah]
cmp	ax, [bp+var_2]	; Compare Two Operands
jle	short loc_527C5	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_8], si
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
mov	[bp+var_2], ax

loc_527C5:		; CODE XREF: sub_52792+23j
inc	si		; Increment by 1

loc_527C6:		; CODE XREF: sub_52792:loc_527A8j
cmp	si, 5		; Compare Two Operands
jl	short loc_527AA	; Jump if Less (SF!=OF)
mov	[bp+var_A], 0
mov	ax, [word_3866A]

loc_527D3:
mov	[bp+var_2], ax
mov	si, 1
jmp	short loc_527FC	; Jump

loc_527DB:		; CODE XREF: sub_52792+6Dj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
cmp	ax, [bp+var_2]	; Compare Two Operands
jle	short loc_527FB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_527E8:		; Compare Two Operands
cmp	[bp+var_8], si

loc_527EB:		; Jump if Zero (ZF=1)
jz	short loc_527FB
mov	[bp+var_A], si
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx+695Ah]
mov	[bp+var_2], ax

loc_527FB:		; CODE XREF: sub_52792+54j
			; sub_52792:loc_527EBj
inc	si		; Increment by 1

loc_527FC:		; CODE XREF: sub_52792+47j
cmp	si, 5		; Compare Two Operands
jl	short loc_527DB	; Jump if Less (SF!=OF)
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left

loc_52806:		; Compare Two Operands
cmp	[word ptr bx+695Ah], 0
jnz	short loc_52813	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_8]

loc_52810:
mov	[bp+var_A], ax

loc_52813:		; CODE XREF: sub_52792+79j
mov	ax, [bp+var_8]
mov	[word_38AD4], ax
mov	ax, [bp+var_A]
mov	[word_38AD6], ax

loc_5281F:
mov	di, 1
jmp	loc_52C2A	; Jump

loc_52825:		; CODE XREF: sub_52792:loc_52C30j
mov	[bp+var_8], 0
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ah]
mov	[bp+var_2], ax
mov	si, 1
jmp	short loc_52871	; Jump

loc_5283F:		; CODE XREF: sub_52792+E2j
mov	ax, di
mov	dx, 4C8h

loc_52844:		; Signed Multiply
imul	dx
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+695Ah]
cmp	ax, [bp+var_2]	; Compare Two Operands
jle	short loc_52870	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_8], si
mov	ax, di

loc_5285C:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+695Ah]
mov	[bp+var_2], ax

loc_52870:		; CODE XREF: sub_52792+C3j
inc	si		; Increment by 1

loc_52871:		; CODE XREF: sub_52792+ABj
cmp	si, 5		; Compare Two Operands
jl	short loc_5283F	; Jump if Less (SF!=OF)

loc_52876:
mov	bx, [bp+var_8]
cmp	bx, 4		; switch 5 cases
ja	short loc_528D5	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_52C43+bx] ; switch jump

loc_52885:		; DATA XREF: ovr056:off_52C43o
mov	ax, di		; case 0x0
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_5288E:
mov	[byte ptr bx+6B6Ch], 2
jmp	short loc_528D5	; default

loc_52895:		; CODE XREF: sub_52792+EEj
			; DATA XREF: ovr056:off_52C43o
mov	ax, di		; case 0x3
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6BE4h], 2
jmp	short loc_528D5	; default

loc_528A5:		; CODE XREF: sub_52792+EEj
			; DATA XREF: ovr056:off_52C43o
mov	ax, di		; case 0x4
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_528AE:
mov	[byte ptr bx+6C09h], 2
jmp	short loc_528D5	; default

loc_528B5:		; CODE XREF: sub_52792+EEj
			; DATA XREF: ovr056:off_52C43o
mov	ax, di		; case 0x2
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_528BC:
mov	bx, ax
mov	[byte ptr bx+6BB7h], 2
jmp	short loc_528D5	; default

loc_528C5:		; CODE XREF: sub_52792+EEj
			; DATA XREF: ovr056:off_52C43o
mov	ax, di		; case 0x1
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6B94h], 2
jmp	short $+2	; Jump

loc_528D5:		; CODE XREF: sub_52792+EAj
			; sub_52792+101j
			; sub_52792+111j
			; sub_52792+121j
			; sub_52792+131j
cmp	[word_3A4DC], 3	; default
jge	short loc_528DF	; Jump if Greater or Equal (SF=OF)
jmp	loc_52992	; default

loc_528DF:		; CODE XREF: sub_52792+148j
mov	bx, [bp+var_8]
cmp	bx, 4		; switch 5 cases
jbe	short loc_528EA	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_52992	; default

loc_528EA:		; CODE XREF: sub_52792+153j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_52C39+bx] ; switch jump

loc_528F1:		; DATA XREF: ovr056:off_52C39o
mov	ax, di		; case 0x0
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6B77h], 0 ; Compare Two Operands
jnz	short loc_5290F	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6B77h], 1

loc_5290F:		; CODE XREF: sub_52792+16Dj
jmp	loc_52992	; default

loc_52912:		; CODE XREF: sub_52792+15Aj
			; DATA XREF: ovr056:off_52C39o
mov	ax, di		; case 0x3
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6B73h], 0 ; Compare Two Operands

loc_52920:		; Jump if Not Zero (ZF=0)
jnz	short loc_52930
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6BEBh], 1

loc_52930:		; CODE XREF: sub_52792:loc_52920j
jmp	short loc_52992	; default

loc_52932:		; CODE XREF: sub_52792+15Aj
			; DATA XREF: ovr056:off_52C39o
mov	ax, di		; case 0x4
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6B77h], 0 ; Compare Two Operands
jnz	short loc_52950	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6C17h], 1

loc_52950:		; CODE XREF: sub_52792+1AEj
jmp	short loc_52992	; default

loc_52952:		; CODE XREF: sub_52792+15Aj
			; DATA XREF: ovr056:off_52C39o
mov	ax, di		; case 0x2
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6B77h], 0 ; Compare Two Operands
jnz	short loc_52970	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_52969:
mov	bx, ax
mov	[byte ptr bx+6BC7h], 1

loc_52970:		; CODE XREF: sub_52792+1CEj
jmp	short loc_52992	; default

loc_52972:		; CODE XREF: sub_52792+15Aj
			; DATA XREF: ovr056:off_52C39o
mov	ax, di		; case 0x1
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6B77h], 0 ; Compare Two Operands
jnz	short loc_52990	; Jump if Not Zero (ZF=0)
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6B9Fh], 1

loc_52990:		; CODE XREF: sub_52792+1EEj
jmp	short $+2	; Jump

loc_52992:		; CODE XREF: sub_52792+14Aj
			; sub_52792+155j
			; sub_52792:loc_5290Fj
			; sub_52792:loc_52930j
			; sub_52792:loc_52950j
			; sub_52792:loc_52970j
mov	[bp+var_A], 0	; default
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ah]
mov	[bp+var_2], ax
mov	si, 1
jmp	short loc_529E3	; Jump

loc_529AC:		; CODE XREF: sub_52792+254j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+695Ah]
cmp	ax, [bp+var_2]	; Compare Two Operands
jle	short loc_529E2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_8], si	; Compare Two Operands
jz	short loc_529E2	; Jump if Zero (ZF=1)
mov	[bp+var_A], si
mov	ax, di

loc_529CE:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+695Ah]
mov	[bp+var_2], ax

loc_529E2:		; CODE XREF: sub_52792+230j
			; sub_52792+235j
inc	si		; Increment by 1

loc_529E3:		; CODE XREF: sub_52792+218j
cmp	si, 5		; Compare Two Operands
jl	short loc_529AC	; Jump if Less (SF!=OF)
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
cmp	[word ptr bx+695Ah], 0 ; Compare Two Operands
jnz	short loc_52A05	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_8]
mov	[bp+var_A], ax

loc_52A05:		; CODE XREF: sub_52792+26Bj
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_8]
mov	bx, ax
mov	[bx+6DC4h], dx
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_A]
mov	bx, ax
mov	[bx+6DC6h], dx
xor	si, si		; Logical Exclusive OR
jmp	short loc_52A49	; Jump

loc_52A29:		; CODE XREF: sub_52792+2BAj
mov	ax, [bp+var_8]
mov	dx, 0Ch
imul	dx		; Signed Multiply
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+354Ch]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_1A]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	si		; Increment by 1

loc_52A49:		; CODE XREF: sub_52792+295j
cmp	si, 6		; Compare Two Operands
jl	short loc_52A29	; Jump if Less (SF!=OF)
xor	si, si		; Logical Exclusive OR
jmp	short loc_52A72	; Jump

loc_52A52:		; CODE XREF: sub_52792+2E3j
mov	ax, [bp+var_8]
mov	dx, 0Ah
imul	dx		; Signed Multiply
mov	dx, si
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+3594h]
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_26]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	si		; Increment by 1

loc_52A72:		; CODE XREF: sub_52792+2BEj
cmp	si, 5		; Compare Two Operands
jl	short loc_52A52	; Jump if Less (SF!=OF)
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6965h], 1 ; Compare Two Operands
jnz	short loc_52A97	; Jump if Not Zero (ZF=0)
add	[bp+var_18], 2	; Add
add	[bp+var_16], 3	; Add
add	[bp+var_24], 2	; Add
add	[bp+var_1E], 3	; Add

loc_52A97:		; CODE XREF: sub_52792+2F3j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6966h], 1 ; Compare Two Operands
jnz	short loc_52AAE	; Jump if Not Zero (ZF=0)
add	[bp+var_14], 3	; Add
inc	[bp+var_22]	; Increment by 1

loc_52AAE:		; CODE XREF: sub_52792+313j
mov	ax, di

loc_52AB0:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6967h], 1 ; Compare Two Operands
jnz	short loc_52AC5	; Jump if Not Zero (ZF=0)
add	[bp+var_12], 3	; Add
inc	[bp+var_22]	; Increment by 1

loc_52AC5:		; CODE XREF: sub_52792+32Aj
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_52ACC:
mov	bx, ax
cmp	[byte ptr bx+6969h], 1 ; Compare Two Operands
jnz	short loc_52AD9	; Jump if Not Zero (ZF=0)
add	[bp+var_1A], 4	; Add

loc_52AD9:		; CODE XREF: sub_52792+341j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_52AE0:
mov	bx, ax
cmp	[byte ptr bx+696Ah], 1 ; Compare Two Operands
jnz	short loc_52AED	; Jump if Not Zero (ZF=0)
add	[bp+var_10], 4	; Add

loc_52AED:		; CODE XREF: sub_52792+355j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Ch], 1 ; Compare Two Operands
jnz	short loc_52B01	; Jump if Not Zero (ZF=0)
add	[bp+var_16], 2	; Add

loc_52B01:		; CODE XREF: sub_52792+369j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6964h], 1 ; Compare Two Operands
jnz	short loc_52B15	; Jump if Not Zero (ZF=0)
add	[bp+var_20], 2	; Add

loc_52B15:		; CODE XREF: sub_52792+37Dj
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Eh], 1 ; Compare Two Operands
jnz	short loc_52B29	; Jump if Not Zero (ZF=0)
add	[bp+var_22], 4	; Add

loc_52B29:		; CODE XREF: sub_52792+391j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Dh], 1 ; Compare Two Operands
jnz	short loc_52B3D	; Jump if Not Zero (ZF=0)
add	[bp+var_1E], 4	; Add

loc_52B3D:		; CODE XREF: sub_52792+3A5j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6973h], 1 ; Compare Two Operands
jnz	short loc_52B51	; Jump if Not Zero (ZF=0)
add	[bp+var_24], 3	; Add

loc_52B51:		; CODE XREF: sub_52792+3B9j
cmp	[bp+var_8], 3	; Compare Two Operands
jnz	short loc_52B5C	; Jump if Not Zero (ZF=0)
mov	[bp+var_1A], 0

loc_52B5C:		; CODE XREF: sub_52792+3C3j
cmp	[bp+var_8], 4	; Compare Two Operands
jnz	short loc_52B67	; Jump if Not Zero (ZF=0)
mov	[bp+var_10], 0

loc_52B67:		; CODE XREF: sub_52792+3CEj
mov	[bp+var_E], 0
xor	si, si		; Logical Exclusive OR
jmp	short loc_52B7F	; Jump

loc_52B70:		; CODE XREF: sub_52792+3F0j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
add	[bp+var_E], ax	; Add
inc	si		; Increment by 1

loc_52B7F:		; CODE XREF: sub_52792+3DCj
cmp	si, 6		; Compare Two Operands
jl	short loc_52B70	; Jump if Less (SF!=OF)
push	[bp+var_E]
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx

loc_52B8D:
mov	[bp+var_C], ax
mov	[bp+var_4], 0
mov	ax, [bp+var_1A]
jmp	short loc_52BA9	; Jump

loc_52B9A:		; CODE XREF: sub_52792+424j
inc	[bp+var_4]	; Increment by 1
mov	bx, [bp+var_4]

loc_52BA0:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_1A]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]

loc_52BA9:		; CODE XREF: sub_52792+406j
sub	[bp+var_C], ax	; Integer Subtraction
cmp	[bp+var_C], 0	; Compare Two Operands
jle	short loc_52BB8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_4], 5	; Compare Two Operands
jl	short loc_52B9A	; Jump if Less (SF!=OF)

loc_52BB8:		; CODE XREF: sub_52792+41Ej
mov	[bp+var_E], 0
xor	si, si		; Logical Exclusive OR
jmp	short loc_52BD0	; Jump

loc_52BC1:		; CODE XREF: sub_52792+441j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_26]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]
add	[bp+var_E], ax	; Add
inc	si		; Increment by 1

loc_52BD0:		; CODE XREF: sub_52792+42Dj
cmp	si, 5		; Compare Two Operands
jl	short loc_52BC1	; Jump if Less (SF!=OF)
push	[bp+var_E]

loc_52BD8:		; Call Procedure
call	idk_Arg_0Fail_ElseMathyDiSi
pop	cx
mov	[bp+var_C], ax

loc_52BE1:
mov	[bp+var_6], 0
mov	ax, [bp+var_26]
jmp	short loc_52BFA	; Jump

loc_52BEB:		; CODE XREF: sub_52792+475j
inc	[bp+var_6]	; Increment by 1

loc_52BEE:
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_26]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]

loc_52BFA:		; CODE XREF: sub_52792+457j
sub	[bp+var_C], ax	; Integer Subtraction

loc_52BFD:		; Compare Two Operands
cmp	[bp+var_C], 0
jle	short loc_52C09	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_6], 4	; Compare Two Operands
jl	short loc_52BEB	; Jump if Less (SF!=OF)

loc_52C09:		; CODE XREF: sub_52792+46Fj
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
mov	bx, ax
mov	[bx+6918h], dx
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_6]
mov	bx, ax

loc_52C25:
mov	[bx+691Ah], dx

loc_52C29:		; Increment by 1
inc	di

loc_52C2A:		; CODE XREF: sub_52792+90j
cmp	di, [word_3A4E2] ; Compare Two Operands
jge	short loc_52C33	; Jump if Greater or Equal (SF=OF)

loc_52C30:		; Jump
jmp	loc_52825

loc_52C33:		; CODE XREF: sub_52792+49Cj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_52792

off_52C39 dw offset loc_528F1
			; DATA XREF: sub_52792+15Ar
dw offset loc_52972	; jump table for switch	statement
dw offset loc_52952
dw offset loc_52912
dw offset loc_52932
off_52C43 dw offset loc_52885
			; DATA XREF: sub_52792+EEr
dw offset loc_528C5	; jump table for switch	statement
dw offset loc_528B5
dw offset loc_52895
dw offset loc_528A5


; Attributes: bp-based frame

proc sub_52C4D far	; CODE XREF: sub_31BC9J
			; sub_523A3:loc_523C2p
push	bp
mov	bp, sp
push	si
xor	cx, cx		; Logical Exclusive OR

loc_52C53:		; Jump
jmp	loc_52CDB

loc_52C56:		; CODE XREF: sub_52C4D:loc_52CE1j
mov	ax, cx
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_52C5F:
mov	[word ptr bx+6DAAh], 0
mov	ax, cx
mov	dx, 4C8h

loc_52C6A:		; Signed Multiply
imul	dx
mov	bx, ax
mov	[word ptr bx+6DACh], 0
mov	ax, cx
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6DAEh], 0
xor	si, si		; Logical Exclusive OR
jmp	short loc_52C98	; Jump

loc_52C87:		; CODE XREF: sub_52C4D+4Fj
mov	ax, cx
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, si		; Add
mov	bx, ax
mov	[byte ptr bx+6DB0h], 0FFh
inc	si		; Increment by 1

loc_52C98:		; CODE XREF: sub_52C4D+38j
cmp	si, [word_3A4E2] ; Compare Two Operands
jl	short loc_52C87	; Jump if Less (SF!=OF)
mov	ax, cx

loc_52CA0:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6DB6h], 0FFFFh
mov	ax, cx

loc_52CAF:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6DB8h], 0FFFFh
mov	ax, cx
mov	dx, 4C8h

loc_52CC1:		; Signed Multiply
imul	dx
mov	bx, ax
mov	[word ptr bx+6DBAh], 0FFFFh
mov	ax, cx
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_52CD4:
mov	[word ptr bx+6DBCh], 0FFFFh
inc	cx		; Increment by 1

loc_52CDB:		; CODE XREF: sub_52C4D:loc_52C53j
cmp	cx, [word_3A4E2] ; Compare Two Operands
jge	short loc_52CE4	; Jump if Greater or Equal (SF=OF)

loc_52CE1:		; Jump
jmp	loc_52C56

loc_52CE4:		; CODE XREF: sub_52C4D+92j
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_52C4D



; Attributes: bp-based frame

proc sub_52CE7 far	; CODE XREF: sub_31BCEJ
			; sub_523A3+1Ap

var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di

loc_52CEF:		; Logical Exclusive OR
xor	si, si
jmp	loc_5300F	; Jump

loc_52CF4:		; CODE XREF: sub_52CE7+32Ej
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6971h], 1 ; Compare Two Operands
jnz	short loc_52D15	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6924h], 0Ah
jmp	short loc_52D24	; Jump

loc_52D15:		; CODE XREF: sub_52CE7+1Bj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_52D1E:
mov	[word ptr bx+6924h], 0

loc_52D24:		; CODE XREF: sub_52CE7+2Cj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ah]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+695Ch]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+695Eh]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+6960h]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax

loc_52D69:		; Add
add	ax, [bx+6962h]
mov	di, ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Eh], 0 ; Compare Two Operands
jz	short loc_52D82	; Jump if Zero (ZF=1)
add	di, 5		; Add

loc_52D82:		; CODE XREF: sub_52CE7+96j
add	di, di		; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6956h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6B60h], 0
mov	[word ptr bx+6B5Eh], 0
jmp	short loc_52DD3	; Jump

loc_52DAA:		; CODE XREF: sub_52CE7+F9j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
add	[word ptr bx+6B5Eh], 1 ; Add
adc	[word ptr bx+6B60h], 0 ; Add with Carry
push	si
nop			; No Operation
push	cs
call	near ptr sub_552B3 ; Call Procedure
pop	cx
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx+6956h], ax

loc_52DD3:		; CODE XREF: sub_52CE7+C1j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[bx+6956h], di	; Compare Two Operands
jl	short loc_52DAA	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6B62h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6B5Ch], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6B5Ah], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+692Ch], 21h ; '!'
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+692Bh], 21h ; '!'
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+692Ah], 22h ; '"'
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6C38h], 3
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6952h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+694Eh], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D82h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D83h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D84h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D85h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D86h], 0

loc_52EAB:
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D87h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D88h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D89h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D8Ah], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D8Bh], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D8Ch], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D8Dh], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_52F14:
mov	bx, ax
mov	[byte ptr bx+6D8Eh], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D8Fh], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D90h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_52F40:
mov	[byte ptr bx+6D91h], 0

loc_52F45:
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_52F4E:
mov	[byte ptr bx+6D92h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D93h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D94h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D95h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_52F86:
mov	[word ptr bx+6928h], 0

loc_52F8C:
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6D98h], 0
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6958h], 2
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_52FB2:
mov	[word ptr bx+6A20h], 0FFFFh
mov	ax, si
mov	dx, 4C8h

loc_52FBD:		; Signed Multiply
imul	dx
mov	bx, ax
mov	[word ptr bx+6A22h], 0FFFFh
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6A24h], 0FFFFh
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6A26h], 0FFFFh
mov	[bp+var_2], 0
jmp	short loc_53008	; Jump

loc_52FEC:		; CODE XREF: sub_52CE7+325j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_2]
mov	dx, 1Ch
imul	dx		; Signed Multiply
pop	bx

loc_52FFD:		; Add
add	bx, ax
mov	[word ptr bx+6976h], 0FFFFh
inc	[bp+var_2]	; Increment by 1

loc_53008:		; CODE XREF: sub_52CE7+303j
cmp	[bp+var_2], 6	; Compare Two Operands
jl	short loc_52FEC	; Jump if Less (SF!=OF)
inc	si		; Increment by 1

loc_5300F:		; CODE XREF: sub_52CE7+Aj
cmp	si, [word_3A4E2] ; Compare Two Operands
jge	short loc_53018	; Jump if Greater or Equal (SF=OF)
jmp	loc_52CF4	; Jump

loc_53018:		; CODE XREF: sub_52CE7+32Cj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_52CE7



; Attributes: bp-based frame

proc sub_5301E far	; CODE XREF: sub_31BD3J
			; sub_522E0:loc_522E7p

var_30=	word ptr -30h
var_2E=	word ptr -2Eh
var_2C=	word ptr -2Ch
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 30h		; Integer Subtraction
push	si
push	di		; argSrc
xor	di, di		; Logical Exclusive OR
jmp	short loc_53038	; Jump

loc_5302A:		; CODE XREF: sub_5301E:loc_5303Bj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1E]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0
inc	di		; Increment by 1

loc_53038:		; CODE XREF: sub_5301E+Aj
cmp	di, 5		; Compare Two Operands

loc_5303B:		; Jump if Less (SF!=OF)
jl	short loc_5302A
mov	al, [byte_38626]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
lea	dx, [bp+var_1E]	; Load Effective Address
add	ax, dx		; Add
mov	bx, ax
mov	[word ptr bx], 1

loc_5304E:		; CODE XREF: sub_5301E+8B0j
mov	si, 1
jmp	short loc_530A7	; Jump

loc_53053:		; CODE XREF: sub_5301E+76j
			; sub_5301E+8Dj
mov	[bp+var_4], 0
mov	ax, 0Eh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_6], ax
mov	[bp+var_2], 0
jmp	short loc_53089	; Jump

loc_5306D:		; CODE XREF: sub_5301E+6Ej
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_53086	; Jump if Not Zero (ZF=0)
mov	[bp+var_4], 1

loc_53086:		; CODE XREF: sub_5301E+61j
inc	[bp+var_2]	; Increment by 1

loc_53089:		; CODE XREF: sub_5301E+4Dj
cmp	[bp+var_2], si	; Compare Two Operands
jl	short loc_5306D	; Jump if Less (SF!=OF)
cmp	[bp+var_4], 1	; Compare Two Operands
jnz	short loc_53096	; Jump if Not Zero (ZF=0)
jmp	short loc_53053	; Jump

loc_53096:		; CODE XREF: sub_5301E+74j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dl, [byte ptr bp+var_6]
mov	bx, ax
mov	[bx+6900h], dl
inc	si		; Increment by 1

loc_530A7:		; CODE XREF: sub_5301E+33j
cmp	si, [word_3A4E2] ; Compare Two Operands
jl	short loc_53053	; Jump if Less (SF!=OF)
mov	si, 1
jmp	short loc_530DC	; Jump

loc_530B2:		; CODE XREF: sub_5301E+C2j
mov	ax, si

loc_530B4:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
mov	dx, 16h
imul	dx		; Signed Multiply
add	ax, 2AD0h	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, 6901h	; Add
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
inc	si		; Increment by 1

loc_530DC:		; CODE XREF: sub_5301E+92j
cmp	si, [word_3A4E2] ; Compare Two Operands
jl	short loc_530B2	; Jump if Less (SF!=OF)
mov	si, 1
jmp	loc_5322A	; Jump

loc_530E8:		; CODE XREF: sub_5301E+212j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+2ADAh]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx+6960h], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+2AE0h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx+6962h], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+2AE2h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx+695Eh], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_53167:
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+2ADEh]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx+695Ah], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+2ADCh]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
mov	[bx+695Ch], ax
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_531CD	; Jump if Not Zero (ZF=0)
cmp	[word_3A4DC], 2	; Compare Two Operands
jle	short loc_531CD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	si
nop			; No Operation
push	cs
call	near ptr sub_54E71 ; Call Procedure
pop	cx

loc_531CD:		; CODE XREF: sub_5301E+19Fj
			; sub_5301E+1A6j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, 6964h	; Add

loc_531D7:
mov	[bp+var_14], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_531E7	; Jump

loc_531DE:		; CODE XREF: sub_5301E+1CCj
mov	bx, [bp+var_14]
add	bx, di		; Add
mov	[byte ptr bx], 0
inc	di		; Increment by 1

loc_531E7:		; CODE XREF: sub_5301E+1BEj
cmp	di, 12h		; Compare Two Operands
jl	short loc_531DE	; Jump if Less (SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
mov	dx, 16h
imul	dx		; Signed Multiply
mov	bx, ax
db 83h,0BFh,0E4h,2Ah,0FFh ; <BAD>cmp	 [word ptr bx+2AE4h], 0FFFFh ; Compare Two Operands
jz	short loc_53229	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	al, [bx+6900h]
cbw			; AL ->	AX (with sign)
mov	dx, 16h
imul	dx		; Signed Multiply
mov	dx, [bp+var_14]
mov	bx, ax
add	dx, [bx+2AE4h]	; Add
mov	bx, dx
mov	[byte ptr bx], 1

loc_53229:		; CODE XREF: sub_5301E+1E8j
inc	si		; Increment by 1

loc_5322A:		; CODE XREF: sub_5301E+C7j
cmp	si, [word_3A4E2] ; Compare Two Operands
jge	short loc_53233	; Jump if Greater or Equal (SF=OF)
jmp	loc_530E8	; Jump

loc_53233:		; CODE XREF: sub_5301E+210j
mov	si, 1
jmp	loc_5339E	; Jump

loc_53239:		; CODE XREF: sub_5301E+386j
mov	bx, [word_3A4DC]
cmp	bx, 5		; switch 6 cases
ja	short loc_5329E	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_539FA+bx] ; switch jump

loc_53249:		; CODE XREF: sub_5301E:loc_53250j
			; DATA XREF: ovr056:off_539FAo
mov	[bp+var_8], 0	; case 0x0
jmp	short loc_5329E	; default

loc_53250:		; CODE XREF: sub_5301E+226j
			; DATA XREF: ovr056:off_539FAo
jmp	short loc_53249	; case 0x1

loc_53252:		; CODE XREF: sub_5301E+226j
			; DATA XREF: ovr056:off_539FAo
mov	ax, 3		; case 0x2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_8], ax
jmp	short loc_5329E	; default

loc_53261:		; CODE XREF: sub_5301E+226j
			; DATA XREF: ovr056:off_539FAo
mov	ax, 3		; case 0x3
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
push	ax
mov	ax, 3
jmp	short loc_5328F	; Jump

loc_53271:		; CODE XREF: sub_5301E+226j
			; DATA XREF: ovr056:off_539FAo
mov	ax, 5		; case 0x4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
push	ax
mov	ax, 5
jmp	short loc_5328F	; Jump

loc_53281:		; CODE XREF: sub_5301E+226j
			; DATA XREF: ovr056:off_539FAo
mov	ax, 8		; case 0x5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
push	ax
mov	ax, 8

loc_5328F:		; CODE XREF: sub_5301E+251j
			; sub_5301E+261j
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
pop	dx
add	dx, ax		; Add
mov	[bp+var_8], dx
jmp	short $+2	; Jump

loc_5329E:		; CODE XREF: sub_5301E+222j
			; sub_5301E+230j
			; sub_5301E+241j
mov	ax, si		; default

loc_532A0:
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, 6964h	; Add
mov	[bp+var_14], ax
xor	di, di		; Logical Exclusive OR
jmp	loc_53395	; Jump

loc_532B0:		; CODE XREF: sub_5301E+37Cj
mov	ax, 6
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_A], ax
mov	bx, [bp+var_A]
dec	bx		; Decrement by 1
cmp	bx, 5		; switch 6 cases
jbe	short loc_532C9	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_53394	; default

loc_532C9:		; CODE XREF: sub_5301E+2A6j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_539EE+bx] ; switch jump

loc_532D0:		; DATA XREF: ovr056:off_539EEo
mov	ax, si		; case 0x0
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6960h], 1 ; Compare Two Operands
jle	short loc_532ED	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_532E0:
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
dec	[word ptr bx+6960h] ; Decrement	by 1

loc_532ED:		; CODE XREF: sub_5301E+2C0j
jmp	loc_53394	; default

loc_532F0:		; CODE XREF: sub_5301E+2ADj
			; DATA XREF: ovr056:off_539EEo
mov	ax, si		; case 0x1
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6962h], 1 ; Compare Two Operands
jle	short loc_5330D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
dec	[word ptr bx+6962h] ; Decrement	by 1

loc_5330D:		; CODE XREF: sub_5301E+2E0j
jmp	loc_53394	; default

loc_53310:		; CODE XREF: sub_5301E+2ADj
			; DATA XREF: ovr056:off_539EEo
mov	ax, si		; case 0x2
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Eh], 1 ; Compare Two Operands
jle	short loc_5332D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
dec	[word ptr bx+695Eh] ; Decrement	by 1

loc_5332D:		; CODE XREF: sub_5301E+300j
jmp	short loc_53394	; default

loc_5332F:		; CODE XREF: sub_5301E+2ADj
			; DATA XREF: ovr056:off_539EEo
mov	ax, si		; case 0x3
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ah], 1 ; Compare Two Operands
jle	short loc_5334C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
dec	[word ptr bx+695Ah] ; Decrement	by 1

loc_5334C:		; CODE XREF: sub_5301E+31Fj
jmp	short loc_53394	; default

loc_5334E:		; CODE XREF: sub_5301E+2ADj
			; DATA XREF: ovr056:off_539EEo
mov	ax, si		; case 0x4
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ch], 1 ; Compare Two Operands
jle	short loc_5336B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
dec	[word ptr bx+695Ch] ; Decrement	by 1

loc_5336B:		; CODE XREF: sub_5301E+33Ej
jmp	short loc_53394	; default

loc_5336D:		; CODE XREF: sub_5301E+2ADj
			; DATA XREF: ovr056:off_539EEo
mov	ax, si		; case 0x5
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, 6964h	; Add
mov	[bp+var_14], ax
mov	[bp+var_2], 0
jmp	short loc_5338C	; Jump

loc_53381:		; CODE XREF: sub_5301E+372j
mov	bx, [bp+var_14]
add	bx, di		; Add
mov	[byte ptr bx], 0
inc	[bp+var_2]	; Increment by 1

loc_5338C:		; CODE XREF: sub_5301E+361j
cmp	[bp+var_2], 12h	; Compare Two Operands
jl	short loc_53381	; Jump if Less (SF!=OF)
jmp	short $+2	; Jump

loc_53394:		; CODE XREF: sub_5301E+2A8j
			; sub_5301E:loc_532EDj
			; sub_5301E:loc_5330Dj
			; sub_5301E:loc_5332Dj
			; sub_5301E:loc_5334Cj
			; sub_5301E:loc_5336Bj
inc	di		; default

loc_53395:		; CODE XREF: sub_5301E+28Fj
cmp	di, [bp+var_8]	; Compare Two Operands
jge	short loc_5339D	; Jump if Greater or Equal (SF=OF)
jmp	loc_532B0	; Jump

loc_5339D:		; CODE XREF: sub_5301E+37Aj
inc	si		; Increment by 1

loc_5339E:		; CODE XREF: sub_5301E+218j
cmp	si, [word_3A4E2] ; Compare Two Operands
jge	short loc_533A7	; Jump if Greater or Equal (SF=OF)
jmp	loc_53239	; Jump

loc_533A7:		; CODE XREF: sub_5301E+384j
mov	si, 1
jmp	loc_53887	; Jump

loc_533AD:		; CODE XREF: sub_5301E+86Fj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
add	ax, 6964h	; Add
mov	[bp+var_14], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6960h]
push	ax
mov	ax, si
mov	dx, 4C8h

loc_533CD:		; Signed Multiply
imul	dx
mov	bx, ax
pop	ax
add	ax, [bx+6962h]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+695Ah]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+695Eh]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+695Ch]	; Add
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
mov	[bp+var_12], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_53448	; Jump

loc_53410:		; CODE XREF: sub_5301E:loc_5344Bj
mov	bx, [bp+var_14]
add	bx, di		; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jz	short loc_53447	; Jump if Zero (ZF=1)

loc_5341A:		; Compare Two Operands
cmp	di, 9
jnz	short loc_53425	; Jump if Not Zero (ZF=0)
add	[bp+var_C], 3	; Add
jmp	short loc_53447	; Jump

loc_53425:		; CODE XREF: sub_5301E+3FFj
cmp	di, 1		; Compare Two Operands
jz	short loc_5343E	; Jump if Zero (ZF=1)
cmp	di, 5		; Compare Two Operands

loc_5342D:		; Jump if Zero (ZF=1)
jz	short loc_5343E
cmp	di, 6		; Compare Two Operands
jz	short loc_5343E	; Jump if Zero (ZF=1)
cmp	di, 0Dh		; Compare Two Operands
jz	short loc_5343E	; Jump if Zero (ZF=1)

loc_53439:		; Compare Two Operands
cmp	di, 8
jnz	short loc_53444	; Jump if Not Zero (ZF=0)

loc_5343E:		; CODE XREF: sub_5301E+40Aj
			; sub_5301E:loc_5342Dj
			; sub_5301E+414j
			; sub_5301E+419j
add	[bp+var_C], 2	; Add
jmp	short loc_53447	; Jump

loc_53444:		; CODE XREF: sub_5301E+41Ej
inc	[bp+var_C]	; Increment by 1

loc_53447:		; CODE XREF: sub_5301E+3FAj
			; sub_5301E+405j
			; sub_5301E+424j
inc	di		; Increment by 1

loc_53448:		; CODE XREF: sub_5301E+3F0j
cmp	di, 12h		; Compare Two Operands

loc_5344B:		; Jump if Less (SF!=OF)
jl	short loc_53410

loc_5344D:
mov	[bp+var_20], 0Bh

loc_53452:		; Compare Two Operands
cmp	[word_3A4DC], 3
jnz	short loc_5345E	; Jump if Not Zero (ZF=0)
mov	[bp+var_20], 0Dh

loc_5345E:		; CODE XREF: sub_5301E+439j
cmp	[word_3A4DC], 4	; Compare Two Operands
jnz	short loc_5346A	; Jump if Not Zero (ZF=0)
mov	[bp+var_20], 0Fh

loc_5346A:		; CODE XREF: sub_5301E+445j
jmp	loc_5387B	; Jump

loc_5346D:		; CODE XREF: sub_5301E+865j
mov	ax, 8
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
mov	[bp+var_A], ax
mov	ax, 4
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
inc	ax		; Increment by 1
mov	[bp+var_E], ax
mov	ax, [bp+var_E]
add	ax, [bp+var_C]	; Add
cmp	ax, [bp+var_20]	; Compare Two Operands
jle	short loc_5349C	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_20]
sub	ax, [bp+var_C]	; Integer Subtraction
mov	[bp+var_E], ax

loc_5349C:		; CODE XREF: sub_5301E+473j
mov	ax, [bp+var_E]
add	ax, [bp+var_12]	; Add
cmp	ax, 0Ch		; Compare Two Operands
jle	short loc_534B0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 0Ch
sub	ax, [bp+var_12]	; Integer Subtraction

loc_534AD:
mov	[bp+var_E], ax

loc_534B0:		; CODE XREF: sub_5301E+487j
cmp	[bp+var_E], 0	; Compare Two Operands
jg	short loc_534BB	; Jump if Greater (ZF=0	& SF=OF)
mov	[bp+var_A], 6

loc_534BB:		; CODE XREF: sub_5301E+496j
cmp	[bp+var_A], 6	; Compare Two Operands
jnz	short loc_534C6	; Jump if Not Zero (ZF=0)
mov	[bp+var_E], 1

loc_534C6:		; CODE XREF: sub_5301E+4A1j
mov	bx, [bp+var_A]
dec	bx		; Decrement by 1
cmp	bx, 7		; switch 8 cases
jbe	short loc_534D2	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_537E8	; default

loc_534D2:		; CODE XREF: sub_5301E+4AFj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_539DE+bx] ; switch jump

loc_534D9:		; DATA XREF: ovr056:off_539DEo
mov	ax, si		; case 0x0
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6960h], 0Bh ; Compare Two Operands
jge	short loc_53509	; Jump if Greater or Equal (SF=OF)
mov	ax, si

loc_534EB:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_534F2:		; Compare Two Operands
cmp	[word ptr bx+6962h], 0
jnz	short loc_53509	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
mov	bx, ax

loc_53505:		; Add
add	[bx+6960h], dx

loc_53509:		; CODE XREF: sub_5301E+4C9j
			; sub_5301E+4D9j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6960h], 0Bh ; Compare Two Operands
jle	short loc_53528	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_53519:
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6960h], 0Bh

loc_53528:		; CODE XREF: sub_5301E+4F9j
jmp	loc_537E8	; default

loc_5352B:		; CODE XREF: sub_5301E+4B6j
			; DATA XREF: ovr056:off_539DEo
mov	ax, si		; case 0x1
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6962h], 0Bh ; Compare Two Operands
jge	short loc_5355B	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_53542:
mov	bx, ax

loc_53544:		; Compare Two Operands
cmp	[word ptr bx+6960h], 0
jnz	short loc_5355B	; Jump if Not Zero (ZF=0)
mov	ax, si

loc_5354D:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
mov	bx, ax
add	[bx+6962h], dx	; Add

loc_5355B:		; CODE XREF: sub_5301E+51Bj
			; sub_5301E+52Bj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_53564:		; Compare Two Operands
cmp	[word ptr bx+6962h], 0Bh

loc_53569:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_5357A
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_53572:
mov	bx, ax

loc_53574:
mov	[word ptr bx+6962h], 0Bh

loc_5357A:		; CODE XREF: sub_5301E:loc_53569j
jmp	loc_537E8	; default

loc_5357D:		; CODE XREF: sub_5301E+4B6j
			; DATA XREF: ovr056:off_539DEo
mov	ax, si		; case 0x2

loc_5357F:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ah], 0Bh ; Compare Two Operands
jge	short loc_5359D	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
mov	bx, ax
add	[bx+695Ah], dx	; Add

loc_5359D:		; CODE XREF: sub_5301E+56Dj
mov	ax, si

loc_5359F:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ah], 0Bh ; Compare Two Operands
jle	short loc_535BC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ah], 0Bh

loc_535BC:		; CODE XREF: sub_5301E+58Dj
jmp	loc_537E8	; default

loc_535BF:		; CODE XREF: sub_5301E+4B6j
			; DATA XREF: ovr056:off_539DEo
mov	ax, si		; case 0x3

loc_535C1:
mov	dx, 4C8h

loc_535C4:		; Signed Multiply
imul	dx
mov	bx, ax
cmp	[word ptr bx+695Ch], 0Bh ; Compare Two Operands
jge	short loc_535DF	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]

loc_535D9:
mov	bx, ax
add	[bx+695Ch], dx	; Add

loc_535DF:		; CODE XREF: sub_5301E+5AFj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ch], 0Bh ; Compare Two Operands
jle	short loc_535FE	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ch], 0Bh

loc_535FE:		; CODE XREF: sub_5301E+5CFj
jmp	loc_537E8	; default

loc_53601:		; CODE XREF: sub_5301E+4B6j
			; DATA XREF: ovr056:off_539DEo
mov	ax, si		; case 0x4
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Eh], 0Bh ; Compare Two Operands
jge	short loc_53621	; Jump if Greater or Equal (SF=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_E]
mov	bx, ax
add	[bx+695Eh], dx	; Add

loc_53621:		; CODE XREF: sub_5301E+5F1j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Eh], 0Bh ; Compare Two Operands
jle	short loc_53640	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Eh], 0Bh

loc_53640:		; CODE XREF: sub_5301E+611j
jmp	loc_537E8	; default

loc_53643:		; CODE XREF: sub_5301E+4B6j
			; DATA XREF: ovr056:off_539DEo
mov	ax, 12h		; case 0x5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_E], ax
cmp	[bp+var_E], 2	; Compare Two Operands
jge	short loc_5365A	; Jump if Greater or Equal (SF=OF)
jmp	loc_5379B	; Jump

loc_5365A:		; CODE XREF: sub_5301E+637j
cmp	[bp+var_E], 6	; Compare Two Operands
jle	short loc_53663	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_5379B	; Jump

loc_53663:		; CODE XREF: sub_5301E+640j
mov	[bp+var_2E], 0
jmp	short loc_5368D	; Jump

loc_5366A:		; CODE XREF: sub_5301E+673j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_2E]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+695Ah]
mov	bx, [bp+var_2E]
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_2C]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax
inc	[bp+var_2E]	; Increment by 1

loc_5368D:		; CODE XREF: sub_5301E+64Aj
cmp	[bp+var_2E], 4	; Compare Two Operands
jle	short loc_5366A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6966h], 0 ; Compare Two Operands
jle	short loc_536A8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_28], 0

loc_536A8:		; CODE XREF: sub_5301E+683j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6967h], 0 ; Compare Two Operands
jle	short loc_536BD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_536B8:
mov	[bp+var_2C], 0

loc_536BD:		; CODE XREF: sub_5301E+698j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6968h], 0 ; Compare Two Operands
jle	short loc_536D2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	[bp+var_2A], 0

loc_536D2:		; CODE XREF: sub_5301E+6ADj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Ah], 0 ; Compare Two Operands
jg	short loc_536ED	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [bp+var_20]
add	ax, 0FFFEh	; Add
cmp	ax, [bp+var_C]	; Compare Two Operands
jge	short loc_536F2	; Jump if Greater or Equal (SF=OF)

loc_536ED:		; CODE XREF: sub_5301E+6C2j
mov	[bp+var_26], 0

loc_536F2:		; CODE XREF: sub_5301E+6CDj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6969h], 0 ; Compare Two Operands
jg	short loc_5370D	; Jump if Greater (ZF=0	& SF=OF)
mov	ax, [bp+var_20]
add	ax, 0FFFEh	; Add
cmp	ax, [bp+var_C]	; Compare Two Operands
jge	short loc_53712	; Jump if Greater or Equal (SF=OF)

loc_5370D:		; CODE XREF: sub_5301E+6E2j
mov	[bp+var_24], 0

loc_53712:		; CODE XREF: sub_5301E+6EDj
mov	[bp+var_30], 0
mov	[bp+var_2E], 0
jmp	short loc_53730	; Jump

loc_5371E:		; CODE XREF: sub_5301E+716j
mov	bx, [bp+var_2E]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_2C]	; Load Effective Address
add	bx, ax		; Add
mov	ax, [bx]

loc_5372A:		; Add
add	[bp+var_30], ax
inc	[bp+var_2E]	; Increment by 1

loc_53730:		; CODE XREF: sub_5301E+6FEj
cmp	[bp+var_2E], 4	; Compare Two Operands
jle	short loc_5371E	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_30], 0	; Compare Two Operands
jle	short loc_53799	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, 5
push	ax
lea	ax, [bp+var_2C]	; Load Effective Address
push	ax
nop			; No Operation
push	cs
call	near ptr sub_55315 ; Call Procedure
pop	cx
pop	cx
add	ax, 2		; Add
mov	[bp+var_E], ax
cmp	[bp+var_E], 2	; Compare Two Operands
jnz	short loc_5375E	; Jump if Not Zero (ZF=0)
mov	[bp+var_E], 3
jmp	short loc_53790	; Jump

loc_5375E:		; CODE XREF: sub_5301E+737j
cmp	[bp+var_E], 3	; Compare Two Operands
jnz	short loc_5376B	; Jump if Not Zero (ZF=0)
mov	[bp+var_E], 4
jmp	short loc_53790	; Jump

loc_5376B:		; CODE XREF: sub_5301E+744j
cmp	[bp+var_E], 4	; Compare Two Operands
jnz	short loc_53778	; Jump if Not Zero (ZF=0)
mov	[bp+var_E], 2
jmp	short loc_53790	; Jump

loc_53778:		; CODE XREF: sub_5301E+751j
cmp	[bp+var_E], 5	; Compare Two Operands
jnz	short loc_53785	; Jump if Not Zero (ZF=0)
mov	[bp+var_E], 6
jmp	short loc_53790	; Jump

loc_53785:		; CODE XREF: sub_5301E+75Ej
cmp	[bp+var_E], 6	; Compare Two Operands
jnz	short loc_53790	; Jump if Not Zero (ZF=0)
mov	[bp+var_E], 5

loc_53790:		; CODE XREF: sub_5301E+73Ej
			; sub_5301E+74Bj
			; sub_5301E+758j
			; sub_5301E+765j
			; sub_5301E+76Bj
mov	bx, [bp+var_14]
add	bx, [bp+var_E]	; Add
mov	[byte ptr bx], 1

loc_53799:		; CODE XREF: sub_5301E+71Cj
jmp	short loc_537E6	; Jump

loc_5379B:		; CODE XREF: sub_5301E+639j
			; sub_5301E+642j
cmp	[bp+var_E], 1	; Compare Two Operands
jz	short loc_537AD	; Jump if Zero (ZF=1)
cmp	[bp+var_E], 8	; Compare Two Operands
jz	short loc_537AD	; Jump if Zero (ZF=1)
cmp	[bp+var_E], 0Dh	; Compare Two Operands
jnz	short loc_537C1	; Jump if Not Zero (ZF=0)

loc_537AD:		; CODE XREF: sub_5301E+781j
			; sub_5301E+787j
mov	ax, [bp+var_20]
dec	ax		; Decrement by 1
cmp	ax, [bp+var_C]	; Compare Two Operands
jle	short loc_537BF	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, [bp+var_14]
add	bx, [bp+var_E]	; Add
mov	[byte ptr bx], 1

loc_537BF:		; CODE XREF: sub_5301E+796j
jmp	short loc_537E6	; Jump

loc_537C1:		; CODE XREF: sub_5301E+78Dj
cmp	[bp+var_E], 9	; Compare Two Operands
jnz	short loc_537DD	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_20]
add	ax, 0FFFEh	; Add
cmp	ax, [bp+var_C]	; Compare Two Operands
jle	short loc_537DB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	bx, [bp+var_14]
add	bx, [bp+var_E]	; Add
mov	[byte ptr bx], 1

loc_537DB:		; CODE XREF: sub_5301E+7B2j
jmp	short loc_537E6	; Jump

loc_537DD:		; CODE XREF: sub_5301E+7A7j
mov	bx, [bp+var_14]
add	bx, [bp+var_E]	; Add
mov	[byte ptr bx], 1

loc_537E6:		; CODE XREF: sub_5301E:loc_53799j
			; sub_5301E:loc_537BFj
			; sub_5301E:loc_537DBj
jmp	short $+2	; Jump

loc_537E8:		; CODE XREF: sub_5301E+4B1j
			; sub_5301E:loc_53528j
			; sub_5301E:loc_5357Aj
			; sub_5301E:loc_535BCj
			; sub_5301E:loc_535FEj
			; sub_5301E:loc_53640j
mov	ax, si		; default
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6960h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+6962h]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+695Ah]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+695Eh]	; Add
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	ax, [bx+695Ch]	; Add
mov	[bp+var_C], ax
mov	ax, [bp+var_C]
mov	[bp+var_12], ax
xor	di, di		; Logical Exclusive OR
jmp	short loc_53876	; Jump

loc_5383E:		; CODE XREF: sub_5301E+85Bj
mov	bx, [bp+var_14]
add	bx, di		; Add
cmp	[byte ptr bx], 0 ; Compare Two Operands
jz	short loc_53875	; Jump if Zero (ZF=1)
cmp	di, 9		; Compare Two Operands
jnz	short loc_53853	; Jump if Not Zero (ZF=0)
add	[bp+var_C], 3	; Add
jmp	short loc_53875	; Jump

loc_53853:		; CODE XREF: sub_5301E+82Dj
cmp	di, 1		; Compare Two Operands
jz	short loc_5386C	; Jump if Zero (ZF=1)
cmp	di, 5		; Compare Two Operands
jz	short loc_5386C	; Jump if Zero (ZF=1)
cmp	di, 6		; Compare Two Operands
jz	short loc_5386C	; Jump if Zero (ZF=1)
cmp	di, 0Dh		; Compare Two Operands
jz	short loc_5386C	; Jump if Zero (ZF=1)
cmp	di, 8		; Compare Two Operands
jnz	short loc_53872	; Jump if Not Zero (ZF=0)

loc_5386C:		; CODE XREF: sub_5301E+838j
			; sub_5301E+83Dj
			; sub_5301E+842j
			; sub_5301E+847j
add	[bp+var_C], 2	; Add
jmp	short loc_53875	; Jump

loc_53872:		; CODE XREF: sub_5301E+84Cj
inc	[bp+var_C]	; Increment by 1

loc_53875:		; CODE XREF: sub_5301E+828j
			; sub_5301E+833j
			; sub_5301E+852j
inc	di		; Increment by 1

loc_53876:		; CODE XREF: sub_5301E+81Ej
cmp	di, 12h		; Compare Two Operands
jl	short loc_5383E	; Jump if Less (SF!=OF)

loc_5387B:		; CODE XREF: sub_5301E:loc_5346Aj
mov	ax, [bp+var_C]
cmp	ax, [bp+var_20]	; Compare Two Operands
jge	short loc_53886	; Jump if Greater or Equal (SF=OF)
jmp	loc_5346D	; Jump

loc_53886:		; CODE XREF: sub_5301E+863j
inc	si		; Increment by 1

loc_53887:		; CODE XREF: sub_5301E+38Cj
cmp	si, [word_3A4E2] ; Compare Two Operands
jge	short loc_53890	; Jump if Greater or Equal (SF=OF)
jmp	loc_533AD	; Jump

loc_53890:		; CODE XREF: sub_5301E+86Dj
mov	[bp+var_22], 0
mov	di, 1
jmp	short loc_538AE	; Jump

loc_5389A:		; CODE XREF: sub_5301E+894j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Dh], 0 ; Compare Two Operands
jz	short loc_538AD	; Jump if Zero (ZF=1)
inc	[bp+var_22]	; Increment by 1

loc_538AD:		; CODE XREF: sub_5301E+88Aj
inc	di		; Increment by 1

loc_538AE:		; CODE XREF: sub_5301E+87Aj
cmp	di, [word_3A4E2] ; Compare Two Operands
jl	short loc_5389A	; Jump if Less (SF!=OF)
cmp	[bp+var_22], 1	; Compare Two Operands
jl	short loc_538C0	; Jump if Less (SF!=OF)
cmp	[bp+var_22], 2	; Compare Two Operands
jle	short loc_538DD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_538C0:		; CODE XREF: sub_5301E+89Aj
cmp	[word_3A4DC], 2	; Compare Two Operands
jle	short loc_538DD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[word_3A4E2], 3	; Compare Two Operands
jle	short loc_538DD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_5304E	; Jump
mov	[word_3488E], 0FFFFh
mov	[word_3488C], 7

loc_538DD:		; CODE XREF: sub_5301E+8A0j
			; sub_5301E+8A7j
			; sub_5301E+8AEj
mov	si, 1
jmp	loc_539CF	; Jump

loc_538E3:		; CODE XREF: sub_5301E+9B7j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ah], 3 ; Compare Two Operands
jle	short loc_5390F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_1C], 0	; Compare Two Operands
jnz	short loc_5390F	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6916h], 1
mov	[bp+var_1C], 1
jmp	loc_539CE	; Jump

loc_5390F:		; CODE XREF: sub_5301E+8D3j
			; sub_5301E+8D9j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Eh], 3 ; Compare Two Operands
jle	short loc_5393B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_5391F:		; Compare Two Operands
cmp	[bp+var_18], 0
jnz	short loc_5393B	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6916h], 3
mov	[bp+var_18], 1
jmp	loc_539CE	; Jump

loc_5393B:		; CODE XREF: sub_5301E+8FFj
			; sub_5301E+905j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ch], 3 ; Compare Two Operands
jle	short loc_53966	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_1E], 0	; Compare Two Operands
jnz	short loc_53966	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h

loc_53956:		; Signed Multiply
imul	dx
mov	bx, ax
mov	[byte ptr bx+6916h], 0
mov	[bp+var_1E], 1
jmp	short loc_539CE	; Jump

loc_53966:		; CODE XREF: sub_5301E+92Bj
			; sub_5301E+931j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6962h], 3 ; Compare Two Operands
jle	short loc_53991	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_1A], 0	; Compare Two Operands
jnz	short loc_53991	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6916h], 2
mov	[bp+var_1A], 1
jmp	short loc_539CE	; Jump

loc_53991:		; CODE XREF: sub_5301E+956j
			; sub_5301E+95Cj
			; sub_5301E+990j
mov	ax, 5
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_10], ax
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1E]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jnz	short loc_539B0	; Jump if Not Zero (ZF=0)
jmp	short loc_53991	; Jump

loc_539B0:		; CODE XREF: sub_5301E+98Ej
mov	bx, [bp+var_10]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_1E]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 1
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dl, [byte ptr bp+var_10]
mov	bx, ax
mov	[bx+6916h], dl

loc_539CE:		; CODE XREF: sub_5301E+8EEj
			; sub_5301E+91Aj
			; sub_5301E+946j
			; sub_5301E+971j
inc	si		; Increment by 1

loc_539CF:		; CODE XREF: sub_5301E+8C2j
cmp	si, [word_3A4E2] ; Compare Two Operands
jge	short loc_539D8	; Jump if Greater or Equal (SF=OF)
jmp	loc_538E3	; Jump

loc_539D8:		; CODE XREF: sub_5301E+9B5j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_5301E

off_539DE dw offset loc_534D9
			; DATA XREF: sub_5301E+4B6r
dw offset loc_5352B	; jump table for switch	statement
dw offset loc_5357D
dw offset loc_535BF
dw offset loc_53601
dw offset loc_53643
dw offset loc_53643
dw offset loc_53643
off_539EE dw offset loc_532D0
			; DATA XREF: sub_5301E+2ADr
dw offset loc_532F0	; jump table for switch	statement
dw offset loc_53310
dw offset loc_5332F
dw offset loc_5334E
dw offset loc_5336D
off_539FA dw offset loc_53249
			; DATA XREF: sub_5301E+226r
dw offset loc_53250	; jump table for switch	statement
dw offset loc_53252
dw offset loc_53261
dw offset loc_53271
dw offset loc_53281


; Attributes: bp-based frame

proc sub_53A06 far	; CODE XREF: sub_31BD8J
			; sub_522E0+B1p

var_22=	word ptr -22h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 22h		; Integer Subtraction
push	si
push	di
mov	[bp+var_2], 0
jmp	loc_54618	; Jump

loc_53A16:		; CODE XREF: sub_53A06+C1Bj
mov	[bp+var_4], 0
jmp	short loc_53A4C	; Jump

loc_53A1D:		; CODE XREF: sub_53A06+4Aj
mov	[bp+var_6], 0
jmp	short loc_53A43	; Jump

loc_53A24:		; CODE XREF: sub_53A06+41j
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, [bp+var_6]	; Add
mov	[byte ptr bx+6B64h], 0
inc	[bp+var_6]	; Increment by 1

loc_53A43:		; CODE XREF: sub_53A06+1Cj
cmp	[bp+var_6], 28h	; '(' ; Compare Two Operands
jl	short loc_53A24	; Jump if Less (SF!=OF)
inc	[bp+var_4]	; Increment by 1

loc_53A4C:		; CODE XREF: sub_53A06+15j
cmp	[bp+var_4], 6	; Compare Two Operands
jl	short loc_53A1D	; Jump if Less (SF!=OF)
mov	[bp+var_4], 0
jmp	loc_545CE	; Jump

loc_53A5A:		; CODE XREF: sub_53A06+BCEj
cmp	[bp+var_4], 5	; Compare Two Operands
jz	short loc_53A63	; Jump if Zero (ZF=1)
jmp	loc_53BAB	; Jump

loc_53A63:		; CODE XREF: sub_53A06+58j
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B64h], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B65h], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B66h], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h

loc_53AB4:		; Signed Multiply
imul	dx
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B67h], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B68h], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B69h], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B6Ah], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B6Bh], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B6Ch], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B6Dh], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B6Eh], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B6Fh], 1
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	[byte ptr bx+6B71h], 2
jmp	loc_545CB	; Jump

loc_53BAB:		; CODE XREF: sub_53A06+5Aj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
cmp	[word ptr bx+695Ah], 0 ; Compare Two Operands
jnz	short loc_53BC6	; Jump if Not Zero (ZF=0)
jmp	loc_545CB	; Jump

loc_53BC6:		; CODE XREF: sub_53A06+1BBj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
cmp	[word ptr bx+695Ah], 0Bh ; Compare Two Operands
jz	short loc_53BE1	; Jump if Zero (ZF=1)
jmp	loc_53F9E	; Jump

loc_53BE1:		; CODE XREF: sub_53A06+1D6j
xor	di, di		; Logical Exclusive OR
jmp	short loc_53C01	; Jump

loc_53BE5:		; CODE XREF: sub_53A06+1FEj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr bx+6B64h], 1
inc	di		; Increment by 1

loc_53C01:		; CODE XREF: sub_53A06+1DDj
cmp	di, 28h	; '('   ; Compare Two Operands
jl	short loc_53BE5	; Jump if Less (SF!=OF)
mov	bx, [bp+var_4]
cmp	bx, 4		; switch 5 cases
jbe	short loc_53C11	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_53F9B	; default

loc_53C11:		; CODE XREF: sub_53A06+206j
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_54681+bx] ; switch jump

loc_53C18:		; DATA XREF: ovr056:off_54681o
mov	[bp+var_C], 0	; case 0x0
jmp	short loc_53C3E	; Jump

loc_53C1F:		; CODE XREF: sub_53A06+23Cj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply

loc_53C30:
pop	bx
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
mov	[byte ptr bx+6B64h], 2
inc	[bp+var_C]	; Increment by 1

loc_53C3E:		; CODE XREF: sub_53A06+217j
cmp	[bp+var_C], 0Ah	; Compare Two Operands
jl	short loc_53C1F	; Jump if Less (SF!=OF)

loc_53C44:
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-75AAh]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add

loc_53C6F:
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-75A8h]
dec	ax		; Decrement by 1

loc_53C97:
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-75A6h]

loc_53CC6:		; CODE XREF: sub_53A06+37Fj
			; sub_53A06+430j
			; sub_53A06+4E1j
			; sub_53A06+592j
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide

loc_53CCD:		; Add
add	bx, dx

loc_53CCF:
mov	[byte ptr bx+6B64h], 2
jmp	loc_53F9B	; default

loc_53CD7:		; CODE XREF: sub_53A06+20Dj
			; DATA XREF: ovr056:off_54681o
mov	[bp+var_C], 0	; case 0x4
jmp	short loc_53CFD	; Jump

loc_53CDE:		; CODE XREF: sub_53A06+2FBj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
mov	[byte ptr bx+6B64h], 2
inc	[bp+var_C]	; Increment by 1

loc_53CFD:		; CODE XREF: sub_53A06+2D6j
cmp	[bp+var_C], 0Ah	; Compare Two Operands
jl	short loc_53CDE	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]

loc_53D06:
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-7542h]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-7540h]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-753Eh]
jmp	loc_53CC6	; Jump

loc_53D88:		; CODE XREF: sub_53A06+20Dj
			; DATA XREF: ovr056:off_54681o
mov	[bp+var_C], 0	; case 0x2
jmp	short loc_53DAE	; Jump

loc_53D8F:		; CODE XREF: sub_53A06+3ACj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
mov	[byte ptr bx+6B64h], 2
inc	[bp+var_C]	; Increment by 1

loc_53DAE:		; CODE XREF: sub_53A06+387j
cmp	[bp+var_C], 0Ah	; Compare Two Operands
jl	short loc_53D8F	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-7576h]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-7574h]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-7572h]
jmp	loc_53CC6	; Jump

loc_53E39:		; CODE XREF: sub_53A06+20Dj
			; DATA XREF: ovr056:off_54681o
mov	[bp+var_C], 0	; case 0x3
jmp	short loc_53E5F	; Jump

loc_53E40:		; CODE XREF: sub_53A06+45Dj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add
mov	[byte ptr bx+6B64h], 2
inc	[bp+var_C]	; Increment by 1

loc_53E5F:		; CODE XREF: sub_53A06+438j
cmp	[bp+var_C], 0Ah	; Compare Two Operands
jl	short loc_53E40	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-755Ch]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]

loc_53E98:
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''

loc_53EAF:		; Signed Multiply
imul	dx
mov	si, ax
mov	ax, [si-755Ah]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-7558h]
jmp	loc_53CC6	; Jump

loc_53EEA:		; CODE XREF: sub_53A06+20Dj
			; DATA XREF: ovr056:off_54681o
mov	[bp+var_C], 0	; case 0x1

loc_53EEF:		; Jump
jmp	short loc_53F10

loc_53EF1:		; CODE XREF: sub_53A06+50Ej
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, [bp+var_C]	; Add

loc_53F08:
mov	[byte ptr bx+6B64h], 2
inc	[bp+var_C]	; Increment by 1

loc_53F10:		; CODE XREF: sub_53A06:loc_53EEFj
cmp	[bp+var_C], 0Ah	; Compare Two Operands
jl	short loc_53EF1	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-7590h]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-758Eh]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	si, ax
mov	ax, [si-758Ch]
jmp	loc_53CC6	; Jump

loc_53F9B:		; CODE XREF: sub_53A06+208j
			; sub_53A06+2CEj
jmp	loc_545CB	; default

loc_53F9E:		; CODE XREF: sub_53A06+1D8j
xor	di, di		; Logical Exclusive OR
jmp	short loc_53FB0	; Jump

loc_53FA2:		; CODE XREF: sub_53A06+5ADj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0
inc	di		; Increment by 1

loc_53FB0:		; CODE XREF: sub_53A06+59Aj
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_53FA2	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	bx, [bx+695Ah]
dec	bx		; Decrement by 1
cmp	bx, 9		; switch 10 cases
ja	short loc_5400E	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_5466D+bx] ; switch jump

loc_53FD7:		; DATA XREF: ovr056:off_5466Do
mov	[bp+var_8], 3	; case 0x0
jmp	short loc_5400E	; default

loc_53FDE:		; CODE XREF: sub_53A06+5CCj
			; DATA XREF: ovr056:off_5466Do
mov	[bp+var_8], 5	; case 0x1
jmp	short loc_5400E	; default

loc_53FE5:		; CODE XREF: sub_53A06+5CCj
			; DATA XREF: ovr056:off_5466Do
mov	[bp+var_8], 6	; case 0x2
jmp	short loc_5400E	; default

loc_53FEC:		; CODE XREF: sub_53A06+5CCj
			; DATA XREF: ovr056:off_5466Do
mov	[bp+var_8], 7	; case 0x3
jmp	short loc_5400E	; default

loc_53FF3:		; CODE XREF: sub_53A06+5CCj
			; DATA XREF: ovr056:off_5466Do
mov	[bp+var_8], 8	; case 0x4
jmp	short loc_5400E	; default

loc_53FFA:		; CODE XREF: sub_53A06+5CCj
			; DATA XREF: ovr056:off_5466Do
mov	[bp+var_8], 9	; case 0x5
jmp	short loc_5400E	; default

loc_54001:		; CODE XREF: sub_53A06+5CCj
			; DATA XREF: ovr056:off_5466Do
jmp	short loc_54007	; case 0x6

loc_54003:		; CODE XREF: sub_53A06+5CCj
			; DATA XREF: ovr056:off_5466Do
jmp	short loc_54007	; case 0x7

loc_54005:		; CODE XREF: sub_53A06+5CCj
			; DATA XREF: ovr056:off_5466Do
jmp	short $+2	; case 0x8

loc_54007:		; CODE XREF: sub_53A06+5CCj
			; sub_53A06:loc_54001j
			; sub_53A06:loc_54003j
			; DATA XREF: ovr056:off_5466Do
mov	[bp+var_8], 0Ah	; case 0x9
jmp	short $+2	; Jump

loc_5400E:		; CODE XREF: sub_53A06+5C8j
			; sub_53A06+5D6j
			; sub_53A06+5DDj
			; sub_53A06+5E4j
			; sub_53A06+5EBj
			; sub_53A06+5F2j
			; sub_53A06+5F9j
mov	bx, [bp+var_4]	; default
cmp	bx, 4		; switch 5 cases
jbe	short loc_54019	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_541D6	; default

loc_54019:		; CODE XREF: sub_53A06+60Ej
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_54663+bx] ; switch jump

loc_54020:		; DATA XREF: ovr056:off_54663o
xor	di, di		; case 0x0
jmp	short loc_5405B	; Jump

loc_54024:		; CODE XREF: sub_53A06+66Dj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	dx, di
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	si, ax
mov	ax, [si-75BEh]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
inc	di		; Increment by 1

loc_5405B:		; CODE XREF: sub_53A06+61Cj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jg	short loc_54024	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_541D6	; default

loc_54078:		; CODE XREF: sub_53A06+615j
			; DATA XREF: ovr056:off_54663o
xor	di, di		; case 0x3
jmp	short loc_540B3	; Jump

loc_5407C:		; CODE XREF: sub_53A06+6C5j
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	dx, di
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	si, ax
mov	ax, [si-7570h]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
inc	di		; Increment by 1

loc_540B3:		; CODE XREF: sub_53A06+674j
mov	ax, [bp+var_2]
mov	dx, 4C8h

loc_540B9:		; Signed Multiply
imul	dx
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left

loc_540C0:		; Add
add	ax, dx
mov	bx, ax
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jg	short loc_5407C	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_541D6	; default

loc_540D0:		; CODE XREF: sub_53A06+615j
			; DATA XREF: ovr056:off_54663o
xor	di, di		; case 0x4
jmp	short loc_5410B	; Jump

loc_540D4:		; CODE XREF: sub_53A06+71Dj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax

loc_540DD:
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add

loc_540E8:
mov	ax, [bp+var_2]

loc_540EB:
mov	dx, 82h	; ''
imul	dx		; Signed Multiply

loc_540F0:
mov	dx, di

loc_540F2:		; Shift	Logical	Left
shl	dx, 1
add	ax, dx		; Add
mov	si, ax
mov	ax, [si-7556h]
dec	ax		; Decrement by 1

loc_540FD:
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
inc	di		; Increment by 1

loc_5410B:		; CODE XREF: sub_53A06+6CCj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_54113:
mov	dx, [bp+var_4]

loc_54116:		; Shift	Logical	Left
shl	dx, 1

loc_54118:		; Add
add	ax, dx
mov	bx, ax
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jg	short loc_540D4	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_541D6	; default

loc_54128:		; CODE XREF: sub_53A06+615j
			; DATA XREF: ovr056:off_54663o
xor	di, di		; case 0x2
jmp	short loc_54163	; Jump

loc_5412C:		; CODE XREF: sub_53A06+775j
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]

loc_54143:
mov	dx, 82h	; ''
imul	dx		; Signed Multiply
mov	dx, di
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	si, ax

loc_54150:
mov	ax, [si-758Ah]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)

loc_54159:		; Signed Divide
idiv	cx
add	bx, dx		; Add
mov	[byte ptr bx+6B64h], 2
inc	di		; Increment by 1

loc_54163:		; CODE XREF: sub_53A06+724j
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_5416B:
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1
cmp	ax, di		; Compare Two Operands
jg	short loc_5412C	; Jump if Greater (ZF=0	& SF=OF)
jmp	short loc_541D6	; default

loc_5417F:		; CODE XREF: sub_53A06+615j
			; DATA XREF: ovr056:off_54663o
xor	di, di		; case 0x1
jmp	short loc_541BA	; Jump

loc_54183:		; CODE XREF: sub_53A06+7CCj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('

loc_54192:		; Signed Multiply
imul	dx
pop	bx
add	bx, ax		; Add
mov	ax, [bp+var_2]
mov	dx, 82h	; ''
imul	dx		; Signed Multiply

loc_5419F:
mov	dx, di
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	si, ax
mov	ax, [si-75A4h]
dec	ax		; Decrement by 1
mov	cx, 28h	; '('
cwd			; AX ->	DX:AX (with sign)
idiv	cx		; Signed Divide

loc_541B2:		; Add
add	bx, dx
mov	[byte ptr bx+6B64h], 2
inc	di		; Increment by 1

loc_541BA:		; CODE XREF: sub_53A06+77Bj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_541C2:
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add

loc_541C9:
mov	bx, ax

loc_541CB:
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1

loc_541D0:		; Compare Two Operands
cmp	ax, di
jg	short loc_54183	; Jump if Greater (ZF=0	& SF=OF)
jmp	short $+2	; Jump

loc_541D6:		; CODE XREF: sub_53A06+610j
			; sub_53A06+66Fj
			; sub_53A06+6C7j
			; sub_53A06+71Fj
			; sub_53A06+777j
mov	ax, [bp+var_2]	; default
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	ax, [bx+695Ah]
dec	ax		; Decrement by 1
mov	[bp+var_E], ax
jmp	short loc_54265	; Jump

loc_541F1:		; CODE XREF: sub_53A06+865j
mov	ax, 0Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	di, ax
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add

loc_54212:		; Add
add	bx, di
cmp	[byte ptr bx+6B64h], 0 ; Compare Two Operands
jnz	short loc_54236	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr bx+6B64h], 1

loc_54236:		; CODE XREF: sub_53A06+813j
mov	[bp+var_E], 0
xor	di, di		; Logical Exclusive OR
jmp	short loc_54260	; Jump

loc_5423F:		; CODE XREF: sub_53A06+85Dj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, di		; Add
cmp	[byte ptr bx+6B64h], 0 ; Compare Two Operands
jz	short loc_5425F	; Jump if Zero (ZF=1)

loc_5425C:		; Increment by 1
inc	[bp+var_E]

loc_5425F:		; CODE XREF: sub_53A06+854j
inc	di		; Increment by 1

loc_54260:		; CODE XREF: sub_53A06+837j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_5423F	; Jump if Less (SF!=OF)

loc_54265:		; CODE XREF: sub_53A06+7E9j
mov	ax, [bp+var_E]
cmp	ax, [bp+var_8]	; Compare Two Operands
jl	short loc_541F1	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
cmp	[word ptr bx+695Ah], 7 ; Compare Two Operands
jle	short loc_542AD	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	di, di		; Logical Exclusive OR
jmp	short loc_542A5	; Jump

loc_54289:		; CODE XREF: sub_53A06+8A2j
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr bx+6B6Eh], 1
inc	di		; Increment by 1

loc_542A5:		; CODE XREF: sub_53A06+881j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_54289	; Jump if Less (SF!=OF)
jmp	loc_5438C	; Jump

loc_542AD:		; CODE XREF: sub_53A06+87Dj
xor	di, di		; Logical Exclusive OR
jmp	short loc_542BF	; Jump

loc_542B1:		; CODE XREF: sub_53A06+8BCj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0
inc	di		; Increment by 1

loc_542BF:		; CODE XREF: sub_53A06+8A9j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_542B1	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply

loc_542CC:
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
mov	bx, [bx+695Ah]
dec	bx		; Decrement by 1
cmp	bx, 9		; switch 10 cases
ja	short loc_54322	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_5464F+bx] ; switch jump

loc_542E6:		; DATA XREF: ovr056:off_5464Fo
mov	[bp+var_8], 1	; case 0x0
jmp	short loc_54322	; default

loc_542ED:		; CODE XREF: sub_53A06+8DBj
			; DATA XREF: ovr056:off_5464Fo
mov	[bp+var_8], 2	; case 0x1
jmp	short loc_54322	; default

loc_542F4:		; CODE XREF: sub_53A06+8DBj
			; DATA XREF: ovr056:off_5464Fo
mov	[bp+var_8], 3	; case 0x2
jmp	short loc_54322	; default

loc_542FB:		; CODE XREF: sub_53A06+8DBj
			; DATA XREF: ovr056:off_5464Fo
mov	[bp+var_8], 4	; case 0x3
jmp	short loc_54322	; default

loc_54302:		; CODE XREF: sub_53A06+8DBj
			; DATA XREF: ovr056:off_5464Fo
mov	[bp+var_8], 5	; case 0x4
jmp	short loc_54322	; default

loc_54309:		; CODE XREF: sub_53A06+8DBj
			; DATA XREF: ovr056:off_5464Fo
mov	[bp+var_8], 6	; case 0x5
jmp	short loc_54322	; default

loc_54310:		; CODE XREF: sub_53A06+8DBj
			; DATA XREF: ovr056:off_5464Fo
mov	[bp+var_8], 8	; case 0x6

loc_54315:		; default
jmp	short loc_54322

loc_54317:		; CODE XREF: sub_53A06+8DBj
			; DATA XREF: ovr056:off_5464Fo
jmp	short loc_5431B	; case 0x7

loc_54319:		; CODE XREF: sub_53A06+8DBj
			; DATA XREF: ovr056:off_5464Fo
jmp	short $+2	; case 0x8

loc_5431B:		; CODE XREF: sub_53A06+8DBj
			; sub_53A06:loc_54317j
			; DATA XREF: ovr056:off_5464Fo
mov	[bp+var_8], 0Ah	; case 0x9
jmp	short $+2	; Jump

loc_54322:		; CODE XREF: sub_53A06+8D7j
			; sub_53A06+8E5j
			; sub_53A06+8ECj
			; sub_53A06+8F3j
			; sub_53A06+8FAj
			; sub_53A06+901j
			; sub_53A06+908j
			; sub_53A06:loc_54315j
xor	di, di		; default
jmp	short loc_54354	; Jump

loc_54326:		; CODE XREF: sub_53A06+93Dj
			; sub_53A06:loc_54357j
mov	ax, 0Ah
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_A], ax
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jnz	short loc_54345	; Jump if Not Zero (ZF=0)
jmp	short loc_54326	; Jump

loc_54345:		; CODE XREF: sub_53A06+93Bj
mov	bx, [bp+var_A]

loc_54348:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 1
inc	di		; Increment by 1

loc_54354:		; CODE XREF: sub_53A06+91Ej
cmp	di, [bp+var_8]	; Compare Two Operands

loc_54357:		; Jump if Less (SF!=OF)
jl	short loc_54326
xor	di, di		; Logical Exclusive OR
jmp	short loc_54387	; Jump

loc_5435D:		; CODE XREF: sub_53A06+984j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jnz	short loc_54386	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr bx+6B6Eh], 1

loc_54386:		; CODE XREF: sub_53A06+963j
inc	di		; Increment by 1

loc_54387:		; CODE XREF: sub_53A06+955j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_5435D	; Jump if Less (SF!=OF)

loc_5438C:		; CODE XREF: sub_53A06+8A4j
mov	ax, [bp+var_2]

loc_5438F:
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add

loc_5439B:
mov	bx, ax
cmp	[word ptr bx+695Ah], 9 ; Compare Two Operands
jle	short loc_543CC	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	di, di		; Logical Exclusive OR
jmp	short loc_543C4	; Jump

loc_543A8:		; CODE XREF: sub_53A06+9C1j
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr bx+6B78h], 1
inc	di		; Increment by 1

loc_543C4:		; CODE XREF: sub_53A06+9A0j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_543A8	; Jump if Less (SF!=OF)
jmp	loc_544AE	; Jump

loc_543CC:		; CODE XREF: sub_53A06+99Cj
xor	di, di		; Logical Exclusive OR
jmp	short loc_543DE	; Jump

loc_543D0:		; CODE XREF: sub_53A06+9DBj
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0
inc	di		; Increment by 1

loc_543DE:		; CODE XREF: sub_53A06+9C8j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_543D0	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]

loc_543EE:		; Shift	Logical	Left
shl	dx, 1

loc_543F0:		; Add
add	ax, dx
mov	bx, ax
mov	bx, [bx+695Ah]
dec	bx		; Decrement by 1
cmp	bx, 8		; switch 9 cases
ja	short loc_54444	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_5463D+bx] ; switch jump

loc_54405:		; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 0	; case 0x0
jmp	short loc_54444	; default

loc_5440C:		; CODE XREF: sub_53A06+9FAj
			; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 1	; case 0x1
jmp	short loc_54444	; default

loc_54413:		; CODE XREF: sub_53A06+9FAj
			; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 2	; case 0x2
jmp	short loc_54444	; default

loc_5441A:		; CODE XREF: sub_53A06+9FAj
			; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 3	; case 0x3
jmp	short loc_54444	; default

loc_54421:		; CODE XREF: sub_53A06+9FAj
			; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 4	; case 0x4

loc_54426:		; default
jmp	short loc_54444

loc_54428:		; CODE XREF: sub_53A06+9FAj
			; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 5	; case 0x5
jmp	short loc_54444	; default

loc_5442F:		; CODE XREF: sub_53A06+9FAj
			; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 6	; case 0x6
jmp	short loc_54444	; default

loc_54436:		; CODE XREF: sub_53A06+9FAj
			; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 7	; case 0x7
jmp	short loc_54444	; default

loc_5443D:		; CODE XREF: sub_53A06+9FAj
			; DATA XREF: ovr056:off_5463Do
mov	[bp+var_8], 9	; case 0x8
jmp	short $+2	; Jump

loc_54444:		; CODE XREF: sub_53A06+9F6j
			; sub_53A06+A04j
			; sub_53A06+A0Bj
			; sub_53A06+A12j
			; sub_53A06+A19j
			; sub_53A06:loc_54426j
			; sub_53A06+A27j
			; sub_53A06+A2Ej
			; sub_53A06+A35j
xor	di, di		; default
jmp	short loc_54476	; Jump

loc_54448:		; CODE XREF: sub_53A06+A5Fj
			; sub_53A06+A73j
mov	ax, 0Ah
push	ax

loc_5444C:		; Call Procedure
call	idk_Arg_0Fail_ElseMathyDiSi
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_A], ax
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jnz	short loc_54467	; Jump if Not Zero (ZF=0)
jmp	short loc_54448	; Jump

loc_54467:		; CODE XREF: sub_53A06+A5Dj
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 1
inc	di		; Increment by 1

loc_54476:		; CODE XREF: sub_53A06+A40j
cmp	di, [bp+var_8]	; Compare Two Operands
jl	short loc_54448	; Jump if Less (SF!=OF)

loc_5447B:		; Logical Exclusive OR
xor	di, di
jmp	short loc_544A9	; Jump

loc_5447F:		; CODE XREF: sub_53A06+AA6j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands

loc_5448B:		; Jump if Not Zero (ZF=0)
jnz	short loc_544A8
mov	ax, [bp+var_2]
mov	dx, 4C8h

loc_54493:		; Signed Multiply
imul	dx
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr bx+6B78h], 1

loc_544A8:		; CODE XREF: sub_53A06:loc_5448Bj
inc	di		; Increment by 1

loc_544A9:		; CODE XREF: sub_53A06+A77j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_5447F	; Jump if Less (SF!=OF)

loc_544AE:		; CODE XREF: sub_53A06+9C3j
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax
cmp	[word ptr bx+695Ah], 9 ; Compare Two Operands
jle	short loc_544EE	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
xor	di, di		; Logical Exclusive OR
jmp	short loc_544E6	; Jump

loc_544CA:		; CODE XREF: sub_53A06+AE3j
mov	ax, [bp+var_2]

loc_544CD:
mov	dx, 4C8h

loc_544D0:		; Signed Multiply
imul	dx
push	ax
mov	ax, [bp+var_4]

loc_544D6:
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx
add	bx, ax		; Add
add	bx, di		; Add
mov	[byte ptr bx+6B82h], 1
inc	di		; Increment by 1

loc_544E6:		; CODE XREF: sub_53A06+AC2j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_544CA	; Jump if Less (SF!=OF)
jmp	loc_545CB	; Jump

loc_544EE:		; CODE XREF: sub_53A06+ABEj
xor	di, di		; Logical Exclusive OR
jmp	short loc_54500	; Jump

loc_544F2:		; CODE XREF: sub_53A06+AFDj
mov	bx, di

loc_544F4:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0
inc	di		; Increment by 1

loc_54500:		; CODE XREF: sub_53A06+AEAj
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_544F2	; Jump if Less (SF!=OF)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	dx, [bp+var_4]
shl	dx, 1		; Shift	Logical	Left
add	ax, dx		; Add
mov	bx, ax

loc_54516:
mov	bx, [bx+695Ah]
dec	bx		; Decrement by 1

loc_5451B:		; switch 9 cases
cmp	bx, 8
ja	short loc_54561	; default
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_5462B+bx] ; switch jump

loc_54527:		; CODE XREF: sub_53A06:loc_5452Ej
			; DATA XREF: ovr056:off_5462Bo
mov	[bp+var_8], 0	; case 0x0
jmp	short loc_54561	; default

loc_5452E:		; CODE XREF: sub_53A06+B1Cj
			; DATA XREF: ovr056:off_5462Bo
jmp	short loc_54527	; case 0x1

loc_54530:		; CODE XREF: sub_53A06+B1Cj
			; DATA XREF: ovr056:off_5462Bo
mov	[bp+var_8], 1	; case 0x2
jmp	short loc_54561	; default

loc_54537:		; CODE XREF: sub_53A06+B1Cj
			; DATA XREF: ovr056:off_5462Bo
mov	[bp+var_8], 2	; case 0x3
jmp	short loc_54561	; default

loc_5453E:		; CODE XREF: sub_53A06+B1Cj
			; DATA XREF: ovr056:off_5462Bo
mov	[bp+var_8], 3	; case 0x4
jmp	short loc_54561	; default

loc_54545:		; CODE XREF: sub_53A06+B1Cj
			; DATA XREF: ovr056:off_5462Bo
mov	[bp+var_8], 4	; case 0x5
jmp	short loc_54561	; default

loc_5454C:		; CODE XREF: sub_53A06+B1Cj
			; DATA XREF: ovr056:off_5462Bo
mov	[bp+var_8], 5	; case 0x6
jmp	short loc_54561	; default

loc_54553:		; CODE XREF: sub_53A06+B1Cj
			; DATA XREF: ovr056:off_5462Bo
mov	[bp+var_8], 6	; case 0x7
jmp	short loc_54561	; default

loc_5455A:		; CODE XREF: sub_53A06+B1Cj
			; DATA XREF: ovr056:off_5462Bo
mov	[bp+var_8], 7	; case 0x8
jmp	short $+2	; Jump

loc_54561:		; CODE XREF: sub_53A06+B18j
			; sub_53A06+B26j
			; sub_53A06+B2Fj
			; sub_53A06+B36j
			; sub_53A06+B3Dj
			; sub_53A06+B44j
			; sub_53A06+B4Bj
			; sub_53A06+B52j
xor	di, di		; default
jmp	short loc_54593	; Jump

loc_54565:		; CODE XREF: sub_53A06+B7Cj
			; sub_53A06+B90j
mov	ax, 0Ah
push	ax

loc_54569:		; Call Procedure
call	idk_Arg_0Fail_ElseMathyDiSi
pop	cx
dec	ax		; Decrement by 1
mov	[bp+var_A], ax

loc_54573:
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jnz	short loc_54584	; Jump if Not Zero (ZF=0)
jmp	short loc_54565	; Jump

loc_54584:		; CODE XREF: sub_53A06+B7Aj
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address

loc_5458C:		; Add
add	bx, ax
mov	[word ptr bx], 1
inc	di		; Increment by 1

loc_54593:		; CODE XREF: sub_53A06+B5Dj
cmp	di, [bp+var_8]	; Compare Two Operands
jl	short loc_54565	; Jump if Less (SF!=OF)
xor	di, di		; Logical Exclusive OR
jmp	short loc_545C6	; Jump

loc_5459C:		; CODE XREF: sub_53A06+BC3j
mov	bx, di
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_22]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 1 ; Compare Two Operands
jnz	short loc_545C5	; Jump if Not Zero (ZF=0)

loc_545AA:
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
push	ax
mov	ax, [bp+var_4]
mov	dx, 28h	; '('
imul	dx		; Signed Multiply
pop	bx

loc_545BC:		; Add
add	bx, ax
add	bx, di		; Add
mov	[byte ptr bx+6B82h], 1

loc_545C5:		; CODE XREF: sub_53A06+BA2j
inc	di		; Increment by 1

loc_545C6:		; CODE XREF: sub_53A06+B94j
cmp	di, 0Ah		; Compare Two Operands
jl	short loc_5459C	; Jump if Less (SF!=OF)

loc_545CB:		; CODE XREF: sub_53A06+1A2j
			; sub_53A06+1BDj
			; sub_53A06:loc_53F9Bj
			; sub_53A06+AE5j
inc	[bp+var_4]	; Increment by 1

loc_545CE:		; CODE XREF: sub_53A06+51j
cmp	[bp+var_4], 6	; Compare Two Operands
jge	short loc_545D7	; Jump if Greater or Equal (SF=OF)
jmp	loc_53A5A	; Jump

loc_545D7:		; CODE XREF: sub_53A06+BCCj
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6C2Ch], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+6975h], 0 ; Compare Two Operands
jz	short loc_54615	; Jump if Zero (ZF=1)
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6C32h], 2
mov	ax, [bp+var_2]
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[byte ptr bx+6C36h], 2

loc_54615:		; CODE XREF: sub_53A06+BEFj
inc	[bp+var_2]	; Increment by 1

loc_54618:		; CODE XREF: sub_53A06+Dj
mov	ax, [bp+var_2]
cmp	ax, [word_3A4E2] ; Compare Two Operands
jge	short loc_54624	; Jump if Greater or Equal (SF=OF)
jmp	loc_53A16	; Jump

loc_54624:		; CODE XREF: sub_53A06+C19j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_53A06

db 0
off_5462B dw offset loc_54527
			; DATA XREF: sub_53A06+B1Cr
dw offset loc_5452E	; jump table for switch	statement
dw offset loc_54530
dw offset loc_54537
dw offset loc_5453E
dw offset loc_54545
dw offset loc_5454C
dw offset loc_54553
dw offset loc_5455A
off_5463D dw offset loc_54405
			; DATA XREF: sub_53A06+9FAr
dw offset loc_5440C	; jump table for switch	statement
dw offset loc_54413
dw offset loc_5441A
dw offset loc_54421
dw offset loc_54428
dw offset loc_5442F
dw offset loc_54436
dw offset loc_5443D
off_5464F dw offset loc_542E6
			; DATA XREF: sub_53A06+8DBr
dw offset loc_542ED	; jump table for switch	statement
dw offset loc_542F4
dw offset loc_542FB
dw offset loc_54302
dw offset loc_54309
dw offset loc_54310
dw offset loc_54317
dw offset loc_54319
dw offset loc_5431B
off_54663 dw offset loc_54020
			; DATA XREF: sub_53A06+615r
dw offset loc_5417F	; jump table for switch	statement
dw offset loc_54128
dw offset loc_54078
dw offset loc_540D0
off_5466D dw offset loc_53FD7
			; DATA XREF: sub_53A06+5CCr
dw offset loc_53FDE	; jump table for switch	statement
dw offset loc_53FE5
dw offset loc_53FEC
dw offset loc_53FF3
dw offset loc_53FFA
dw offset loc_54001
dw offset loc_54003
dw offset loc_54005
dw offset loc_54007
off_54681 dw offset loc_53C18
			; DATA XREF: sub_53A06+20Dr
dw offset loc_53EEA	; jump table for switch	statement
dw offset loc_53D88
dw offset loc_53E39
dw offset loc_53CD7


; Attributes: bp-based frame

proc sub_5468B far	; CODE XREF: sub_31BDDJ
push	bp
mov	bp, sp
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx], 32h ;	'2'
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+2], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+8], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+0Eh], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+10h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+18h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+1Eh], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+24h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+2Ch], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+32h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+38h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+3Eh], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+44h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+4Ch], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+50h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx

loc_54727:
mov	[word ptr es:bx+54h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx
mov	[word ptr es:bx+58h], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx

loc_5473B:
mov	[word ptr es:bx+5Ch], 0
les	bx, [dword_37EC8] ; Load Full Pointer to ES:xx

loc_54745:
mov	[word ptr es:bx+60h], 0
pop	bp
retf			; Return Far from Procedure
endp sub_5468B



; Attributes: bp-based frame

proc sub_5474D far	; CODE XREF: sub_31BE2J
			; sub_523A3+15p

var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp

loc_5474E:
mov	bp, sp
sub	sp, 0Eh		; Integer Subtraction
push	si
push	di

loc_54755:
mov	[bp+var_2], 0
jmp	loc_54D9E	; Jump

loc_5475D:		; CODE XREF: sub_5474D+657j
mov	[bp+var_4], 0
jmp	loc_54D92	; Jump

loc_54765:		; CODE XREF: sub_5474D+64Bj
mov	bx, [bp+var_2]
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
les	bx, [bx+65ACh]	; Load Full Pointer to ES:xx
mov	ax, [bp+var_4]
mov	dx, 0Ch

loc_54776:		; Signed Multiply
imul	dx
add	bx, ax		; Add
mov	[word ptr es:bx], 0
xor	di, di		; Logical Exclusive OR
mov	[bp+var_8], 0
mov	[bp+var_A], 0
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+35D2h]
or	ax, ax		; Logical Inclusive OR
jz	short loc_547A9	; Jump if Zero (ZF=1)
cmp	ax, 1		; Compare Two Operands
jz	short loc_547B9	; Jump if Zero (ZF=1)

loc_547A2:		; Compare Two Operands
cmp	ax, 2
jz	short loc_547CC	; Jump if Zero (ZF=1)
jmp	short loc_547DF	; Jump

loc_547A9:		; CODE XREF: sub_5474D+4Ej
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	bx, ax
mov	di, [bx+35D0h]
jmp	short loc_547DF	; Jump

loc_547B9:		; CODE XREF: sub_5474D+53j
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+35D0h]
mov	[bp+var_8], ax
jmp	short loc_547DF	; Jump

loc_547CC:		; CODE XREF: sub_5474D+58j
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+35D0h]
mov	[bp+var_A], ax
jmp	short $+2	; Jump

loc_547DF:		; CODE XREF: sub_5474D+5Aj
			; sub_5474D+6Aj
			; sub_5474D+7Dj
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+35D6h]

loc_547ED:
mov	dx, [bx+35D4h]
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+35D8h]
mov	[bp+var_6], ax
cmp	[bp+var_A], 0	; Compare Two Operands
jle	short loc_54817	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	di, [bp+var_A]
mov	ax, [bp+var_A]
mov	[bp+var_8], ax

loc_54817:		; CODE XREF: sub_5474D+BFj
jmp	loc_54CA4	; default

loc_5481A:		; CODE XREF: sub_5474D+55Bj
			; sub_5474D+564j
mov	ax, 0Eh
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
dec	ax		; Decrement by 1
mov	bx, ax
cmp	bx, 0Dh		; switch 14 cases
jbe	short loc_5482F	; Jump if Below	or Equal (CF=1 | ZF=1)
jmp	loc_54CA4	; default

loc_5482F:		; CODE XREF: sub_5474D+DDj
shl	bx, 1		; Shift	Logical	Left
jmp	[cs:off_54DAD+bx] ; switch jump

loc_54836:		; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x0
mov	dx, [bp+var_E]
and	dx, 2		; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_5488D	; Jump if Not Zero (ZF=0)
or	di, di		; Logical Inclusive OR
jle	short loc_5488D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 1		; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_54877	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
xor	dx, 1		; Logical Exclusive OR
xor	ax, 0		; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 2		; Logical Inclusive OR
jmp	short loc_54880	; Jump

loc_54877:		; CODE XREF: sub_5474D+10Bj
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 1		; Logical Inclusive OR

loc_54880:		; CODE XREF: sub_5474D+128j
or	ax, 0		; Logical Inclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_5488D:		; CODE XREF: sub_5474D+F7j
			; sub_5474D+FBj
jmp	loc_54CA4	; default

loc_54890:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x1
mov	dx, [bp+var_E]
and	dx, 10h		; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_548E7	; Jump if Not Zero (ZF=0)
or	di, di		; Logical Inclusive OR
jle	short loc_548E7	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 8		; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_548D1	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
xor	dx, 8		; Logical Exclusive OR
xor	ax, 0		; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 10h		; Logical Inclusive OR
jmp	short loc_548DA	; Jump

loc_548D1:		; CODE XREF: sub_5474D+165j
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 8		; Logical Inclusive OR

loc_548DA:		; CODE XREF: sub_5474D+182j
or	ax, 0		; Logical Inclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_548E7:		; CODE XREF: sub_5474D+151j
			; sub_5474D+155j
jmp	loc_54CA4	; default

loc_548EA:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x2
mov	dx, [bp+var_E]
and	dx, 400h	; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_54946	; Jump if Not Zero (ZF=0)
or	di, di		; Logical Inclusive OR
jle	short loc_54946	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 200h	; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_5492F	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
xor	dx, 200h	; Logical Exclusive OR
xor	ax, 0		; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]

loc_54929:		; Logical Inclusive OR
or	dx, 400h
jmp	short loc_54939	; Jump

loc_5492F:		; CODE XREF: sub_5474D+1C1j
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 200h	; Logical Inclusive OR

loc_54939:		; CODE XREF: sub_5474D+1E0j
or	ax, 0		; Logical Inclusive OR

loc_5493C:
mov	[bp+var_C], ax
mov	[bp+var_E], dx

loc_54942:		; Decrement by 1
dec	di
dec	[bp+var_8]	; Decrement by 1

loc_54946:		; CODE XREF: sub_5474D+1ACj
			; sub_5474D+1B0j
jmp	loc_54CA4	; default

loc_54949:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x3
mov	dx, [bp+var_E]
and	dx, 80h		; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_549A2	; Jump if Not Zero (ZF=0)
or	di, di		; Logical Inclusive OR
jle	short loc_549A2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 40h		; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_5498C	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
xor	dx, 40h		; Logical Exclusive OR
xor	ax, 0		; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 80h		; Logical Inclusive OR
jmp	short loc_54995	; Jump

loc_5498C:		; CODE XREF: sub_5474D+21Fj
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 40h		; Logical Inclusive OR

loc_54995:		; CODE XREF: sub_5474D+23Dj
or	ax, 0		; Logical Inclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx

loc_5499E:		; Decrement by 1
dec	di
dec	[bp+var_8]	; Decrement by 1

loc_549A2:		; CODE XREF: sub_5474D+20Bj
			; sub_5474D+20Fj
jmp	loc_54CA4	; default

loc_549A5:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x4
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 1		; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_54A02	; Jump if Not Zero (ZF=0)
or	di, di		; Logical Inclusive OR
jle	short loc_54A02	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 8000h	; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_549EB	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
xor	dx, 8000h	; Logical Exclusive OR
xor	ax, 0		; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 1		; Logical Inclusive OR
jmp	short loc_549F8	; Jump

loc_549EB:		; CODE XREF: sub_5474D+27Bj
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 8000h	; Logical Inclusive OR
or	ax, 0		; Logical Inclusive OR

loc_549F8:		; CODE XREF: sub_5474D+29Cj
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54A02:		; CODE XREF: sub_5474D+266j
			; sub_5474D+26Aj
jmp	loc_54CA4	; default

loc_54A05:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x5
mov	dx, [bp+var_E]
and	dx, 2000h	; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_54A61	; Jump if Not Zero (ZF=0)
or	di, di		; Logical Inclusive OR
jle	short loc_54A61	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 1000h	; Logical AND
and	ax, 0		; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_54A4A	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
xor	dx, 1000h	; Logical Exclusive OR

loc_54A35:		; Logical Exclusive OR
xor	ax, 0

loc_54A38:
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 2000h	; Logical Inclusive OR
jmp	short loc_54A54	; Jump

loc_54A4A:		; CODE XREF: sub_5474D+2DCj
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 1000h	; Logical Inclusive OR

loc_54A54:		; CODE XREF: sub_5474D+2FBj
or	ax, 0		; Logical Inclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54A61:		; CODE XREF: sub_5474D+2C7j
			; sub_5474D+2CBj
jmp	loc_54CA4	; default

loc_54A64:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x6

loc_54A67:
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 8		; Logical AND

loc_54A70:		; Logical Inclusive OR
or	dx, ax
jnz	short loc_54AE8	; Jump if Not Zero (ZF=0)
cmp	[bp+var_8], 0	; Compare Two Operands
jle	short loc_54AE8	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
cmp	[bp+var_4], 1Fh	; Compare Two Operands
jz	short loc_54AE8	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 4		; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_54AD2	; Jump if Zero (ZF=1)

loc_54A90:
mov	ax, [bp+var_4]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+210h], 1Fh	; Compare Two Operands
jl	short loc_54AD2	; Jump if Less (SF!=OF)
mov	ax, [bp+var_4]
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+210h], 26h	; '&' ; Compare Two Operands

loc_54AB0:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_54AD2

loc_54AB2:
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
xor	dx, 0		; Logical Exclusive OR
xor	ax, 4		; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 8		; Logical Inclusive OR
jmp	short loc_54ADE	; Jump

loc_54AD2:		; CODE XREF: sub_5474D+341j
			; sub_5474D+352j
			; sub_5474D:loc_54AB0j
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 4		; Logical Inclusive OR

loc_54ADE:		; CODE XREF: sub_5474D+383j
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54AE8:		; CODE XREF: sub_5474D+325j
			; sub_5474D+32Bj
			; sub_5474D+331j
jmp	loc_54CA4	; default

loc_54AEB:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x7
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 200h	; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_54B47	; Jump if Not Zero (ZF=0)
cmp	[bp+var_8], 0	; Compare Two Operands
jle	short loc_54B47	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 100h	; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_54B31	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]

loc_54B14:
mov	dx, [bp+var_E]

loc_54B17:		; Logical Exclusive OR
xor	dx, 0
xor	ax, 100h	; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR

loc_54B2C:		; Logical Inclusive OR
or	ax, 200h
jmp	short loc_54B3D	; Jump

loc_54B31:		; CODE XREF: sub_5474D+3C2j
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 100h	; Logical Inclusive OR

loc_54B3D:		; CODE XREF: sub_5474D+3E2j
mov	[bp+var_C], ax
mov	[bp+var_E], dx

loc_54B43:		; Decrement by 1
dec	di
dec	[bp+var_8]	; Decrement by 1

loc_54B47:		; CODE XREF: sub_5474D+3ACj
			; sub_5474D+3B2j
jmp	loc_54CA4	; default

loc_54B4A:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
cmp	[bp+var_8], 0	; case 0x8
jle	short loc_54B57	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_54B50:		; Increment by 1
inc	[bp+var_6]
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54B57:		; CODE XREF: sub_5474D+401j
jmp	loc_54CA4	; default

loc_54B5A:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0x9
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 2000h	; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_54B86	; Jump if Not Zero (ZF=0)
cmp	[bp+var_4], 22h	; '"' ; Compare Two Operands
jz	short loc_54B86	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 2000h	; Logical Inclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54B86:		; CODE XREF: sub_5474D+41Bj
			; sub_5474D+421j
jmp	loc_54CA4	; default

loc_54B89:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0xA
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 1000h	; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_54BC1	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_4]

loc_54B9C:
mov	dx, 24h	; '$'

loc_54B9F:		; Signed Multiply
imul	dx
mov	bx, ax
test	[word ptr bx+226h], 20h	; Logical Compare
jnz	short loc_54BC1	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]

loc_54BB1:		; Logical Inclusive OR
or	dx, 0
or	ax, 1000h	; Logical Inclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54BC1:		; CODE XREF: sub_5474D+44Aj
			; sub_5474D+45Cj
jmp	loc_54CA4	; default

loc_54BC4:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0xB

loc_54BC7:
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND

loc_54BCD:		; Logical AND
and	ax, 800h

loc_54BD0:		; Logical Inclusive OR
or	dx, ax
jnz	short loc_54BEA	; case 0xC
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 800h	; Logical Inclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54BEA:		; CODE XREF: sub_5474D+E4j
			; sub_5474D+485j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0xC
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 400h	; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_54C44	; Jump if Not Zero (ZF=0)
or	di, di		; Logical Inclusive OR
jle	short loc_54C44	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 8000h	; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_54C2E	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]

loc_54C11:
mov	dx, [bp+var_E]
xor	dx, 0		; Logical Exclusive OR
xor	ax, 8000h	; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 400h	; Logical Inclusive OR
jmp	short loc_54C3A	; Jump

loc_54C2E:		; CODE XREF: sub_5474D+4BFj
mov	ax, [bp+var_C]

loc_54C31:
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 8000h	; Logical Inclusive OR

loc_54C3A:		; CODE XREF: sub_5474D+4DFj
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54C44:		; CODE XREF: sub_5474D+4ABj
			; sub_5474D+4AFj
jmp	short loc_54CA4	; default

loc_54C46:		; CODE XREF: sub_5474D+E4j
			; DATA XREF: ovr056:off_54DADo
mov	ax, [bp+var_C]	; case 0xD
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 40h		; Logical AND
or	dx, ax		; Logical Inclusive OR
jnz	short loc_54CA2	; Jump if Not Zero (ZF=0)
cmp	[bp+var_8], 0	; Compare Two Operands
jle	short loc_54CA2	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
and	dx, 0		; Logical AND
and	ax, 20h		; Logical AND
or	dx, ax		; Logical Inclusive OR
jz	short loc_54C8C	; Jump if Zero (ZF=1)
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
xor	dx, 0		; Logical Exclusive OR
xor	ax, 20h		; Logical Exclusive OR
mov	[bp+var_C], ax
mov	[bp+var_E], dx
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 40h		; Logical Inclusive OR
jmp	short loc_54C98	; Jump

loc_54C8C:		; CODE XREF: sub_5474D+51Dj
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]
or	dx, 0		; Logical Inclusive OR
or	ax, 20h		; Logical Inclusive OR

loc_54C98:		; CODE XREF: sub_5474D+53Dj
mov	[bp+var_C], ax
mov	[bp+var_E], dx
dec	di		; Decrement by 1
dec	[bp+var_8]	; Decrement by 1

loc_54CA2:		; CODE XREF: sub_5474D+507j
			; sub_5474D+50Dj
jmp	short $+2	; Jump

loc_54CA4:		; CODE XREF: sub_5474D:loc_54817j
			; sub_5474D+DFj
			; sub_5474D:loc_5488Dj
			; sub_5474D:loc_548E7j
			; sub_5474D:loc_54946j
			; sub_5474D:loc_549A2j
			; sub_5474D:loc_54A02j
			; sub_5474D:loc_54A61j
			; sub_5474D:loc_54AE8j
			; sub_5474D:loc_54B47j
			; sub_5474D:loc_54B57j
			; sub_5474D:loc_54B86j
			; sub_5474D:loc_54BC1j
			; sub_5474D:loc_54C44j
or	di, di		; default
jle	short loc_54CAB	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_5481A	; Jump

loc_54CAB:		; CODE XREF: sub_5474D+559j
cmp	[bp+var_8], 0	; Compare Two Operands
jle	short loc_54CB4	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_5481A	; Jump

loc_54CB4:		; CODE XREF: sub_5474D+562j
mov	bx, [bp+var_2]
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
les	bx, [bx+65ACh]	; Load Full Pointer to ES:xx
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_C]
mov	dx, [bp+var_E]

loc_54CCF:
mov	[es:bx+4], ax
mov	[es:bx+2], dx
mov	bx, [bp+var_2]
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
les	bx, [bx+65ACh]	; Load Full Pointer to ES:xx
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	al, [byte ptr bp+var_6]
mov	[es:bx+6], al
mov	bx, [bp+var_2]
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
les	bx, [bx+65ACh]	; Load Full Pointer to ES:xx
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	si, ax
mov	al, [si+35DAh]
mov	[es:bx+7], al
mov	bx, [bp+var_2]
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
les	bx, [bx+65ACh]	; Load Full Pointer to ES:xx
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	si, ax

loc_54D39:
mov	al, [si+35DCh]

loc_54D3D:
mov	[es:bx+8], al
mov	bx, [bp+var_2]
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
les	bx, [bx+65ACh]	; Load Full Pointer to ES:xx
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	si, ax
mov	al, [si+35DEh]
mov	[es:bx+9], al
mov	bx, [bp+var_2]
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
les	bx, [bx+65ACh]	; Load Full Pointer to ES:xx
mov	ax, [bp+var_4]
mov	dx, 0Ch
imul	dx		; Signed Multiply
add	bx, ax		; Add
mov	ax, [bp+var_4]
mov	dx, 12h
imul	dx		; Signed Multiply
mov	si, ax
mov	al, [si+35E0h]
mov	[es:bx+0Ah], al
inc	[bp+var_4]	; Increment by 1

loc_54D92:		; CODE XREF: sub_5474D+15j
cmp	[bp+var_4], 23h	; '#' ; Compare Two Operands
jge	short loc_54D9B	; Jump if Greater or Equal (SF=OF)
jmp	loc_54765	; Jump

loc_54D9B:		; CODE XREF: sub_5474D+649j
inc	[bp+var_2]	; Increment by 1

loc_54D9E:		; CODE XREF: sub_5474D+Dj
cmp	[bp+var_2], 5	; Compare Two Operands
jge	short loc_54DA7	; Jump if Greater or Equal (SF=OF)
jmp	loc_5475D	; Jump

loc_54DA7:		; CODE XREF: sub_5474D+655j
pop	di
pop	si
mov	sp, bp
pop	bp

locret_54DAC:		; Return Far from Procedure
retf
endp sub_5474D

off_54DAD dw offset loc_54836
			; DATA XREF: sub_5474D+E4r
dw offset loc_54890	; jump table for switch	statement
dw offset loc_548EA
dw offset loc_54949
dw offset loc_549A5
dw offset loc_54A05
dw offset loc_54A64
dw offset loc_54AEB
dw offset loc_54B4A
dw offset loc_54B5A
dw offset loc_54B89
dw offset loc_54BC4
dw offset loc_54BEA
dw offset loc_54C46


; Attributes: bp-based frame

proc sub_54DC9 far	; CODE XREF: sub_31BE7J
			; sub_523A3:loc_523D1p
push	bp
mov	bp, sp

loc_54DCC:
mov	[byte_380C4], 0
mov	[byte_38116], 0
mov	[byte_38192], 0
mov	[byte_381A7], 0
mov	[byte_381BC], 0
mov	[byte_38168], 0
mov	[byte_3817D], 0
mov	[byte_38072], 0
mov	[byte_37EF2], 0
mov	[byte_3800B], 0
pop	bp
retf			; Return Far from Procedure
endp sub_54DC9



; Attributes: bp-based frame

proc sub_54E00 far	; CODE XREF: sub_31BECJ

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	si
mov	cx, [bp+arg_0]
mov	si, [bp+arg_2]
mov	ax, cx
mov	dx, 24h	; '$'

loc_54E0F:		; Signed Multiply
imul	dx
mov	bx, ax
cmp	[byte ptr bx+21Bh], 2 ;	Compare	Two Operands
jnz	short loc_54E2A	; Jump if Not Zero (ZF=0)
mov	[word ptr si], 3
mov	[word ptr si+2], 5
mov	[word ptr si+4], 6
jmp	short loc_54E6E	; Jump

loc_54E2A:		; CODE XREF: sub_54E00+18j
mov	ax, cx
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+21Bh], 3 ;	Compare	Two Operands
jnz	short loc_54E4A	; Jump if Not Zero (ZF=0)
mov	[word ptr si], 4
mov	[word ptr si+2], 6
mov	[word ptr si+4], 6
jmp	short loc_54E6E	; Jump

loc_54E4A:		; CODE XREF: sub_54E00+38j
mov	ax, cx
mov	dx, 24h	; '$'
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+21Bh], 1 ;	Compare	Two Operands
jnz	short loc_54E60	; Jump if Not Zero (ZF=0)
mov	[word ptr si], 2
jmp	short loc_54E64	; Jump

loc_54E60:		; CODE XREF: sub_54E00+58j
mov	[word ptr si], 1

loc_54E64:		; CODE XREF: sub_54E00+5Ej
mov	[word ptr si+2], 5
mov	[word ptr si+4], 6

loc_54E6E:		; CODE XREF: sub_54E00+28j
			; sub_54E00+48j
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_54E00



; Attributes: bp-based frame

proc sub_54E71 far	; CODE XREF: sub_31BF1J
			; sub_5301E+1ABp

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
mov	si, [bp+arg_0]
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6962h], 0 ; Compare Two Operands
jz	short loc_54EFF	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Eh], 0 ; Compare Two Operands
jz	short loc_54EFF	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_54ED4	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Eh]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+6962h], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Eh], 0
jmp	short loc_54EFF	; Jump

loc_54ED4:		; CODE XREF: sub_54E71+34j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6962h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Eh], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6962h], 0

loc_54EFF:		; CODE XREF: sub_54E71+15j
			; sub_54E71+25j
			; sub_54E71+61j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6962h], 0 ; Compare Two Operands
jz	short loc_54F86	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ah], 0 ; Compare Two Operands
jz	short loc_54F86	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_54F5B	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ah]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+6962h], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ah], 0
jmp	short loc_54F86	; Jump

loc_54F5B:		; CODE XREF: sub_54E71+BBj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6962h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Ah], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6962h], 0

loc_54F86:		; CODE XREF: sub_54E71+9Cj
			; sub_54E71+ACj
			; sub_54E71+E8j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6962h], 0 ; Compare Two Operands
jz	short loc_5500D	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ch], 0 ; Compare Two Operands
jz	short loc_5500D	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_54FE2	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ch]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax

loc_54FCD:		; Add
add	[bx+6962h], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ch], 0
jmp	short loc_5500D	; Jump

loc_54FE2:		; CODE XREF: sub_54E71+142j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6962h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Ch], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6962h], 0

loc_5500D:		; CODE XREF: sub_54E71+123j
			; sub_54E71+133j
			; sub_54E71+16Fj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6960h], 0 ; Compare Two Operands
jz	short loc_55094	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Eh], 0 ; Compare Two Operands
jz	short loc_55094	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_55069	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Eh]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+6960h], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Eh], 0
jmp	short loc_55094	; Jump

loc_55069:		; CODE XREF: sub_54E71+1C9j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6960h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Eh], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6960h], 0

loc_55094:		; CODE XREF: sub_54E71+1AAj
			; sub_54E71+1BAj
			; sub_54E71+1F6j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+6960h], 0 ; Compare Two Operands
jz	short loc_5511B	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ah], 0 ; Compare Two Operands
jz	short loc_5511B	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_550F0	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ah]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+6960h], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ah], 0
jmp	short loc_5511B	; Jump

loc_550F0:		; CODE XREF: sub_54E71+250j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6960h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Ah], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+6960h], 0

loc_5511B:		; CODE XREF: sub_54E71+231j
			; sub_54E71+241j
			; sub_54E71+27Dj
mov	ax, si

loc_5511D:
mov	dx, 4C8h

loc_55120:		; Signed Multiply
imul	dx
mov	bx, ax
cmp	[word ptr bx+6960h], 0 ; Compare Two Operands
jz	short loc_551A2	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_55134:		; Compare Two Operands
cmp	[word ptr bx+695Ch], 0
jz	short loc_551A2	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_55177	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ch]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_55161:
pop	ax

loc_55162:		; Add
add	[bx+6960h], ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ch], 0
jmp	short loc_551A2	; Jump

loc_55177:		; CODE XREF: sub_54E71+2D7j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+6960h]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Ch], ax	; Add
mov	ax, si
mov	dx, 4C8h

loc_55198:		; Signed Multiply
imul	dx
mov	bx, ax
mov	[word ptr bx+6960h], 0

loc_551A2:		; CODE XREF: sub_54E71+2B8j
			; sub_54E71+2C8j
			; sub_54E71+304j
mov	ax, si
mov	dx, 4C8h

loc_551A7:		; Signed Multiply
imul	dx
mov	bx, ax

loc_551AB:		; Compare Two Operands
cmp	[word ptr bx+695Ch], 0
jz	short loc_55229	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_551BB:		; Compare Two Operands
cmp	[word ptr bx+695Eh], 0

loc_551C0:		; Jump if Zero (ZF=1)
jz	short loc_55229
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands

loc_551CF:		; Jump if Not Zero (ZF=0)
jnz	short loc_551FE
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Eh]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Ch], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Eh], 0
jmp	short loc_55229	; Jump

loc_551FE:		; CODE XREF: sub_54E71:loc_551CFj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ch]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Eh], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ch], 0

loc_55229:		; CODE XREF: sub_54E71+33Fj
			; sub_54E71:loc_551C0j
			; sub_54E71+38Bj
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ch], 0 ; Compare Two Operands
jz	short loc_552B0	; Jump if Zero (ZF=1)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[word ptr bx+695Ah], 0 ; Compare Two Operands
jz	short loc_552B0	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
cmp	ax, 1		; Compare Two Operands
jnz	short loc_55285	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ah]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Ch], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ah], 0
jmp	short loc_552B0	; Jump

loc_55285:		; CODE XREF: sub_54E71+3E5j
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	ax, [bx+695Ch]
push	ax
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
pop	ax
add	[bx+695Ah], ax	; Add
mov	ax, si
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
mov	[word ptr bx+695Ch], 0

loc_552B0:		; CODE XREF: sub_54E71+3C6j
			; sub_54E71+3D6j
			; sub_54E71+412j
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_54E71



; Attributes: bp-based frame

proc sub_552B3 far	; CODE XREF: sub_31BF6J
			; sub_52CE7+D9p

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	di, [bp+arg_0]

loc_552BE:		; Logical Exclusive OR
xor	si, si
xor	cx, cx		; Logical Exclusive OR
mov	[bp+var_2], 0
mov	[bp+var_4], 0
jmp	short loc_552DB	; Jump

loc_552CE:		; CODE XREF: sub_552B3+3Cj
			; sub_552B3+43j
inc	cx		; Increment by 1
add	si, 2		; Add
mov	ax, si
cwd			; AX ->	DX:AX (with sign)
add	[bp+var_4], ax	; Add
adc	[bp+var_2], dx	; Add with Carry

loc_552DB:		; CODE XREF: sub_552B3+19j
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax

loc_552E4:
mov	ax, [bx+6B60h]
mov	dx, [bx+6B5Eh]
cmp	ax, [bp+var_2]	; Compare Two Operands
jg	short loc_552CE	; Jump if Greater (ZF=0	& SF=OF)
jnz	short loc_552F8	; Jump if Not Zero (ZF=0)
cmp	dx, [bp+var_4]	; Compare Two Operands
ja	short loc_552CE	; Jump if Above	(CF=0 &	ZF=0)

loc_552F8:		; CODE XREF: sub_552B3+3Ej
mov	ax, di
mov	dx, 4C8h
imul	dx		; Signed Multiply
mov	bx, ax
cmp	[byte ptr bx+696Eh], 0 ; Compare Two Operands
jle	short loc_5530B	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
add	cx, 0Ah		; Add

loc_5530B:		; CODE XREF: sub_552B3+53j
mov	ax, cx
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_552B3



; Attributes: bp-based frame

proc sub_55315 far	; CODE XREF: sub_31C00J
			; sub_5301E+728p

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 8		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg_0]

loc_55320:		; CODE XREF: sub_55315+43j
xor	di, di		; Logical Exclusive OR
mov	[bp+var_2], 0
jmp	short loc_5535D	; Jump

loc_55329:		; CODE XREF: sub_55315+4Ej
mov	bx, [bp+var_2]
shl	bx, 1		; Shift	Logical	Left
add	di, [bx+si]	; Add
cmp	di, 200h	; Compare Two Operands
jb	short loc_5535A	; Jump if Below	(CF=1)

loc_55336:
mov	[bp+var_8], 0

loc_5533B:		; Jump
jmp	short loc_55350

loc_5533D:		; CODE XREF: sub_55315+41j
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left

loc_55342:
mov	ax, [bx+si]
shr	ax, 1		; Shift	Logical	Right
mov	bx, [bp+var_8]
shl	bx, 1		; Shift	Logical	Left
mov	[bx+si], ax
inc	[bp+var_8]	; Increment by 1

loc_55350:		; CODE XREF: sub_55315:loc_5533Bj
mov	ax, [bp+var_8]
cmp	ax, [bp+arg_2]	; Compare Two Operands
jl	short loc_5533D	; Jump if Less (SF!=OF)
jmp	short loc_55320	; Jump

loc_5535A:		; CODE XREF: sub_55315+1Fj
inc	[bp+var_2]	; Increment by 1

loc_5535D:		; CODE XREF: sub_55315+12j
mov	ax, [bp+var_2]
cmp	ax, [bp+arg_2]	; Compare Two Operands
jl	short loc_55329	; Jump if Less (SF!=OF)
or	di, di		; Logical Inclusive OR
jnz	short loc_5536D	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR

loc_5536B:		; CODE XREF: sub_55315+8Dj
jmp	short loc_553A4	; Jump

loc_5536D:		; CODE XREF: sub_55315+52j
push	di
call	idk_Arg_0Fail_ElseMathyDiSi ; Call Procedure
pop	cx
sub	ax, [si]	; Integer Subtraction
mov	[bp+var_4], ax
mov	[bp+var_6], 0
jmp	short loc_55390	; Jump

loc_55380:		; CODE XREF: sub_55315:loc_5539Dj
inc	[bp+var_6]	; Increment by 1
mov	bx, [bp+var_6]
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bp+var_4]
sub	ax, [bx+si]	; Integer Subtraction
mov	[bp+var_4], ax

loc_55390:		; CODE XREF: sub_55315+69j
cmp	[bp+var_4], 0	; Compare Two Operands
jle	short loc_5539F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+arg_2]
dec	ax		; Decrement by 1
cmp	ax, [bp+var_6]	; Compare Two Operands

loc_5539D:		; Jump if Greater (ZF=0	& SF=OF)
jg	short loc_55380

loc_5539F:		; CODE XREF: sub_55315+7Fj
mov	ax, [bp+var_6]
jmp	short loc_5536B	; Jump

loc_553A4:		; CODE XREF: sub_55315:loc_5536Bj
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_55315

ends ovr056


; Segment type:	Pure code
segment	ovr057 para public 'OVERLAY' use16
assume cs:ovr057
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc idk_EmsPgNm_TileFigureCont_s553B0 far
			; CODE XREF: j_idk_Ems_TileFigureCont_s553B0J

arg_0= word ptr	 6

push	bp

loc_553B1:
mov	bp, sp

loc_553B3:
push	si

loc_553B4:
mov	ax, 1

loc_553B7:		; arg4_value
push	ax

loc_553B8:		; "FIGUREX"
mov	ax, offset strFIGUREX

loc_553BB:
push	ax

loc_553BC:		; argValue
mov	ax, 28

loc_553BF:		; arg0_EmmPageCount
push	ax

loc_553C0:		; Call Procedure
call	EMM_Allocate

loc_553C5:		; Add
add	sp, 6
mov	[word_3B196], ax

loc_553CB:
mov	ax, 1

loc_553CE:		; arg4_value
push	ax

loc_553CF:		; "TILEXXX"
mov	ax, offset strTILEXXX
push	ax
mov	ax, 3		; argValue
push	ax		; arg0_EmmPageCount
call	EMM_Allocate	; Call Procedure
add	sp, 6		; Add
mov	[word_3B194], ax
mov	[word_38460], 0DBFh
mov	ax, [bp+arg_0]
add	ax, 515		; Add
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx		;
			;
mov	[idk_LBX_w37EBE], ax ; THIS IS THE ONLY	PLACE THIS IS SET!!
			;
mov	ax, 96h	; ''
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[word_37EBC], ax
mov	ax, 27Bh
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[word_38464], ax

loc_55412:
push	[word_38460]

loc_55416:		; Call Procedure
call	ST_AllocateSpace
pop	cx

loc_5541C:
mov	si, ax
mov	[word_38466], si
mov	ax, 2CAh
push	ax
push	si

loc_55427:		; Call Procedure
call	idk_Mem_StoSW_s149FA
pop	cx
pop	cx
push	ax

loc_5542F:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_55435:
mov	[word ptr dword_3A6E2+2], dx

loc_55439:
mov	[word ptr dword_3A6E2],	ax

loc_5543C:
mov	ax, 25Ah

loc_5543F:
push	ax
push	si

loc_55441:		; Call Procedure
call	sub_14AF8

loc_55446:
pop	cx
pop	cx
push	ax

loc_55449:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2

loc_5544E:
pop	cx

loc_5544F:
mov	[word ptr dword_3A702+2], dx
mov	[word ptr dword_3A702],	ax
mov	ax, 0Eh
push	ax
push	si

loc_5545B:		; Call Procedure
call	sub_14AF8
pop	cx
pop	cx
push	ax

loc_55463:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_55469:
mov	[word_3A700], dx

loc_5546D:
mov	[word_3A6FE], ax

loc_55470:
mov	ax, 0Eh
push	ax
push	si

loc_55475:		; Call Procedure
call	sub_14AF8

loc_5547A:
pop	cx
pop	cx
push	ax

loc_5547D:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_3A6FC], dx

loc_55487:
mov	[word_3A6FA], ax

loc_5548A:
mov	ax, 12Eh
push	ax
push	si

loc_5548F:		; Call Procedure
call	sub_14AF8
pop	cx

loc_55495:
pop	cx
push	ax

loc_55497:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_5549D:
mov	[word ptr dword_3A6F6+2], dx

loc_554A1:
mov	[word ptr dword_3A6F6],	ax
mov	ax, 12Eh

loc_554A7:
push	ax
push	si

loc_554A9:		; Call Procedure
call	sub_14AF8

loc_554AE:
pop	cx

loc_554AF:
pop	cx

loc_554B0:
push	ax

loc_554B1:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3A6DE+2], dx
mov	[word ptr dword_3A6DE],	ax
mov	ax, 12Eh
push	ax
push	si
call	sub_14AF8	; Call Procedure
pop	cx
pop	cx
push	ax

loc_554CB:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2

loc_554D0:
pop	cx
mov	[word ptr dword_3A6DA+2], dx

loc_554D5:
mov	[word ptr dword_3A6DA],	ax

loc_554D8:
mov	ax, 12Eh
push	ax
push	si

loc_554DD:		; Call Procedure
call	sub_14AF8
pop	cx
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3A6D6+2], dx

loc_554EF:
mov	[word ptr dword_3A6D6],	ax
mov	ax, 13h
push	ax
push	si
call	sub_14AF8	; Call Procedure
pop	cx
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_378C8], dx
mov	[word_378C6], ax

loc_5550C:
mov	ax, 13h

loc_5550F:
push	ax
push	si

loc_55511:		; Call Procedure
call	sub_14AF8

loc_55516:
pop	cx
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_378C4], dx
mov	[word_378C2], ax
push	si
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
dec	ax		; Decrement by 1
push	ax
push	si

loc_55530:		; Call Procedure
call	sub_14AF8
pop	cx

loc_55536:
pop	cx
mov	[word_38462], ax
mov	ax, 278h
push	ax

loc_5553E:		; Call Procedure
call	sub_17A50
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_3A6CC], dx
mov	[word_3A6CA], ax
mov	ax, 70Ah
push	ax
call	sub_17AFA	; Call Procedure
pop	cx
push	ax

loc_5555D:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3A6D2+2], dx
mov	[word ptr dword_3A6D2],	ax
mov	ax, 12Dh
push	ax
call	sub_17AFA	; Call Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_3A6C8], dx
mov	[word_3A6C6], ax

loc_55582:
mov	ax, 12Dh
push	ax
call	sub_17AFA	; Call Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_55593:
mov	[word_3A6C4], dx
mov	[word_3A6C2], ax
mov	ax, 409h
push	ax
call	sub_17AFA	; Call Procedure
pop	cx

loc_555A4:
push	ax

loc_555A5:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_3A6B8], dx

loc_555AF:
mov	[word_3A6B6], ax
mov	ax, 1Ch
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx

loc_555BC:
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[idk_SavGamDS_w382BE], dx
mov	[idk_SavGamDS_w382BC], ax
mov	ax, 1Bh
push	ax

loc_555CE:		; Call Procedure
call	ST_AllocateSpace
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_555DB:
mov	[word_382C2], dx

loc_555DF:
mov	[word_382C0], ax

loc_555E2:
mov	ax, 1Bh
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx

loc_555EC:
push	ax

loc_555ED:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_382C6], dx

loc_555F7:
mov	[word_382C4], ax
mov	ax, 1Bh
push	ax
call	ST_AllocateSpace ; Call	Procedure

loc_55603:
pop	cx
push	ax

loc_55605:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_382CA], dx
mov	[word_382C8], ax
mov	ax, 1Bh
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_382CE], dx
mov	[word_382CC], ax
mov	ax, 1Bh
push	ax

loc_5562E:		; Call Procedure
call	ST_AllocateSpace
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_382D2], dx
mov	[word_382D0], ax
mov	ax, 7ECh
push	ax

loc_55646:		; Call Procedure
call	ST_AllocateSpace
pop	cx
push	ax

loc_5564D:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_38608+2], dx
mov	[word ptr dword_38608],	ax

loc_5565A:
mov	ax, 8
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_5566B:
mov	[word_382B2], dx
mov	[word_382B0], ax
mov	ax, 5Ch	; '\'
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_55683:
mov	[word ptr dword_3A6F2+2], dx
mov	[word ptr dword_3A6F2],	ax
mov	ax, 3
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx

loc_5569B:
mov	[word ptr dword_3A6EE+2], dx
mov	[word ptr dword_3A6EE],	ax
mov	ax, 3
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax

loc_556AD:		;   mov	    ax,	[bp+arg_0]
call	idk_DxAxBpSp_s14BFC ;	mov	[bp+var_6], ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2

loc_556B2:
pop	cx

loc_556B3:
mov	[word ptr dword_3A6EA+2], dx
mov	[word ptr dword_3A6EA],	ax

loc_556BA:
mov	ax, 15Fh
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3A6E6+2], dx

loc_556CF:
mov	[word ptr dword_3A6E6],	ax
mov	ax, 7
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_37EC8+2], dx
mov	[word ptr dword_37EC8],	ax
mov	ax, 25h	; '%'
push	ax

loc_556EE:		; Call Procedure
call	ST_AllocateSpace
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word_3860E], dx
mov	[word_3860C], ax
mov	ax, 1B1h
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_381C0+2], dx
mov	[word ptr dword_381C0],	ax
mov	ax, 11h
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_381C4+2], dx
mov	[word ptr dword_381C4],	ax
mov	ax, 1E5h
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
push	ax
call	idk_DxAxBpSp_s14BFC ;	mov	ax, [bp+arg_0]
			;   mov	    [bp+var_6],	ax
			;   mov	    ax,	[bp+var_6]
			;   mov	    [bp+var_2],	ax
			;   mov	    [bp+var_4],	0
			;   mov	    dx,	[bp+var_2]
			;   mov	    ax,	[bp+var_4]
			;   jmp	    short $+2
pop	cx
mov	[word ptr dword_3833C+2], dx
mov	[word ptr dword_3833C],	ax

loc_5574A:
mov	ax, 3Ch	; '<'
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[word_37B78], ax
mov	ax, 15Eh
push	ax
call	ST_AllocateSpace ; Call	Procedure
pop	cx
mov	[word_378C0], ax
mov	[word_37742], 834Ch
mov	[word_37744], 8358h

loc_55770:
mov	[word_3773C], 8364h
mov	[word_37738], 8374h

loc_5577C:
mov	[word_3773A], 8388h
mov	[word_37734], 839Ch

loc_55788:
mov	[word_37736], 83B0h
mov	[word_3773E], 83C4h

loc_55794:
mov	[word_37740], 83D8h
mov	[word_37730], 83ECh

loc_557A0:
mov	[word_37732], 8400h
mov	[word_3772C], 8414h
mov	[word_3772E], 8420h
mov	[word_3772A], 842Ch
mov	ax, 1
push	ax		; arg4_value

loc_557BC:		; "CONTXXX"
mov	ax, offset strCONTXXX
push	ax
mov	ax, 4		; argValue
push	ax		; arg0_EmmPageCount
call	EMM_Allocate	; Call Procedure
add	sp, 6		; Add
mov	[word_38606], ax
pop	si

loc_557D0:
pop	bp
retf			; Return Far from Procedure
endp idk_EmsPgNm_TileFigureCont_s553B0

ends ovr057


; Segment type:	Pure code
segment	ovr058 para public 'OVERLAY' use16
assume cs:ovr058
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc ST_LoadMusicSoundfxIntro far
			; CODE XREF: j_ST_LoadMusicSoundfxIntroJ

var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 12h		; Integer Subtraction

loc_557E6:
push	si
push	di

loc_557E8:
mov	[byte ptr bp+var_12], 79

loc_557EC:
mov	[byte ptr bp+var_12+1],	163
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
mov	ax, 112
push	ax		; argEntryNumber
mov	ax, offset strMUSICLBX ; "music.lbx"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_8], ax
push	[idk_LBX_w37EBE]
call	idk_LoadSw10_StoreSw14 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 115
push	ax		; argFileName
mov	ax, offset strSOUNDFXLBX ; "soundfx.lbx"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax
cmp	[MagSet_02], 1	; Compare Two Operands
jnz	short loc_55838	; Jump if Not Zero (ZF=0)

loc_5582F:		; int
push	[bp+var_8]
call	ST_LoadSound	; Call Procedure
pop	cx

loc_55838:		; CODE XREF: ST_LoadMusicSoundfxIntro+4Dj
mov	ax, offset word_33C70
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, 0FFFFh
push	ax
mov	ax, (offset strMUSICLBX+9) ; ? crazy compiler way to get '\0' ?
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_2], ax
mov	ax, offset asc_3559E ; ? 1Bh = 27d ?
push	ax
call	idk_Mouse_s29C99 ; Call	Procedure
pop	cx
mov	[bp+var_10], ax
xor	si, si		; Logical Exclusive OR
jmp	loc_55B71	; Jump

loc_5587F:		; CODE XREF: ST_LoadMusicSoundfxIntro+396j
push	si		; argIntroLbxEntryNumber
mov	ax, offset strINTROLBX ; int
push	ax		; argIntroLbxFileName
call	LBX_Intro_MemAndReadAndMem ; Call Procedure
pop	cx
pop	cx
mov	[bp+var_6], 0
or	si, si		; Logical Inclusive OR
jz	short loc_55899	; Jump if Zero (ZF=1)

loc_55894:		; Compare Two Operands
cmp	si, 3
jle	short loc_558A0	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_55899:		; CODE XREF: ST_LoadMusicSoundfxIntro+B2j
nop			; No Operation
push	cs
call	near ptr sub_55B7F ; Call Procedure
jmp	short loc_558BE	; Jump

loc_558A0:		; CODE XREF: ST_LoadMusicSoundfxIntro+B7j
cmp	si, 3		; Compare Two Operands
jnz	short loc_558AA	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_55BEF ; Call Procedure

loc_558AA:		; CODE XREF: ST_LoadMusicSoundfxIntro+C3j
cmp	si, 1		; Compare Two Operands
jnz	short loc_558B4	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_55BEF ; Call Procedure

loc_558B4:		; CODE XREF: ST_LoadMusicSoundfxIntro+CDj
cmp	si, 2		; Compare Two Operands
jnz	short loc_558BE	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr sub_55BB7 ; Call Procedure

loc_558BE:		; CODE XREF: ST_LoadMusicSoundfxIntro+BEj
			; ST_LoadMusicSoundfxIntro+D7j
xor	di, di		; Logical Exclusive OR
jmp	loc_55B5A	; Jump

loc_558C3:		; CODE XREF: ST_LoadMusicSoundfxIntro+384j
call	_f020105_bios_timeofday	; Call Procedure
call	sub_2B97A	; Call Procedure
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
cmp	ax, [bp+var_2]	; Compare Two Operands
jz	short loc_558E0	; Jump if Zero (ZF=1)

loc_558D8:
mov	ax, [bp+var_4]
cmp	ax, [bp+var_10]	; Compare Two Operands
jnz	short loc_558E5	; Jump if Not Zero (ZF=0)

loc_558E0:		; CODE XREF: ST_LoadMusicSoundfxIntro+F6j
mov	[bp+var_6], 1

loc_558E5:		; CODE XREF: ST_LoadMusicSoundfxIntro+FEj
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
or	di, di		; Logical Inclusive OR
jnz	short loc_55907	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add

loc_55907:		; CODE XREF: ST_LoadMusicSoundfxIntro+10Cj
call	LBX_Load_IntroLbx_s21977 ; Call	Procedure
cmp	si, 2		; Compare Two Operands
jnz	short loc_55938	; Jump if Not Zero (ZF=0)
cmp	di, 6		; Compare Two Operands
jle	short loc_55938	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_55916:		; Load Effective Address
lea	ax, [bp+var_12]
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, offset strSimTexCopyrightr2	; int
push	ax		; int
mov	ax, 192
push	ax		; int
mov	ax, 160
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add

loc_55938:		; CODE XREF: ST_LoadMusicSoundfxIntro+12Fj
			; ST_LoadMusicSoundfxIntro+134j
cmp	si, 4		; Compare Two Operands
jnz	short loc_55951	; Jump if Not Zero (ZF=0)

loc_5593D:		; Logical Inclusive OR
or	di, di
jnz	short loc_55951	; Jump if Not Zero (ZF=0)

loc_55941:		; Compare Two Operands
cmp	[MagSet_01], 1
jnz	short loc_55951	; Jump if Not Zero (ZF=0)
push	[bp+var_C]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

loc_55951:		; CODE XREF: ST_LoadMusicSoundfxIntro+15Bj
			; ST_LoadMusicSoundfxIntro+15Fj
			; ST_LoadMusicSoundfxIntro+166j
cmp	si, 5		; Compare Two Operands
jnz	short loc_559AD	; Jump if Not Zero (ZF=0)
cmp	di, 10		; Compare Two Operands
jnz	short loc_559AD	; Jump if Not Zero (ZF=0)
push	[idk_LBX_w37EBE]
call	idk_LoadSw14_StoreSw10 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE]
call	idk_LoadSw10_StoreSw14 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 4
push	ax		; argFileName
mov	ax, offset strSOUNDFXLBX ; "soundfx.lbx"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 116
push	ax		; argFileName
mov	ax, offset strSOUNDFXLBX ; "soundfx.lbx"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_E], ax
cmp	[MagSet_01], 1	; Compare Two Operands
jnz	short loc_559AD	; Jump if Not Zero (ZF=0)
push	[bp+var_C]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

loc_559AD:		; CODE XREF: ST_LoadMusicSoundfxIntro+174j
			; ST_LoadMusicSoundfxIntro+179j
			; ST_LoadMusicSoundfxIntro+1C2j
cmp	si, 6		; Compare Two Operands
jnz	short loc_559C6	; Jump if Not Zero (ZF=0)

loc_559B2:		; Logical Inclusive OR
or	di, di
jnz	short loc_559C6	; Jump if Not Zero (ZF=0)

loc_559B6:		; Compare Two Operands
cmp	[MagSet_01], 1
jnz	short loc_559C6	; Jump if Not Zero (ZF=0)

loc_559BD:		; int
push	[bp+var_E]
call	ST_LoadSound	; Call Procedure
pop	cx

loc_559C6:		; CODE XREF: ST_LoadMusicSoundfxIntro+1D0j
			; ST_LoadMusicSoundfxIntro+1D4j
			; ST_LoadMusicSoundfxIntro+1DBj
cmp	si, 7		; Compare Two Operands
jnz	short loc_55A22	; Jump if Not Zero (ZF=0)
cmp	di, 2		; Compare Two Operands
jnz	short loc_55A22	; Jump if Not Zero (ZF=0)

loc_559D0:
push	[idk_LBX_w37EBE]
call	idk_LoadSw14_StoreSw10 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE]
call	idk_LoadSw10_StoreSw14 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 1
push	ax		; argFileName
mov	ax, offset strSOUNDFXLBX ; "soundfx.lbx"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 27
push	ax		; argFileName
mov	ax, offset strSOUNDFXLBX ; "soundfx.lbx"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_A], ax
cmp	[MagSet_01], 1	; Compare Two Operands
jnz	short loc_55A22	; Jump if Not Zero (ZF=0)
push	[bp+var_C]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

loc_55A22:		; CODE XREF: ST_LoadMusicSoundfxIntro+1E9j
			; ST_LoadMusicSoundfxIntro+1EEj
			; ST_LoadMusicSoundfxIntro+237j
cmp	si, 9		; Compare Two Operands
jnz	short loc_55A7D	; Jump if Not Zero (ZF=0)

loc_55A27:		; Logical Inclusive OR
or	di, di
jnz	short loc_55A7D	; Jump if Not Zero (ZF=0)
push	[idk_LBX_w37EBE]
call	idk_LoadSw14_StoreSw10 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE]
call	idk_LoadSw10_StoreSw14 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 118
push	ax		; argFileName
mov	ax, offset strSOUNDFXLBX ; "soundfx.lbx"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 27
push	ax		; argFileName
mov	ax, offset strSOUNDFXLBX ; "soundfx.lbx"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_A], ax
cmp	[MagSet_01], 1	; Compare Two Operands
jnz	short loc_55A7D	; Jump if Not Zero (ZF=0)
push	[bp+var_C]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

loc_55A7D:		; CODE XREF: ST_LoadMusicSoundfxIntro+245j
			; ST_LoadMusicSoundfxIntro+249j
			; ST_LoadMusicSoundfxIntro+292j
cmp	si, 11		; Compare Two Operands
jnz	short loc_55AC2	; Jump if Not Zero (ZF=0)
cmp	di, 2		; Compare Two Operands
jnz	short loc_55AC2	; Jump if Not Zero (ZF=0)
push	[idk_LBX_w37EBE]
call	idk_LoadSw14_StoreSw10 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE]
call	idk_LoadSw10_StoreSw14 ; Call Procedure
pop	cx
push	[idk_LBX_w37EBE] ; arg4_Int
mov	ax, 3
push	ax		; argFileName
mov	ax, offset strSOUNDFXLBX ; "soundfx.lbx"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_C], ax
cmp	[MagSet_01], 1	; Compare Two Operands
jnz	short loc_55AC2	; Jump if Not Zero (ZF=0)
push	[bp+var_C]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

loc_55AC2:		; CODE XREF: ST_LoadMusicSoundfxIntro+2A0j
			; ST_LoadMusicSoundfxIntro+2A5j
			; ST_LoadMusicSoundfxIntro+2D7j
cmp	si, 8		; Compare Two Operands
jnz	short loc_55ADC	; Jump if Not Zero (ZF=0)
cmp	di, 3		; Compare Two Operands
jnz	short loc_55ADC	; Jump if Not Zero (ZF=0)
cmp	[MagSet_01], 1	; Compare Two Operands
jnz	short loc_55ADC	; Jump if Not Zero (ZF=0)
push	[bp+var_A]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

loc_55ADC:		; CODE XREF: ST_LoadMusicSoundfxIntro+2E5j
			; ST_LoadMusicSoundfxIntro+2EAj
			; ST_LoadMusicSoundfxIntro+2F1j
cmp	si, 8		; Compare Two Operands

loc_55ADF:		; Jump if Not Zero (ZF=0)
jnz	short loc_55AF6

loc_55AE1:		; Compare Two Operands
cmp	di, 9
jnz	short loc_55AF6	; Jump if Not Zero (ZF=0)

loc_55AE6:		; Compare Two Operands
cmp	[MagSet_01], 1
jnz	short loc_55AF6	; Jump if Not Zero (ZF=0)
push	[bp+var_A]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

loc_55AF6:		; CODE XREF: ST_LoadMusicSoundfxIntro:loc_55ADFj
			; ST_LoadMusicSoundfxIntro+304j
			; ST_LoadMusicSoundfxIntro+30Bj
cmp	si, 10		; Compare Two Operands
jnz	short loc_55B10	; Jump if Not Zero (ZF=0)
cmp	di, 2		; Compare Two Operands
jnz	short loc_55B10	; Jump if Not Zero (ZF=0)
cmp	[MagSet_01], 1	; Compare Two Operands
jnz	short loc_55B10	; Jump if Not Zero (ZF=0)
push	[bp+var_A]	; int
call	ST_LoadSound	; Call Procedure
pop	cx

loc_55B10:		; CODE XREF: ST_LoadMusicSoundfxIntro+319j
			; ST_LoadMusicSoundfxIntro+31Ej
			; ST_LoadMusicSoundfxIntro+325j
call	sub_2E303	; Call Procedure
or	di, di		; Logical Inclusive OR
jnz	short loc_55B25	; Jump if Not Zero (ZF=0)
cmp	si, 2		; Compare Two Operands
jle	short loc_55B25	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
nop			; No Operation
push	cs
call	near ptr sub_55C27 ; Call Procedure
jmp	short loc_55B3C	; Jump

loc_55B25:		; CODE XREF: ST_LoadMusicSoundfxIntro+337j
			; ST_LoadMusicSoundfxIntro+33Cj
or	di, di		; Logical Inclusive OR
jnz	short loc_55B3C	; Jump if Not Zero (ZF=0)
cmp	si, 2		; Compare Two Operands
jz	short loc_55B37	; Jump if Zero (ZF=1)
or	si, si		; Logical Inclusive OR
jz	short loc_55B37	; Jump if Zero (ZF=1)
cmp	si, 1		; Compare Two Operands

loc_55B35:		; Jump if Not Zero (ZF=0)
jnz	short loc_55B3C

loc_55B37:		; CODE XREF: ST_LoadMusicSoundfxIntro+34Cj
			; ST_LoadMusicSoundfxIntro+350j
nop			; No Operation
push	cs
call	near ptr sub_55C5E ; Call Procedure

loc_55B3C:		; CODE XREF: ST_LoadMusicSoundfxIntro+343j
			; ST_LoadMusicSoundfxIntro+347j
			; ST_LoadMusicSoundfxIntro:loc_55B35j
call	sub_1E525	; Call Procedure
mov	ax, 3
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
cmp	[bp+var_6], 1	; Compare Two Operands
jnz	short loc_55B59	; Jump if Not Zero (ZF=0)
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	di, [bx+385Eh]

loc_55B59:		; CODE XREF: ST_LoadMusicSoundfxIntro+36Fj
inc	di		; Increment by 1

loc_55B5A:		; CODE XREF: ST_LoadMusicSoundfxIntro+E0j
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
cmp	[word_3556E+bx], di ; Compare Two Operands
jle	short loc_55B67	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jmp	loc_558C3	; Jump

loc_55B67:		; CODE XREF: ST_LoadMusicSoundfxIntro+382j
cmp	[bp+var_6], 1	; Compare Two Operands
jnz	short loc_55B70	; Jump if Not Zero (ZF=0)
mov	si, 13

loc_55B70:		; CODE XREF: ST_LoadMusicSoundfxIntro+38Bj
inc	si		; Increment by 1

loc_55B71:		; CODE XREF: ST_LoadMusicSoundfxIntro+9Cj
cmp	si, 13		;
			; ? because INTRO.LBX has 13 entries ?
			;
jge	short loc_55B79	; Jump if Greater or Equal (SF=OF)
jmp	loc_5587F	; Jump

loc_55B79:		; CODE XREF: ST_LoadMusicSoundfxIntro+394j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp ST_LoadMusicSoundfxIntro ;	sp-analysis failed



; Attributes: bp-based frame

proc sub_55B7F far	; CODE XREF: sub_31C65J
			; ST_LoadMusicSoundfxIntro+BBp
push	bp
mov	bp, sp
push	si
mov	si, 50
jmp	short loc_55BAF	; Jump

loc_55B88:		; CODE XREF: sub_55B7F+33j
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, 255
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx
push	si
call	idk_VGA_PAL_s1C554 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
add	si, 50		; Add

loc_55BAF:		; CODE XREF: sub_55B7F+7j
cmp	si, 101		; Compare Two Operands
jl	short loc_55B88	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_55B7F



; Attributes: bp-based frame

proc sub_55BB7 far	; CODE XREF: sub_31C6FJ
			; ST_LoadMusicSoundfxIntro+DBp
push	bp
mov	bp, sp

loc_55BBA:
push	si
mov	si, 0Ah

loc_55BBE:		; Jump
jmp	short loc_55BE7

loc_55BC0:		; CODE XREF: sub_55BB7+33j
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, 255
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure

loc_55BD1:
pop	cx
pop	cx
push	si
call	idk_VGA_PAL_s1C554 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
add	si, 0Ah		; Add

loc_55BE7:		; CODE XREF: sub_55BB7:loc_55BBEj
cmp	si, 65h	; 'e'   ; Compare Two Operands
jl	short loc_55BC0	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_55BB7



; Attributes: bp-based frame

proc sub_55BEF far	; CODE XREF: sub_31C6AJ
			; ST_LoadMusicSoundfxIntro+C7p
			; ST_LoadMusicSoundfxIntro+D1p
push	bp
mov	bp, sp
push	si
mov	si, 5
jmp	short loc_55C1F	; Jump

loc_55BF8:		; CODE XREF: sub_55BEF+33j
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, 255
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx
push	si
call	idk_VGA_PAL_s1C554 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
add	si, 5		; Add

loc_55C1F:		; CODE XREF: sub_55BEF+7j
cmp	si, 101		; Compare Two Operands
jl	short loc_55BF8	; Jump if Less (SF!=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_55BEF



; Attributes: bp-based frame

proc sub_55C27 far	; CODE XREF: sub_31C74J
			; ST_LoadMusicSoundfxIntro+340p
push	bp
mov	bp, sp
push	si
mov	si, 64h	; 'd'
jmp	short loc_55C57	; Jump

loc_55C30:		; CODE XREF: sub_55C27+32j
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, 255
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset

loc_55C3C:		; Call Procedure
call	idk_Set_FontsLbx1_256arr_to_1
pop	cx
pop	cx
push	si

loc_55C44:		; Call Procedure
call	idk_VGA_PAL_s1C554
pop	cx

loc_55C4A:
mov	ax, 1
push	ax

loc_55C4E:		; Call Procedure
call	_f020305_idk_SleepWaitPause
pop	cx
sub	si, 32h	; '2'   ; Integer Subtraction

loc_55C57:		; CODE XREF: sub_55C27+7j
or	si, si		; Logical Inclusive OR
jge	short loc_55C30	; Jump if Greater or Equal (SF=OF)
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_55C27



; Attributes: bp-based frame

proc sub_55C5E far	; CODE XREF: sub_31C79J
			; ST_LoadMusicSoundfxIntro+359p
push	bp
mov	bp, sp
push	si
mov	si, 64h	; 'd'

loc_55C65:		; Jump
jmp	short loc_55C8E

loc_55C67:		; CODE XREF: sub_55C5E+32j
call	_f020105_bios_timeofday	; Call Procedure
mov	ax, 255
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx
push	si
call	idk_VGA_PAL_s1C554 ; Call Procedure
pop	cx
mov	ax, 1
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx
sub	si, 2		; Integer Subtraction

loc_55C8E:		; CODE XREF: sub_55C5E:loc_55C65j
or	si, si		; Logical Inclusive OR
jge	short loc_55C67	; Jump if Greater or Equal (SF=OF)

loc_55C92:
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_55C5E

ends ovr058


; Segment type:	Pure code
segment	ovr059 para public 'OVERLAY' use16
assume cs:ovr059
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc idk_OVR_LoadLbxHelp far
			; CODE XREF: j_idk_OVR_LoadLbxHelpJ

var_4A=	word ptr -4Ah
var_36=	word ptr -36h
var_34=	word ptr -34h
var_32=	word ptr -32h
var_30=	word ptr -30h
var_2E=	word ptr -2Eh
var_2C=	word ptr -2Ch
var_2A=	word ptr -2Ah
var_28=	word ptr -28h
var_26=	word ptr -26h
var_24=	word ptr -24h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp

loc_55CA1:
mov	bp, sp

loc_55CA3:		; Integer Subtraction
sub	sp, 4Ah

loc_55CA6:
push	si

loc_55CA7:
push	di

loc_55CA8:		; Call Procedure
call	sub_1E525

loc_55CAD:
mov	ax, 1F54h

loc_55CB0:
push	ax

loc_55CB1:
mov	ax, 1

loc_55CB4:
push	ax

loc_55CB5:		; Call Procedure
call	wtf_s23F3E

loc_55CBA:
pop	cx

loc_55CBB:
pop	cx

loc_55CBC:		; No Operation
nop
push	cs

loc_55CBE:		; Call Procedure
call	near ptr sub_56220

loc_55CC1:
mov	[bp+var_8], ax

loc_55CC4:		; Logical Exclusive OR
xor	ax, ax

loc_55CC6:
mov	dx, 8000h
push	ax
push	dx		; int

loc_55CCB:		; int
push	[idk_LBX_w37EBE]

loc_55CCF:		; Logical Exclusive OR
xor	ax, ax
push	ax		; int

loc_55CD2:		; int
push	[bp+var_8]
xor	ax, ax		; Logical Exclusive OR

loc_55CD7:		; int
push	ax

loc_55CD8:		; Call Procedure
call	idk_Mov_Sb_Sw_or_0

loc_55CDD:		; Add
add	sp, 0Ch

loc_55CE0:		; Logical Exclusive OR
xor	ax, ax

loc_55CE2:
mov	dx, 8000h
push	ax

loc_55CE6:		; int
push	dx

loc_55CE7:
mov	ax, [idk_LBX_w37EBE]

loc_55CEA:		; Add
add	ax, 800h
push	ax		; int

loc_55CEE:		; Logical Exclusive OR
xor	ax, ax

loc_55CF0:		; int
push	ax

loc_55CF1:
mov	ax, [bp+var_8]
add	ax, 800h	; Add

loc_55CF7:		; int
push	ax

loc_55CF8:		; Logical Exclusive OR
xor	ax, ax
push	ax		; int

loc_55CFB:		; Call Procedure
call	idk_Mov_Sb_Sw_or_0

loc_55D00:		; Add
add	sp, 0Ch

loc_55D03:
mov	ax, [idk_Mouse_w3C5A8]

loc_55D06:
mov	[bp+var_32], ax

loc_55D09:
mov	[idk_Mouse_w3C5A8], 0

loc_55D0F:
mov	ax, 0FCh ; ''

loc_55D12:
push	ax

loc_55D13:
push	[idk_LBX_w37EBE]

loc_55D17:		; Call Procedure
call	idk_Mem_StoSW_s149FA
pop	cx
pop	cx

loc_55D1E:
mov	[bp+var_2A], ax
mov	ax, 0FA0h
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int

loc_55D28:
mov	ax, 9490h
push	ax		; int

loc_55D2C:		; int
push	[bp+var_2A]

loc_55D2F:		; Logical Exclusive OR
xor	ax, ax

loc_55D31:		; int
push	ax

loc_55D32:		; Call Procedure
call	idk_Mov_Sb_Sw_or_0

loc_55D37:		; Add
add	sp, 0Ah
mov	ax, 0FAh ; ''
push	ax

loc_55D3E:
push	[idk_LBX_w37EBE]
call	sub_14AF8	; Call Procedure
pop	cx
pop	cx

loc_55D49:
mov	[bp+var_36], ax

loc_55D4C:		; Call Procedure
call	sub_14787
mov	ax, 418h

loc_55D54:		; arg_0
push	ax

loc_55D55:		; Call Procedure
call	EMM_CheckAllocation

loc_55D5A:
pop	cx

loc_55D5B:
mov	[word_3B19A], ax

loc_55D5E:
mov	[bp+var_16], 0

loc_55D63:
mov	[bp+var_1E], 1

loc_55D68:
mov	[bp+var_20], 0

loc_55D6D:
mov	[bp+var_22], 0
mov	di, [bp+arg_0]

loc_55D75:		; Jump
jmp	loc_55E50

loc_55D78:		; CODE XREF: idk_OVR_LoadLbxHelp+1B6j
mov	ax, 418h
push	ax		; int

loc_55D7C:
mov	ax, 1
push	ax		; int

loc_55D80:		; int
push	di

loc_55D81:		; int
push	[word_3B19A]

loc_55D85:
mov	ax, 2

loc_55D88:		; int
push	ax

loc_55D89:		; int
mov	ax, offset aHelp
push	ax		; int

loc_55D8D:		; Call Procedure
call	LBX_Load_HelpNewTerrCity
add	sp, 0Ch		; Add

loc_55D95:
mov	bx, [word_3B19A]

loc_55D99:
mov	ax, [bx+2Eh]

loc_55D9C:
mov	[bp+var_1E], ax

loc_55D9F:		; Compare Two Operands
db 83h,7Eh,0E2h,0FFh ; <BAD>cmp	    [bp+var_1E], 0FFFFh
jnz	short loc_55DA8	; Jump if Not Zero (ZF=0)
inc	di		; Increment by 1
jmp	short loc_55DAB	; Jump

loc_55DA8:		; CODE XREF: idk_OVR_LoadLbxHelp+103j
mov	di, [bp+var_1E]

loc_55DAB:		; CODE XREF: idk_OVR_LoadLbxHelp+106j
mov	bx, [word_3B19A]

loc_55DAF:		; Compare Two Operands
cmp	[byte ptr bx+1Eh], 0
jnz	short loc_55DB8	; Jump if Not Zero (ZF=0)
jmp	loc_55E3F	; Jump

loc_55DB8:		; CODE XREF: idk_OVR_LoadLbxHelp+113j
push	[idk_LBX_w37EBE] ; arg4_Int

loc_55DBC:
mov	bx, [word_3B19A]
push	[word ptr bx+2Ch] ; argFileName
mov	ax, [word_3B19A]

loc_55DC6:		; Add
add	ax, 1Eh
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	bx, [bp+var_16]
shl	bx, 1		; Shift	Logical	Left
lea	dx, [bp+var_4A]	; Load Effective Address
add	bx, dx		; Add
mov	[bx], ax

loc_55DDE:
mov	bx, [bp+var_16]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]
call	sub_1FAD4	; Call Procedure
pop	cx
push	[bp+var_36]

loc_55DF3:
mov	bx, [bp+var_16]

loc_55DF6:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_4A]	; Load Effective Address

loc_55DFB:		; Add
add	bx, ax

loc_55DFD:
push	[word ptr bx]

loc_55DFF:		; Call Procedure
call	sub_1F8FD
pop	cx

loc_55E05:
pop	cx

loc_55E06:		; Load Effective Address
lea	ax, [bp+var_2E]
push	ax
lea	ax, [bp+var_30]	; Load Effective Address
push	ax
lea	ax, [bp+var_26]	; Load Effective Address
push	ax
lea	ax, [bp+var_24]	; Load Effective Address
push	ax
push	[bp+var_36]
call	sub_220AA	; Call Procedure

loc_55E1E:		; Add
add	sp, 0Ah
mov	ax, [bp+var_30]

loc_55E24:		; Compare Two Operands
cmp	ax, [bp+var_20]
jle	short loc_55E2F	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_30]
mov	[bp+var_20], ax

loc_55E2F:		; CODE XREF: idk_OVR_LoadLbxHelp+187j
mov	ax, [bp+var_2E]
cmp	ax, [bp+var_22]	; Compare Two Operands
jle	short loc_55E3D	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_2E]

loc_55E3A:
mov	[bp+var_22], ax

loc_55E3D:		; CODE XREF: idk_OVR_LoadLbxHelp+195j
jmp	short loc_55E4D	; Jump

loc_55E3F:		; CODE XREF: idk_OVR_LoadLbxHelp+115j
mov	bx, [bp+var_16]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add
mov	[word ptr bx], 0

loc_55E4D:		; CODE XREF: idk_OVR_LoadLbxHelp:loc_55E3Dj
inc	[bp+var_16]	; Increment by 1

loc_55E50:		; CODE XREF: idk_OVR_LoadLbxHelp:loc_55D75j
cmp	[bp+var_1E], 0	; Compare Two Operands
jz	short loc_55E59	; Jump if Zero (ZF=1)
jmp	loc_55D78	; Jump

loc_55E59:		; CODE XREF: idk_OVR_LoadLbxHelp+1B4j
cmp	[bp+var_20], 0	; Compare Two Operands
jz	short loc_55E63	; Jump if Zero (ZF=1)
add	[bp+var_20], 6	; Add

loc_55E63:		; CODE XREF: idk_OVR_LoadLbxHelp+1BDj
mov	[bp+var_28], 9
mov	ax, [bp+var_22]
cmp	ax, [bp+var_28]	; Compare Two Operands
jle	short loc_55E88	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_55E70:
mov	ax, [bp+var_22]
sub	ax, [bp+var_28]	; Integer Subtraction
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_1A], ax
mov	[bp+var_26], 0

loc_55E83:
mov	ax, [bp+var_22]
jmp	short loc_55E9E	; Jump

loc_55E88:		; CODE XREF: idk_OVR_LoadLbxHelp+1CEj
mov	ax, [bp+var_28]
sub	ax, [bp+var_22]	; Integer Subtraction
cwd			; int
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	[bp+var_26], ax
mov	[bp+var_1A], 0
mov	ax, [bp+var_28]

loc_55E9E:		; CODE XREF: idk_OVR_LoadLbxHelp+1E6j
add	ax, 2		; Add
mov	[bp+var_1C], ax
mov	ax, [bp+var_20]
mov	[bp+var_18], ax
push	[idk_LBX_w37EBE] ; arg4_Int
xor	ax, ax		; Logical Exclusive OR
push	ax		; argFileName
mov	ax, offset aHelp_0 ; "help"
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add

loc_55EBD:
mov	[bp+var_2], ax

loc_55EC0:		; arg4_Int
push	[idk_LBX_w37EBE]
mov	ax, 1
push	ax		; argFileName
mov	ax, offset aHelp_0 ; "help"

loc_55ECB:		; argEntryNumber
push	ax
call	LBX_Load_Entry_0_2 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_4], ax
mov	si, 2
mov	di, [bp+arg_0]

loc_55EDD:
mov	[bp+var_A], 0
jmp	short loc_55F59	; Jump

loc_55EE4:		; CODE XREF: idk_OVR_LoadLbxHelp+2BFj
mov	ax, 38C9h

loc_55EE7:
push	ax
mov	ax, 1
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
mov	ax, 418h
push	ax		; int
mov	ax, 1
push	ax		; int
push	di		; int
push	[word_3B19A]	; int
mov	ax, 2
push	ax		; int
mov	ax, 38D3h	; int
push	ax		; int
call	LBX_Load_HelpNewTerrCity ; Call	Procedure
add	sp, 0Ch		; Add
mov	bx, [word_3B19A]
cmp	[byte ptr bx+30h], 0 ; Compare Two Operands
jnz	short loc_55F24	; Jump if Not Zero (ZF=0)
mov	ax, [bp+var_1C]

loc_55F1D:		; Add
add	ax, 4
add	si, ax		; Add
jmp	short loc_55F40	; Jump

loc_55F24:		; CODE XREF: idk_OVR_LoadLbxHelp+278j
mov	ax, [word_3B19A]
add	ax, 30h	; '0'   ; Add
push	ax
mov	ax, 0B4h ; ''

loc_55F2E:
push	ax
call	sub_1B984	; Call Procedure
pop	cx
pop	cx
mov	dx, [bp+var_1C]
add	dx, ax		; Add
add	dx, 6		; Add
add	si, dx		; Add

loc_55F40:		; CODE XREF: idk_OVR_LoadLbxHelp+282j
mov	bx, [word_3B19A]
mov	ax, [bx+2Eh]
mov	[bp+var_1E], ax
db 83h,7Eh,0E2h,0FFh ; <BAD>cmp	    [bp+var_1E], 0FFFFh	; Compare Two Operands
jnz	short loc_55F53	; Jump if Not Zero (ZF=0)
inc	di		; Increment by 1
jmp	short loc_55F56	; Jump

loc_55F53:		; CODE XREF: idk_OVR_LoadLbxHelp+2AEj
mov	di, [bp+var_1E]

loc_55F56:		; CODE XREF: idk_OVR_LoadLbxHelp+2B1j
inc	[bp+var_A]	; Increment by 1

loc_55F59:		; CODE XREF: idk_OVR_LoadLbxHelp+242j
mov	ax, [bp+var_A]

loc_55F5C:		; Compare Two Operands
cmp	ax, [bp+var_16]
jl	short loc_55EE4	; Jump if Less (SF!=OF)
sub	si, 5		; Integer Subtraction
mov	[bp+var_6], si
mov	[bp+var_C], 18h
mov	[bp+var_E], 18h
mov	[bp+var_10], 32h ; '2'
mov	ax, [bp+var_6]
add	ax, [bp+var_C]	; Add
add	ax, [bp+var_E]	; Add
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, 64h	; 'd'
sub	dx, ax		; Integer Subtraction
mov	[bp+var_12], dx
mov	ax, [bp+var_12]
add	ax, [bp+var_C]	; Add
add	ax, [bp+var_6]	; Add
dec	ax		; Decrement by 1
mov	[bp+var_14], ax
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure

loc_55F9E:
push	[bp+var_14]

loc_55FA1:
mov	ax, 13Fh

loc_55FA4:
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_55FA8:		; Logical Exclusive OR
xor	ax, ax

loc_55FAA:
push	ax
call	wtfCompareSwap	; dx = arg_0 ... word_35EC2
			; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8

loc_55FB0:		; Add
add	sp, 8
push	[bp+var_2]
push	[bp+var_12]
push	[bp+var_10]
call	idk_VidLib_s1F743 ; Call Procedure
add	sp, 6		; Add
call	idk_ScrnPos_0_319_0_199	; Call Procedure
push	[bp+var_4]

loc_55FCC:
mov	ax, [bp+var_12]
add	ax, [bp+var_C]	; Add
add	ax, [bp+var_6]	; Add
push	ax
push	[bp+var_10]

loc_55FD9:		; Call Procedure
call	idk_VidLib_s1F743

loc_55FDE:		; Add
add	sp, 6

loc_55FE1:		; Call Procedure
call	idk_ScrnPos_0_319_0_199
mov	ax, [bp+var_12]
add	ax, [bp+var_C]	; Add
add	ax, 2		; Add

loc_55FEF:
mov	si, ax
mov	di, [bp+arg_0]
mov	[bp+var_A], 0
jmp	loc_5616F	; Jump

loc_55FFC:		; CODE XREF: idk_OVR_LoadLbxHelp+4D7j
mov	[bp+var_2C], di
mov	ax, 418h
push	ax		; int

loc_56003:
mov	ax, 1

loc_56006:		; int
push	ax
push	di		; int
push	[word_3B19A]	; int
mov	ax, 2
push	ax		; int
mov	ax, offset aHelp_0 ; int
push	ax		; int

loc_56014:		; Call Procedure
call	LBX_Load_HelpNewTerrCity
add	sp, 0Ch		; Add
mov	bx, [word_3B19A]
mov	ax, [bx+2Eh]
mov	[bp+var_1E], ax
db 83h,7Eh,0E2h,0FFh ; <BAD>cmp	    [bp+var_1E], 0FFFFh	; Compare Two Operands
jnz	short loc_5602F	; Jump if Not Zero (ZF=0)
inc	di		; Increment by 1
jmp	short loc_56032	; Jump

loc_5602F:		; CODE XREF: idk_OVR_LoadLbxHelp+38Aj
mov	di, [bp+var_1E]

loc_56032:		; CODE XREF: idk_OVR_LoadLbxHelp+38Dj
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add
cmp	[word ptr bx], 0 ; Compare Two Operands
jnz	short loc_56044	; Jump if Not Zero (ZF=0)
jmp	loc_560EB	; Jump

loc_56044:		; CODE XREF: idk_OVR_LoadLbxHelp+39Fj
push	[idk_LBX_w37EBE] ; arg4_Int
mov	bx, [word_3B19A]
push	[word ptr bx+2Ch] ; argFileName
mov	ax, [word_3B19A]
add	ax, 1Eh		; Add
push	ax		; argEntryNumber
call	LBX_Load_Entry_0_2 ; Call Procedure

loc_5605B:		; Add
add	sp, 6
mov	bx, [bp+var_A]
shl	bx, 1		; Shift	Logical	Left

loc_56063:		; Load Effective Address
lea	dx, [bp+var_4A]
add	bx, dx		; Add
mov	[bx], ax
mov	bx, [bp+var_A]

loc_5606D:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_4A]	; Load Effective Address
add	bx, ax		; Add
push	[word ptr bx]

loc_56076:		; Call Procedure
call	sub_1FAD4
pop	cx
push	[bp+var_36]
mov	bx, [bp+var_A]

loc_56082:		; Shift	Logical	Left
shl	bx, 1
lea	ax, [bp+var_4A]	; Load Effective Address

loc_56087:		; Add
add	bx, ax
push	[word ptr bx]
call	sub_1F8FD	; Call Procedure
pop	cx

loc_56091:
pop	cx
lea	ax, [bp+var_2E]	; Load Effective Address
push	ax
lea	ax, [bp+var_30]	; Load Effective Address
push	ax
lea	ax, [bp+var_34]	; Load Effective Address
push	ax
lea	ax, [bp+var_24]	; Load Effective Address
push	ax
push	[bp+var_36]
call	sub_220AA	; Call Procedure
add	sp, 0Ah		; Add
cmp	[bp+var_2C], 0FAh ; '' ; Compare Two Operands
jge	short loc_560BD	; Jump if Greater or Equal (SF=OF)
push	[bp+var_36]
call	sub_21D16	; Call Procedure
pop	cx

loc_560BD:		; CODE XREF: idk_OVR_LoadLbxHelp+412j
push	[bp+var_36]

loc_560C0:
mov	ax, si
add	ax, [bp+var_26]	; Add
sub	ax, [bp+var_34]	; Integer Subtraction
push	ax
mov	ax, [bp+var_20]
sub	ax, [bp+var_30]	; Integer Subtraction
add	ax, 0FFFAh	; Add
cwd			; AX ->	DX:AX (with sign)
sub	ax, dx		; Integer Subtraction
sar	ax, 1		; Shift	Arithmetic Right
mov	dx, [bp+var_10]
add	dx, ax		; Add
add	dx, 14h		; Add
sub	dx, [bp+var_24]	; Integer Subtraction

loc_560E2:
push	dx
call	sub_21014	; Call Procedure
add	sp, 6		; Add

loc_560EB:		; CODE XREF: idk_OVR_LoadLbxHelp+3A1j
mov	ax, 38C4h
push	ax
mov	ax, 4
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
push	[word_3B19A]
mov	ax, si
add	ax, [bp+var_1A]	; Add
push	ax
mov	ax, [bp+var_18]
add	ax, [bp+var_10]	; Add

loc_5610A:		; Add
add	ax, 12h
push	ax

loc_5610E:		; Call Procedure
call	sub_1993F
add	sp, 6		; Add
mov	ax, 38C9h
push	ax
mov	ax, 1
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx
add	si, [bp+var_1C]	; Add
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, [word_3B19A]
add	ax, 30h	; '0'   ; Add
push	ax
mov	ax, 0B4h ; ''
push	ax
push	si
mov	ax, [bp+var_10]
add	ax, 14h		; Add
push	ax

loc_5613E:		; Call Procedure
call	sub_1B0AD
add	sp, 0Ah		; Add
mov	bx, [word_3B19A]

loc_5614A:		; Compare Two Operands
cmp	[byte ptr bx+30h], 0
jnz	short loc_56155	; Jump if Not Zero (ZF=0)
add	si, 4		; Add
jmp	short loc_5616C	; Jump

loc_56155:		; CODE XREF: idk_OVR_LoadLbxHelp+4AEj
mov	ax, [word_3B19A]
add	ax, 30h	; '0'   ; Add
push	ax
mov	ax, 0B4h ; ''
push	ax
call	sub_1B984	; Call Procedure
pop	cx
pop	cx

loc_56167:		; Add
add	ax, 6
add	si, ax		; Add

loc_5616C:		; CODE XREF: idk_OVR_LoadLbxHelp+4B3j
inc	[bp+var_A]	; Increment by 1

loc_5616F:		; CODE XREF: idk_OVR_LoadLbxHelp+359j
mov	ax, [bp+var_A]
cmp	ax, [bp+var_16]	; Compare Two Operands
jge	short loc_5617A	; Jump if Greater or Equal (SF=OF)
jmp	loc_55FFC	; Jump

loc_5617A:		; CODE XREF: idk_OVR_LoadLbxHelp+4D5j
sub	si, 5		; Integer Subtraction
call	sub_2E303	; Call Procedure
call	sub_1E525	; Call Procedure
call	sub_2E22B	; Call Procedure
mov	ax, 1
push	ax
mov	ax, seg	stub059
push	ax
mov	ax, 25h	; '%'
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
call	sub_27CC0	; Call Procedure
call	sub_2E23E	; Call Procedure
mov	ax, 0FA0h
push	ax		; int
push	[bp+var_2A]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int

loc_561B7:
mov	ax, 9490h
push	ax		; int

loc_561BB:		; Call Procedure
call	idk_Mov_Sb_Sw_or_0

loc_561C0:		; Add
add	sp, 0Ah
call	sub_14792	; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_56220 ; Call Procedure
mov	[bp+var_8], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 8000h
push	ax
push	dx		; int
push	[bp+var_8]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
push	[idk_LBX_w37EBE] ; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int

loc_561E4:		; Call Procedure
call	idk_Mov_Sb_Sw_or_0
add	sp, 0Ch		; Add
xor	ax, ax		; Logical Exclusive OR

loc_561EE:
mov	dx, 8000h
push	ax
push	dx		; int
mov	ax, [bp+var_8]
add	ax, 800h	; Add
push	ax		; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
mov	ax, [idk_LBX_w37EBE]
add	ax, 800h	; Add
push	ax		; int

loc_56204:		; Logical Exclusive OR
xor	ax, ax
push	ax		; int
call	idk_Mov_Sb_Sw_or_0 ; Call Procedure
add	sp, 0Ch		; Add
mov	ax, [bp+var_32]
mov	[idk_Mouse_w3C5A8], ax
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_OVR_LoadLbxHelp ; sp-analysis failed

; [00000005 BYTES: COLLAPSED FUNCTION filebuf::terminate(void).	PRESS KEYPAD "+" TO EXPAND]


; Attributes: bp-based frame

proc sub_56220 far	; CODE XREF: sub_31CAAJ
			; idk_OVR_LoadLbxHelp:loc_55CBEp
			; idk_OVR_LoadLbxHelp+52Ap
push	bp
mov	bp, sp
push	[idk_AddrEmsHandle]
mov	ax, 1
push	ax
call	sub_163FC	; Call Procedure
pop	cx
pop	cx
mov	ax, [EMM_PageFrameSegmentAddress]
jmp	short $+2	; Jump
pop	bp

locret_56238:		; Return Far from Procedure
retf
endp sub_56220

ends ovr059


; Segment type:	Pure code
segment	ovr060 para public 'OVERLAY' use16
assume cs:ovr060
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_56240 far	; CODE XREF: sub_31CD0J

var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_E= word ptr	-0Eh
var_4= word ptr	-4

push	bp

loc_56241:
mov	bp, sp

loc_56243:		; Integer Subtraction
sub	sp, 1Ch

loc_56246:
push	si

loc_56247:
push	di

loc_56248:		; Increment by 1
inc	[word_355EC]

loc_5624C:		; Compare Two Operands
cmp	[word_355EC], 7530h

loc_56252:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_5625A

loc_56254:
mov	[word_355EC], 46h ; 'F'

loc_5625A:		; CODE XREF: sub_56240:loc_56252j
cmp	[word_355EC], 46h ; 'F' ; Compare Two Operands

loc_5625F:		; Jump if Greater or Equal (SF=OF)
jge	short loc_56266

loc_56261:		; Logical Exclusive OR
xor	ax, ax

loc_56263:		; Jump
jmp	loc_5640D

loc_56266:		; CODE XREF: sub_56240:loc_5625Fj
mov	[byte ptr bp+var_4], 44h ; 'D'

loc_5626A:
mov	[bp+var_1A], 0

loc_5626F:		; Jump
jmp	short loc_56283

loc_56271:		; CODE XREF: sub_56240:loc_56287j
mov	al, [byte ptr bp+var_1A]
add	al, 0E0h ; ''  ; Add

loc_56276:		; Load Effective Address
lea	dx, [bp+var_E]

loc_56279:
mov	bx, [bp+var_1A]

loc_5627C:		; Add
add	bx, dx

loc_5627E:
mov	[bx], al

loc_56280:		; Increment by 1
inc	[bp+var_1A]

loc_56283:		; CODE XREF: sub_56240:loc_5626Fj
cmp	[bp+var_1A], 0Ah ; Compare Two Operands

loc_56287:		; Jump if Less (SF!=OF)
jl	short loc_56271

loc_56289:
mov	[bp+var_1A], 0

loc_5628E:		; Jump
jmp	short loc_562A2

loc_56290:		; CODE XREF: sub_56240:loc_562A6j
mov	al, 0E9h ; ''
sub	al, [byte ptr bp+var_1A] ; Integer Subtraction
lea	dx, [bp+var_18]	; Load Effective Address
mov	bx, [bp+var_1A]
add	bx, dx		; Add
mov	[bx], al
inc	[bp+var_1A]	; Increment by 1

loc_562A2:		; CODE XREF: sub_56240:loc_5628Ej
cmp	[bp+var_1A], 0Ah ; Compare Two Operands

loc_562A6:		; Jump if Less (SF!=OF)
jl	short loc_56290

loc_562A8:
mov	[byte ptr bp+var_18], 0E8h ; ''

loc_562AC:
push	[word_3B19C]
mov	ax, 7Ah	; 'z'
push	ax
mov	ax, 118h
push	ax
call	hrmStoreSWSB	; Call Procedure
add	sp, 6		; Add
mov	ax, 89h	; ''
push	ax
mov	ax, 13Fh
push	ax
mov	ax, 28h	; '('
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_562CF:		; dx = arg_0 ... word_35EC2
call	wtfCompareSwap	; bx = arg_2 ... word_35EC4
			; cx = arg_4 ... word_35EC6
			; si = arg_6 ... word_35EC8
add	sp, 8		; Add
mov	si, [word_355EA]

loc_562DB:
mov	[bp+var_1A], 0

loc_562E0:		; Jump
jmp	LOOP_x10

loc_562E3:		; CODE XREF: sub_56240:loc_563C4j
cmp	si, 63h	; 'c'   ; Compare Two Operands
jl	short loc_562EB	; Jump if Less (SF!=OF)
jmp	NEXT_x10	; Jump

loc_562EB:		; CODE XREF: sub_56240+A6j
mov	ax, [word_355E8]

loc_562EE:		; Add
add	ax, [bp+var_1A]
cmp	ax, 30h	; '0'   ; Compare Two Operands

loc_562F4:		; Jump if Less (SF!=OF)
jl	short loc_562F9
jmp	NEXT_x10	; Jump

loc_562F9:		; CODE XREF: sub_56240:loc_562F4j
mov	[byte ptr bp+var_4+1], 0E0h ; ''

loc_562FD:		; Compare Two Operands
cmp	si, 0Ah

loc_56300:		; Jump if Greater or Equal (SF=OF)
jge	short loc_56311
mov	bx, 0Ah
sub	bx, si		; Integer Subtraction

loc_56307:		; Load Effective Address
lea	ax, [bp+var_E]
add	bx, ax		; Add

loc_5630C:
mov	al, [bx]
mov	[byte ptr bp+var_4+1], al

loc_56311:		; CODE XREF: sub_56240:loc_56300j
cmp	si, 58h	; 'X'   ; Compare Two Operands
jle	short loc_5632A	; Jump if Less or Equal	(ZF=1 |	SF!=OF)

loc_56316:
mov	ax, si
add	ax, 0FFA8h	; Add
mov	bx, 0Ah
sub	bx, ax		; Integer Subtraction

loc_56320:		; Load Effective Address
lea	ax, [bp+var_18]

loc_56323:		; Add
add	bx, ax

loc_56325:
mov	al, [bx]

loc_56327:
mov	[byte ptr bp+var_4+1], al

loc_5632A:		; CODE XREF: sub_56240+D4j
lea	ax, [bp+var_4]	; Load Effective Address

loc_5632D:
push	ax

loc_5632E:
mov	ax, 2

loc_56331:
push	ax
call	sub_19399	; Call Procedure

loc_56337:
pop	cx
pop	cx

loc_56339:
push	[word_3B19C]

loc_5633D:
mov	bx, [word_355E8]
add	bx, [bp+var_1A]	; Add
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
push	[word ptr bx+38DEh]
push	si
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1A5D5	; Call Procedure
add	sp, 8		; Add
mov	bx, [word_355E8]
add	bx, [bp+var_1A]	; Add
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left

loc_56363:
push	[word ptr bx+38DEh]

loc_56367:		; Call Procedure
call	sub_1AF46
pop	cx
mov	[bp+var_1C], ax
cmp	[bp+var_1C], 1	; Compare Two Operands
jle	short loc_56398	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
mov	ax, [bp+var_1C]
inc	ax		; Increment by 1
mov	di, ax

loc_5637C:		; Jump
jmp	short loc_56393

loc_5637E:		; CODE XREF: sub_56240+156j
push	[word_3B19C]

loc_56382:		; "."
mov	ax, offset a_
push	ax
push	si
push	di
call	sub_1A5D5	; Call Procedure
add	sp, 8		; Add
add	di, 4		; Add

loc_56393:		; CODE XREF: sub_56240:loc_5637Cj
cmp	di, 66h	; 'f'   ; Compare Two Operands
jl	short loc_5637E	; Jump if Less (SF!=OF)

loc_56398:		; CODE XREF: sub_56240+134j
push	[word_3B19C]
mov	bx, [word_355E8]
add	bx, [bp+var_1A]	; Add
mov	cl, 2

loc_563A5:		; Shift	Logical	Left
shl	bx, cl
push	[word ptr bx+38E0h]
push	si
mov	ax, 69h	; 'i'
push	ax
call	sub_1A5D5	; Call Procedure
add	sp, 8		; Add
add	si, 10		; Add

NEXT_x10:		; CODE XREF: sub_56240+A8j
			; sub_56240+B6j
inc	[bp+var_1A]	; Increment by 1

LOOP_x10:		; CODE XREF: sub_56240:loc_562E0j
cmp	[bp+var_1A], 10	; Compare Two Operands
jge	short loc_563C7	; Jump if Greater or Equal (SF=OF)

loc_563C4:		; Jump
jmp	loc_562E3

loc_563C7:		; CODE XREF: sub_56240+182j
dec	[word_355EA]	; Decrement by 1
cmp	[word_355EA], 1	; Compare Two Operands
jge	short loc_563F4	; Jump if Greater or Equal (SF=OF)
inc	[word_355E8]	; Increment by 1
add	[word_355EA], 0Ah ; Add
cmp	[word_355E8], 30h ; '0' ; Compare Two Operands

loc_563E0:		; Jump if Less or Equal	(ZF=1 |	SF!=OF)
jle	short loc_563F4

loc_563E2:
mov	[word_355EC], 0
mov	[word_355E8], 0

loc_563EE:
mov	[word_355EA], 5Fh ; '_'

loc_563F4:		; CODE XREF: sub_56240+190j
			; sub_56240:loc_563E0j
push	[word_3B19C]
mov	ax, 23h	; '#'
push	ax
mov	ax, 55h	; 'U'
push	ax
call	idk_VidLib_s2104D ; Call Procedure
add	sp, 6		; Add

loc_56408:		; Call Procedure
call	idk_ScrnPos_0_319_0_199

loc_5640D:		; CODE XREF: sub_56240:loc_56263j
pop	di
pop	si
mov	sp, bp
pop	bp

locret_56412:		; Return Far from Procedure
retf
endp sub_56240



; Attributes: bp-based frame

proc sub_56413 far	; CODE XREF: j_sub_56413J
push	bp
mov	bp, sp
mov	[word_355E8], 0
mov	[word_355EA], 95
mov	ax, 0C35h
push	ax
push	[idk_LBX_w37EBE]
call	idk_Mem_StoSW_s149FA ; Call Procedure
pop	cx
pop	cx
mov	[word_3B19C], ax
push	[word_3B19C]
mov	ax, 7Ah	; 'z'
push	ax
mov	ax, 118h
push	ax
call	hrmStoreSWSB	; Call Procedure
add	sp, 6		; Add
pop	bp
retf			; Return Far from Procedure
endp sub_56413

ends ovr060


; Segment type:	Pure code
segment	ovr061 para public 'OVERLAY' use16
assume cs:ovr061
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

proc sub_56450 far	; CODE XREF: j_s56450J

var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
call	sub_2E257	; Call Procedure
mov	ax, offset word_33C70
push	ax
mov	ax, 1
push	ax
call	wtf_s23F3E	; Call Procedure
pop	cx
pop	cx
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
call	sub_318CF	; Call Procedure
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add
call	sub_2E303	; Call Procedure
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure
push	[idk_LBX_w37EBE] ; argPtrBuffer_EMS
xor	ax, ax		; Logical Exclusive OR
push	ax		; argEntryNumber
mov	ax, offset aHalofam ; "HALOFAM"
push	ax		; argLbxFileName
call	LBX_Load_Entry_0_1 ; Call Procedure
add	sp, 6		; Add
mov	[bp+var_2], ax
push	[bp+var_2]
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	sub_1F655	; Call Procedure
add	sp, 6		; Add
call	idk_SetPalette_s1C4F4 ;	Call Procedure
call	sub_1E65C	; Call Procedure
call	sub_1E6E2	; Call Procedure
mov	ax, 64h	; 'd'
push	ax		; arg_0
call	EMM_CheckAllocation ; Call Procedure
pop	cx
mov	[dest],	ax
mov	ax, 64h	; 'd'
push	ax
call	sub_147E5	; Call Procedure
pop	cx
mov	[bdata@], ax
call	idk_SetThreeFlags_s25E89 ; Call	Procedure
mov	ax, 2
push	ax
mov	ax, seg	stub061
push	ax
mov	ax, 20h	; ' '
push	ax
call	sub_2E1FB	; Call Procedure
add	sp, 6		; Add
xor	si, si		; Logical Exclusive OR
jmp	short loc_56560	; Jump

loc_5650A:		; CODE XREF: sub_56450+112j
call	_f020105_bios_timeofday	; Call Procedure
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
mov	ax, 0FFFFh
push	ax
mov	ax, offset asc_3599F ; "\x1B"
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_Mouse_s29A0B ; Call	Procedure
add	sp, 0Ch		; Add
mov	[bp+var_6], ax
call	sub_2B97A	; Call Procedure
mov	[bp+var_4], ax
mov	ax, [bp+var_4]
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_56548	; Jump if Not Zero (ZF=0)

loc_56545:
mov	si, 0FFFFh

loc_56548:		; CODE XREF: sub_56450+F3j
or	si, si		; Logical Inclusive OR
jnz	short loc_56560	; Jump if Not Zero (ZF=0)
nop			; No Operation
push	cs
call	near ptr idk_HoF_s565F2	; Call Procedure
call	sub_31929	; Call Procedure
mov	ax, 2
push	ax
call	_f020305_idk_SleepWaitPause ; Call Procedure
pop	cx

loc_56560:		; CODE XREF: sub_56450+B8j
			; sub_56450+FAj
or	si, si		; Logical Inclusive OR
jz	short loc_5650A	; Jump if Zero (ZF=1)
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
call	idk_ScrnPos_0_319_0_199	; Call Procedure
call	setFlagsMaybeMouseEGA ;
			; mov	  word_3C5A8, 1
			; mov	  word_36A32, 0FFFFh
			; mov	  word_36A4A, 0
			; mov	  word_36A6A, 0
			; mov	  word_36A70, 0FFFFh
call	sub_2E257	; Call Procedure


call	idk_SetThreeFlags_s25E89 ; Call	Procedure


call	sub_318CF	; Call Procedure


mov	ax, -1
push	ax		; argColorIndex
xor	ax, ax		; Logical Exclusive OR
push	ax		; argPaletteNumber
call	ILSe_prepare_palette ; Call Procedure
pop	cx
pop	cx


call	idk_Set_PalNbr__w3602C_to_neg1 ; Call Procedure


mov	ax, 255
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_Set_FontsLbx1_256arr_to_0 ;	Call Procedure
pop	cx
pop	cx


mov	ax, 223
push	ax		; argCount
xor	ax, ax		; Logical Exclusive OR
push	ax		; argOffset
call	idk_Set_FontsLbx1_256arr_to_1 ;	Call Procedure
pop	cx
pop	cx


call	sub_1BF79	; Call Procedure


call	VGA_MathThenSetVarToVgaLoc ; Call Procedure


xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 199
push	ax
mov	ax, 319
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
call	idk_VGA_ScData_s186BC ;	Call Procedure
add	sp, 0Ah		; Add


call	sub_2E303	; Call Procedure


call	idk_SetPalette_s1C4F4 ;	Call Procedure


mov	ax, offset unk_33C64
push	ax
mov	ax, 1
push	ax

loc_565E6:		; Call Procedure
call	wtf_s23F3E
pop	cx
pop	cx
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_56450



; Attributes: bp-based frame

proc idk_HoF_s565F2 far	; CODE XREF: j_idk_HoF_s565F2J
			; sub_56450+FEp

var_16=	word ptr -16h
var_14=	byte ptr -14h
var_13=	byte ptr -13h
var_12=	byte ptr -12h
var_11=	byte ptr -11h
var_10=	byte ptr -10h
var_F= byte ptr	-0Fh
var_E= byte ptr	-0Eh
var_D= byte ptr	-0Dh
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
var_8= byte ptr	-8
var_7= byte ptr	-7
argNumber= word	ptr -6
argDest= byte ptr -4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 16h		; Integer Subtraction
push	si
push	di		; argConversionBase
mov	ax, offset asc_359A1 ; " "
push	ax
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	[byte ptr bp+var_16], offset unk_31E06

loc_5660D:
mov	[byte ptr bp+var_16+1],	31h ; '1'
mov	[bp+var_14], struct_HeroTitles.aRogue
mov	[bp+var_13], 0A2h ; ''

loc_56619:
mov	[bp+var_12], 0B2h ; ''
mov	[bp+var_11], 0B3h ; ''

loc_56621:
mov	[bp+var_10], 33h ; '3'

loc_56625:
mov	[bp+var_F], 0B4h ; ''
mov	[bp+var_E], 0B8h ; ''

loc_5662D:
mov	[bp+var_D], 0B9h ; ''

loc_56631:
mov	[bp+var_C], 0D5h ; ''

loc_56635:
mov	[bp+var_B], 0BAh ; ''
mov	[bp+var_A], 0F6h ; ''

loc_5663D:
mov	[bp+var_9], 0F6h ; ''
mov	[bp+var_8], 0F6h ; ''

loc_56645:
mov	[bp+var_7], 0F6h ; ''
call	VGA_MathThenSetVarToVgaLoc ; Call Procedure

loc_5664E:		; Call Procedure
call	idk_ScrnPos_0_319_0_199
call	sub_1E69F	; Call Procedure
lea	ax, [bp+var_16]	; Load Effective Address
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx

loc_56666:
pop	cx
xor	ax, ax		; Logical Exclusive OR
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 0Fh

loc_56670:
push	ax
mov	ax, 5
push	ax
call	sub_1922A	; Call Procedure
add	sp, 8		; Add
mov	ax, 0FAh ; ''
push	ax
call	idk_SetConfigMomFlagValue_s1930B ; Call	Procedure
pop	cx

loc_56687:		; "Hall"
mov	ax, offset aHall
push	ax
push	[dest]		; argDest

loc_5668F:		; argDest,argSrc
call	_strcpy
pop	cx
pop	cx

loc_56696:		; Load Effective Address
lea	ax, [bp+argDest]
push	ax

loc_5669A:		; argDst
push	[dest]
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset aOf_0 ; "Of"
push	ax

loc_566A9:		; argDst
push	[dest]

loc_566AD:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
push	[dest]		; argDst

loc_566BC:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
mov	ax, offset aFame ; "Fame"
push	ax
push	[dest]		; argDst

loc_566CB:		; char*	strcat(char* destination, const	char* source)
call	_strcat
pop	cx
pop	cx
push	[dest]		; int
mov	ax, 7
push	ax		; int
mov	ax, 0A0h ; ''
push	ax		; int
call	sub_196ED	; Call Procedure
add	sp, 6		; Add
xor	si, si		; Logical Exclusive OR
jmp	short loc_566EF	; Jump

loc_566EA:		; CODE XREF: idk_HoF_s565F2+100j
mov	[byte ptr bp+si+var_16], 0B3h ;	''
inc	si		; Increment by 1

loc_566EF:		; CODE XREF: idk_HoF_s565F2+F6j
cmp	si, 10h		; Compare Two Operands
jl	short loc_566EA	; Jump if Less (SF!=OF)
mov	[byte ptr bp+var_16], 0F6h ; ''
lea	ax, [bp+var_16]	; Load Effective Address
push	ax
mov	ax, 2
push	ax
call	sub_19399	; Call Procedure
pop	cx
pop	cx

loc_56707:		; Logical Exclusive OR
xor	ax, ax
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax

loc_5670D:
mov	ax, 0Fh
push	ax
mov	ax, 2
push	ax
call	sub_1922A	; Call Procedure
add	sp, 8		; Add
mov	ax, 0FAh ; ''
push	ax
call	idk_SetConfigMomFlagValue_s1930B ; Call	Procedure
pop	cx
mov	[bp+var_2], 48h	; 'H'

loc_5672C:
mov	di, 2Ah	; '*'
xor	si, si		; Logical Exclusive OR
jmp	loc_56878	; Jump

loc_56734:		; CODE XREF: idk_HoF_s565F2+28Bj
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
cmp	[word ptr bx-7682h], 0 ; Compare Two Operands
jg	short loc_56742	; Jump if Greater (ZF=0	& SF=OF)
jmp	loc_56877	; Jump

loc_56742:		; CODE XREF: idk_HoF_s565F2+14Bj
or	si, si		; Logical Inclusive OR
jnz	short loc_5674C	; Jump if Not Zero (ZF=0)
mov	ax, offset aMaster ; "Master"
push	ax
jmp	short loc_56782	; Jump

loc_5674C:		; CODE XREF: idk_HoF_s565F2+152j
mov	ax, 10
push	ax
push	[bdata@]	; argPtrCharArr
mov	ax, si
inc	ax		; Increment by 1
push	ax		; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
push	[bdata@]
push	[dest]		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset asc_359B7 ; ")"
push	ax
push	[dest]		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
push	[dest]

loc_56782:		; CODE XREF: idk_HoF_s565F2+158j
push	di
push	[bp+var_2]
call	sub_196B8	; Call Procedure
add	sp, 6		; Add
mov	ax, si
mov	dx, 14h
imul	dx		; Signed Multiply
add	ax, offset tmpMagicSet ; Add
push	ax
push	[dest]		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset aOfThe ; " of the "
push	ax
push	[dest]		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	bx, [bx-766Eh]
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx+3BEEh]
push	[dest]		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
push	[dest]
push	di
mov	ax, [bp+var_2]
add	ax, 9		; Add
push	ax
call	sub_1993F	; Call Procedure
add	sp, 6		; Add
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
push	[word ptr bx-7682h] ; value
push	di		; int
mov	ax, [bp+var_2]
add	ax, offset idk_InitMod_w31DBA ;	Add
push	ax		; int
call	sub_19728	; Call Procedure
add	sp, 6		; Add
xor	ax, ax		; Logical Exclusive OR
mov	dx, 1F40h
push	ax
push	dx
mov	bx, si
shl	bx, 1		; Shift	Logical	Left
mov	ax, [bx-7682h]
cwd			; AX ->	DX:AX (with sign)
push	ax
push	dx
xor	dx, dx		; Logical Exclusive OR
mov	ax, 64h	; 'd'
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
push	dx
push	ax		; argConversionBase
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
mov	[bp+argNumber],	ax
mov	ax, 0Ah
push	ax
push	[bdata@]	; argPtrCharArr
push	[bp+argNumber]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, offset asc_359C2 ; "("
push	ax
push	[dest]		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
push	[bdata@]
push	[dest]		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset asc_359C4 ; "%)"
push	ax
push	[dest]		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
push	[dest]
push	di
mov	ax, [bp+var_2]
add	ax, 0C6h ; ''  ; Add
push	ax
call	sub_196B8	; Call Procedure
add	sp, 6		; Add
add	di, 0Dh		; Add

loc_56877:		; CODE XREF: idk_HoF_s565F2+14Dj
inc	si		; Increment by 1

loc_56878:		; CODE XREF: idk_HoF_s565F2+13Fj
cmp	si, 0Ah		; Compare Two Operands
jge	short loc_56880	; Jump if Greater or Equal (SF=OF)
jmp	loc_56734	; Jump

loc_56880:		; CODE XREF: idk_HoF_s565F2+289j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_HoF_s565F2

ends ovr061


end STARTX
